ARM GAS  /tmp/ccWvVg6G.s 			page 1


   1              		.cpu cortex-m0
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"usb_pd_protocol.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.inc_id,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.code	16
  19              		.thumb_func
  20              		.fpu softvfp
  22              	inc_id:
  23              	.LFB25:
  24              		.file 1 "Src/usb_pd_protocol.c"
   1:Src/usb_pd_protocol.c **** /* Copyright (c) 2014 The Chromium OS Authors. All rights reserved.
   2:Src/usb_pd_protocol.c ****  * Use of this source code is governed by a BSD-style license that can be
   3:Src/usb_pd_protocol.c ****  * found in the LICENSE file.
   4:Src/usb_pd_protocol.c ****  */
   5:Src/usb_pd_protocol.c **** 
   6:Src/usb_pd_protocol.c **** //#include "battery.h"
   7:Src/usb_pd_protocol.c **** //#include "battery_smart.h"
   8:Src/usb_pd_protocol.c **** //#include "board.h"
   9:Src/usb_pd_protocol.c **** //#include "charge_manager.h"
  10:Src/usb_pd_protocol.c **** //#include "charge_state.h"
  11:Src/usb_pd_protocol.c **** //#include "chipset.h"
  12:Src/usb_pd_protocol.c **** //#include "common.h"
  13:Src/usb_pd_protocol.c **** //#include "console.h"
  14:Src/usb_pd_protocol.c **** //#include "ec_commands.h"
  15:Src/usb_pd_protocol.c **** //#include "gpio.h"
  16:Src/usb_pd_protocol.c **** //#include "hooks.h"
  17:Src/usb_pd_protocol.c **** //#include "host_command.h"
  18:Src/usb_pd_protocol.c **** //#include "registers.h"
  19:Src/usb_pd_protocol.c **** //#include "system.h"
  20:Src/usb_pd_protocol.c **** //#include "task.h"
  21:Src/usb_pd_protocol.c **** //#include "timer.h"
  22:Src/usb_pd_protocol.c **** //#include "util.h"
  23:Src/usb_pd_protocol.c **** //#include "usb_charge.h"
  24:Src/usb_pd_protocol.c **** //#include "usb_mux.h"
  25:Src/usb_pd_protocol.c **** #include "usb_pd.h"
  26:Src/usb_pd_protocol.c **** #include "usb_pd_tcpm.h"
  27:Src/usb_pd_protocol.c **** #include "tcpm.h"
  28:Src/usb_pd_protocol.c **** #include "usb_pd_driver.h"
  29:Src/usb_pd_protocol.c **** //#include "version.h"
  30:Src/usb_pd_protocol.c **** 
  31:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
  32:Src/usb_pd_protocol.c **** #define CPRINTF(format, args...) cprintf(CC_USBPD, format, ## args)
  33:Src/usb_pd_protocol.c **** #define CPRINTS(format, args...) cprints(CC_USBPD, format, ## args)
  34:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccWvVg6G.s 			page 2


  35:Src/usb_pd_protocol.c **** BUILD_ASSERT(CONFIG_USB_PD_PORT_COUNT <= EC_USB_PD_MAX_PORTS);
  36:Src/usb_pd_protocol.c **** 
  37:Src/usb_pd_protocol.c **** /*
  38:Src/usb_pd_protocol.c ****  * Debug log level - higher number == more log
  39:Src/usb_pd_protocol.c ****  *   Level 0: Log state transitions
  40:Src/usb_pd_protocol.c ****  *   Level 1: Level 0, plus state name
  41:Src/usb_pd_protocol.c ****  *   Level 2: Level 1, plus packet info
  42:Src/usb_pd_protocol.c ****  *   Level 3: Level 2, plus ping packet and packet dump on error
  43:Src/usb_pd_protocol.c ****  *
  44:Src/usb_pd_protocol.c ****  * Note that higher log level causes timing changes and thus may affect
  45:Src/usb_pd_protocol.c ****  * performance.
  46:Src/usb_pd_protocol.c ****  *
  47:Src/usb_pd_protocol.c ****  * Can be limited to constant debug_level by CONFIG_USB_PD_DEBUG_LEVEL
  48:Src/usb_pd_protocol.c ****  */
  49:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DEBUG_LEVEL
  50:Src/usb_pd_protocol.c **** static const int debug_level = CONFIG_USB_PD_DEBUG_LEVEL;
  51:Src/usb_pd_protocol.c **** #else
  52:Src/usb_pd_protocol.c **** static int debug_level;
  53:Src/usb_pd_protocol.c **** #endif
  54:Src/usb_pd_protocol.c **** 
  55:Src/usb_pd_protocol.c **** /*
  56:Src/usb_pd_protocol.c ****  * PD communication enabled flag. When false, PD state machine still
  57:Src/usb_pd_protocol.c ****  * detects source/sink connection and disconnection, and will still
  58:Src/usb_pd_protocol.c ****  * provide VBUS, but never sends any PD communication.
  59:Src/usb_pd_protocol.c ****  */
  60:Src/usb_pd_protocol.c **** static uint8_t pd_comm_enabled[CONFIG_USB_PD_PORT_COUNT];
  61:Src/usb_pd_protocol.c **** #else /* CONFIG_COMMON_RUNTIME */
  62:Src/usb_pd_protocol.c **** #define CPRINTF(format, args...)
  63:Src/usb_pd_protocol.c **** #define CPRINTS(format, args...)
  64:Src/usb_pd_protocol.c **** static const int debug_level;
  65:Src/usb_pd_protocol.c **** #endif
  66:Src/usb_pd_protocol.c **** 
  67:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
  68:Src/usb_pd_protocol.c **** #define DUAL_ROLE_IF_ELSE(port, sink_clause, src_clause) \
  69:Src/usb_pd_protocol.c **** 	(pd[port].power_role == PD_ROLE_SINK ? (sink_clause) : (src_clause))
  70:Src/usb_pd_protocol.c **** #else
  71:Src/usb_pd_protocol.c **** #define DUAL_ROLE_IF_ELSE(port, sink_clause, src_clause) (src_clause)
  72:Src/usb_pd_protocol.c **** #endif
  73:Src/usb_pd_protocol.c **** 
  74:Src/usb_pd_protocol.c **** #define READY_RETURN_STATE(port) DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_READY, \
  75:Src/usb_pd_protocol.c **** 							 PD_STATE_SRC_READY)
  76:Src/usb_pd_protocol.c **** 
  77:Src/usb_pd_protocol.c **** /* Type C supply voltage (mV) */
  78:Src/usb_pd_protocol.c **** #define TYPE_C_VOLTAGE	5000 /* mV */
  79:Src/usb_pd_protocol.c **** 
  80:Src/usb_pd_protocol.c **** /* PD counter definitions */
  81:Src/usb_pd_protocol.c **** #define PD_MESSAGE_ID_COUNT 7
  82:Src/usb_pd_protocol.c **** #define PD_HARD_RESET_COUNT 2
  83:Src/usb_pd_protocol.c **** #define PD_CAPS_COUNT 50
  84:Src/usb_pd_protocol.c **** #define PD_SNK_CAP_RETRIES 3
  85:Src/usb_pd_protocol.c **** 
  86:Src/usb_pd_protocol.c **** enum vdm_states {
  87:Src/usb_pd_protocol.c **** 	VDM_STATE_ERR_BUSY = -3,
  88:Src/usb_pd_protocol.c **** 	VDM_STATE_ERR_SEND = -2,
  89:Src/usb_pd_protocol.c **** 	VDM_STATE_ERR_TMOUT = -1,
  90:Src/usb_pd_protocol.c **** 	VDM_STATE_DONE = 0,
  91:Src/usb_pd_protocol.c **** 	/* Anything >0 represents an active state */
ARM GAS  /tmp/ccWvVg6G.s 			page 3


  92:Src/usb_pd_protocol.c **** 	VDM_STATE_READY = 1,
  93:Src/usb_pd_protocol.c **** 	VDM_STATE_BUSY = 2,
  94:Src/usb_pd_protocol.c **** 	VDM_STATE_WAIT_RSP_BUSY = 3,
  95:Src/usb_pd_protocol.c **** };
  96:Src/usb_pd_protocol.c **** 
  97:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
  98:Src/usb_pd_protocol.c **** /* Port dual-role state */
  99:Src/usb_pd_protocol.c **** enum pd_dual_role_states drp_state = CONFIG_USB_PD_INITIAL_DRP_STATE;
 100:Src/usb_pd_protocol.c **** 
 101:Src/usb_pd_protocol.c **** /* Enable variable for Try.SRC states */
 102:Src/usb_pd_protocol.c **** static uint8_t pd_try_src_enable;
 103:Src/usb_pd_protocol.c **** #endif
 104:Src/usb_pd_protocol.c **** 
 105:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 106:Src/usb_pd_protocol.c **** /*
 107:Src/usb_pd_protocol.c ****  * The spec. revision is used to index into this array.
 108:Src/usb_pd_protocol.c ****  *  Rev 0 (PD 1.0) - return PD_CTRL_REJECT
 109:Src/usb_pd_protocol.c ****  *  Rev 1 (PD 2.0) - return PD_CTRL_REJECT
 110:Src/usb_pd_protocol.c ****  *  Rev 2 (PD 3.0) - return PD_CTRL_NOT_SUPPORTED
 111:Src/usb_pd_protocol.c ****  */
 112:Src/usb_pd_protocol.c **** static const uint8_t refuse[] = {
 113:Src/usb_pd_protocol.c **** 	PD_CTRL_REJECT, PD_CTRL_REJECT, PD_CTRL_NOT_SUPPORTED};
 114:Src/usb_pd_protocol.c **** #define REFUSE(r) refuse[r]
 115:Src/usb_pd_protocol.c **** #else
 116:Src/usb_pd_protocol.c **** #define REFUSE(r) PD_CTRL_REJECT
 117:Src/usb_pd_protocol.c **** #endif
 118:Src/usb_pd_protocol.c **** 
 119:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 120:Src/usb_pd_protocol.c **** /*
 121:Src/usb_pd_protocol.c ****  * The spec. revision is used to index into this array.
 122:Src/usb_pd_protocol.c ****  *  Rev 0 (VDO 1.0) - return VDM_VER10
 123:Src/usb_pd_protocol.c ****  *  Rev 1 (VDO 1.0) - return VDM_VER10
 124:Src/usb_pd_protocol.c ****  *  Rev 2 (VDO 2.0) - return VDM_VER20
 125:Src/usb_pd_protocol.c ****  */
 126:Src/usb_pd_protocol.c **** static const uint8_t vdo_ver[] = {
 127:Src/usb_pd_protocol.c **** 	VDM_VER10, VDM_VER10, VDM_VER20};
 128:Src/usb_pd_protocol.c **** #define VDO_VER(v) vdo_ver[v]
 129:Src/usb_pd_protocol.c **** #else
 130:Src/usb_pd_protocol.c **** #define VDO_VER(v) VDM_VER10
 131:Src/usb_pd_protocol.c **** #endif
 132:Src/usb_pd_protocol.c **** 
 133:Src/usb_pd_protocol.c **** // variables that used to be pd_task, but had to be promoted 
 134:Src/usb_pd_protocol.c **** // so both pd_init and pd_run_state_machine can see them
 135:Src/usb_pd_protocol.c **** static int head;
 136:Src/usb_pd_protocol.c **** static int port = TASK_ID_TO_PD_PORT(task_get_current());
 137:Src/usb_pd_protocol.c **** static uint32_t payload[7];
 138:Src/usb_pd_protocol.c **** static int timeout = 10*MSEC;
 139:Src/usb_pd_protocol.c **** static int cc1, cc2;
 140:Src/usb_pd_protocol.c **** static int res, incoming_packet = 0;
 141:Src/usb_pd_protocol.c **** static int hard_reset_count = 0;
 142:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 143:Src/usb_pd_protocol.c **** static uint64_t next_role_swap = PD_T_DRP_SNK;
 144:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_VBUS_DETECT_NONE
 145:Src/usb_pd_protocol.c **** static int snk_hard_reset_vbus_off = 0;
 146:Src/usb_pd_protocol.c **** #endif
 147:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 148:Src/usb_pd_protocol.c **** static const int auto_toggle_supported = tcpm_auto_toggle_supported(port);
ARM GAS  /tmp/ccWvVg6G.s 			page 4


 149:Src/usb_pd_protocol.c **** #endif
 150:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
 151:Src/usb_pd_protocol.c **** static typec_current_t typec_curr = 0, typec_curr_change = 0;
 152:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
 153:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 154:Src/usb_pd_protocol.c **** static enum pd_states this_state;
 155:Src/usb_pd_protocol.c **** static enum pd_cc_states new_cc_state;
 156:Src/usb_pd_protocol.c **** static timestamp_t now;
 157:Src/usb_pd_protocol.c **** static int caps_count = 0, hard_reset_sent = 0;
 158:Src/usb_pd_protocol.c **** static int snk_cap_count = 0;
 159:Src/usb_pd_protocol.c **** static int evt;
 160:Src/usb_pd_protocol.c **** 
 161:Src/usb_pd_protocol.c **** static struct pd_protocol {
 162:Src/usb_pd_protocol.c **** 	/* current port power role (SOURCE or SINK) */
 163:Src/usb_pd_protocol.c **** 	uint8_t power_role;
 164:Src/usb_pd_protocol.c **** 	/* current port data role (DFP or UFP) */
 165:Src/usb_pd_protocol.c **** 	uint8_t data_role;
 166:Src/usb_pd_protocol.c **** 	/* 3-bit rolling message ID counter */
 167:Src/usb_pd_protocol.c **** 	uint8_t msg_id;
 168:Src/usb_pd_protocol.c **** 	/* Port polarity : 0 => CC1 is CC line, 1 => CC2 is CC line */
 169:Src/usb_pd_protocol.c **** 	uint8_t polarity;
 170:Src/usb_pd_protocol.c **** 	/* PD state for port */
 171:Src/usb_pd_protocol.c **** 	enum pd_states task_state;
 172:Src/usb_pd_protocol.c **** 	/* PD state when we run state handler the last time */
 173:Src/usb_pd_protocol.c **** 	enum pd_states last_state;
 174:Src/usb_pd_protocol.c **** 	/* bool: request state change to SUSPENDED */
 175:Src/usb_pd_protocol.c **** 	uint8_t req_suspend_state;
 176:Src/usb_pd_protocol.c **** 	/* The state to go to after timeout */
 177:Src/usb_pd_protocol.c **** 	enum pd_states timeout_state;
 178:Src/usb_pd_protocol.c **** 	/* port flags, see PD_FLAGS_* */
 179:Src/usb_pd_protocol.c **** 	uint32_t flags;
 180:Src/usb_pd_protocol.c **** 	/* Timeout for the current state. Set to 0 for no timeout. */
 181:Src/usb_pd_protocol.c **** 	uint64_t timeout;
 182:Src/usb_pd_protocol.c **** 	/* Time for source recovery after hard reset */
 183:Src/usb_pd_protocol.c **** 	uint64_t src_recover;
 184:Src/usb_pd_protocol.c **** 	/* Time for CC debounce end */
 185:Src/usb_pd_protocol.c **** 	uint64_t cc_debounce;
 186:Src/usb_pd_protocol.c **** 	/* The cc state */
 187:Src/usb_pd_protocol.c **** 	enum pd_cc_states cc_state;
 188:Src/usb_pd_protocol.c **** 	/* status of last transmit */
 189:Src/usb_pd_protocol.c **** 	uint8_t tx_status;
 190:Src/usb_pd_protocol.c **** 
 191:Src/usb_pd_protocol.c **** 	/* last requested voltage PDO index */
 192:Src/usb_pd_protocol.c **** 	int requested_idx;
 193:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 194:Src/usb_pd_protocol.c **** 	/* Current limit / voltage based on the last request message */
 195:Src/usb_pd_protocol.c **** 	uint32_t curr_limit;
 196:Src/usb_pd_protocol.c **** 	uint32_t supply_voltage;
 197:Src/usb_pd_protocol.c **** 	/* Signal charging update that affects the port */
 198:Src/usb_pd_protocol.c **** 	int new_power_request;
 199:Src/usb_pd_protocol.c **** 	/* Store previously requested voltage request */
 200:Src/usb_pd_protocol.c **** 	int prev_request_mv;
 201:Src/usb_pd_protocol.c **** 	/* Time for Try.SRC states */
 202:Src/usb_pd_protocol.c **** 	uint64_t try_src_marker;
 203:Src/usb_pd_protocol.c **** #endif
 204:Src/usb_pd_protocol.c **** 
 205:Src/usb_pd_protocol.c **** 	/* PD state for Vendor Defined Messages */
ARM GAS  /tmp/ccWvVg6G.s 			page 5


 206:Src/usb_pd_protocol.c **** 	enum vdm_states vdm_state;
 207:Src/usb_pd_protocol.c **** 	/* Timeout for the current vdm state.  Set to 0 for no timeout. */
 208:Src/usb_pd_protocol.c **** 	timestamp_t vdm_timeout;
 209:Src/usb_pd_protocol.c **** 	/* next Vendor Defined Message to send */
 210:Src/usb_pd_protocol.c **** 	uint32_t vdo_data[VDO_MAX_SIZE];
 211:Src/usb_pd_protocol.c **** 	uint8_t vdo_count;
 212:Src/usb_pd_protocol.c **** 	/* VDO to retry if UFP responder replied busy. */
 213:Src/usb_pd_protocol.c **** 	uint32_t vdo_retry;
 214:Src/usb_pd_protocol.c **** 
 215:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
 216:Src/usb_pd_protocol.c **** 	/* Attached ChromeOS device id, RW hash, and current RO / RW image */
 217:Src/usb_pd_protocol.c **** 	uint16_t dev_id;
 218:Src/usb_pd_protocol.c **** 	uint32_t dev_rw_hash[PD_RW_HASH_SIZE/4];
 219:Src/usb_pd_protocol.c **** 	enum ec_current_image current_image;
 220:Src/usb_pd_protocol.c **** #endif
 221:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 222:Src/usb_pd_protocol.c **** 	/* PD Collision avoidance buffer */
 223:Src/usb_pd_protocol.c **** 	uint16_t ca_buffered;
 224:Src/usb_pd_protocol.c **** 	uint16_t ca_header;
 225:Src/usb_pd_protocol.c **** 	uint32_t ca_buffer[PDO_MAX_OBJECTS];
 226:Src/usb_pd_protocol.c **** 	enum tcpm_transmit_type ca_type;
 227:Src/usb_pd_protocol.c **** 	/* protocol revision */
 228:Src/usb_pd_protocol.c **** 	uint8_t rev;
 229:Src/usb_pd_protocol.c **** #endif
 230:Src/usb_pd_protocol.c **** } pd[CONFIG_USB_PD_PORT_COUNT];
 231:Src/usb_pd_protocol.c **** 
 232:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 233:Src/usb_pd_protocol.c **** static const char * const pd_state_names[] = {
 234:Src/usb_pd_protocol.c **** 	"DISABLED", "SUSPENDED",
 235:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 236:Src/usb_pd_protocol.c **** 	"SNK_DISCONNECTED", "SNK_DISCONNECTED_DEBOUNCE",
 237:Src/usb_pd_protocol.c **** 	"SNK_HARD_RESET_RECOVER",
 238:Src/usb_pd_protocol.c **** 	"SNK_DISCOVERY", "SNK_REQUESTED", "SNK_TRANSITION", "SNK_READY",
 239:Src/usb_pd_protocol.c **** 	"SNK_SWAP_INIT", "SNK_SWAP_SNK_DISABLE",
 240:Src/usb_pd_protocol.c **** 	"SNK_SWAP_SRC_DISABLE", "SNK_SWAP_STANDBY", "SNK_SWAP_COMPLETE",
 241:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 242:Src/usb_pd_protocol.c **** 	"SRC_DISCONNECTED", "SRC_DISCONNECTED_DEBOUNCE",
 243:Src/usb_pd_protocol.c **** 	"SRC_HARD_RESET_RECOVER", "SRC_STARTUP",
 244:Src/usb_pd_protocol.c **** 	"SRC_DISCOVERY", "SRC_NEGOCIATE", "SRC_ACCEPTED", "SRC_POWERED",
 245:Src/usb_pd_protocol.c **** 	"SRC_TRANSITION", "SRC_READY", "SRC_GET_SNK_CAP", "DR_SWAP",
 246:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 247:Src/usb_pd_protocol.c **** 	"SRC_SWAP_INIT", "SRC_SWAP_SNK_DISABLE", "SRC_SWAP_SRC_DISABLE",
 248:Src/usb_pd_protocol.c **** 	"SRC_SWAP_STANDBY",
 249:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 250:Src/usb_pd_protocol.c **** 	"VCONN_SWAP_SEND", "VCONN_SWAP_INIT", "VCONN_SWAP_READY",
 251:Src/usb_pd_protocol.c **** #endif /* CONFIG_USBC_VCONN_SWAP */
 252:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 253:Src/usb_pd_protocol.c **** 	"SOFT_RESET", "HARD_RESET_SEND", "HARD_RESET_EXECUTE", "BIST_RX",
 254:Src/usb_pd_protocol.c **** 	"BIST_TX",
 255:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 256:Src/usb_pd_protocol.c **** 	"DRP_AUTO_TOGGLE",
 257:Src/usb_pd_protocol.c **** #endif
 258:Src/usb_pd_protocol.c **** };
 259:Src/usb_pd_protocol.c **** BUILD_ASSERT(ARRAY_SIZE(pd_state_names) == PD_STATE_COUNT);
 260:Src/usb_pd_protocol.c **** #endif
 261:Src/usb_pd_protocol.c **** 
 262:Src/usb_pd_protocol.c **** /*
ARM GAS  /tmp/ccWvVg6G.s 			page 6


 263:Src/usb_pd_protocol.c ****  * 4 entry rw_hash table of type-C devices that AP has firmware updates for.
 264:Src/usb_pd_protocol.c ****  */
 265:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 266:Src/usb_pd_protocol.c **** #define RW_HASH_ENTRIES 4
 267:Src/usb_pd_protocol.c **** static struct ec_params_usb_pd_rw_hash_entry rw_hash_table[RW_HASH_ENTRIES];
 268:Src/usb_pd_protocol.c **** #endif
 269:Src/usb_pd_protocol.c **** 
 270:Src/usb_pd_protocol.c **** int pd_comm_is_enabled(int port)
 271:Src/usb_pd_protocol.c **** {
 272:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 273:Src/usb_pd_protocol.c **** 	return pd_comm_enabled[port];
 274:Src/usb_pd_protocol.c **** #else
 275:Src/usb_pd_protocol.c **** 	return 1;
 276:Src/usb_pd_protocol.c **** #endif
 277:Src/usb_pd_protocol.c **** }
 278:Src/usb_pd_protocol.c **** 
 279:Src/usb_pd_protocol.c **** static inline void set_state_timeout(int port,
 280:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 281:Src/usb_pd_protocol.c **** 				     enum pd_states timeout_state)
 282:Src/usb_pd_protocol.c **** {
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout = timeout;
 284:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 285:Src/usb_pd_protocol.c **** }
 286:Src/usb_pd_protocol.c **** 
 287:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 288:Src/usb_pd_protocol.c **** int pd_get_rev(int port)
 289:Src/usb_pd_protocol.c **** {
 290:Src/usb_pd_protocol.c **** 	return pd[port].rev;
 291:Src/usb_pd_protocol.c **** }
 292:Src/usb_pd_protocol.c **** 
 293:Src/usb_pd_protocol.c **** int pd_get_vdo_ver(int port)
 294:Src/usb_pd_protocol.c **** {
 295:Src/usb_pd_protocol.c **** 	return vdo_ver[pd[port].rev];
 296:Src/usb_pd_protocol.c **** }
 297:Src/usb_pd_protocol.c **** #endif
 298:Src/usb_pd_protocol.c **** 
 299:Src/usb_pd_protocol.c **** /* Return flag for pd state is connected */
 300:Src/usb_pd_protocol.c **** int pd_is_connected(int port)
 301:Src/usb_pd_protocol.c **** {
 302:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_DISABLED)
 303:Src/usb_pd_protocol.c **** 		return 0;
 304:Src/usb_pd_protocol.c **** 
 305:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 306:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_DRP_AUTO_TOGGLE)
 307:Src/usb_pd_protocol.c **** 		return 0;
 308:Src/usb_pd_protocol.c **** #endif
 309:Src/usb_pd_protocol.c **** 
 310:Src/usb_pd_protocol.c **** 	return DUAL_ROLE_IF_ELSE(port,
 311:Src/usb_pd_protocol.c **** 		/* sink */
 312:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_DISCONNECTED &&
 313:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_DISCONNECTED_DEBOUNCE,
 314:Src/usb_pd_protocol.c **** 		/* source */
 315:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SRC_DISCONNECTED &&
 316:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SRC_DISCONNECTED_DEBOUNCE);
 317:Src/usb_pd_protocol.c **** }
 318:Src/usb_pd_protocol.c **** 
 319:Src/usb_pd_protocol.c **** /*
ARM GAS  /tmp/ccWvVg6G.s 			page 7


 320:Src/usb_pd_protocol.c ****  * Return true if partner port is a DTS or TS capable of entering debug
 321:Src/usb_pd_protocol.c ****  * mode (eg. is presenting Rp/Rp or Rd/Rd).
 322:Src/usb_pd_protocol.c ****  */
 323:Src/usb_pd_protocol.c **** int pd_ts_dts_plugged(int port)
 324:Src/usb_pd_protocol.c **** {
 325:Src/usb_pd_protocol.c **** 	return pd[port].flags & PD_FLAGS_TS_DTS_PARTNER;
 326:Src/usb_pd_protocol.c **** }
 327:Src/usb_pd_protocol.c **** 
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 329:Src/usb_pd_protocol.c **** void pd_vbus_low(int port)
 330:Src/usb_pd_protocol.c **** {
 331:Src/usb_pd_protocol.c **** 	pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
 332:Src/usb_pd_protocol.c **** }
 333:Src/usb_pd_protocol.c **** 
 334:Src/usb_pd_protocol.c **** static inline int pd_is_vbus_present(int port)
 335:Src/usb_pd_protocol.c **** {
 336:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_TCPC
 337:Src/usb_pd_protocol.c **** 	return tcpm_get_vbus_level(port);
 338:Src/usb_pd_protocol.c **** #else
 339:Src/usb_pd_protocol.c **** 	return pd_snk_is_vbus_provided(port);
 340:Src/usb_pd_protocol.c **** #endif
 341:Src/usb_pd_protocol.c **** }
 342:Src/usb_pd_protocol.c **** #endif
 343:Src/usb_pd_protocol.c **** 
 344:Src/usb_pd_protocol.c **** static inline void set_state(int port, enum pd_states next_state)
 345:Src/usb_pd_protocol.c **** {
 346:Src/usb_pd_protocol.c **** 	enum pd_states last_state = pd[port].task_state;
 347:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 348:Src/usb_pd_protocol.c **** 	int i;
 349:Src/usb_pd_protocol.c **** #endif
 350:Src/usb_pd_protocol.c **** 
 351:Src/usb_pd_protocol.c **** 	set_state_timeout(port, 0, 0);
 352:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 353:Src/usb_pd_protocol.c **** 
 354:Src/usb_pd_protocol.c **** 	if (last_state == next_state)
 355:Src/usb_pd_protocol.c **** 		return;
 356:Src/usb_pd_protocol.c **** 
 357:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 358:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 359:Src/usb_pd_protocol.c **** 	/* Clear flag to allow DRP auto toggle when possible */
 360:Src/usb_pd_protocol.c **** 	if (last_state != PD_STATE_DRP_AUTO_TOGGLE)
 361:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_TCPC_DRP_TOGGLE;
 362:Src/usb_pd_protocol.c **** #endif
 363:Src/usb_pd_protocol.c **** 
 364:Src/usb_pd_protocol.c **** 	/* Ignore dual-role toggling between sink and source */
 365:Src/usb_pd_protocol.c **** 	if ((last_state == PD_STATE_SNK_DISCONNECTED &&
 366:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 367:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 368:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 369:Src/usb_pd_protocol.c **** 		return;
 370:Src/usb_pd_protocol.c **** 
 371:Src/usb_pd_protocol.c **** 	if (next_state == PD_STATE_SRC_DISCONNECTED ||
 372:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 373:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 374:Src/usb_pd_protocol.c **** 		pd_set_input_current_limit(port, 0, 0);
 375:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 376:Src/usb_pd_protocol.c **** 		//typec_set_input_current_limit(port, 0, 0);
ARM GAS  /tmp/ccWvVg6G.s 			page 8


 377:Src/usb_pd_protocol.c **** 		//charge_manager_set_ceil(port,
 378:Src/usb_pd_protocol.c **** 		//			CEIL_REQUESTOR_PD,
 379:Src/usb_pd_protocol.c **** 		//			CHARGE_CEIL_NONE);
 380:Src/usb_pd_protocol.c **** #endif
 381:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN
 382:Src/usb_pd_protocol.c **** 		tcpm_set_vconn(port, 0);
 383:Src/usb_pd_protocol.c **** #endif
 384:Src/usb_pd_protocol.c **** #else /* CONFIG_USB_PD_DUAL_ROLE */
 385:Src/usb_pd_protocol.c **** 	if (next_state == PD_STATE_SRC_DISCONNECTED) {
 386:Src/usb_pd_protocol.c **** #endif
 387:Src/usb_pd_protocol.c **** 		/*
 388:Src/usb_pd_protocol.c **** 		 * If we are source, make sure VBUS is off and
 389:Src/usb_pd_protocol.c **** 		 * if PD REV3.0, restore RP.
 390:Src/usb_pd_protocol.c **** 		 */
 391:Src/usb_pd_protocol.c **** 		if (pd[port].power_role == PD_ROLE_SOURCE) {
 392:Src/usb_pd_protocol.c **** 			/*
 393:Src/usb_pd_protocol.c **** 			 * Rp is restored by pd_power_supply_reset if
 394:Src/usb_pd_protocol.c **** 			 * CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT is defined.
 395:Src/usb_pd_protocol.c **** 			 */
 396:Src/usb_pd_protocol.c **** 			pd_power_supply_reset(port);
 397:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 398:Src/usb_pd_protocol.c **** 		defined(CONFIG_USB_PD_REV30)
 399:Src/usb_pd_protocol.c **** 			/* Restore Rp */
 400:Src/usb_pd_protocol.c **** 			tcpm_select_rp_value(port, CONFIG_USB_PD_PULLUP);
 401:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
 402:Src/usb_pd_protocol.c **** #endif
 403:Src/usb_pd_protocol.c **** 		}
 404:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 405:Src/usb_pd_protocol.c **** 		/* Adjust rev to highest level*/
 406:Src/usb_pd_protocol.c **** 		pd[port].rev = PD_REV30;
 407:Src/usb_pd_protocol.c **** #endif
 408:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
 409:Src/usb_pd_protocol.c **** 		pd[port].dev_id = 0;
 410:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_RESET_ON_DISCONNECT_MASK;
 411:Src/usb_pd_protocol.c **** #endif
 412:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 413:Src/usb_pd_protocol.c **** 		//charge_manager_update_dualrole(port, CAP_UNKNOWN);
 414:Src/usb_pd_protocol.c **** #endif
 415:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 416:Src/usb_pd_protocol.c **** 		pd_dfp_exit_mode(port, 0, 0);
 417:Src/usb_pd_protocol.c **** #endif
 418:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
 419:Src/usb_pd_protocol.c **** 		usb_mux_set(port, TYPEC_MUX_NONE, USB_SWITCH_DISCONNECT,
 420:Src/usb_pd_protocol.c **** 			    pd[port].polarity);
 421:Src/usb_pd_protocol.c **** #endif
 422:Src/usb_pd_protocol.c **** 		/* Disable TCPC RX */
 423:Src/usb_pd_protocol.c **** 		tcpm_set_rx_enable(port, 0);
 424:Src/usb_pd_protocol.c **** 	}
 425:Src/usb_pd_protocol.c **** 
 426:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 427:Src/usb_pd_protocol.c **** 	/* If a PD device is attached then disable deep sleep */
 428:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++) {
 429:Src/usb_pd_protocol.c **** 		if (pd[i].flags & PD_FLAGS_PREVIOUS_PD_CONN)
 430:Src/usb_pd_protocol.c **** 			break;
 431:Src/usb_pd_protocol.c **** 	}
 432:Src/usb_pd_protocol.c **** 	if (i == CONFIG_USB_PD_PORT_COUNT)
 433:Src/usb_pd_protocol.c **** 		enable_sleep(SLEEP_MASK_USB_PD);
ARM GAS  /tmp/ccWvVg6G.s 			page 9


 434:Src/usb_pd_protocol.c **** 	else
 435:Src/usb_pd_protocol.c **** 		disable_sleep(SLEEP_MASK_USB_PD);
 436:Src/usb_pd_protocol.c **** #endif
 437:Src/usb_pd_protocol.c **** 
 438:Src/usb_pd_protocol.c **** 	if (debug_level >= 1)
 439:Src/usb_pd_protocol.c **** 		CPRINTF("C%d st%d %s\n", port, next_state,
 440:Src/usb_pd_protocol.c **** 					 pd_state_names[next_state]);
 441:Src/usb_pd_protocol.c **** 	else
 442:Src/usb_pd_protocol.c **** 		CPRINTF("C%d st%d\n", port, next_state);
 443:Src/usb_pd_protocol.c **** }
 444:Src/usb_pd_protocol.c **** 
 445:Src/usb_pd_protocol.c **** /* increment message ID counter */
 446:Src/usb_pd_protocol.c **** static void inc_id(int port)
 447:Src/usb_pd_protocol.c **** {
  25              		.loc 1 447 0
  26              		.cfi_startproc
  27              		@ args = 0, pretend = 0, frame = 0
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              		@ link register save eliminated.
  30              	.LVL0:
 448:Src/usb_pd_protocol.c **** 	pd[port].msg_id = (pd[port].msg_id + 1) & PD_MESSAGE_ID_COUNT;
  31              		.loc 1 448 0
  32 0000 C301     		lsls	r3, r0, #7
  33 0002 0448     		ldr	r0, .L2
  34              	.LVL1:
  35 0004 C018     		adds	r0, r0, r3
  36 0006 8378     		ldrb	r3, [r0, #2]
  37 0008 0133     		adds	r3, r3, #1
  38 000a 0722     		movs	r2, #7
  39 000c 1340     		ands	r3, r2
  40 000e 8370     		strb	r3, [r0, #2]
 449:Src/usb_pd_protocol.c **** }
  41              		.loc 1 449 0
  42              		@ sp needed
  43 0010 7047     		bx	lr
  44              	.L3:
  45 0012 C046     		.align	2
  46              	.L2:
  47 0014 00000000 		.word	pd
  48              		.cfi_endproc
  49              	.LFE25:
  51              		.section	.text.pd_update_roles,"ax",%progbits
  52              		.align	1
  53              		.syntax unified
  54              		.code	16
  55              		.thumb_func
  56              		.fpu softvfp
  58              	pd_update_roles:
  59              	.LFB28:
 450:Src/usb_pd_protocol.c **** 
 451:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 452:Src/usb_pd_protocol.c **** static void sink_can_xmit(int port, int rp)
 453:Src/usb_pd_protocol.c **** {
 454:Src/usb_pd_protocol.c **** 	tcpm_select_rp_value(port, rp);
 455:Src/usb_pd_protocol.c **** 	tcpm_set_cc(port, TYPEC_CC_RP);
 456:Src/usb_pd_protocol.c **** }
 457:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccWvVg6G.s 			page 10


 458:Src/usb_pd_protocol.c **** static inline void pd_ca_reset(int port)
 459:Src/usb_pd_protocol.c **** {
 460:Src/usb_pd_protocol.c **** 	pd[port].ca_buffered = 0;
 461:Src/usb_pd_protocol.c **** }
 462:Src/usb_pd_protocol.c **** #endif
 463:Src/usb_pd_protocol.c **** 
 464:Src/usb_pd_protocol.c **** void pd_transmit_complete(int port, int status)
 465:Src/usb_pd_protocol.c **** {
 466:Src/usb_pd_protocol.c **** 	if (status == TCPC_TX_COMPLETE_SUCCESS)
 467:Src/usb_pd_protocol.c **** 		inc_id(port);
 468:Src/usb_pd_protocol.c **** 
 469:Src/usb_pd_protocol.c **** 	pd[port].tx_status = status;
 470:Src/usb_pd_protocol.c **** 	//task_set_event(PD_PORT_TO_TASK_ID(port), PD_EVENT_TX, 0);
 471:Src/usb_pd_protocol.c **** 	pd_task_set_event(PD_EVENT_TX, 0);
 472:Src/usb_pd_protocol.c **** }
 473:Src/usb_pd_protocol.c **** 
 474:Src/usb_pd_protocol.c **** static int pd_transmit(int port, enum tcpm_transmit_type type,
 475:Src/usb_pd_protocol.c **** 		       uint16_t header, const uint32_t *data)
 476:Src/usb_pd_protocol.c **** {
 477:Src/usb_pd_protocol.c **** 	int evt;
 478:Src/usb_pd_protocol.c **** 
 479:Src/usb_pd_protocol.c **** 	/* If comms are disabled, do not transmit, return error */
 480:Src/usb_pd_protocol.c **** 	if (!pd_comm_is_enabled(port))
 481:Src/usb_pd_protocol.c **** 		return -1;
 482:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 483:Src/usb_pd_protocol.c **** 	/* Source-coordinated collision avoidance */
 484:Src/usb_pd_protocol.c **** 	/*
 485:Src/usb_pd_protocol.c **** 	 * In order to avoid message collisions due to asynchronous Messaging
 486:Src/usb_pd_protocol.c **** 	 * sent from the Sink, the Source sets Rp to SinkTxOk to indicate to
 487:Src/usb_pd_protocol.c **** 	 * the Sink that it is ok to initiate an AMS. When the Source wishes
 488:Src/usb_pd_protocol.c **** 	 * to initiate an AMS it sets Rp to SinkTxNG. When the Sink detects
 489:Src/usb_pd_protocol.c **** 	 * that Rp is set to SinkTxOk it May initiate an AMS. When the Sink
 490:Src/usb_pd_protocol.c **** 	 * detects that Rp is set to SinkTxNG it Shall Not initiate an AMS
 491:Src/usb_pd_protocol.c **** 	 * and Shall only send Messages that are part of an AMS the Source has
 492:Src/usb_pd_protocol.c **** 	 * initiated. Note that this restriction applies to SOP* AMS’s i.e.
 493:Src/usb_pd_protocol.c **** 	 * for both Port to Port and Port to Cable Plug communications.
 494:Src/usb_pd_protocol.c **** 	 *
 495:Src/usb_pd_protocol.c **** 	 * This starts after an Explicit Contract is in place
 496:Src/usb_pd_protocol.c **** 	 * PD R3 V1.1 Section 2.5.2.
 497:Src/usb_pd_protocol.c **** 	 *
 498:Src/usb_pd_protocol.c **** 	 * Note: a Sink can still send Hard Reset signaling at any time.
 499:Src/usb_pd_protocol.c **** 	 */
 500:Src/usb_pd_protocol.c **** 	if ((pd[port].rev == PD_REV30) &&
 501:Src/usb_pd_protocol.c **** 		(pd[port].flags & PD_FLAGS_EXPLICIT_CONTRACT)) {
 502:Src/usb_pd_protocol.c **** 		if (pd[port].power_role == PD_ROLE_SOURCE) {
 503:Src/usb_pd_protocol.c **** 			/*
 504:Src/usb_pd_protocol.c **** 			 * Inform Sink that it can't transmit. If a sink
 505:Src/usb_pd_protocol.c **** 			 * transmition is in progress and a collsion occurs,
 506:Src/usb_pd_protocol.c **** 			 * a reset is generated. This should be rare because
 507:Src/usb_pd_protocol.c **** 			 * all extended messages are chunked. This effectively
 508:Src/usb_pd_protocol.c **** 			 * defaults to PD REV 2.0 collision avoidance.
 509:Src/usb_pd_protocol.c **** 			 */
 510:Src/usb_pd_protocol.c **** 			sink_can_xmit(port, SINK_TX_NG);
 511:Src/usb_pd_protocol.c **** 		} else if (type != TCPC_TX_HARD_RESET) {
 512:Src/usb_pd_protocol.c **** 			int cc1;
 513:Src/usb_pd_protocol.c **** 			int cc2;
 514:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccWvVg6G.s 			page 11


 515:Src/usb_pd_protocol.c **** 			tcpm_get_cc(port, &cc1, &cc2);
 516:Src/usb_pd_protocol.c **** 			if (cc1 == TYPEC_CC_VOLT_SNK_1_5 ||
 517:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_SNK_1_5) {
 518:Src/usb_pd_protocol.c **** 				/* Sink can't transmit now. */
 519:Src/usb_pd_protocol.c **** 				/* Check if message is already buffered. */
 520:Src/usb_pd_protocol.c **** 				if (pd[port].ca_buffered)
 521:Src/usb_pd_protocol.c **** 					return -1;
 522:Src/usb_pd_protocol.c **** 
 523:Src/usb_pd_protocol.c **** 				/* Buffer message and send later. */
 524:Src/usb_pd_protocol.c **** 				pd[port].ca_type = type;
 525:Src/usb_pd_protocol.c **** 				pd[port].ca_header = header;
 526:Src/usb_pd_protocol.c **** 				memcpy(pd[port].ca_buffer,
 527:Src/usb_pd_protocol.c **** 					data, sizeof(uint32_t) *
 528:Src/usb_pd_protocol.c **** 					PD_HEADER_CNT(header));
 529:Src/usb_pd_protocol.c **** 				pd[port].ca_buffered = 1;
 530:Src/usb_pd_protocol.c **** 				return 1;
 531:Src/usb_pd_protocol.c **** 			}
 532:Src/usb_pd_protocol.c **** 		}
 533:Src/usb_pd_protocol.c **** 	}
 534:Src/usb_pd_protocol.c **** #endif
 535:Src/usb_pd_protocol.c **** 	tcpm_transmit(port, type, header, data);
 536:Src/usb_pd_protocol.c **** 
 537:Src/usb_pd_protocol.c **** 	/* Wait until TX is complete */
 538:Src/usb_pd_protocol.c **** 	// Would wait, except that we're making tcpm_transmit blocking
 539:Src/usb_pd_protocol.c **** 	//evt = task_wait_event_mask(PD_EVENT_TX, PD_T_TCPC_TX_TIMEOUT);
 540:Src/usb_pd_protocol.c **** 
 541:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 542:Src/usb_pd_protocol.c **** 	/*
 543:Src/usb_pd_protocol.c **** 	 * If the source just completed a transmit, tell
 544:Src/usb_pd_protocol.c **** 	 * the sink it can transmit if it wants to.
 545:Src/usb_pd_protocol.c **** 	 */
 546:Src/usb_pd_protocol.c **** 	if ((pd[port].rev == PD_REV30) &&
 547:Src/usb_pd_protocol.c **** 			(pd[port].power_role == PD_ROLE_SOURCE) &&
 548:Src/usb_pd_protocol.c **** 			(pd[port].flags & PD_FLAGS_EXPLICIT_CONTRACT)) {
 549:Src/usb_pd_protocol.c **** 		sink_can_xmit(port, SINK_TX_OK);
 550:Src/usb_pd_protocol.c **** 	}
 551:Src/usb_pd_protocol.c **** #endif
 552:Src/usb_pd_protocol.c **** 
 553:Src/usb_pd_protocol.c **** 	// removing task-based stuff from the library
 554:Src/usb_pd_protocol.c **** 	//if (evt & TASK_EVENT_TIMER)
 555:Src/usb_pd_protocol.c ****     //		return -1;
 556:Src/usb_pd_protocol.c **** 
 557:Src/usb_pd_protocol.c **** 	/* TODO: give different error condition for failed vs discarded */
 558:Src/usb_pd_protocol.c **** 	return pd[port].tx_status == TCPC_TX_COMPLETE_SUCCESS ? 1 : -1;
 559:Src/usb_pd_protocol.c **** }
 560:Src/usb_pd_protocol.c **** 
 561:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 562:Src/usb_pd_protocol.c **** static void pd_ca_send_pending(int port)
 563:Src/usb_pd_protocol.c **** {
 564:Src/usb_pd_protocol.c **** 	int cc1;
 565:Src/usb_pd_protocol.c **** 	int cc2;
 566:Src/usb_pd_protocol.c **** 
 567:Src/usb_pd_protocol.c **** 	/* Check if a message has been buffered. */
 568:Src/usb_pd_protocol.c **** 	if (!pd[port].ca_buffered)
 569:Src/usb_pd_protocol.c **** 		return;
 570:Src/usb_pd_protocol.c **** 
 571:Src/usb_pd_protocol.c **** 	tcpm_get_cc(port, &cc1, &cc2);
ARM GAS  /tmp/ccWvVg6G.s 			page 12


 572:Src/usb_pd_protocol.c **** 	if ((cc1 != TYPEC_CC_VOLT_SNK_1_5) &&
 573:Src/usb_pd_protocol.c **** 			(cc2 != TYPEC_CC_VOLT_SNK_1_5))
 574:Src/usb_pd_protocol.c **** 		if (pd_transmit(port, pd[port].ca_type,
 575:Src/usb_pd_protocol.c **** 				pd[port].ca_header,
 576:Src/usb_pd_protocol.c **** 				pd[port].ca_buffer) < 0)
 577:Src/usb_pd_protocol.c **** 			return;
 578:Src/usb_pd_protocol.c **** 
 579:Src/usb_pd_protocol.c **** 	/* Message was sent, so free up the buffer. */
 580:Src/usb_pd_protocol.c **** 	pd[port].ca_buffered = 0;
 581:Src/usb_pd_protocol.c **** }
 582:Src/usb_pd_protocol.c **** #endif
 583:Src/usb_pd_protocol.c **** 
 584:Src/usb_pd_protocol.c **** static void pd_update_roles(int port)
 585:Src/usb_pd_protocol.c **** {
  60              		.loc 1 585 0
  61              		.cfi_startproc
  62              		@ args = 0, pretend = 0, frame = 0
  63              		@ frame_needed = 0, uses_anonymous_args = 0
  64              	.LVL2:
  65 0000 10B5     		push	{r4, lr}
  66              	.LCFI0:
  67              		.cfi_def_cfa_offset 8
  68              		.cfi_offset 4, -8
  69              		.cfi_offset 14, -4
 586:Src/usb_pd_protocol.c **** 	/* Notify TCPC of role update */
 587:Src/usb_pd_protocol.c **** 	tcpm_set_msg_header(port, pd[port].power_role, pd[port].data_role);
  70              		.loc 1 587 0
  71 0002 064B     		ldr	r3, .L5
  72 0004 C201     		lsls	r2, r0, #7
  73 0006 D15C     		ldrb	r1, [r2, r3]
  74 0008 9B18     		adds	r3, r3, r2
  75 000a 5A78     		ldrb	r2, [r3, #1]
  76              	.LVL3:
  77              	.LBB146:
  78              	.LBB147:
  79              		.file 2 "Inc/tcpm.h"
   1:Inc/tcpm.h    **** /* Copyright 2015 The Chromium OS Authors. All rights reserved.
   2:Inc/tcpm.h    ****  * Use of this source code is governed by a BSD-style license that can be
   3:Inc/tcpm.h    ****  * found in the LICENSE file.
   4:Inc/tcpm.h    ****  */
   5:Inc/tcpm.h    **** 
   6:Inc/tcpm.h    **** /* USB Power delivery port management - common header for TCPM drivers */
   7:Inc/tcpm.h    **** 
   8:Inc/tcpm.h    **** #ifndef __CROS_EC_USB_PD_TCPM_TCPM_H
   9:Inc/tcpm.h    **** #define __CROS_EC_USB_PD_TCPM_TCPM_H
  10:Inc/tcpm.h    **** 
  11:Inc/tcpm.h    **** #include "tcpm_driver.h"
  12:Inc/tcpm.h    **** #include "usb_pd_tcpm.h"
  13:Inc/tcpm.h    **** 
  14:Inc/tcpm.h    **** #if defined(CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE) && \
  15:Inc/tcpm.h    **** 	!defined(CONFIG_USB_PD_DUAL_ROLE)
  16:Inc/tcpm.h    **** #error "DRP auto toggle requires board to have DRP support"
  17:Inc/tcpm.h    **** #error "Please upgrade your board configuration"
  18:Inc/tcpm.h    **** #endif
  19:Inc/tcpm.h    **** 
  20:Inc/tcpm.h    **** #ifndef CONFIG_USB_PD_TCPC
  21:Inc/tcpm.h    **** extern const struct tcpc_config_t tcpc_config[];
ARM GAS  /tmp/ccWvVg6G.s 			page 13


  22:Inc/tcpm.h    **** 
  23:Inc/tcpm.h    **** /* I2C wrapper functions - get I2C port / slave addr from config struct. */
  24:Inc/tcpm.h    **** int tcpc_write(int port, int reg, int val);
  25:Inc/tcpm.h    **** int tcpc_write16(int port, int reg, int val);
  26:Inc/tcpm.h    **** int tcpc_read(int port, int reg, int *val);
  27:Inc/tcpm.h    **** int tcpc_read16(int port, int reg, int *val);
  28:Inc/tcpm.h    **** int tcpc_xfer(int port,
  29:Inc/tcpm.h    **** 		uint8_t *out, int out_size,
  30:Inc/tcpm.h    **** 		uint8_t *in, int in_size,
  31:Inc/tcpm.h    **** 		int flags);
  32:Inc/tcpm.h    **** 
  33:Inc/tcpm.h    **** /* TCPM driver wrapper function */
  34:Inc/tcpm.h    **** static inline int tcpm_init(int port)
  35:Inc/tcpm.h    **** {
  36:Inc/tcpm.h    **** 	int rv;
  37:Inc/tcpm.h    **** 
  38:Inc/tcpm.h    **** 	rv = tcpc_config[port].drv->init(port);
  39:Inc/tcpm.h    **** 	if (rv)
  40:Inc/tcpm.h    **** 		return rv;
  41:Inc/tcpm.h    **** 
  42:Inc/tcpm.h    **** 	/* Board specific post TCPC init */
  43:Inc/tcpm.h    **** 	if (board_tcpc_post_init)
  44:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
  45:Inc/tcpm.h    **** 
  46:Inc/tcpm.h    **** 	return rv;
  47:Inc/tcpm.h    **** }
  48:Inc/tcpm.h    **** 
  49:Inc/tcpm.h    **** static inline int tcpm_release(int port)
  50:Inc/tcpm.h    **** {
  51:Inc/tcpm.h    **** 	return tcpc_config[port].drv->release(port);
  52:Inc/tcpm.h    **** }
  53:Inc/tcpm.h    **** 
  54:Inc/tcpm.h    **** static inline int tcpm_get_cc(int port, int *cc1, int *cc2)
  55:Inc/tcpm.h    **** {
  56:Inc/tcpm.h    **** 	return tcpc_config[port].drv->get_cc(port, cc1, cc2);
  57:Inc/tcpm.h    **** }
  58:Inc/tcpm.h    **** 
  59:Inc/tcpm.h    **** static inline int tcpm_get_vbus_level(int port)
  60:Inc/tcpm.h    **** {
  61:Inc/tcpm.h    **** 	return tcpc_config[port].drv->get_vbus_level(port);
  62:Inc/tcpm.h    **** }
  63:Inc/tcpm.h    **** 
  64:Inc/tcpm.h    **** static inline int tcpm_select_rp_value(int port, int rp)
  65:Inc/tcpm.h    **** {
  66:Inc/tcpm.h    **** 	return tcpc_config[port].drv->select_rp_value(port, rp);
  67:Inc/tcpm.h    **** }
  68:Inc/tcpm.h    **** 
  69:Inc/tcpm.h    **** static inline int tcpm_set_cc(int port, int pull)
  70:Inc/tcpm.h    **** {
  71:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_cc(port, pull);
  72:Inc/tcpm.h    **** }
  73:Inc/tcpm.h    **** 
  74:Inc/tcpm.h    **** static inline int tcpm_set_polarity(int port, int polarity)
  75:Inc/tcpm.h    **** {
  76:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_polarity(port, polarity);
  77:Inc/tcpm.h    **** }
  78:Inc/tcpm.h    **** 
ARM GAS  /tmp/ccWvVg6G.s 			page 14


  79:Inc/tcpm.h    **** static inline int tcpm_set_vconn(int port, int enable)
  80:Inc/tcpm.h    **** {
  81:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_vconn(port, enable);
  82:Inc/tcpm.h    **** }
  83:Inc/tcpm.h    **** 
  84:Inc/tcpm.h    **** static inline int tcpm_set_msg_header(int port, int power_role, int data_role)
  85:Inc/tcpm.h    **** {
  86:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_msg_header(port, power_role,
  80              		.loc 2 86 0
  81 000c 0401     		lsls	r4, r0, #4
  82 000e 044B     		ldr	r3, .L5+4
  83 0010 1B19     		adds	r3, r3, r4
  84 0012 9B68     		ldr	r3, [r3, #8]
  85 0014 1B6A     		ldr	r3, [r3, #32]
  86 0016 9847     		blx	r3
  87              	.LVL4:
  88              	.LBE147:
  89              	.LBE146:
 588:Src/usb_pd_protocol.c **** }
  90              		.loc 1 588 0
  91              		@ sp needed
  92 0018 10BD     		pop	{r4, pc}
  93              	.L6:
  94 001a C046     		.align	2
  95              	.L5:
  96 001c 00000000 		.word	pd
  97 0020 00000000 		.word	tcpc_config
  98              		.cfi_endproc
  99              	.LFE28:
 101              		.section	.text.pd_update_pdo_flags,"ax",%progbits
 102              		.align	1
 103              		.syntax unified
 104              		.code	16
 105              		.thumb_func
 106              		.fpu softvfp
 108              	pd_update_pdo_flags:
 109              	.LFB39:
 589:Src/usb_pd_protocol.c **** 
 590:Src/usb_pd_protocol.c **** static int send_control(int port, int type)
 591:Src/usb_pd_protocol.c **** {
 592:Src/usb_pd_protocol.c **** 	int bit_len;
 593:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(type, pd[port].power_role,
 594:Src/usb_pd_protocol.c **** 				pd[port].data_role, pd[port].msg_id, 0,
 595:Src/usb_pd_protocol.c **** 				pd_get_rev(port), 0);
 596:Src/usb_pd_protocol.c **** 
 597:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, NULL);
 598:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 599:Src/usb_pd_protocol.c **** 		CPRINTF("CTRL[%d]>%d\n", type, bit_len);
 600:Src/usb_pd_protocol.c **** 
 601:Src/usb_pd_protocol.c **** 	return bit_len;
 602:Src/usb_pd_protocol.c **** }
 603:Src/usb_pd_protocol.c **** 
 604:Src/usb_pd_protocol.c **** static int send_source_cap(int port)
 605:Src/usb_pd_protocol.c **** {
 606:Src/usb_pd_protocol.c **** 	int bit_len;
 607:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_DYNAMIC_SRC_CAP) || \
 608:Src/usb_pd_protocol.c **** 		defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT)
ARM GAS  /tmp/ccWvVg6G.s 			page 15


 609:Src/usb_pd_protocol.c **** 	const uint32_t *src_pdo;
 610:Src/usb_pd_protocol.c **** 	const int src_pdo_cnt = charge_manager_get_source_pdo(&src_pdo, port);
 611:Src/usb_pd_protocol.c **** #else
 612:Src/usb_pd_protocol.c **** 	const uint32_t *src_pdo = pd_src_pdo;
 613:Src/usb_pd_protocol.c **** 	const int src_pdo_cnt = pd_src_pdo_cnt;
 614:Src/usb_pd_protocol.c **** #endif
 615:Src/usb_pd_protocol.c **** 	uint16_t header;
 616:Src/usb_pd_protocol.c **** 
 617:Src/usb_pd_protocol.c **** 	if (src_pdo_cnt == 0)
 618:Src/usb_pd_protocol.c **** 		/* No source capabilities defined, sink only */
 619:Src/usb_pd_protocol.c **** 		header = PD_HEADER(PD_CTRL_REJECT, pd[port].power_role,
 620:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 0,
 621:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 622:Src/usb_pd_protocol.c **** 	else
 623:Src/usb_pd_protocol.c **** 		header = PD_HEADER(PD_DATA_SOURCE_CAP, pd[port].power_role,
 624:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 625:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 626:Src/usb_pd_protocol.c **** 
 627:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, src_pdo);
 628:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 629:Src/usb_pd_protocol.c **** 		CPRINTF("srcCAP>%d\n", bit_len);
 630:Src/usb_pd_protocol.c **** 
 631:Src/usb_pd_protocol.c **** 	return bit_len;
 632:Src/usb_pd_protocol.c **** }
 633:Src/usb_pd_protocol.c **** 
 634:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 635:Src/usb_pd_protocol.c **** static int send_battery_cap(int port, uint32_t *payload)
 636:Src/usb_pd_protocol.c **** {
 637:Src/usb_pd_protocol.c **** 	int bit_len;
 638:Src/usb_pd_protocol.c **** 	uint16_t msg[6] = {0, 0, 0, 0, 0, 0};
 639:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_EXT_BATTERY_CAP,
 640:Src/usb_pd_protocol.c **** 				    pd[port].power_role,
 641:Src/usb_pd_protocol.c **** 				    pd[port].data_role,
 642:Src/usb_pd_protocol.c **** 				    pd[port].msg_id,
 643:Src/usb_pd_protocol.c **** 				    3, /* Number of Data Objects */
 644:Src/usb_pd_protocol.c **** 				    pd[port].rev,
 645:Src/usb_pd_protocol.c **** 				    1  /* This is an exteded message */
 646:Src/usb_pd_protocol.c **** 				   );
 647:Src/usb_pd_protocol.c **** 
 648:Src/usb_pd_protocol.c **** 	/* Set extended header */
 649:Src/usb_pd_protocol.c **** 	msg[0] = PD_EXT_HEADER(0, /* Chunk Number */
 650:Src/usb_pd_protocol.c **** 			       0, /* Request Chunk */
 651:Src/usb_pd_protocol.c **** 			       9  /* Data Size in bytes */
 652:Src/usb_pd_protocol.c **** 			      );
 653:Src/usb_pd_protocol.c **** 	/* Set VID */
 654:Src/usb_pd_protocol.c **** 	msg[1] = USB_VID_GOOGLE;
 655:Src/usb_pd_protocol.c **** 
 656:Src/usb_pd_protocol.c **** 	/* Set PID */
 657:Src/usb_pd_protocol.c **** 	msg[2] = CONFIG_USB_PID;
 658:Src/usb_pd_protocol.c **** 
 659:Src/usb_pd_protocol.c **** 	if (battery_is_present()) {
 660:Src/usb_pd_protocol.c **** 		/*
 661:Src/usb_pd_protocol.c **** 		 * We only have one fixed battery,
 662:Src/usb_pd_protocol.c **** 		 * so make sure batt cap ref is 0.
 663:Src/usb_pd_protocol.c **** 		 */
 664:Src/usb_pd_protocol.c **** 		if (BATT_CAP_REF(payload[0]) != 0) {
 665:Src/usb_pd_protocol.c **** 			/* Invalid battery reference */
ARM GAS  /tmp/ccWvVg6G.s 			page 16


 666:Src/usb_pd_protocol.c **** 			msg[5] = 1;
 667:Src/usb_pd_protocol.c **** 		} else {
 668:Src/usb_pd_protocol.c **** 			uint32_t v;
 669:Src/usb_pd_protocol.c **** 			uint32_t c;
 670:Src/usb_pd_protocol.c **** 
 671:Src/usb_pd_protocol.c **** 			/*
 672:Src/usb_pd_protocol.c **** 			 * The Battery Design Capacity field shall return the
 673:Src/usb_pd_protocol.c **** 			 * Battery’s design capacity in tenths of Wh. If the
 674:Src/usb_pd_protocol.c **** 			 * Battery is Hot Swappable and is not present, the
 675:Src/usb_pd_protocol.c **** 			 * Battery Design Capacity field shall be set to 0. If
 676:Src/usb_pd_protocol.c **** 			 * the Battery is unable to report its Design Capacity,
 677:Src/usb_pd_protocol.c **** 			 * it shall return 0xFFFF
 678:Src/usb_pd_protocol.c **** 			 */
 679:Src/usb_pd_protocol.c **** 			msg[3] = 0xffff;
 680:Src/usb_pd_protocol.c **** 
 681:Src/usb_pd_protocol.c **** 			/*
 682:Src/usb_pd_protocol.c **** 			 * The Battery Last Full Charge Capacity field shall
 683:Src/usb_pd_protocol.c **** 			 * return the Battery’s last full charge capacity in
 684:Src/usb_pd_protocol.c **** 			 * tenths of Wh. If the Battery is Hot Swappable and
 685:Src/usb_pd_protocol.c **** 			 * is not present, the Battery Last Full Charge Capacity
 686:Src/usb_pd_protocol.c **** 			 * field shall be set to 0. If the Battery is unable to
 687:Src/usb_pd_protocol.c **** 			 * report its Design Capacity, the Battery Last Full
 688:Src/usb_pd_protocol.c **** 			 * Charge Capacity field shall be set to 0xFFFF.
 689:Src/usb_pd_protocol.c **** 			 */
 690:Src/usb_pd_protocol.c **** 			msg[4] = 0xffff;
 691:Src/usb_pd_protocol.c **** 
 692:Src/usb_pd_protocol.c **** 			if (battery_design_voltage(&v) == 0) {
 693:Src/usb_pd_protocol.c **** 				if (battery_design_capacity(&c) == 0) {
 694:Src/usb_pd_protocol.c **** 					/*
 695:Src/usb_pd_protocol.c **** 					 * Wh = (c * v) / 1000000
 696:Src/usb_pd_protocol.c **** 					 * 10th of a Wh = Wh * 10
 697:Src/usb_pd_protocol.c **** 					 */
 698:Src/usb_pd_protocol.c **** 					msg[3] = DIV_ROUND_NEAREST((c * v),
 699:Src/usb_pd_protocol.c **** 								100000);
 700:Src/usb_pd_protocol.c **** 				}
 701:Src/usb_pd_protocol.c **** 
 702:Src/usb_pd_protocol.c **** 				if (battery_full_charge_capacity(&c) == 0) {
 703:Src/usb_pd_protocol.c **** 					/*
 704:Src/usb_pd_protocol.c **** 					 * Wh = (c * v) / 1000000
 705:Src/usb_pd_protocol.c **** 					 * 10th of a Wh = Wh * 10
 706:Src/usb_pd_protocol.c **** 					 */
 707:Src/usb_pd_protocol.c **** 					msg[4] = DIV_ROUND_NEAREST((c * v),
 708:Src/usb_pd_protocol.c **** 								100000);
 709:Src/usb_pd_protocol.c **** 				}
 710:Src/usb_pd_protocol.c **** 			}
 711:Src/usb_pd_protocol.c **** 		}
 712:Src/usb_pd_protocol.c **** 	}
 713:Src/usb_pd_protocol.c **** 
 714:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, (uint32_t *)msg);
 715:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 716:Src/usb_pd_protocol.c **** 		CPRINTF("batCap>%d\n", bit_len);
 717:Src/usb_pd_protocol.c **** 	return bit_len;
 718:Src/usb_pd_protocol.c **** }
 719:Src/usb_pd_protocol.c **** 
 720:Src/usb_pd_protocol.c **** static int send_battery_status(int port,  uint32_t *payload)
 721:Src/usb_pd_protocol.c **** {
 722:Src/usb_pd_protocol.c **** 	int bit_len;
ARM GAS  /tmp/ccWvVg6G.s 			page 17


 723:Src/usb_pd_protocol.c **** 	uint32_t msg = 0;
 724:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_BATTERY_STATUS,
 725:Src/usb_pd_protocol.c **** 				    pd[port].power_role,
 726:Src/usb_pd_protocol.c **** 				    pd[port].data_role,
 727:Src/usb_pd_protocol.c **** 				    pd[port].msg_id,
 728:Src/usb_pd_protocol.c **** 				    1, /* Number of Data Objects */
 729:Src/usb_pd_protocol.c **** 				    pd[port].rev,
 730:Src/usb_pd_protocol.c **** 				    0 /* This is NOT an extended message */
 731:Src/usb_pd_protocol.c **** 				  );
 732:Src/usb_pd_protocol.c **** 
 733:Src/usb_pd_protocol.c **** 	if (battery_is_present()) {
 734:Src/usb_pd_protocol.c **** 		/*
 735:Src/usb_pd_protocol.c **** 		 * We only have one fixed battery,
 736:Src/usb_pd_protocol.c **** 		 * so make sure batt cap ref is 0.
 737:Src/usb_pd_protocol.c **** 		 */
 738:Src/usb_pd_protocol.c **** 		if (BATT_CAP_REF(payload[0]) != 0) {
 739:Src/usb_pd_protocol.c **** 			/* Invalid battery reference */
 740:Src/usb_pd_protocol.c **** 			msg |= BSDO_INVALID;
 741:Src/usb_pd_protocol.c **** 		} else {
 742:Src/usb_pd_protocol.c **** 			uint32_t v;
 743:Src/usb_pd_protocol.c **** 			uint32_t c;
 744:Src/usb_pd_protocol.c **** 
 745:Src/usb_pd_protocol.c **** 			if (battery_design_voltage(&v) != 0 ||
 746:Src/usb_pd_protocol.c **** 					battery_remaining_capacity(&c) != 0) {
 747:Src/usb_pd_protocol.c **** 				msg |= BSDO_CAP(BSDO_CAP_UNKNOWN);
 748:Src/usb_pd_protocol.c **** 			} else {
 749:Src/usb_pd_protocol.c **** 				/*
 750:Src/usb_pd_protocol.c **** 				 * Wh = (c * v) / 1000000
 751:Src/usb_pd_protocol.c **** 				 * 10th of a Wh = Wh * 10
 752:Src/usb_pd_protocol.c **** 				 */
 753:Src/usb_pd_protocol.c **** 				msg |= BSDO_CAP(DIV_ROUND_NEAREST((c * v),
 754:Src/usb_pd_protocol.c **** 								100000));
 755:Src/usb_pd_protocol.c **** 			}
 756:Src/usb_pd_protocol.c **** 
 757:Src/usb_pd_protocol.c **** 			/* Battery is present */
 758:Src/usb_pd_protocol.c **** 			msg |= BSDO_PRESENT;
 759:Src/usb_pd_protocol.c **** 
 760:Src/usb_pd_protocol.c **** 			/*
 761:Src/usb_pd_protocol.c **** 			 * For drivers that are not smart battery compliant,
 762:Src/usb_pd_protocol.c **** 			 * battery_status() returns EC_ERROR_UNIMPLEMENTED and
 763:Src/usb_pd_protocol.c **** 			 * the battery is assumed to be idle.
 764:Src/usb_pd_protocol.c **** 			 */
 765:Src/usb_pd_protocol.c **** 			if (battery_status(&c) != 0) {
 766:Src/usb_pd_protocol.c **** 				msg |= BSDO_IDLE; /* assume idle */
 767:Src/usb_pd_protocol.c **** 			} else {
 768:Src/usb_pd_protocol.c **** 				if (c & STATUS_FULLY_CHARGED)
 769:Src/usb_pd_protocol.c **** 					/* Fully charged */
 770:Src/usb_pd_protocol.c **** 					msg |= BSDO_IDLE;
 771:Src/usb_pd_protocol.c **** 				else if (c & STATUS_DISCHARGING)
 772:Src/usb_pd_protocol.c **** 					/* Discharging */
 773:Src/usb_pd_protocol.c **** 					msg |= BSDO_DISCHARGING;
 774:Src/usb_pd_protocol.c **** 				/* else battery is charging.*/
 775:Src/usb_pd_protocol.c **** 			}
 776:Src/usb_pd_protocol.c **** 		}
 777:Src/usb_pd_protocol.c **** 	} else {
 778:Src/usb_pd_protocol.c **** 		msg = BSDO_CAP(BSDO_CAP_UNKNOWN);
 779:Src/usb_pd_protocol.c **** 	}
ARM GAS  /tmp/ccWvVg6G.s 			page 18


 780:Src/usb_pd_protocol.c **** 
 781:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, &msg);
 782:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 783:Src/usb_pd_protocol.c **** 		CPRINTF("batStat>%d\n", bit_len);
 784:Src/usb_pd_protocol.c **** 
 785:Src/usb_pd_protocol.c **** 	return bit_len;
 786:Src/usb_pd_protocol.c **** }
 787:Src/usb_pd_protocol.c **** #endif
 788:Src/usb_pd_protocol.c **** 
 789:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 790:Src/usb_pd_protocol.c **** static void send_sink_cap(int port)
 791:Src/usb_pd_protocol.c **** {
 792:Src/usb_pd_protocol.c **** 	int bit_len;
 793:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_SINK_CAP, pd[port].power_role,
 794:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, pd_snk_pdo_cnt,
 795:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 796:Src/usb_pd_protocol.c **** 
 797:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, pd_snk_pdo);
 798:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 799:Src/usb_pd_protocol.c **** 		CPRINTF("snkCAP>%d\n", bit_len);
 800:Src/usb_pd_protocol.c **** }
 801:Src/usb_pd_protocol.c **** 
 802:Src/usb_pd_protocol.c **** static int send_request(int port, uint32_t rdo)
 803:Src/usb_pd_protocol.c **** {
 804:Src/usb_pd_protocol.c **** 	int bit_len;
 805:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_REQUEST, pd[port].power_role,
 806:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 807:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 808:Src/usb_pd_protocol.c **** 
 809:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, &rdo);
 810:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 811:Src/usb_pd_protocol.c **** 		CPRINTF("REQ%d>\n", bit_len);
 812:Src/usb_pd_protocol.c **** 
 813:Src/usb_pd_protocol.c **** 	return bit_len;
 814:Src/usb_pd_protocol.c **** }
 815:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
 816:Src/usb_pd_protocol.c **** static int pd_get_saved_active(int port)
 817:Src/usb_pd_protocol.c **** {
 818:Src/usb_pd_protocol.c **** 	uint8_t val;
 819:Src/usb_pd_protocol.c **** 
 820:Src/usb_pd_protocol.c **** 	if (system_get_bbram(port ? SYSTEM_BBRAM_IDX_PD1 :
 821:Src/usb_pd_protocol.c **** 				    SYSTEM_BBRAM_IDX_PD0, &val)) {
 822:Src/usb_pd_protocol.c **** 		CPRINTS("PD NVRAM FAIL");
 823:Src/usb_pd_protocol.c **** 		return 0;
 824:Src/usb_pd_protocol.c **** 	}
 825:Src/usb_pd_protocol.c **** 	return !!val;
 826:Src/usb_pd_protocol.c **** }
 827:Src/usb_pd_protocol.c **** 
 828:Src/usb_pd_protocol.c **** static void pd_set_saved_active(int port, int val)
 829:Src/usb_pd_protocol.c **** {
 830:Src/usb_pd_protocol.c **** 	if (system_set_bbram(port ? SYSTEM_BBRAM_IDX_PD1 :
 831:Src/usb_pd_protocol.c **** 				    SYSTEM_BBRAM_IDX_PD0, val))
 832:Src/usb_pd_protocol.c **** 		CPRINTS("PD NVRAM FAIL");
 833:Src/usb_pd_protocol.c **** }
 834:Src/usb_pd_protocol.c **** #endif // CONFIG_BBRAM
 835:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 836:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccWvVg6G.s 			page 19


 837:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 838:Src/usb_pd_protocol.c **** static int send_bist_cmd(int port)
 839:Src/usb_pd_protocol.c **** {
 840:Src/usb_pd_protocol.c **** 	/* currently only support sending bist carrier 2 */
 841:Src/usb_pd_protocol.c **** 	uint32_t bdo = BDO(BDO_MODE_CARRIER2, 0);
 842:Src/usb_pd_protocol.c **** 	int bit_len;
 843:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_BIST, pd[port].power_role,
 844:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 845:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 846:Src/usb_pd_protocol.c **** 
 847:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, &bdo);
 848:Src/usb_pd_protocol.c **** 	CPRINTF("BIST>%d\n", bit_len);
 849:Src/usb_pd_protocol.c **** 
 850:Src/usb_pd_protocol.c **** 	return bit_len;
 851:Src/usb_pd_protocol.c **** }
 852:Src/usb_pd_protocol.c **** #endif
 853:Src/usb_pd_protocol.c **** 
 854:Src/usb_pd_protocol.c **** static void queue_vdm(int port, uint32_t *header, const uint32_t *data,
 855:Src/usb_pd_protocol.c **** 			     int data_cnt)
 856:Src/usb_pd_protocol.c **** {
 857:Src/usb_pd_protocol.c **** 	pd[port].vdo_count = data_cnt + 1;
 858:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 859:Src/usb_pd_protocol.c **** 	memcpy(&pd[port].vdo_data[1], data, sizeof(uint32_t) * data_cnt);
 860:Src/usb_pd_protocol.c **** 	/* Set ready, pd task will actually send */
 861:Src/usb_pd_protocol.c **** 	pd[port].vdm_state = VDM_STATE_READY;
 862:Src/usb_pd_protocol.c **** }
 863:Src/usb_pd_protocol.c **** 
 864:Src/usb_pd_protocol.c **** static void handle_vdm_request(int port, int cnt, uint32_t *payload)
 865:Src/usb_pd_protocol.c **** {
 866:Src/usb_pd_protocol.c **** 	int rlen = 0;
 867:Src/usb_pd_protocol.c **** 	uint32_t *rdata;
 868:Src/usb_pd_protocol.c **** 
 869:Src/usb_pd_protocol.c **** 	if (pd[port].vdm_state == VDM_STATE_BUSY) {
 870:Src/usb_pd_protocol.c **** 		/* If UFP responded busy retry after timeout */
 871:Src/usb_pd_protocol.c **** 		if (PD_VDO_CMDT(payload[0]) == CMDT_RSP_BUSY) {
 872:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 873:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 874:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_WAIT_RSP_BUSY;
 875:Src/usb_pd_protocol.c **** 			pd[port].vdo_retry = (payload[0] & ~VDO_CMDT_MASK) |
 876:Src/usb_pd_protocol.c **** 				CMDT_INIT;
 877:Src/usb_pd_protocol.c **** 			return;
 878:Src/usb_pd_protocol.c **** 		} else {
 879:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_DONE;
 880:Src/usb_pd_protocol.c **** 		}
 881:Src/usb_pd_protocol.c **** 	}
 882:Src/usb_pd_protocol.c **** 
 883:Src/usb_pd_protocol.c **** 	if (PD_VDO_SVDM(payload[0]))
 884:Src/usb_pd_protocol.c **** 		rlen = pd_svdm(port, cnt, payload, &rdata);
 885:Src/usb_pd_protocol.c **** 	else
 886:Src/usb_pd_protocol.c **** 		rlen = pd_custom_vdm(port, cnt, payload, &rdata);
 887:Src/usb_pd_protocol.c **** 
 888:Src/usb_pd_protocol.c **** 	if (rlen > 0) {
 889:Src/usb_pd_protocol.c **** 		queue_vdm(port, rdata, &rdata[1], rlen - 1);
 890:Src/usb_pd_protocol.c **** 		return;
 891:Src/usb_pd_protocol.c **** 	}
 892:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 893:Src/usb_pd_protocol.c **** 		CPRINTF("Unhandled VDM VID %04x CMD %04x\n",
ARM GAS  /tmp/ccWvVg6G.s 			page 20


 894:Src/usb_pd_protocol.c **** 			PD_VDO_VID(payload[0]), payload[0] & 0xFFFF);
 895:Src/usb_pd_protocol.c **** }
 896:Src/usb_pd_protocol.c **** 
 897:Src/usb_pd_protocol.c **** void pd_execute_hard_reset(int port)
 898:Src/usb_pd_protocol.c **** {
 899:Src/usb_pd_protocol.c **** 	if (pd[port].last_state == PD_STATE_HARD_RESET_SEND)
 900:Src/usb_pd_protocol.c **** 		CPRINTF("C%d HARD RST TX\n", port);
 901:Src/usb_pd_protocol.c **** 	else
 902:Src/usb_pd_protocol.c **** 		CPRINTF("C%d HARD RST RX\n", port);
 903:Src/usb_pd_protocol.c **** 
 904:Src/usb_pd_protocol.c **** 	pd[port].msg_id = 0;
 905:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 906:Src/usb_pd_protocol.c **** 	pd_dfp_exit_mode(port, 0, 0);
 907:Src/usb_pd_protocol.c **** #endif
 908:Src/usb_pd_protocol.c **** 
 909:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 910:Src/usb_pd_protocol.c **** 	pd[port].rev = PD_REV30;
 911:Src/usb_pd_protocol.c **** 	pd_ca_reset(port);
 912:Src/usb_pd_protocol.c **** #endif
 913:Src/usb_pd_protocol.c **** 	/*
 914:Src/usb_pd_protocol.c **** 	 * Fake set last state to hard reset to make sure that the next
 915:Src/usb_pd_protocol.c **** 	 * state to run knows that we just did a hard reset.
 916:Src/usb_pd_protocol.c **** 	 */
 917:Src/usb_pd_protocol.c **** 	pd[port].last_state = PD_STATE_HARD_RESET_EXECUTE;
 918:Src/usb_pd_protocol.c **** 
 919:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 920:Src/usb_pd_protocol.c **** 	/*
 921:Src/usb_pd_protocol.c **** 	 * If we are swapping to a source and have changed to Rp, restore back
 922:Src/usb_pd_protocol.c **** 	 * to Rd and turn off vbus to match our power_role.
 923:Src/usb_pd_protocol.c **** 	 */
 924:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SNK_SWAP_STANDBY ||
 925:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE) {
 926:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RD);
 927:Src/usb_pd_protocol.c **** 		pd_power_supply_reset(port);
 928:Src/usb_pd_protocol.c **** 	}
 929:Src/usb_pd_protocol.c **** 
 930:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SINK) {
 931:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 932:Src/usb_pd_protocol.c **** 		pd_set_input_current_limit(port, 0, 0);
 933:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 934:Src/usb_pd_protocol.c **** 		//charge_manager_set_ceil(port,
 935:Src/usb_pd_protocol.c **** 		//			CEIL_REQUESTOR_PD,
 936:Src/usb_pd_protocol.c **** 		//			CHARGE_CEIL_NONE);
 937:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
 938:Src/usb_pd_protocol.c **** 
 939:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_HARD_RESET_RECOVER);
 940:Src/usb_pd_protocol.c **** 		return;
 941:Src/usb_pd_protocol.c **** 	}
 942:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 943:Src/usb_pd_protocol.c **** 
 944:Src/usb_pd_protocol.c **** 	/* We are a source, cut power */
 945:Src/usb_pd_protocol.c **** 	pd_power_supply_reset(port);
 946:Src/usb_pd_protocol.c **** 	pd[port].src_recover = get_time().val + PD_T_SRC_RECOVER;
 947:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 948:Src/usb_pd_protocol.c **** }
 949:Src/usb_pd_protocol.c **** 
 950:Src/usb_pd_protocol.c **** static void execute_soft_reset(int port)
ARM GAS  /tmp/ccWvVg6G.s 			page 21


 951:Src/usb_pd_protocol.c **** {
 952:Src/usb_pd_protocol.c **** 	pd[port].msg_id = 0;
 953:Src/usb_pd_protocol.c **** 	set_state(port, DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_DISCOVERY,
 954:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 955:Src/usb_pd_protocol.c **** 	CPRINTF("C%d Soft Rst\n", port);
 956:Src/usb_pd_protocol.c **** }
 957:Src/usb_pd_protocol.c **** 
 958:Src/usb_pd_protocol.c **** void pd_soft_reset(void)
 959:Src/usb_pd_protocol.c **** {
 960:Src/usb_pd_protocol.c **** 	int i;
 961:Src/usb_pd_protocol.c **** 
 962:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; ++i)
 963:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 964:Src/usb_pd_protocol.c **** 			set_state(i, PD_STATE_SOFT_RESET);
 965:Src/usb_pd_protocol.c **** 			// getting rid of task stuff
 966:Src/usb_pd_protocol.c **** 			//task_wake(PD_PORT_TO_TASK_ID(i));
 967:Src/usb_pd_protocol.c **** 		}
 968:Src/usb_pd_protocol.c **** }
 969:Src/usb_pd_protocol.c **** 
 970:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 971:Src/usb_pd_protocol.c **** /*
 972:Src/usb_pd_protocol.c ****  * Request desired charge voltage from source.
 973:Src/usb_pd_protocol.c ****  * Returns EC_SUCCESS on success or non-zero on failure.
 974:Src/usb_pd_protocol.c ****  */
 975:Src/usb_pd_protocol.c **** static int pd_send_request_msg(int port, int always_send_request)
 976:Src/usb_pd_protocol.c **** {
 977:Src/usb_pd_protocol.c **** 	uint32_t rdo, curr_limit, supply_voltage;
 978:Src/usb_pd_protocol.c **** 	int res;
 979:Src/usb_pd_protocol.c **** 
 980:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 981:Src/usb_pd_protocol.c **** 	//int charging = (charge_manager_get_active_charge_port() == port);
 982:Src/usb_pd_protocol.c **** 	const int charging = 1;
 983:Src/usb_pd_protocol.c **** #else
 984:Src/usb_pd_protocol.c **** 	const int charging = 1;
 985:Src/usb_pd_protocol.c **** #endif
 986:Src/usb_pd_protocol.c **** 
 987:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHECK_MAX_REQUEST_ALLOWED
 988:Src/usb_pd_protocol.c **** 	int max_request_allowed = pd_is_max_request_allowed();
 989:Src/usb_pd_protocol.c **** #else
 990:Src/usb_pd_protocol.c **** 	const int max_request_allowed = 1;
 991:Src/usb_pd_protocol.c **** #endif
 992:Src/usb_pd_protocol.c **** 
 993:Src/usb_pd_protocol.c **** 	/* Clear new power request */
 994:Src/usb_pd_protocol.c **** 	pd[port].new_power_request = 0;
 995:Src/usb_pd_protocol.c **** 
 996:Src/usb_pd_protocol.c **** 	/* Build and send request RDO */
 997:Src/usb_pd_protocol.c **** 	/*
 998:Src/usb_pd_protocol.c **** 	 * If this port is not actively charging or we are not allowed to
 999:Src/usb_pd_protocol.c **** 	 * request the max voltage, then select vSafe5V
1000:Src/usb_pd_protocol.c **** 	 */
1001:Src/usb_pd_protocol.c **** 	res = pd_build_request(port, &rdo, &curr_limit, &supply_voltage,
1002:Src/usb_pd_protocol.c **** 			       charging && max_request_allowed ?
1003:Src/usb_pd_protocol.c **** 					PD_REQUEST_MAX : PD_REQUEST_VSAFE5V);
1004:Src/usb_pd_protocol.c **** 
1005:Src/usb_pd_protocol.c **** 	if (res != EC_SUCCESS)
1006:Src/usb_pd_protocol.c **** 		/*
1007:Src/usb_pd_protocol.c **** 		 * If fail to choose voltage, do nothing, let source re-send
ARM GAS  /tmp/ccWvVg6G.s 			page 22


1008:Src/usb_pd_protocol.c **** 		 * source cap
1009:Src/usb_pd_protocol.c **** 		 */
1010:Src/usb_pd_protocol.c **** 		return -1;
1011:Src/usb_pd_protocol.c **** 
1012:Src/usb_pd_protocol.c **** 	if (!always_send_request) {
1013:Src/usb_pd_protocol.c **** 		/* Don't re-request the same voltage */
1014:Src/usb_pd_protocol.c **** 		if (pd[port].prev_request_mv == supply_voltage)
1015:Src/usb_pd_protocol.c **** 			return EC_SUCCESS;
1016:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
1017:Src/usb_pd_protocol.c **** 		/* Limit current to PD_MIN_MA during transition */
1018:Src/usb_pd_protocol.c **** 		//else
1019:Src/usb_pd_protocol.c **** 		//	charge_manager_force_ceil(port, PD_MIN_MA);
1020:Src/usb_pd_protocol.c **** #endif
1021:Src/usb_pd_protocol.c **** 	}
1022:Src/usb_pd_protocol.c **** 
1023:Src/usb_pd_protocol.c **** 	CPRINTF("Req C%d [%d] %dmV %dmA", port, RDO_POS(rdo),
1024:Src/usb_pd_protocol.c **** 		supply_voltage, curr_limit);
1025:Src/usb_pd_protocol.c **** 	if (rdo & RDO_CAP_MISMATCH)
1026:Src/usb_pd_protocol.c **** 		CPRINTF(" Mismatch");
1027:Src/usb_pd_protocol.c **** 	CPRINTF("\n");
1028:Src/usb_pd_protocol.c **** 
1029:Src/usb_pd_protocol.c **** 	pd[port].curr_limit = curr_limit;
1030:Src/usb_pd_protocol.c **** 	pd[port].supply_voltage = supply_voltage;
1031:Src/usb_pd_protocol.c **** 	pd[port].prev_request_mv = supply_voltage;
1032:Src/usb_pd_protocol.c **** 	res = send_request(port, rdo);
1033:Src/usb_pd_protocol.c **** 	if (res < 0)
1034:Src/usb_pd_protocol.c **** 		return res;
1035:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SNK_REQUESTED);
1036:Src/usb_pd_protocol.c **** 	return EC_SUCCESS;
1037:Src/usb_pd_protocol.c **** }
1038:Src/usb_pd_protocol.c **** #endif
1039:Src/usb_pd_protocol.c **** 
1040:Src/usb_pd_protocol.c **** static void pd_update_pdo_flags(int port, uint32_t pdo)
1041:Src/usb_pd_protocol.c **** {
 110              		.loc 1 1041 0
 111              		.cfi_startproc
 112              		@ args = 0, pretend = 0, frame = 0
 113              		@ frame_needed = 0, uses_anonymous_args = 0
 114              	.LVL5:
 115 0000 10B5     		push	{r4, lr}
 116              	.LCFI1:
 117              		.cfi_def_cfa_offset 8
 118              		.cfi_offset 4, -8
 119              		.cfi_offset 14, -4
 120              	.LVL6:
1042:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
1043:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
1044:Src/usb_pd_protocol.c **** 	int charge_whitelisted =
1045:Src/usb_pd_protocol.c **** 		(pd[port].power_role == PD_ROLE_SINK &&
1046:Src/usb_pd_protocol.c **** 		 pd_charge_from_device(pd_get_identity_vid(port),
1047:Src/usb_pd_protocol.c **** 				       pd_get_identity_pid(port)));
1048:Src/usb_pd_protocol.c **** #else
1049:Src/usb_pd_protocol.c **** 	const int charge_whitelisted = 0;
1050:Src/usb_pd_protocol.c **** #endif
1051:Src/usb_pd_protocol.c **** #endif
1052:Src/usb_pd_protocol.c **** 
1053:Src/usb_pd_protocol.c **** 	/* can only parse PDO flags if type is fixed */
ARM GAS  /tmp/ccWvVg6G.s 			page 23


1054:Src/usb_pd_protocol.c **** 	if ((pdo & PDO_TYPE_MASK) != PDO_TYPE_FIXED)
 121              		.loc 1 1054 0
 122 0002 8B0F     		lsrs	r3, r1, #30
 123 0004 25D1     		bne	.L7
1055:Src/usb_pd_protocol.c **** 		return;
1056:Src/usb_pd_protocol.c **** 
1057:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1058:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_DUAL_ROLE)
 124              		.loc 1 1058 0
 125 0006 8B00     		lsls	r3, r1, #2
 126 0008 24D5     		bpl	.L9
1059:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_DR_POWER;
 127              		.loc 1 1059 0
 128 000a C201     		lsls	r2, r0, #7
 129 000c 214B     		ldr	r3, .L17
 130 000e 9B18     		adds	r3, r3, r2
 131 0010 0222     		movs	r2, #2
 132 0012 9C68     		ldr	r4, [r3, #8]
 133 0014 2243     		orrs	r2, r4
 134 0016 9A60     		str	r2, [r3, #8]
 135              	.L10:
1060:Src/usb_pd_protocol.c **** 	else
1061:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_DR_POWER;
1062:Src/usb_pd_protocol.c **** 
1063:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_EXTERNAL)
 136              		.loc 1 1063 0
 137 0018 0B01     		lsls	r3, r1, #4
 138 001a 23D5     		bpl	.L11
1064:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_EXTPOWER;
 139              		.loc 1 1064 0
 140 001c C201     		lsls	r2, r0, #7
 141 001e 1D4B     		ldr	r3, .L17
 142 0020 9B18     		adds	r3, r3, r2
 143 0022 8022     		movs	r2, #128
 144 0024 1201     		lsls	r2, r2, #4
 145 0026 9C68     		ldr	r4, [r3, #8]
 146 0028 2243     		orrs	r2, r4
 147 002a 9A60     		str	r2, [r3, #8]
 148              	.L12:
1065:Src/usb_pd_protocol.c **** 	else
1066:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_EXTPOWER;
1067:Src/usb_pd_protocol.c **** 
1068:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_COMM_CAP)
 149              		.loc 1 1068 0
 150 002c 4B01     		lsls	r3, r1, #5
 151 002e 21D5     		bpl	.L13
1069:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_USB_COMM;
 152              		.loc 1 1069 0
 153 0030 C201     		lsls	r2, r0, #7
 154 0032 184B     		ldr	r3, .L17
 155 0034 9B18     		adds	r3, r3, r2
 156 0036 8022     		movs	r2, #128
 157 0038 D201     		lsls	r2, r2, #7
 158 003a 9C68     		ldr	r4, [r3, #8]
 159 003c 2243     		orrs	r2, r4
 160 003e 9A60     		str	r2, [r3, #8]
 161              	.L14:
ARM GAS  /tmp/ccWvVg6G.s 			page 24


1070:Src/usb_pd_protocol.c **** 	else
1071:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_USB_COMM;
1072:Src/usb_pd_protocol.c **** #endif
1073:Src/usb_pd_protocol.c **** 
1074:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_DATA_SWAP)
 162              		.loc 1 1074 0
 163 0040 8B01     		lsls	r3, r1, #6
 164 0042 1FD4     		bmi	.L16
1075:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_DR_DATA;
1076:Src/usb_pd_protocol.c **** 	else
1077:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_DR_DATA;
 165              		.loc 1 1077 0
 166 0044 C001     		lsls	r0, r0, #7
 167              	.LVL7:
 168 0046 134B     		ldr	r3, .L17
 169 0048 1818     		adds	r0, r3, r0
 170 004a 0423     		movs	r3, #4
 171 004c 8268     		ldr	r2, [r0, #8]
 172 004e 9A43     		bics	r2, r3
 173 0050 8260     		str	r2, [r0, #8]
 174              	.L7:
1078:Src/usb_pd_protocol.c **** 
1079:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
1080:Src/usb_pd_protocol.c **** 	/*
1081:Src/usb_pd_protocol.c **** 	 * Treat device as a dedicated charger (meaning we should charge
1082:Src/usb_pd_protocol.c **** 	 * from it) if it does not support power swap, or if it is externally
1083:Src/usb_pd_protocol.c **** 	 * powered, or if we are a sink and the device identity matches a
1084:Src/usb_pd_protocol.c **** 	 * charging white-list.
1085:Src/usb_pd_protocol.c **** 	 */
1086:Src/usb_pd_protocol.c **** 	/*
1087:Src/usb_pd_protocol.c **** 	if (!(pd[port].flags & PD_FLAGS_PARTNER_DR_POWER) ||
1088:Src/usb_pd_protocol.c **** 	    (pd[port].flags & PD_FLAGS_PARTNER_EXTPOWER) ||
1089:Src/usb_pd_protocol.c **** 	    charge_whitelisted)
1090:Src/usb_pd_protocol.c **** 		charge_manager_update_dualrole(port, CAP_DEDICATED);
1091:Src/usb_pd_protocol.c **** 	else
1092:Src/usb_pd_protocol.c **** 		charge_manager_update_dualrole(port, CAP_DUALROLE);
1093:Src/usb_pd_protocol.c **** 	*/
1094:Src/usb_pd_protocol.c **** #endif
1095:Src/usb_pd_protocol.c **** }
 175              		.loc 1 1095 0
 176              		@ sp needed
 177 0052 10BD     		pop	{r4, pc}
 178              	.LVL8:
 179              	.L9:
1061:Src/usb_pd_protocol.c **** 
 180              		.loc 1 1061 0
 181 0054 C201     		lsls	r2, r0, #7
 182 0056 0F4B     		ldr	r3, .L17
 183 0058 9B18     		adds	r3, r3, r2
 184 005a 0222     		movs	r2, #2
 185 005c 9C68     		ldr	r4, [r3, #8]
 186 005e 9443     		bics	r4, r2
 187 0060 9C60     		str	r4, [r3, #8]
 188 0062 D9E7     		b	.L10
 189              	.L11:
1066:Src/usb_pd_protocol.c **** 
 190              		.loc 1 1066 0
ARM GAS  /tmp/ccWvVg6G.s 			page 25


 191 0064 C201     		lsls	r2, r0, #7
 192 0066 0B4B     		ldr	r3, .L17
 193 0068 9B18     		adds	r3, r3, r2
 194 006a 0B4A     		ldr	r2, .L17+4
 195 006c 9C68     		ldr	r4, [r3, #8]
 196 006e 2240     		ands	r2, r4
 197 0070 9A60     		str	r2, [r3, #8]
 198 0072 DBE7     		b	.L12
 199              	.L13:
1071:Src/usb_pd_protocol.c **** #endif
 200              		.loc 1 1071 0
 201 0074 C201     		lsls	r2, r0, #7
 202 0076 074B     		ldr	r3, .L17
 203 0078 9B18     		adds	r3, r3, r2
 204 007a 084A     		ldr	r2, .L17+8
 205 007c 9C68     		ldr	r4, [r3, #8]
 206 007e 2240     		ands	r2, r4
 207 0080 9A60     		str	r2, [r3, #8]
 208 0082 DDE7     		b	.L14
 209              	.L16:
1075:Src/usb_pd_protocol.c **** 	else
 210              		.loc 1 1075 0
 211 0084 C001     		lsls	r0, r0, #7
 212              	.LVL9:
 213 0086 034B     		ldr	r3, .L17
 214 0088 1818     		adds	r0, r3, r0
 215 008a 0423     		movs	r3, #4
 216 008c 8268     		ldr	r2, [r0, #8]
 217 008e 1343     		orrs	r3, r2
 218 0090 8360     		str	r3, [r0, #8]
 219 0092 DEE7     		b	.L7
 220              	.L18:
 221              		.align	2
 222              	.L17:
 223 0094 00000000 		.word	pd
 224 0098 FFF7FFFF 		.word	-2049
 225 009c FFBFFFFF 		.word	-16385
 226              		.cfi_endproc
 227              	.LFE39:
 229              		.section	.text.vdm_get_ready_timeout,"ax",%progbits
 230              		.align	1
 231              		.syntax unified
 232              		.code	16
 233              		.thumb_func
 234              		.fpu softvfp
 236              	vdm_get_ready_timeout:
 237              	.LFB49:
1096:Src/usb_pd_protocol.c **** 
1097:Src/usb_pd_protocol.c **** static void handle_data_request(int port, uint16_t head,
1098:Src/usb_pd_protocol.c **** 		uint32_t *payload)
1099:Src/usb_pd_protocol.c **** {
1100:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
1101:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
1102:Src/usb_pd_protocol.c **** 
1103:Src/usb_pd_protocol.c **** 	switch (type) {
1104:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1105:Src/usb_pd_protocol.c **** 	case PD_DATA_SOURCE_CAP:
ARM GAS  /tmp/ccWvVg6G.s 			page 26


1106:Src/usb_pd_protocol.c **** 		if ((pd[port].task_state == PD_STATE_SNK_DISCOVERY)
1107:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_TRANSITION)
1108:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_NONE
1109:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state ==
1110:Src/usb_pd_protocol.c **** 			    PD_STATE_SNK_HARD_RESET_RECOVER)
1111:Src/usb_pd_protocol.c **** #endif
1112:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_READY)) {
1113:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1114:Src/usb_pd_protocol.c **** 			/*
1115:Src/usb_pd_protocol.c **** 			 * Only adjust sink rev if source rev is higher.
1116:Src/usb_pd_protocol.c **** 			 */
1117:Src/usb_pd_protocol.c **** 			if (PD_HEADER_REV(head) < pd[port].rev)
1118:Src/usb_pd_protocol.c **** 				pd[port].rev = PD_HEADER_REV(head);
1119:Src/usb_pd_protocol.c **** #endif
1120:Src/usb_pd_protocol.c **** 			/* Port partner is now known to be PD capable */
1121:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_PREVIOUS_PD_CONN;
1122:Src/usb_pd_protocol.c **** 
1123:Src/usb_pd_protocol.c **** 			/* src cap 0 should be fixed PDO */
1124:Src/usb_pd_protocol.c **** 			pd_update_pdo_flags(port, payload[0]);
1125:Src/usb_pd_protocol.c **** 
1126:Src/usb_pd_protocol.c **** 			pd_process_source_cap(port, cnt, payload);
1127:Src/usb_pd_protocol.c **** 			pd_process_source_cap_callback(port, cnt, payload);
1128:Src/usb_pd_protocol.c **** 
1129:Src/usb_pd_protocol.c **** 			/* Source will resend source cap on failure */
1130:Src/usb_pd_protocol.c **** 			pd_send_request_msg(port, 1);
1131:Src/usb_pd_protocol.c **** 		}
1132:Src/usb_pd_protocol.c **** 		break;
1133:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
1134:Src/usb_pd_protocol.c **** 	case PD_DATA_REQUEST:
1135:Src/usb_pd_protocol.c **** 		if ((pd[port].power_role == PD_ROLE_SOURCE) && (cnt == 1)) {
1136:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1137:Src/usb_pd_protocol.c **** 			/*
1138:Src/usb_pd_protocol.c **** 			 * Adjust the rev level to what the sink supports. If
1139:Src/usb_pd_protocol.c **** 			 * they're equal, no harm done.
1140:Src/usb_pd_protocol.c **** 			 */
1141:Src/usb_pd_protocol.c **** 			pd[port].rev = PD_HEADER_REV(head);
1142:Src/usb_pd_protocol.c **** #endif
1143:Src/usb_pd_protocol.c **** 			if (!pd_check_requested_voltage(payload[0], port)) {
1144:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
1145:Src/usb_pd_protocol.c **** 					/*
1146:Src/usb_pd_protocol.c **** 					 * if we fail to send accept, do
1147:Src/usb_pd_protocol.c **** 					 * nothing and let sink timeout and
1148:Src/usb_pd_protocol.c **** 					 * send hard reset
1149:Src/usb_pd_protocol.c **** 					 */
1150:Src/usb_pd_protocol.c **** 					return;
1151:Src/usb_pd_protocol.c **** 
1152:Src/usb_pd_protocol.c **** 				/* explicit contract is now in place */
1153:Src/usb_pd_protocol.c **** 				pd[port].flags |= PD_FLAGS_EXPLICIT_CONTRACT;
1154:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1155:Src/usb_pd_protocol.c **** 				/*
1156:Src/usb_pd_protocol.c **** 				 * Start Source-coordinated collision
1157:Src/usb_pd_protocol.c **** 				 * avoidance
1158:Src/usb_pd_protocol.c **** 				 */
1159:Src/usb_pd_protocol.c **** 				if (pd[port].rev == PD_REV30 &&
1160:Src/usb_pd_protocol.c **** 					pd[port].power_role == PD_ROLE_SOURCE)
1161:Src/usb_pd_protocol.c **** 					sink_can_xmit(port, SINK_TX_OK);
1162:Src/usb_pd_protocol.c **** #endif
ARM GAS  /tmp/ccWvVg6G.s 			page 27


1163:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1164:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1165:Src/usb_pd_protocol.c **** 				pd_set_saved_active(port, 1);
1166:Src/usb_pd_protocol.c **** #endif
1167:Src/usb_pd_protocol.c **** #endif
1168:Src/usb_pd_protocol.c **** 				pd[port].requested_idx = RDO_POS(payload[0]);
1169:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_ACCEPTED);
1170:Src/usb_pd_protocol.c **** 				return;
1171:Src/usb_pd_protocol.c **** 			}
1172:Src/usb_pd_protocol.c **** 		}
1173:Src/usb_pd_protocol.c **** 		/* the message was incorrect or cannot be satisfied */
1174:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_REJECT);
1175:Src/usb_pd_protocol.c **** 		/* keep last contract in place (whether implicit or explicit) */
1176:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_READY);
1177:Src/usb_pd_protocol.c **** 		break;
1178:Src/usb_pd_protocol.c **** 	case PD_DATA_BIST:
1179:Src/usb_pd_protocol.c **** 		/* If not in READY state, then don't start BIST */
1180:Src/usb_pd_protocol.c **** 		if (DUAL_ROLE_IF_ELSE(port,
1181:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
1182:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SRC_READY)) {
1183:Src/usb_pd_protocol.c **** 			/* currently only support sending bist carrier mode 2 */
1184:Src/usb_pd_protocol.c **** 			if ((payload[0] >> 28) == 5) {
1185:Src/usb_pd_protocol.c **** 				/* bist data object mode is 2 */
1186:Src/usb_pd_protocol.c **** 				pd_transmit(port, TCPC_TX_BIST_MODE_2, 0,
1187:Src/usb_pd_protocol.c **** 					    NULL);
1188:Src/usb_pd_protocol.c **** 				/* Set to appropriate port disconnected state */
1189:Src/usb_pd_protocol.c **** 				set_state(port, DUAL_ROLE_IF_ELSE(port,
1190:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
1191:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED));
1192:Src/usb_pd_protocol.c **** 			}
1193:Src/usb_pd_protocol.c **** 		}
1194:Src/usb_pd_protocol.c **** 		break;
1195:Src/usb_pd_protocol.c **** 	case PD_DATA_SINK_CAP:
1196:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_SNK_CAP_RECVD;
1197:Src/usb_pd_protocol.c **** 		/* snk cap 0 should be fixed PDO */
1198:Src/usb_pd_protocol.c **** 		pd_update_pdo_flags(port, payload[0]);
1199:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SRC_GET_SINK_CAP)
1200:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
1201:Src/usb_pd_protocol.c **** 		break;
1202:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1203:Src/usb_pd_protocol.c **** 	case PD_DATA_BATTERY_STATUS:
1204:Src/usb_pd_protocol.c **** 		break;
1205:Src/usb_pd_protocol.c **** #endif
1206:Src/usb_pd_protocol.c **** 	case PD_DATA_VENDOR_DEF:
1207:Src/usb_pd_protocol.c **** 		handle_vdm_request(port, cnt, payload);
1208:Src/usb_pd_protocol.c **** 		break;
1209:Src/usb_pd_protocol.c **** 	default:
1210:Src/usb_pd_protocol.c **** 		CPRINTF("Unhandled data message type %d\n", type);
1211:Src/usb_pd_protocol.c **** 	}
1212:Src/usb_pd_protocol.c **** }
1213:Src/usb_pd_protocol.c **** 
1214:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1215:Src/usb_pd_protocol.c **** void pd_request_power_swap(int port)
1216:Src/usb_pd_protocol.c **** {
1217:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SRC_READY)
1218:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_SWAP_INIT);
1219:Src/usb_pd_protocol.c **** 	else if (pd[port].task_state == PD_STATE_SNK_READY)
ARM GAS  /tmp/ccWvVg6G.s 			page 28


1220:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_SWAP_INIT);
1221:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1222:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1223:Src/usb_pd_protocol.c **** }
1224:Src/usb_pd_protocol.c **** 
1225:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1226:Src/usb_pd_protocol.c **** static void pd_request_vconn_swap(int port)
1227:Src/usb_pd_protocol.c **** {
1228:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SRC_READY ||
1229:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_READY)
1230:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_VCONN_SWAP_SEND);
1231:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1232:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1233:Src/usb_pd_protocol.c **** }
1234:Src/usb_pd_protocol.c **** 
1235:Src/usb_pd_protocol.c **** void pd_try_vconn_src(int port)
1236:Src/usb_pd_protocol.c **** {
1237:Src/usb_pd_protocol.c **** 	/*
1238:Src/usb_pd_protocol.c **** 	 * If we don't currently provide vconn, and we can supply it, send
1239:Src/usb_pd_protocol.c **** 	 * a vconn swap request.
1240:Src/usb_pd_protocol.c **** 	 */
1241:Src/usb_pd_protocol.c **** 	if (!(pd[port].flags & PD_FLAGS_VCONN_ON)) {
1242:Src/usb_pd_protocol.c **** 		if (pd_check_vconn_swap(port))
1243:Src/usb_pd_protocol.c **** 			pd_request_vconn_swap(port);
1244:Src/usb_pd_protocol.c **** 	}
1245:Src/usb_pd_protocol.c **** }
1246:Src/usb_pd_protocol.c **** #endif
1247:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
1248:Src/usb_pd_protocol.c **** 
1249:Src/usb_pd_protocol.c **** void pd_request_data_swap(int port)
1250:Src/usb_pd_protocol.c **** {
1251:Src/usb_pd_protocol.c **** 	if (DUAL_ROLE_IF_ELSE(port,
1252:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
1253:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SRC_READY))
1254:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_DR_SWAP);
1255:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1256:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1257:Src/usb_pd_protocol.c **** }
1258:Src/usb_pd_protocol.c **** 
1259:Src/usb_pd_protocol.c **** static void pd_set_data_role(int port, int role)
1260:Src/usb_pd_protocol.c **** {
1261:Src/usb_pd_protocol.c **** 	pd[port].data_role = role;
1262:Src/usb_pd_protocol.c **** 	pd_execute_data_swap(port, role);
1263:Src/usb_pd_protocol.c **** 
1264:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
1265:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX_DFP_ONLY
1266:Src/usb_pd_protocol.c **** 	/*
1267:Src/usb_pd_protocol.c **** 	 * Need to connect SS mux for if new data role is DFP.
1268:Src/usb_pd_protocol.c **** 	 * If new data role is UFP, then disconnect the SS mux.
1269:Src/usb_pd_protocol.c **** 	 */
1270:Src/usb_pd_protocol.c **** 	if (role == PD_ROLE_DFP)
1271:Src/usb_pd_protocol.c **** 		usb_mux_set(port, TYPEC_MUX_USB, USB_SWITCH_CONNECT,
1272:Src/usb_pd_protocol.c **** 			    pd[port].polarity);
1273:Src/usb_pd_protocol.c **** 	else
1274:Src/usb_pd_protocol.c **** 		usb_mux_set(port, TYPEC_MUX_NONE, USB_SWITCH_DISCONNECT,
1275:Src/usb_pd_protocol.c **** 			    pd[port].polarity);
1276:Src/usb_pd_protocol.c **** #else
ARM GAS  /tmp/ccWvVg6G.s 			page 29


1277:Src/usb_pd_protocol.c **** 	usb_mux_set(port, TYPEC_MUX_USB, USB_SWITCH_CONNECT,
1278:Src/usb_pd_protocol.c **** 		    pd[port].polarity);
1279:Src/usb_pd_protocol.c **** #endif
1280:Src/usb_pd_protocol.c **** #endif
1281:Src/usb_pd_protocol.c **** 	pd_update_roles(port);
1282:Src/usb_pd_protocol.c **** }
1283:Src/usb_pd_protocol.c **** 
1284:Src/usb_pd_protocol.c **** static void pd_dr_swap(int port)
1285:Src/usb_pd_protocol.c **** {
1286:Src/usb_pd_protocol.c **** 	pd_set_data_role(port, !pd[port].data_role);
1287:Src/usb_pd_protocol.c **** 	pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
1288:Src/usb_pd_protocol.c **** }
1289:Src/usb_pd_protocol.c **** 
1290:Src/usb_pd_protocol.c **** static void handle_ctrl_request(int port, uint16_t head,
1291:Src/usb_pd_protocol.c **** 		uint32_t *payload)
1292:Src/usb_pd_protocol.c **** {
1293:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
1294:Src/usb_pd_protocol.c **** 	int res;
1295:Src/usb_pd_protocol.c **** 
1296:Src/usb_pd_protocol.c **** 	switch (type) {
1297:Src/usb_pd_protocol.c **** 	case PD_CTRL_GOOD_CRC:
1298:Src/usb_pd_protocol.c **** 		/* should not get it */
1299:Src/usb_pd_protocol.c **** 		break;
1300:Src/usb_pd_protocol.c **** 	case PD_CTRL_PING:
1301:Src/usb_pd_protocol.c **** 		/* Nothing else to do */
1302:Src/usb_pd_protocol.c **** 		break;
1303:Src/usb_pd_protocol.c **** 	case PD_CTRL_GET_SOURCE_CAP:
1304:Src/usb_pd_protocol.c **** 		res = send_source_cap(port);
1305:Src/usb_pd_protocol.c **** 		if ((res >= 0) &&
1306:Src/usb_pd_protocol.c **** 		    (pd[port].task_state == PD_STATE_SRC_DISCOVERY))
1307:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_NEGOCIATE);
1308:Src/usb_pd_protocol.c **** 		break;
1309:Src/usb_pd_protocol.c **** 	case PD_CTRL_GET_SINK_CAP:
1310:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1311:Src/usb_pd_protocol.c **** 		send_sink_cap(port);
1312:Src/usb_pd_protocol.c **** #else
1313:Src/usb_pd_protocol.c **** 		send_control(port, REFUSE(pd[port].rev));
1314:Src/usb_pd_protocol.c **** #endif
1315:Src/usb_pd_protocol.c **** 		break;
1316:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1317:Src/usb_pd_protocol.c **** 	case PD_CTRL_GOTO_MIN:
1318:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_GIVE_BACK
1319:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SNK_READY) {
1320:Src/usb_pd_protocol.c **** 			/*
1321:Src/usb_pd_protocol.c **** 			 * Reduce power consumption now!
1322:Src/usb_pd_protocol.c **** 			 *
1323:Src/usb_pd_protocol.c **** 			 * The source will restore power to this sink
1324:Src/usb_pd_protocol.c **** 			 * by sending a new source cap message at a
1325:Src/usb_pd_protocol.c **** 			 * later time.
1326:Src/usb_pd_protocol.c **** 			 */
1327:Src/usb_pd_protocol.c **** 			pd_snk_give_back(port, &pd[port].curr_limit,
1328:Src/usb_pd_protocol.c **** 				&pd[port].supply_voltage);
1329:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_TRANSITION);
1330:Src/usb_pd_protocol.c **** 		}
1331:Src/usb_pd_protocol.c **** #endif
1332:Src/usb_pd_protocol.c **** 
1333:Src/usb_pd_protocol.c **** 		break;
ARM GAS  /tmp/ccWvVg6G.s 			page 30


1334:Src/usb_pd_protocol.c **** 	case PD_CTRL_PS_RDY:
1335:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SNK_SWAP_SRC_DISABLE) {
1336:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_STANDBY);
1337:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SRC_SWAP_STANDBY) {
1338:Src/usb_pd_protocol.c **** 			/* reset message ID and swap roles */
1339:Src/usb_pd_protocol.c **** 			pd[port].msg_id = 0;
1340:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
1341:Src/usb_pd_protocol.c **** 			pd_update_roles(port);
1342:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
1343:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1344:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_VCONN_SWAP_INIT) {
1345:Src/usb_pd_protocol.c **** 			/*
1346:Src/usb_pd_protocol.c **** 			 * If VCONN is on, then this PS_RDY tells us it's
1347:Src/usb_pd_protocol.c **** 			 * ok to turn VCONN off
1348:Src/usb_pd_protocol.c **** 			 */
1349:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_VCONN_ON)
1350:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_VCONN_SWAP_READY);
1351:Src/usb_pd_protocol.c **** #endif
1352:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_DISCOVERY) {
1353:Src/usb_pd_protocol.c **** 			/* Don't know what power source is ready. Reset. */
1354:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_HARD_RESET_SEND);
1355:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_SWAP_STANDBY) {
1356:Src/usb_pd_protocol.c **** 			/* Do nothing, assume this is a redundant PD_RDY */
1357:Src/usb_pd_protocol.c **** 		} else if (pd[port].power_role == PD_ROLE_SINK) {
1358:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
1359:Src/usb_pd_protocol.c **** 			pd_set_input_current_limit(port, pd[port].curr_limit,
1360:Src/usb_pd_protocol.c **** 						   pd[port].supply_voltage);
1361:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
1362:Src/usb_pd_protocol.c **** 			/* Set ceiling based on what's negotiated */
1363:Src/usb_pd_protocol.c **** 			//charge_manager_set_ceil(port,
1364:Src/usb_pd_protocol.c **** 			//			CEIL_REQUESTOR_PD,
1365:Src/usb_pd_protocol.c **** 			//			pd[port].curr_limit);
1366:Src/usb_pd_protocol.c **** #endif
1367:Src/usb_pd_protocol.c **** 		}
1368:Src/usb_pd_protocol.c **** 		break;
1369:Src/usb_pd_protocol.c **** #endif
1370:Src/usb_pd_protocol.c **** 	case PD_CTRL_REJECT:
1371:Src/usb_pd_protocol.c **** 	case PD_CTRL_WAIT:
1372:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_DR_SWAP)
1373:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
1374:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1375:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_VCONN_SWAP_SEND)
1376:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
1377:Src/usb_pd_protocol.c **** #endif
1378:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1379:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SRC_SWAP_INIT)
1380:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
1381:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SNK_SWAP_INIT)
1382:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
1383:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SNK_REQUESTED) {
1384:Src/usb_pd_protocol.c **** 			/*
1385:Src/usb_pd_protocol.c **** 			 * Explicit Contract in place
1386:Src/usb_pd_protocol.c **** 			 *
1387:Src/usb_pd_protocol.c **** 			 *  On reception of a WAIT message, transition to
1388:Src/usb_pd_protocol.c **** 			 *  PD_STATE_SNK_READY after PD_T_SINK_REQUEST ms to
1389:Src/usb_pd_protocol.c **** 			 *  send another reqest.
1390:Src/usb_pd_protocol.c **** 			 *
ARM GAS  /tmp/ccWvVg6G.s 			page 31


1391:Src/usb_pd_protocol.c **** 			 *  On reception of a REJECT messag, transition to
1392:Src/usb_pd_protocol.c **** 			 *  PD_STATE_SNK_READY but don't resend the request.
1393:Src/usb_pd_protocol.c **** 			 *
1394:Src/usb_pd_protocol.c **** 			 * NO Explicit Contract in place
1395:Src/usb_pd_protocol.c **** 			 *
1396:Src/usb_pd_protocol.c **** 			 *  On reception of a WAIT or REJECT message,
1397:Src/usb_pd_protocol.c **** 			 *  transition to PD_STATE_SNK_DISCOVERY
1398:Src/usb_pd_protocol.c **** 			 */
1399:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_EXPLICIT_CONTRACT) {
1400:Src/usb_pd_protocol.c **** 				/* We have an explicit contract */
1401:Src/usb_pd_protocol.c **** 				if (type == PD_CTRL_WAIT) {
1402:Src/usb_pd_protocol.c **** 					/*
1403:Src/usb_pd_protocol.c **** 					 * Trigger a new power request when
1404:Src/usb_pd_protocol.c **** 					 * we enter PD_STATE_SNK_READY
1405:Src/usb_pd_protocol.c **** 					 */
1406:Src/usb_pd_protocol.c **** 					pd[port].new_power_request = 1;
1407:Src/usb_pd_protocol.c **** 
1408:Src/usb_pd_protocol.c **** 					/*
1409:Src/usb_pd_protocol.c **** 					 * After the request is triggered,
1410:Src/usb_pd_protocol.c **** 					 * make sure the request is sent.
1411:Src/usb_pd_protocol.c **** 					 */
1412:Src/usb_pd_protocol.c **** 					pd[port].prev_request_mv = 0;
1413:Src/usb_pd_protocol.c **** 
1414:Src/usb_pd_protocol.c **** 					/*
1415:Src/usb_pd_protocol.c **** 					 * Transition to PD_STATE_SNK_READY
1416:Src/usb_pd_protocol.c **** 					 * after PD_T_SINK_REQUEST ms.
1417:Src/usb_pd_protocol.c **** 					 */
1418:Src/usb_pd_protocol.c **** 					set_state_timeout(port, get_time().val +
1419:Src/usb_pd_protocol.c **** 							PD_T_SINK_REQUEST,
1420:Src/usb_pd_protocol.c **** 							PD_STATE_SNK_READY);
1421:Src/usb_pd_protocol.c **** 				} else {
1422:Src/usb_pd_protocol.c **** 					/* The request was rejected */
1423:Src/usb_pd_protocol.c **** 					set_state(port, PD_STATE_SNK_READY);
1424:Src/usb_pd_protocol.c **** 				}
1425:Src/usb_pd_protocol.c **** 			} else {
1426:Src/usb_pd_protocol.c **** 				/* No explicit contract */
1427:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SNK_DISCOVERY);
1428:Src/usb_pd_protocol.c **** 			}
1429:Src/usb_pd_protocol.c **** 		}
1430:Src/usb_pd_protocol.c **** #endif
1431:Src/usb_pd_protocol.c **** 		break;
1432:Src/usb_pd_protocol.c **** 	case PD_CTRL_ACCEPT:
1433:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SOFT_RESET) {
1434:Src/usb_pd_protocol.c **** 			/*
1435:Src/usb_pd_protocol.c **** 			 * For the case that we sent soft reset in SNK_DISCOVERY
1436:Src/usb_pd_protocol.c **** 			 * on startup due to VBUS never low, clear the flag.
1437:Src/usb_pd_protocol.c **** 			 */
1438:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
1439:Src/usb_pd_protocol.c **** 			execute_soft_reset(port);
1440:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_DR_SWAP) {
1441:Src/usb_pd_protocol.c **** 			/* switch data role */
1442:Src/usb_pd_protocol.c **** 			pd_dr_swap(port);
1443:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
1444:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1445:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1446:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_VCONN_SWAP_SEND) {
1447:Src/usb_pd_protocol.c **** 			/* switch vconn */
ARM GAS  /tmp/ccWvVg6G.s 			page 32


1448:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_VCONN_SWAP_INIT);
1449:Src/usb_pd_protocol.c **** #endif
1450:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SRC_SWAP_INIT) {
1451:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
1452:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_EXPLICIT_CONTRACT;
1453:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_SWAP_SNK_DISABLE);
1454:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_SWAP_INIT) {
1455:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
1456:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_EXPLICIT_CONTRACT;
1457:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_SNK_DISABLE);
1458:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_REQUESTED) {
1459:Src/usb_pd_protocol.c **** 			/* explicit contract is now in place */
1460:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_EXPLICIT_CONTRACT;
1461:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1462:Src/usb_pd_protocol.c **** 			pd_set_saved_active(port, 1);
1463:Src/usb_pd_protocol.c **** #endif
1464:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_TRANSITION);
1465:Src/usb_pd_protocol.c **** #endif
1466:Src/usb_pd_protocol.c **** 		}
1467:Src/usb_pd_protocol.c **** 		break;
1468:Src/usb_pd_protocol.c **** 	case PD_CTRL_SOFT_RESET:
1469:Src/usb_pd_protocol.c **** 		execute_soft_reset(port);
1470:Src/usb_pd_protocol.c **** 		/* We are done, acknowledge with an Accept packet */
1471:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_ACCEPT);
1472:Src/usb_pd_protocol.c **** 		break;
1473:Src/usb_pd_protocol.c **** 	case PD_CTRL_PR_SWAP:
1474:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1475:Src/usb_pd_protocol.c **** 		if (pd_check_power_swap(port)) {
1476:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_ACCEPT);
1477:Src/usb_pd_protocol.c **** 			/*
1478:Src/usb_pd_protocol.c **** 			 * Clear flag for checking power role to avoid
1479:Src/usb_pd_protocol.c **** 			 * immediately requesting another swap.
1480:Src/usb_pd_protocol.c **** 			 */
1481:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_PR_ROLE;
1482:Src/usb_pd_protocol.c **** 			set_state(port,
1483:Src/usb_pd_protocol.c **** 				  DUAL_ROLE_IF_ELSE(port,
1484:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_SWAP_SNK_DISABLE,
1485:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_SWAP_SNK_DISABLE));
1486:Src/usb_pd_protocol.c **** 		} else {
1487:Src/usb_pd_protocol.c **** 			send_control(port, REFUSE(pd[port].rev));
1488:Src/usb_pd_protocol.c **** 		}
1489:Src/usb_pd_protocol.c **** #else
1490:Src/usb_pd_protocol.c **** 		send_control(port, REFUSE(pd[port].rev));
1491:Src/usb_pd_protocol.c **** #endif
1492:Src/usb_pd_protocol.c **** 		break;
1493:Src/usb_pd_protocol.c **** 	case PD_CTRL_DR_SWAP:
1494:Src/usb_pd_protocol.c **** 		if (pd_check_data_swap(port, pd[port].data_role)) {
1495:Src/usb_pd_protocol.c **** 			/*
1496:Src/usb_pd_protocol.c **** 			 * Accept switch and perform data swap. Clear
1497:Src/usb_pd_protocol.c **** 			 * flag for checking data role to avoid
1498:Src/usb_pd_protocol.c **** 			 * immediately requesting another swap.
1499:Src/usb_pd_protocol.c **** 			 */
1500:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_DR_ROLE;
1501:Src/usb_pd_protocol.c **** 			if (send_control(port, PD_CTRL_ACCEPT) >= 0)
1502:Src/usb_pd_protocol.c **** 				pd_dr_swap(port);
1503:Src/usb_pd_protocol.c **** 		} else {
1504:Src/usb_pd_protocol.c **** 			send_control(port, REFUSE(pd[port].rev));
ARM GAS  /tmp/ccWvVg6G.s 			page 33


1505:Src/usb_pd_protocol.c **** 
1506:Src/usb_pd_protocol.c **** 		}
1507:Src/usb_pd_protocol.c **** 		break;
1508:Src/usb_pd_protocol.c **** 	case PD_CTRL_VCONN_SWAP:
1509:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1510:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SRC_READY ||
1511:Src/usb_pd_protocol.c **** 		    pd[port].task_state == PD_STATE_SNK_READY) {
1512:Src/usb_pd_protocol.c **** 			if (pd_check_vconn_swap(port)) {
1513:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) > 0)
1514:Src/usb_pd_protocol.c **** 					set_state(port,
1515:Src/usb_pd_protocol.c **** 						  PD_STATE_VCONN_SWAP_INIT);
1516:Src/usb_pd_protocol.c **** 			} else {
1517:Src/usb_pd_protocol.c **** 				send_control(port, REFUSE(pd[port].rev));
1518:Src/usb_pd_protocol.c **** 			}
1519:Src/usb_pd_protocol.c **** 		}
1520:Src/usb_pd_protocol.c **** #else
1521:Src/usb_pd_protocol.c **** 		send_control(port, REFUSE(pd[port].rev));
1522:Src/usb_pd_protocol.c **** #endif
1523:Src/usb_pd_protocol.c **** 		break;
1524:Src/usb_pd_protocol.c **** 	default:
1525:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1526:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_NOT_SUPPORTED);
1527:Src/usb_pd_protocol.c **** #endif
1528:Src/usb_pd_protocol.c **** 		CPRINTF("Unhandled ctrl message type %d\n", type);
1529:Src/usb_pd_protocol.c **** 	}
1530:Src/usb_pd_protocol.c **** }
1531:Src/usb_pd_protocol.c **** 
1532:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1533:Src/usb_pd_protocol.c **** static void handle_ext_request(int port, uint16_t head, uint32_t *payload)
1534:Src/usb_pd_protocol.c **** {
1535:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
1536:Src/usb_pd_protocol.c **** 
1537:Src/usb_pd_protocol.c **** 	switch (type) {
1538:Src/usb_pd_protocol.c **** 	case PD_EXT_GET_BATTERY_CAP:
1539:Src/usb_pd_protocol.c **** 		send_battery_cap(port, payload);
1540:Src/usb_pd_protocol.c **** 		break;
1541:Src/usb_pd_protocol.c **** 	case PD_EXT_GET_BATTERY_STATUS:
1542:Src/usb_pd_protocol.c **** 		send_battery_status(port, payload);
1543:Src/usb_pd_protocol.c **** 		break;
1544:Src/usb_pd_protocol.c **** 	case PD_EXT_BATTERY_CAP:
1545:Src/usb_pd_protocol.c **** 		break;
1546:Src/usb_pd_protocol.c **** 	default:
1547:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_NOT_SUPPORTED);
1548:Src/usb_pd_protocol.c **** 	}
1549:Src/usb_pd_protocol.c **** }
1550:Src/usb_pd_protocol.c **** #endif
1551:Src/usb_pd_protocol.c **** 
1552:Src/usb_pd_protocol.c **** static void handle_request(int port, uint16_t head,
1553:Src/usb_pd_protocol.c **** 		uint32_t *payload)
1554:Src/usb_pd_protocol.c **** {
1555:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
1556:Src/usb_pd_protocol.c **** 	int p;
1557:Src/usb_pd_protocol.c **** 
1558:Src/usb_pd_protocol.c **** 	/* dump received packet content (only dump ping at debug level 3) */
1559:Src/usb_pd_protocol.c **** 	if ((debug_level == 2 && PD_HEADER_TYPE(head) != PD_CTRL_PING) ||
1560:Src/usb_pd_protocol.c **** 	    debug_level >= 3) {
1561:Src/usb_pd_protocol.c **** 		CPRINTF("RECV %04x/%d ", head, cnt);
ARM GAS  /tmp/ccWvVg6G.s 			page 34


1562:Src/usb_pd_protocol.c **** 		for (p = 0; p < cnt; p++)
1563:Src/usb_pd_protocol.c **** 			CPRINTF("[%d]%08x ", p, payload[p]);
1564:Src/usb_pd_protocol.c **** 		CPRINTF("\n");
1565:Src/usb_pd_protocol.c **** 	}
1566:Src/usb_pd_protocol.c **** 
1567:Src/usb_pd_protocol.c **** 	/*
1568:Src/usb_pd_protocol.c **** 	 * If we are in disconnected state, we shouldn't get a request. Do
1569:Src/usb_pd_protocol.c **** 	 * a hard reset if we get one.
1570:Src/usb_pd_protocol.c **** 	 */
1571:Src/usb_pd_protocol.c **** 	if (!pd_is_connected(port))
1572:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_HARD_RESET_SEND);
1573:Src/usb_pd_protocol.c **** 
1574:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1575:Src/usb_pd_protocol.c **** 	/* Check if this is an extended chunked data message. */
1576:Src/usb_pd_protocol.c **** 	if (pd[port].rev == PD_REV30 && PD_HEADER_EXT(head)) {
1577:Src/usb_pd_protocol.c **** 		handle_ext_request(port, head, payload);
1578:Src/usb_pd_protocol.c **** 		return;
1579:Src/usb_pd_protocol.c **** 	}
1580:Src/usb_pd_protocol.c **** #endif
1581:Src/usb_pd_protocol.c **** 	if (cnt)
1582:Src/usb_pd_protocol.c **** 		handle_data_request(port, head, payload);
1583:Src/usb_pd_protocol.c **** 	else
1584:Src/usb_pd_protocol.c **** 		handle_ctrl_request(port, head, payload);
1585:Src/usb_pd_protocol.c **** }
1586:Src/usb_pd_protocol.c **** 
1587:Src/usb_pd_protocol.c **** void pd_send_vdm(int port, uint32_t vid, int cmd, const uint32_t *data,
1588:Src/usb_pd_protocol.c **** 		 int count)
1589:Src/usb_pd_protocol.c **** {
1590:Src/usb_pd_protocol.c **** 	if (count > VDO_MAX_SIZE - 1) {
1591:Src/usb_pd_protocol.c **** 		CPRINTF("VDM over max size\n");
1592:Src/usb_pd_protocol.c **** 		return;
1593:Src/usb_pd_protocol.c **** 	}
1594:Src/usb_pd_protocol.c **** 
1595:Src/usb_pd_protocol.c **** 	/* set VDM header with VID & CMD */
1596:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = VDO(vid, ((vid & USB_SID_PD) == USB_SID_PD) ?
1597:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
1598:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1599:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] |= VDO_SVDM_VERS(vdo_ver[pd[port].rev]);
1600:Src/usb_pd_protocol.c **** #endif
1601:Src/usb_pd_protocol.c **** 	queue_vdm(port, pd[port].vdo_data, data, count);
1602:Src/usb_pd_protocol.c **** 
1603:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1604:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1605:Src/usb_pd_protocol.c **** }
1606:Src/usb_pd_protocol.c **** 
1607:Src/usb_pd_protocol.c **** static inline int pdo_busy(int port)
1608:Src/usb_pd_protocol.c **** {
1609:Src/usb_pd_protocol.c **** 	/*
1610:Src/usb_pd_protocol.c **** 	 * Note, main PDO state machine (pd_task) uses READY state exclusively
1611:Src/usb_pd_protocol.c **** 	 * to denote port partners have successfully negociated a contract.  All
1612:Src/usb_pd_protocol.c **** 	 * other protocol actions force state transitions.
1613:Src/usb_pd_protocol.c **** 	 */
1614:Src/usb_pd_protocol.c **** 	int rv = (pd[port].task_state != PD_STATE_SRC_READY);
1615:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1616:Src/usb_pd_protocol.c **** 	rv &= (pd[port].task_state != PD_STATE_SNK_READY);
1617:Src/usb_pd_protocol.c **** #endif
1618:Src/usb_pd_protocol.c **** 	return rv;
ARM GAS  /tmp/ccWvVg6G.s 			page 35


1619:Src/usb_pd_protocol.c **** }
1620:Src/usb_pd_protocol.c **** 
1621:Src/usb_pd_protocol.c **** static uint64_t vdm_get_ready_timeout(uint32_t vdm_hdr)
1622:Src/usb_pd_protocol.c **** {
 238              		.loc 1 1622 0
 239              		.cfi_startproc
 240              		@ args = 0, pretend = 0, frame = 0
 241              		@ frame_needed = 0, uses_anonymous_args = 0
 242              		@ link register save eliminated.
 243              	.LVL10:
1623:Src/usb_pd_protocol.c **** 	uint64_t timeout;
1624:Src/usb_pd_protocol.c **** 	int cmd = PD_VDO_CMD(vdm_hdr);
 244              		.loc 1 1624 0
 245 0000 1F23     		movs	r3, #31
 246 0002 0340     		ands	r3, r0
 247              	.LVL11:
1625:Src/usb_pd_protocol.c **** 
1626:Src/usb_pd_protocol.c **** 	/* its not a structured VDM command */
1627:Src/usb_pd_protocol.c **** 	if (!PD_VDO_SVDM(vdm_hdr))
 248              		.loc 1 1627 0
 249 0004 0204     		lsls	r2, r0, #16
 250 0006 14D5     		bpl	.L23
1628:Src/usb_pd_protocol.c **** 		return 500*MSEC;
1629:Src/usb_pd_protocol.c **** 
1630:Src/usb_pd_protocol.c **** 	switch (PD_VDO_CMDT(vdm_hdr)) {
 251              		.loc 1 1630 0
 252 0008 8009     		lsrs	r0, r0, #6
 253              	.LVL12:
 254 000a 8207     		lsls	r2, r0, #30
 255 000c 08D1     		bne	.L26
1631:Src/usb_pd_protocol.c **** 	case CMDT_INIT:
1632:Src/usb_pd_protocol.c **** 		if ((cmd == CMD_ENTER_MODE) || (cmd == CMD_EXIT_MODE))
 256              		.loc 1 1632 0
 257 000e 043B     		subs	r3, r3, #4
 258              	.LVL13:
 259 0010 012B     		cmp	r3, #1
 260 0012 02D9     		bls	.L27
1633:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_WAIT_MODE_E;
1634:Src/usb_pd_protocol.c **** 		else
1635:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_SNDR_RSP;
 261              		.loc 1 1635 0
 262 0014 0848     		ldr	r0, .L29
 263 0016 0021     		movs	r1, #0
 264 0018 0DE0     		b	.L19
 265              	.L27:
1633:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_WAIT_MODE_E;
 266              		.loc 1 1633 0
 267 001a 0848     		ldr	r0, .L29+4
 268 001c 0021     		movs	r1, #0
 269 001e 0AE0     		b	.L19
 270              	.LVL14:
 271              	.L26:
1636:Src/usb_pd_protocol.c **** 		break;
1637:Src/usb_pd_protocol.c **** 	default:
1638:Src/usb_pd_protocol.c **** 		if ((cmd == CMD_ENTER_MODE) || (cmd == CMD_EXIT_MODE))
 272              		.loc 1 1638 0
 273 0020 043B     		subs	r3, r3, #4
ARM GAS  /tmp/ccWvVg6G.s 			page 36


 274              	.LVL15:
 275 0022 012B     		cmp	r3, #1
 276 0024 02D9     		bls	.L28
1639:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_E_MODE;
1640:Src/usb_pd_protocol.c **** 		else
1641:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_RCVR_RSP;
 277              		.loc 1 1641 0
 278 0026 0648     		ldr	r0, .L29+8
 279 0028 0021     		movs	r1, #0
 280 002a 04E0     		b	.L19
 281              	.L28:
1639:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_E_MODE;
 282              		.loc 1 1639 0
 283 002c 0548     		ldr	r0, .L29+12
 284 002e 0021     		movs	r1, #0
 285 0030 01E0     		b	.L19
 286              	.LVL16:
 287              	.L23:
1628:Src/usb_pd_protocol.c **** 
 288              		.loc 1 1628 0
 289 0032 0548     		ldr	r0, .L29+16
 290              	.LVL17:
 291 0034 0021     		movs	r1, #0
 292              	.LVL18:
 293              	.L19:
1642:Src/usb_pd_protocol.c **** 		break;
1643:Src/usb_pd_protocol.c **** 	}
1644:Src/usb_pd_protocol.c **** 	return timeout;
1645:Src/usb_pd_protocol.c **** }
 294              		.loc 1 1645 0
 295              		@ sp needed
 296 0036 7047     		bx	lr
 297              	.L30:
 298              		.align	2
 299              	.L29:
 300 0038 30750000 		.word	30000
 301 003c A0860100 		.word	100000
 302 0040 983A0000 		.word	15000
 303 0044 A8610000 		.word	25000
 304 0048 20A10700 		.word	500000
 305              		.cfi_endproc
 306              	.LFE49:
 308              		.section	.text.pd_is_power_swapping,"ax",%progbits
 309              		.align	1
 310              		.syntax unified
 311              		.code	16
 312              		.thumb_func
 313              		.fpu softvfp
 315              	pd_is_power_swapping:
 316              	.LFB56:
1646:Src/usb_pd_protocol.c **** 
1647:Src/usb_pd_protocol.c **** static void pd_vdm_send_state_machine(int port)
1648:Src/usb_pd_protocol.c **** {
1649:Src/usb_pd_protocol.c **** 	int res;
1650:Src/usb_pd_protocol.c **** 	uint16_t header;
1651:Src/usb_pd_protocol.c **** 
1652:Src/usb_pd_protocol.c **** 	switch (pd[port].vdm_state) {
ARM GAS  /tmp/ccWvVg6G.s 			page 37


1653:Src/usb_pd_protocol.c **** 	case VDM_STATE_READY:
1654:Src/usb_pd_protocol.c **** 		/* Only transmit VDM if connected. */
1655:Src/usb_pd_protocol.c **** 		if (!pd_is_connected(port)) {
1656:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_BUSY;
1657:Src/usb_pd_protocol.c **** 			break;
1658:Src/usb_pd_protocol.c **** 		}
1659:Src/usb_pd_protocol.c **** 
1660:Src/usb_pd_protocol.c **** 		/*
1661:Src/usb_pd_protocol.c **** 		 * if there's traffic or we're not in PDO ready state don't send
1662:Src/usb_pd_protocol.c **** 		 * a VDM.
1663:Src/usb_pd_protocol.c **** 		 */
1664:Src/usb_pd_protocol.c **** 		if (pdo_busy(port))
1665:Src/usb_pd_protocol.c **** 			break;
1666:Src/usb_pd_protocol.c **** 
1667:Src/usb_pd_protocol.c **** 		/* Prepare and send VDM */
1668:Src/usb_pd_protocol.c **** 		header = PD_HEADER(PD_DATA_VENDOR_DEF, pd[port].power_role,
1669:Src/usb_pd_protocol.c **** 				   pd[port].data_role, pd[port].msg_id,
1670:Src/usb_pd_protocol.c **** 				   (int)pd[port].vdo_count,
1671:Src/usb_pd_protocol.c **** 				   pd_get_rev(port), 0);
1672:Src/usb_pd_protocol.c **** 		res = pd_transmit(port, TCPC_TX_SOP, header,
1673:Src/usb_pd_protocol.c **** 				  pd[port].vdo_data);
1674:Src/usb_pd_protocol.c **** 		if (res < 0) {
1675:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_SEND;
1676:Src/usb_pd_protocol.c **** 		} else {
1677:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_BUSY;
1678:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
1679:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
1680:Src/usb_pd_protocol.c **** 		}
1681:Src/usb_pd_protocol.c **** 		break;
1682:Src/usb_pd_protocol.c **** 	case VDM_STATE_WAIT_RSP_BUSY:
1683:Src/usb_pd_protocol.c **** 		/* wait and then initiate request again */
1684:Src/usb_pd_protocol.c **** 		if (get_time().val > pd[port].vdm_timeout.val) {
1685:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
1686:Src/usb_pd_protocol.c **** 			pd[port].vdo_count = 1;
1687:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_READY;
1688:Src/usb_pd_protocol.c **** 		}
1689:Src/usb_pd_protocol.c **** 		break;
1690:Src/usb_pd_protocol.c **** 	case VDM_STATE_BUSY:
1691:Src/usb_pd_protocol.c **** 		/* Wait for VDM response or timeout */
1692:Src/usb_pd_protocol.c **** 		if (pd[port].vdm_timeout.val &&
1693:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
1694:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_TMOUT;
1695:Src/usb_pd_protocol.c **** 		}
1696:Src/usb_pd_protocol.c **** 		break;
1697:Src/usb_pd_protocol.c **** 	default:
1698:Src/usb_pd_protocol.c **** 		break;
1699:Src/usb_pd_protocol.c **** 	}
1700:Src/usb_pd_protocol.c **** }
1701:Src/usb_pd_protocol.c **** 
1702:Src/usb_pd_protocol.c **** #ifdef CONFIG_CMD_PD_DEV_DUMP_INFO
1703:Src/usb_pd_protocol.c **** static inline void pd_dev_dump_info(uint16_t dev_id, uint8_t *hash)
1704:Src/usb_pd_protocol.c **** {
1705:Src/usb_pd_protocol.c **** 	int j;
1706:Src/usb_pd_protocol.c **** 	ccprintf("DevId:%d.%d Hash:", HW_DEV_ID_MAJ(dev_id),
1707:Src/usb_pd_protocol.c **** 		 HW_DEV_ID_MIN(dev_id));
1708:Src/usb_pd_protocol.c **** 	for (j = 0; j < PD_RW_HASH_SIZE; j += 4) {
1709:Src/usb_pd_protocol.c **** 		ccprintf(" 0x%02x%02x%02x%02x", hash[j + 3], hash[j + 2],
ARM GAS  /tmp/ccWvVg6G.s 			page 38


1710:Src/usb_pd_protocol.c **** 			 hash[j + 1], hash[j]);
1711:Src/usb_pd_protocol.c **** 	}
1712:Src/usb_pd_protocol.c **** 	ccprintf("\n");
1713:Src/usb_pd_protocol.c **** }
1714:Src/usb_pd_protocol.c **** #endif /* CONFIG_CMD_PD_DEV_DUMP_INFO */
1715:Src/usb_pd_protocol.c **** 
1716:Src/usb_pd_protocol.c **** int pd_dev_store_rw_hash(int port, uint16_t dev_id, uint32_t *rw_hash,
1717:Src/usb_pd_protocol.c **** 			 uint32_t current_image)
1718:Src/usb_pd_protocol.c **** {
1719:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
1720:Src/usb_pd_protocol.c **** 	int i;
1721:Src/usb_pd_protocol.c **** #endif
1722:Src/usb_pd_protocol.c **** 
1723:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
1724:Src/usb_pd_protocol.c **** 	pd[port].dev_id = dev_id;
1725:Src/usb_pd_protocol.c **** 	memcpy(pd[port].dev_rw_hash, rw_hash, PD_RW_HASH_SIZE);
1726:Src/usb_pd_protocol.c **** #endif
1727:Src/usb_pd_protocol.c **** #ifdef CONFIG_CMD_PD_DEV_DUMP_INFO
1728:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
1729:Src/usb_pd_protocol.c **** 		pd_dev_dump_info(dev_id, (uint8_t *)rw_hash);
1730:Src/usb_pd_protocol.c **** #endif
1731:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
1732:Src/usb_pd_protocol.c **** 	pd[port].current_image = current_image;
1733:Src/usb_pd_protocol.c **** #endif
1734:Src/usb_pd_protocol.c **** 
1735:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
1736:Src/usb_pd_protocol.c **** 	/* Search table for matching device / hash */
1737:Src/usb_pd_protocol.c **** 	for (i = 0; i < RW_HASH_ENTRIES; i++)
1738:Src/usb_pd_protocol.c **** 		if (dev_id == rw_hash_table[i].dev_id)
1739:Src/usb_pd_protocol.c **** 			return !memcmp(rw_hash,
1740:Src/usb_pd_protocol.c **** 				       rw_hash_table[i].dev_rw_hash,
1741:Src/usb_pd_protocol.c **** 				       PD_RW_HASH_SIZE);
1742:Src/usb_pd_protocol.c **** #endif
1743:Src/usb_pd_protocol.c **** 	return 0;
1744:Src/usb_pd_protocol.c **** }
1745:Src/usb_pd_protocol.c **** 
1746:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1747:Src/usb_pd_protocol.c **** enum pd_dual_role_states pd_get_dual_role(void)
1748:Src/usb_pd_protocol.c **** {
1749:Src/usb_pd_protocol.c **** 	return drp_state;
1750:Src/usb_pd_protocol.c **** }
1751:Src/usb_pd_protocol.c **** 
1752:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TRY_SRC
1753:Src/usb_pd_protocol.c **** static void pd_update_try_source(void)
1754:Src/usb_pd_protocol.c **** {
1755:Src/usb_pd_protocol.c **** 	int i;
1756:Src/usb_pd_protocol.c **** 
1757:Src/usb_pd_protocol.c **** #ifndef CONFIG_CHARGER
1758:Src/usb_pd_protocol.c **** 	int batt_soc = board_get_battery_soc();
1759:Src/usb_pd_protocol.c **** #else
1760:Src/usb_pd_protocol.c **** 	int batt_soc = charge_get_percent();
1761:Src/usb_pd_protocol.c **** #endif
1762:Src/usb_pd_protocol.c **** 
1763:Src/usb_pd_protocol.c **** 	/*
1764:Src/usb_pd_protocol.c **** 	 * Enable try source when dual-role toggling AND battery is present
1765:Src/usb_pd_protocol.c **** 	 * and at some minimum percentage.
1766:Src/usb_pd_protocol.c **** 	 */
ARM GAS  /tmp/ccWvVg6G.s 			page 39


1767:Src/usb_pd_protocol.c **** 	pd_try_src_enable = drp_state == PD_DRP_TOGGLE_ON &&
1768:Src/usb_pd_protocol.c **** 			    batt_soc >= CONFIG_USB_PD_TRY_SRC_MIN_BATT_SOC;
1769:Src/usb_pd_protocol.c **** #if defined(CONFIG_BATTERY_PRESENT_CUSTOM) || \
1770:Src/usb_pd_protocol.c **** 	defined(CONFIG_BATTERY_PRESENT_GPIO)
1771:Src/usb_pd_protocol.c **** 	/*
1772:Src/usb_pd_protocol.c **** 	 * When battery is cutoff in ship mode it may not be reliable to
1773:Src/usb_pd_protocol.c **** 	 * check if battery is present with its state of charge.
1774:Src/usb_pd_protocol.c **** 	 * Also check if battery is initialized and ready to provide power.
1775:Src/usb_pd_protocol.c **** 	 */
1776:Src/usb_pd_protocol.c **** 	pd_try_src_enable &= (battery_is_present() == BP_YES);
1777:Src/usb_pd_protocol.c **** #endif
1778:Src/usb_pd_protocol.c **** 
1779:Src/usb_pd_protocol.c **** 	/*
1780:Src/usb_pd_protocol.c **** 	 * Clear this flag to cover case where a TrySrc
1781:Src/usb_pd_protocol.c **** 	 * mode went from enabled to disabled and trying_source
1782:Src/usb_pd_protocol.c **** 	 * was active at that time.
1783:Src/usb_pd_protocol.c **** 	 */
1784:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++)
1785:Src/usb_pd_protocol.c **** 		pd[i].flags &= ~PD_FLAGS_TRY_SRC;
1786:Src/usb_pd_protocol.c **** 
1787:Src/usb_pd_protocol.c **** }
1788:Src/usb_pd_protocol.c **** DECLARE_HOOK(HOOK_BATTERY_SOC_CHANGE, pd_update_try_source, HOOK_PRIO_DEFAULT);
1789:Src/usb_pd_protocol.c **** #endif
1790:Src/usb_pd_protocol.c **** 
1791:Src/usb_pd_protocol.c **** void pd_set_dual_role(enum pd_dual_role_states state)
1792:Src/usb_pd_protocol.c **** {
1793:Src/usb_pd_protocol.c **** 	int i;
1794:Src/usb_pd_protocol.c **** 	drp_state = state;
1795:Src/usb_pd_protocol.c **** 
1796:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TRY_SRC
1797:Src/usb_pd_protocol.c **** 	pd_update_try_source();
1798:Src/usb_pd_protocol.c **** #endif
1799:Src/usb_pd_protocol.c **** 
1800:Src/usb_pd_protocol.c **** 	/* Inform PD tasks of dual role change. */
1801:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++)
1802:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
1803:Src/usb_pd_protocol.c **** 		//task_set_event(PD_PORT_TO_TASK_ID(i),
1804:Src/usb_pd_protocol.c **** 		//	       PD_EVENT_UPDATE_DUAL_ROLE, 0);
1805:Src/usb_pd_protocol.c **** 		;
1806:Src/usb_pd_protocol.c **** }
1807:Src/usb_pd_protocol.c **** 
1808:Src/usb_pd_protocol.c **** void pd_update_dual_role_config(int port)
1809:Src/usb_pd_protocol.c **** {
1810:Src/usb_pd_protocol.c **** 	/*
1811:Src/usb_pd_protocol.c **** 	 * Change to sink if port is currently a source AND (new DRP
1812:Src/usb_pd_protocol.c **** 	 * state is force sink OR new DRP state is either toggle off
1813:Src/usb_pd_protocol.c **** 	 * or debug accessory toggle only and we are in the source
1814:Src/usb_pd_protocol.c **** 	 * disconnected state).
1815:Src/usb_pd_protocol.c **** 	 */
1816:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SOURCE &&
1817:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
1818:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
1819:Src/usb_pd_protocol.c **** 	      && pd[port].task_state == PD_STATE_SRC_DISCONNECTED))) {
1820:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SINK;
1821:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_DISCONNECTED);
1822:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RD);
1823:Src/usb_pd_protocol.c **** 		/* Make sure we're not sourcing VBUS. */
ARM GAS  /tmp/ccWvVg6G.s 			page 40


1824:Src/usb_pd_protocol.c **** 		pd_power_supply_reset(port);
1825:Src/usb_pd_protocol.c **** 	}
1826:Src/usb_pd_protocol.c **** 
1827:Src/usb_pd_protocol.c **** 	/*
1828:Src/usb_pd_protocol.c **** 	 * Change to source if port is currently a sink and the
1829:Src/usb_pd_protocol.c **** 	 * new DRP state is force source.
1830:Src/usb_pd_protocol.c **** 	 */
1831:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SINK &&
1832:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
1833:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
1834:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCONNECTED);
1835:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RP);
1836:Src/usb_pd_protocol.c **** 	}
1837:Src/usb_pd_protocol.c **** 
1838:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE) && \
1839:Src/usb_pd_protocol.c **** 	defined(CONFIG_USB_PD_TCPC_LOW_POWER)
1840:Src/usb_pd_protocol.c **** 	/* When switching drp mode, make sure tcpc is out of standby mode */
1841:Src/usb_pd_protocol.c **** 	tcpm_set_drp_toggle(port, 0);
1842:Src/usb_pd_protocol.c **** #endif
1843:Src/usb_pd_protocol.c **** }
1844:Src/usb_pd_protocol.c **** 
1845:Src/usb_pd_protocol.c **** int pd_get_role(int port)
1846:Src/usb_pd_protocol.c **** {
1847:Src/usb_pd_protocol.c **** 	return pd[port].power_role;
1848:Src/usb_pd_protocol.c **** }
1849:Src/usb_pd_protocol.c **** 
1850:Src/usb_pd_protocol.c **** static int pd_is_power_swapping(int port)
1851:Src/usb_pd_protocol.c **** {
 317              		.loc 1 1851 0
 318              		.cfi_startproc
 319              		@ args = 0, pretend = 0, frame = 0
 320              		@ frame_needed = 0, uses_anonymous_args = 0
 321              		@ link register save eliminated.
 322              	.LVL19:
1852:Src/usb_pd_protocol.c **** 	/* return true if in the act of swapping power roles */
1853:Src/usb_pd_protocol.c **** 	return  pd[port].task_state == PD_STATE_SNK_SWAP_SNK_DISABLE ||
 323              		.loc 1 1853 0
 324 0000 C301     		lsls	r3, r0, #7
 325 0002 0C48     		ldr	r0, .L38
 326              	.LVL20:
 327 0004 C018     		adds	r0, r0, r3
 328 0006 0279     		ldrb	r2, [r0, #4]
1854:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_SRC_DISABLE ||
1855:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_STANDBY ||
 329              		.loc 1 1855 0
 330 0008 1300     		movs	r3, r2
 331 000a 0A3B     		subs	r3, r3, #10
 332 000c DBB2     		uxtb	r3, r3
1856:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE ||
1857:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_SNK_DISABLE ||
1858:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_SRC_DISABLE ||
 333              		.loc 1 1858 0
 334 000e 032B     		cmp	r3, #3
 335 0010 09D9     		bls	.L33
1856:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE ||
 336              		.loc 1 1856 0
 337 0012 1B2A     		cmp	r2, #27
ARM GAS  /tmp/ccWvVg6G.s 			page 41


 338 0014 09D0     		beq	.L34
1857:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_SRC_DISABLE ||
 339              		.loc 1 1857 0
 340 0016 1C2A     		cmp	r2, #28
 341 0018 09D0     		beq	.L35
 342              		.loc 1 1858 0 discriminator 2
 343 001a 1D2A     		cmp	r2, #29
 344 001c 01D0     		beq	.L37
 345              		.loc 1 1858 0 is_stmt 0
 346 001e 0020     		movs	r0, #0
 347 0020 02E0     		b	.L31
 348              	.L37:
 349 0022 0120     		movs	r0, #1
 350 0024 00E0     		b	.L31
 351              	.L33:
 352 0026 0120     		movs	r0, #1
 353              	.L31:
1859:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_STANDBY;
1860:Src/usb_pd_protocol.c **** }
 354              		.loc 1 1860 0 is_stmt 1
 355              		@ sp needed
 356 0028 7047     		bx	lr
 357              	.L34:
1858:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_STANDBY;
 358              		.loc 1 1858 0
 359 002a 0120     		movs	r0, #1
 360 002c FCE7     		b	.L31
 361              	.L35:
 362 002e 0120     		movs	r0, #1
 363 0030 FAE7     		b	.L31
 364              	.L39:
 365 0032 C046     		.align	2
 366              	.L38:
 367 0034 00000000 		.word	pd
 368              		.cfi_endproc
 369              	.LFE56:
 371              		.section	.text.get_typec_current_limit,"ax",%progbits
 372              		.align	1
 373              		.syntax unified
 374              		.code	16
 375              		.thumb_func
 376              		.fpu softvfp
 378              	get_typec_current_limit:
 379              	.LFB63:
1861:Src/usb_pd_protocol.c **** 
1862:Src/usb_pd_protocol.c **** /*
1863:Src/usb_pd_protocol.c ****  * Provide Rp to ensure the partner port is in a known state (eg. not
1864:Src/usb_pd_protocol.c ****  * PD negotiated, not sourcing 20V).
1865:Src/usb_pd_protocol.c ****  */
1866:Src/usb_pd_protocol.c **** static void pd_partner_port_reset(int port)
1867:Src/usb_pd_protocol.c **** {
1868:Src/usb_pd_protocol.c **** 	uint64_t timeout;
1869:Src/usb_pd_protocol.c **** 
1870:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1871:Src/usb_pd_protocol.c **** 	/*
1872:Src/usb_pd_protocol.c **** 	 * Check our battery-backed previous port state. If PD comms were
1873:Src/usb_pd_protocol.c **** 	 * active, and we didn't just lose power, make sure we
ARM GAS  /tmp/ccWvVg6G.s 			page 42


1874:Src/usb_pd_protocol.c **** 	 * don't boot into RO with a pre-existing power contract.
1875:Src/usb_pd_protocol.c **** 	 */
1876:Src/usb_pd_protocol.c **** 	if (!pd_get_saved_active(port) ||
1877:Src/usb_pd_protocol.c **** 	   system_get_image_copy() != SYSTEM_IMAGE_RO ||
1878:Src/usb_pd_protocol.c **** 	   system_get_reset_flags() &
1879:Src/usb_pd_protocol.c **** 	   (RESET_FLAG_BROWNOUT | RESET_FLAG_POWER_ON))
1880:Src/usb_pd_protocol.c **** 		return;
1881:Src/usb_pd_protocol.c **** #endif // CONFIG_BBRAM
1882:Src/usb_pd_protocol.c **** 	/* Provide Rp for 100 msec. or until we no longer have VBUS. */
1883:Src/usb_pd_protocol.c **** 	tcpm_set_cc(port, TYPEC_CC_RP);
1884:Src/usb_pd_protocol.c **** 	timeout = get_time().val + 100 * MSEC;
1885:Src/usb_pd_protocol.c **** 
1886:Src/usb_pd_protocol.c **** 	while (get_time().val < timeout && pd_is_vbus_present(port))
1887:Src/usb_pd_protocol.c **** 		msleep(10);
1888:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1889:Src/usb_pd_protocol.c **** 	pd_set_saved_active(port, 0);
1890:Src/usb_pd_protocol.c **** #endif
1891:Src/usb_pd_protocol.c **** }
1892:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
1893:Src/usb_pd_protocol.c **** 
1894:Src/usb_pd_protocol.c **** int pd_get_polarity(int port)
1895:Src/usb_pd_protocol.c **** {
1896:Src/usb_pd_protocol.c **** 	return pd[port].polarity;
1897:Src/usb_pd_protocol.c **** }
1898:Src/usb_pd_protocol.c **** 
1899:Src/usb_pd_protocol.c **** int pd_get_partner_data_swap_capable(int port)
1900:Src/usb_pd_protocol.c **** {
1901:Src/usb_pd_protocol.c **** 	/* return data swap capable status of port partner */
1902:Src/usb_pd_protocol.c **** 	return pd[port].flags & PD_FLAGS_PARTNER_DR_DATA;
1903:Src/usb_pd_protocol.c **** }
1904:Src/usb_pd_protocol.c **** 
1905:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
1906:Src/usb_pd_protocol.c **** void pd_comm_enable(int port, int enable)
1907:Src/usb_pd_protocol.c **** {
1908:Src/usb_pd_protocol.c **** 	/* We don't check port >= CONFIG_USB_PD_PORT_COUNT deliberately */
1909:Src/usb_pd_protocol.c **** 	pd_comm_enabled[port] = enable;
1910:Src/usb_pd_protocol.c **** 
1911:Src/usb_pd_protocol.c **** 	/* If type-C connection, then update the TCPC RX enable */
1912:Src/usb_pd_protocol.c **** 	if (pd_is_connected(port))
1913:Src/usb_pd_protocol.c **** 		tcpm_set_rx_enable(port, enable);
1914:Src/usb_pd_protocol.c **** 
1915:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1916:Src/usb_pd_protocol.c **** 	/*
1917:Src/usb_pd_protocol.c **** 	 * If communications are enabled, start hard reset timer for
1918:Src/usb_pd_protocol.c **** 	 * any port in PD_SNK_DISCOVERY.
1919:Src/usb_pd_protocol.c **** 	 */
1920:Src/usb_pd_protocol.c **** 	if (enable && pd[port].task_state == PD_STATE_SNK_DISCOVERY)
1921:Src/usb_pd_protocol.c **** 		set_state_timeout(port,
1922:Src/usb_pd_protocol.c **** 				  get_time().val + PD_T_SINK_WAIT_CAP,
1923:Src/usb_pd_protocol.c **** 				  PD_STATE_HARD_RESET_SEND);
1924:Src/usb_pd_protocol.c **** #endif
1925:Src/usb_pd_protocol.c **** }
1926:Src/usb_pd_protocol.c **** #endif
1927:Src/usb_pd_protocol.c **** 
1928:Src/usb_pd_protocol.c **** void pd_ping_enable(int port, int enable)
1929:Src/usb_pd_protocol.c **** {
1930:Src/usb_pd_protocol.c **** 	if (enable)
ARM GAS  /tmp/ccWvVg6G.s 			page 43


1931:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PING_ENABLED;
1932:Src/usb_pd_protocol.c **** 	else
1933:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PING_ENABLED;
1934:Src/usb_pd_protocol.c **** }
1935:Src/usb_pd_protocol.c **** 
1936:Src/usb_pd_protocol.c **** /**
1937:Src/usb_pd_protocol.c ****  * Returns whether the sink has detected a Rp resistor on the other side.
1938:Src/usb_pd_protocol.c ****  */
1939:Src/usb_pd_protocol.c **** static inline int cc_is_rp(int cc)
1940:Src/usb_pd_protocol.c **** {
1941:Src/usb_pd_protocol.c **** 	return (cc == TYPEC_CC_VOLT_SNK_DEF) || (cc == TYPEC_CC_VOLT_SNK_1_5) ||
1942:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
1943:Src/usb_pd_protocol.c **** }
1944:Src/usb_pd_protocol.c **** 
1945:Src/usb_pd_protocol.c **** /*
1946:Src/usb_pd_protocol.c ****  * CC values for regular sources and Debug sources (aka DTS)
1947:Src/usb_pd_protocol.c ****  *
1948:Src/usb_pd_protocol.c ****  * Source type  Mode of Operation   CC1    CC2
1949:Src/usb_pd_protocol.c ****  * ---------------------------------------------
1950:Src/usb_pd_protocol.c ****  * Regular      Default USB Power   RpUSB  Open
1951:Src/usb_pd_protocol.c ****  * Regular      USB-C @ 1.5 A       Rp1A5  Open
1952:Src/usb_pd_protocol.c ****  * Regular      USB-C @ 3 A         Rp3A0  Open
1953:Src/usb_pd_protocol.c ****  * DTS          Default USB Power   Rp3A0  Rp1A5
1954:Src/usb_pd_protocol.c ****  * DTS          USB-C @ 1.5 A       Rp1A5  RpUSB
1955:Src/usb_pd_protocol.c ****  * DTS          USB-C @ 3 A         Rp3A0  RpUSB
1956:Src/usb_pd_protocol.c **** */
1957:Src/usb_pd_protocol.c **** 
1958:Src/usb_pd_protocol.c **** /**
1959:Src/usb_pd_protocol.c ****  * Returns the polarity of a Sink.
1960:Src/usb_pd_protocol.c ****  */
1961:Src/usb_pd_protocol.c **** static inline int get_snk_polarity(int cc1, int cc2)
1962:Src/usb_pd_protocol.c **** {
1963:Src/usb_pd_protocol.c **** 	/* the following assumes:
1964:Src/usb_pd_protocol.c **** 	 * TYPEC_CC_VOLT_SNK_3_0 > TYPEC_CC_VOLT_SNK_1_5
1965:Src/usb_pd_protocol.c **** 	 * TYPEC_CC_VOLT_SNK_1_5 > TYPEC_CC_VOLT_SNK_DEF
1966:Src/usb_pd_protocol.c **** 	 * TYPEC_CC_VOLT_SNK_DEF > TYPEC_CC_VOLT_OPEN
1967:Src/usb_pd_protocol.c **** 	 */
1968:Src/usb_pd_protocol.c **** 	return (cc2 > cc1);
1969:Src/usb_pd_protocol.c **** }
1970:Src/usb_pd_protocol.c **** 
1971:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
1972:Src/usb_pd_protocol.c **** /**
1973:Src/usb_pd_protocol.c ****  * Returns type C current limit (mA) based upon cc_voltage (mV).
1974:Src/usb_pd_protocol.c ****  */
1975:Src/usb_pd_protocol.c **** static typec_current_t get_typec_current_limit(int polarity, int cc1, int cc2)
1976:Src/usb_pd_protocol.c **** {
 380              		.loc 1 1976 0
 381              		.cfi_startproc
 382              		@ args = 0, pretend = 0, frame = 0
 383              		@ frame_needed = 0, uses_anonymous_args = 0
 384              		@ link register save eliminated.
 385              	.LVL21:
1977:Src/usb_pd_protocol.c **** 	typec_current_t charge;
1978:Src/usb_pd_protocol.c **** 	int cc = polarity ? cc2 : cc1;
 386              		.loc 1 1978 0
 387 0000 0028     		cmp	r0, #0
 388 0002 0FD0     		beq	.L46
ARM GAS  /tmp/ccWvVg6G.s 			page 44


 389 0004 1300     		movs	r3, r2
 390              	.L41:
 391              	.LVL22:
1979:Src/usb_pd_protocol.c **** 	int cc_alt = polarity ? cc1 : cc2;
 392              		.loc 1 1979 0 discriminator 4
 393 0006 0028     		cmp	r0, #0
 394 0008 00D0     		beq	.L42
 395              		.loc 1 1979 0 is_stmt 0
 396 000a 0A00     		movs	r2, r1
 397              	.LVL23:
 398              	.L42:
1980:Src/usb_pd_protocol.c **** 
1981:Src/usb_pd_protocol.c **** 	if (cc == TYPEC_CC_VOLT_SNK_3_0 && cc_alt != TYPEC_CC_VOLT_SNK_1_5)
 399              		.loc 1 1981 0 is_stmt 1 discriminator 4
 400 000c 072B     		cmp	r3, #7
 401 000e 0BD0     		beq	.L49
 402              	.L43:
1982:Src/usb_pd_protocol.c **** 		charge = 3000;
1983:Src/usb_pd_protocol.c **** 	else if (cc == TYPEC_CC_VOLT_SNK_1_5)
 403              		.loc 1 1983 0
 404 0010 062B     		cmp	r3, #6
 405 0012 0DD0     		beq	.L50
1984:Src/usb_pd_protocol.c **** 		charge = 1500;
1985:Src/usb_pd_protocol.c **** 	else
1986:Src/usb_pd_protocol.c **** 		charge = 0;
 406              		.loc 1 1986 0
 407 0014 0020     		movs	r0, #0
 408              	.LVL24:
 409              	.L44:
 410              	.LBB148:
 411              	.LBB149:
1941:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 412              		.loc 1 1941 0
 413 0016 053A     		subs	r2, r2, #5
 414              	.LVL25:
 415              	.LBE149:
 416              	.LBE148:
1987:Src/usb_pd_protocol.c **** 
1988:Src/usb_pd_protocol.c **** 	if (cc_is_rp(cc_alt))
 417              		.loc 1 1988 0
 418 0018 022A     		cmp	r2, #2
 419 001a 02D8     		bhi	.L40
1989:Src/usb_pd_protocol.c **** 		charge |= TYPEC_CURRENT_DTS_MASK;
 420              		.loc 1 1989 0
 421 001c 8023     		movs	r3, #128
 422              	.LVL26:
 423 001e 1B06     		lsls	r3, r3, #24
 424 0020 1843     		orrs	r0, r3
 425              	.LVL27:
 426              	.L40:
1990:Src/usb_pd_protocol.c **** 
1991:Src/usb_pd_protocol.c **** 	return charge;
1992:Src/usb_pd_protocol.c **** }
 427              		.loc 1 1992 0
 428              		@ sp needed
 429 0022 7047     		bx	lr
 430              	.LVL28:
ARM GAS  /tmp/ccWvVg6G.s 			page 45


 431              	.L46:
1978:Src/usb_pd_protocol.c **** 	int cc_alt = polarity ? cc1 : cc2;
 432              		.loc 1 1978 0
 433 0024 0B00     		movs	r3, r1
 434 0026 EEE7     		b	.L41
 435              	.LVL29:
 436              	.L49:
1981:Src/usb_pd_protocol.c **** 		charge = 3000;
 437              		.loc 1 1981 0 discriminator 1
 438 0028 062A     		cmp	r2, #6
 439 002a F1D0     		beq	.L43
1982:Src/usb_pd_protocol.c **** 	else if (cc == TYPEC_CC_VOLT_SNK_1_5)
 440              		.loc 1 1982 0
 441 002c 0148     		ldr	r0, .L51
 442              	.LVL30:
 443 002e F2E7     		b	.L44
 444              	.LVL31:
 445              	.L50:
1984:Src/usb_pd_protocol.c **** 	else
 446              		.loc 1 1984 0
 447 0030 0148     		ldr	r0, .L51+4
 448              	.LVL32:
 449 0032 F0E7     		b	.L44
 450              	.L52:
 451              		.align	2
 452              	.L51:
 453 0034 B80B0000 		.word	3000
 454 0038 DC050000 		.word	1500
 455              		.cfi_endproc
 456              	.LFE63:
 458              		.section	.text.set_state,"ax",%progbits
 459              		.align	1
 460              		.syntax unified
 461              		.code	16
 462              		.thumb_func
 463              		.fpu softvfp
 465              	set_state:
 466              	.LFB24:
 345:Src/usb_pd_protocol.c **** 	enum pd_states last_state = pd[port].task_state;
 467              		.loc 1 345 0
 468              		.cfi_startproc
 469              		@ args = 0, pretend = 0, frame = 0
 470              		@ frame_needed = 0, uses_anonymous_args = 0
 471              	.LVL33:
 472 0000 70B5     		push	{r4, r5, r6, lr}
 473              	.LCFI2:
 474              		.cfi_def_cfa_offset 16
 475              		.cfi_offset 4, -16
 476              		.cfi_offset 5, -12
 477              		.cfi_offset 6, -8
 478              		.cfi_offset 14, -4
 479 0002 0600     		movs	r6, r0
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 480              		.loc 1 346 0
 481 0004 C201     		lsls	r2, r0, #7
 482 0006 184B     		ldr	r3, .L62
 483 0008 9B18     		adds	r3, r3, r2
ARM GAS  /tmp/ccWvVg6G.s 			page 46


 484 000a 1A79     		ldrb	r2, [r3, #4]
 485              	.LVL34:
 486              	.LBB154:
 487              	.LBB155:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 488              		.loc 1 283 0
 489 000c 0024     		movs	r4, #0
 490 000e 0025     		movs	r5, #0
 491 0010 1C61     		str	r4, [r3, #16]
 492 0012 5D61     		str	r5, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 493              		.loc 1 284 0
 494 0014 0020     		movs	r0, #0
 495              	.LVL35:
 496 0016 D871     		strb	r0, [r3, #7]
 497              	.LVL36:
 498              	.LBE155:
 499              	.LBE154:
 352:Src/usb_pd_protocol.c **** 
 500              		.loc 1 352 0
 501 0018 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 502              		.loc 1 354 0
 503 001a 8A42     		cmp	r2, r1
 504 001c 19D0     		beq	.L53
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 505              		.loc 1 365 0
 506 001e 022A     		cmp	r2, #2
 507 0020 18D0     		beq	.L59
 508              	.L55:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 509              		.loc 1 366 0
 510 0022 0E2A     		cmp	r2, #14
 511 0024 19D0     		beq	.L60
 512              	.L56:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 513              		.loc 1 371 0
 514 0026 0E29     		cmp	r1, #14
 515 0028 01D0     		beq	.L57
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 516              		.loc 1 371 0 is_stmt 0 discriminator 1
 517 002a 0229     		cmp	r1, #2
 518 002c 11D1     		bne	.L53
 519              	.L57:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 520              		.loc 1 374 0 is_stmt 1
 521 002e 0022     		movs	r2, #0
 522              	.LVL37:
 523 0030 0021     		movs	r1, #0
 524              	.LVL38:
 525 0032 3000     		movs	r0, r6
 526 0034 FFF7FEFF 		bl	pd_set_input_current_limit
 527              	.LVL39:
 391:Src/usb_pd_protocol.c **** 			/*
 528              		.loc 1 391 0
 529 0038 F301     		lsls	r3, r6, #7
 530 003a 0B4A     		ldr	r2, .L62
ARM GAS  /tmp/ccWvVg6G.s 			page 47


 531 003c 9B5C     		ldrb	r3, [r3, r2]
 532 003e 012B     		cmp	r3, #1
 533 0040 0ED0     		beq	.L61
 534              	.L58:
 535              	.LVL40:
 536              	.LBB156:
 537              	.LBB157:
  87:Inc/tcpm.h    **** 						     data_role);
  88:Inc/tcpm.h    **** }
  89:Inc/tcpm.h    **** 
  90:Inc/tcpm.h    **** static inline int tcpm_set_rx_enable(int port, int enable)
  91:Inc/tcpm.h    **** {
  92:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_rx_enable(port, enable);
 538              		.loc 2 92 0
 539 0042 3201     		lsls	r2, r6, #4
 540 0044 094B     		ldr	r3, .L62+4
 541 0046 9B18     		adds	r3, r3, r2
 542 0048 9B68     		ldr	r3, [r3, #8]
 543 004a 5B6A     		ldr	r3, [r3, #36]
 544 004c 0021     		movs	r1, #0
 545 004e 3000     		movs	r0, r6
 546 0050 9847     		blx	r3
 547              	.LVL41:
 548              	.L53:
 549              	.LBE157:
 550              	.LBE156:
 443:Src/usb_pd_protocol.c **** 
 551              		.loc 1 443 0
 552              		@ sp needed
 553              	.LVL42:
 554 0052 70BD     		pop	{r4, r5, r6, pc}
 555              	.LVL43:
 556              	.L59:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 557              		.loc 1 365 0 discriminator 1
 558 0054 0E29     		cmp	r1, #14
 559 0056 E4D1     		bne	.L55
 560 0058 FBE7     		b	.L53
 561              	.L60:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 562              		.loc 1 367 0
 563 005a 0229     		cmp	r1, #2
 564 005c E3D1     		bne	.L56
 565 005e F8E7     		b	.L53
 566              	.LVL44:
 567              	.L61:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 568              		.loc 1 396 0
 569 0060 3000     		movs	r0, r6
 570 0062 FFF7FEFF 		bl	pd_power_supply_reset
 571              	.LVL45:
 572 0066 ECE7     		b	.L58
 573              	.L63:
 574              		.align	2
 575              	.L62:
 576 0068 00000000 		.word	pd
 577 006c 00000000 		.word	tcpc_config
ARM GAS  /tmp/ccWvVg6G.s 			page 48


 578              		.cfi_endproc
 579              	.LFE24:
 581              		.section	.text.queue_vdm,"ax",%progbits
 582              		.align	1
 583              		.syntax unified
 584              		.code	16
 585              		.thumb_func
 586              		.fpu softvfp
 588              	queue_vdm:
 589              	.LFB33:
 856:Src/usb_pd_protocol.c **** 	pd[port].vdo_count = data_cnt + 1;
 590              		.loc 1 856 0
 591              		.cfi_startproc
 592              		@ args = 0, pretend = 0, frame = 0
 593              		@ frame_needed = 0, uses_anonymous_args = 0
 594              	.LVL46:
 595 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 596              	.LCFI3:
 597              		.cfi_def_cfa_offset 24
 598              		.cfi_offset 3, -24
 599              		.cfi_offset 4, -20
 600              		.cfi_offset 5, -16
 601              		.cfi_offset 6, -12
 602              		.cfi_offset 7, -8
 603              		.cfi_offset 14, -4
 604 0002 1500     		movs	r5, r2
 857:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 605              		.loc 1 857 0
 606 0004 5F1C     		adds	r7, r3, #1
 607 0006 094A     		ldr	r2, .L65
 608              	.LVL47:
 609 0008 C001     		lsls	r0, r0, #7
 610              	.LVL48:
 611 000a 1418     		adds	r4, r2, r0
 612 000c 2600     		movs	r6, r4
 613 000e 7436     		adds	r6, r6, #116
 614 0010 3770     		strb	r7, [r6]
 858:Src/usb_pd_protocol.c **** 	memcpy(&pd[port].vdo_data[1], data, sizeof(uint32_t) * data_cnt);
 615              		.loc 1 858 0
 616 0012 0968     		ldr	r1, [r1]
 617              	.LVL49:
 618 0014 A165     		str	r1, [r4, #88]
 859:Src/usb_pd_protocol.c **** 	/* Set ready, pd task will actually send */
 619              		.loc 1 859 0
 620 0016 5C30     		adds	r0, r0, #92
 621 0018 8018     		adds	r0, r0, r2
 622 001a 9A00     		lsls	r2, r3, #2
 623 001c 2900     		movs	r1, r5
 624 001e FFF7FEFF 		bl	memcpy
 625              	.LVL50:
 861:Src/usb_pd_protocol.c **** }
 626              		.loc 1 861 0
 627 0022 4834     		adds	r4, r4, #72
 628 0024 0123     		movs	r3, #1
 629 0026 2370     		strb	r3, [r4]
 862:Src/usb_pd_protocol.c **** 
 630              		.loc 1 862 0
ARM GAS  /tmp/ccWvVg6G.s 			page 49


 631              		@ sp needed
 632              	.LVL51:
 633              	.LVL52:
 634 0028 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 635              	.L66:
 636 002a C046     		.align	2
 637              	.L65:
 638 002c 00000000 		.word	pd
 639              		.cfi_endproc
 640              	.LFE33:
 642              		.section	.text.handle_vdm_request,"ax",%progbits
 643              		.align	1
 644              		.syntax unified
 645              		.code	16
 646              		.thumb_func
 647              		.fpu softvfp
 649              	handle_vdm_request:
 650              	.LFB34:
 865:Src/usb_pd_protocol.c **** 	int rlen = 0;
 651              		.loc 1 865 0
 652              		.cfi_startproc
 653              		@ args = 0, pretend = 0, frame = 16
 654              		@ frame_needed = 0, uses_anonymous_args = 0
 655              	.LVL53:
 656 0000 30B5     		push	{r4, r5, lr}
 657              	.LCFI4:
 658              		.cfi_def_cfa_offset 12
 659              		.cfi_offset 4, -12
 660              		.cfi_offset 5, -8
 661              		.cfi_offset 14, -4
 662 0002 85B0     		sub	sp, sp, #20
 663              	.LCFI5:
 664              		.cfi_def_cfa_offset 32
 665 0004 0400     		movs	r4, r0
 666 0006 1500     		movs	r5, r2
 667              	.LVL54:
 869:Src/usb_pd_protocol.c **** 		/* If UFP responded busy retry after timeout */
 668              		.loc 1 869 0
 669 0008 C201     		lsls	r2, r0, #7
 670              	.LVL55:
 671 000a 224B     		ldr	r3, .L77
 672 000c 9B18     		adds	r3, r3, r2
 673 000e 4833     		adds	r3, r3, #72
 674 0010 1B78     		ldrb	r3, [r3]
 675 0012 5BB2     		sxtb	r3, r3
 676 0014 022B     		cmp	r3, #2
 677 0016 12D0     		beq	.L75
 678              	.L68:
 883:Src/usb_pd_protocol.c **** 		rlen = pd_svdm(port, cnt, payload, &rdata);
 679              		.loc 1 883 0
 680 0018 2B68     		ldr	r3, [r5]
 681 001a 1B04     		lsls	r3, r3, #16
 682 001c 33D5     		bpl	.L71
 884:Src/usb_pd_protocol.c **** 	else
 683              		.loc 1 884 0
 684 001e 03AB     		add	r3, sp, #12
 685 0020 2A00     		movs	r2, r5
ARM GAS  /tmp/ccWvVg6G.s 			page 50


 686 0022 2000     		movs	r0, r4
 687              	.LVL56:
 688 0024 FFF7FEFF 		bl	pd_svdm
 689              	.LVL57:
 690              	.L72:
 888:Src/usb_pd_protocol.c **** 		queue_vdm(port, rdata, &rdata[1], rlen - 1);
 691              		.loc 1 888 0
 692 0028 0028     		cmp	r0, #0
 693 002a 06DD     		ble	.L67
 889:Src/usb_pd_protocol.c **** 		return;
 694              		.loc 1 889 0
 695 002c 039B     		ldr	r3, [sp, #12]
 696 002e 1A1D     		adds	r2, r3, #4
 697 0030 431E     		subs	r3, r0, #1
 698 0032 0399     		ldr	r1, [sp, #12]
 699 0034 2000     		movs	r0, r4
 700              	.LVL58:
 701 0036 FFF7FEFF 		bl	queue_vdm
 702              	.LVL59:
 703              	.L67:
 895:Src/usb_pd_protocol.c **** 
 704              		.loc 1 895 0
 705 003a 05B0     		add	sp, sp, #20
 706              		@ sp needed
 707              	.LVL60:
 708 003c 30BD     		pop	{r4, r5, pc}
 709              	.LVL61:
 710              	.L75:
 871:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 711              		.loc 1 871 0
 712 003e 2B68     		ldr	r3, [r5]
 713 0040 9A09     		lsrs	r2, r3, #6
 714 0042 0323     		movs	r3, #3
 715 0044 1340     		ands	r3, r2
 716 0046 032B     		cmp	r3, #3
 717 0048 06D0     		beq	.L76
 879:Src/usb_pd_protocol.c **** 		}
 718              		.loc 1 879 0
 719 004a C201     		lsls	r2, r0, #7
 720 004c 114B     		ldr	r3, .L77
 721 004e 9B18     		adds	r3, r3, r2
 722 0050 4833     		adds	r3, r3, #72
 723 0052 0022     		movs	r2, #0
 724 0054 1A70     		strb	r2, [r3]
 725 0056 DFE7     		b	.L68
 726              	.L76:
 872:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 727              		.loc 1 872 0
 728 0058 6846     		mov	r0, sp
 729              	.LVL62:
 730 005a FFF7FEFF 		bl	get_time
 731              	.LVL63:
 732 005e 0E4A     		ldr	r2, .L77+4
 733 0060 0023     		movs	r3, #0
 734 0062 0098     		ldr	r0, [sp]
 735 0064 0199     		ldr	r1, [sp, #4]
 736 0066 1218     		adds	r2, r2, r0
ARM GAS  /tmp/ccWvVg6G.s 			page 51


 737 0068 4B41     		adcs	r3, r3, r1
 738 006a E401     		lsls	r4, r4, #7
 739              	.LVL64:
 740 006c 0949     		ldr	r1, .L77
 741 006e 0C19     		adds	r4, r1, r4
 742 0070 2265     		str	r2, [r4, #80]
 743 0072 6365     		str	r3, [r4, #84]
 874:Src/usb_pd_protocol.c **** 			pd[port].vdo_retry = (payload[0] & ~VDO_CMDT_MASK) |
 744              		.loc 1 874 0
 745 0074 2300     		movs	r3, r4
 746 0076 4833     		adds	r3, r3, #72
 747 0078 0322     		movs	r2, #3
 748 007a 1A70     		strb	r2, [r3]
 875:Src/usb_pd_protocol.c **** 				CMDT_INIT;
 749              		.loc 1 875 0
 750 007c 2B68     		ldr	r3, [r5]
 751 007e BD32     		adds	r2, r2, #189
 752 0080 9343     		bics	r3, r2
 753 0082 A367     		str	r3, [r4, #120]
 877:Src/usb_pd_protocol.c **** 		} else {
 754              		.loc 1 877 0
 755 0084 D9E7     		b	.L67
 756              	.LVL65:
 757              	.L71:
 886:Src/usb_pd_protocol.c **** 
 758              		.loc 1 886 0
 759 0086 03AB     		add	r3, sp, #12
 760 0088 2A00     		movs	r2, r5
 761 008a 2000     		movs	r0, r4
 762              	.LVL66:
 763 008c FFF7FEFF 		bl	pd_custom_vdm
 764              	.LVL67:
 765 0090 CAE7     		b	.L72
 766              	.L78:
 767 0092 C046     		.align	2
 768              	.L77:
 769 0094 00000000 		.word	pd
 770 0098 A0860100 		.word	100000
 771              		.cfi_endproc
 772              	.LFE34:
 774              		.section	.text.pd_set_data_role,"ax",%progbits
 775              		.align	1
 776              		.syntax unified
 777              		.code	16
 778              		.thumb_func
 779              		.fpu softvfp
 781              	pd_set_data_role:
 782              	.LFB43:
1260:Src/usb_pd_protocol.c **** 	pd[port].data_role = role;
 783              		.loc 1 1260 0
 784              		.cfi_startproc
 785              		@ args = 0, pretend = 0, frame = 0
 786              		@ frame_needed = 0, uses_anonymous_args = 0
 787              	.LVL68:
 788 0000 10B5     		push	{r4, lr}
 789              	.LCFI6:
 790              		.cfi_def_cfa_offset 8
ARM GAS  /tmp/ccWvVg6G.s 			page 52


 791              		.cfi_offset 4, -8
 792              		.cfi_offset 14, -4
 793 0002 0400     		movs	r4, r0
1261:Src/usb_pd_protocol.c **** 	pd_execute_data_swap(port, role);
 794              		.loc 1 1261 0
 795 0004 C201     		lsls	r2, r0, #7
 796 0006 044B     		ldr	r3, .L80
 797 0008 9B18     		adds	r3, r3, r2
 798 000a 5970     		strb	r1, [r3, #1]
1262:Src/usb_pd_protocol.c **** 
 799              		.loc 1 1262 0
 800 000c FFF7FEFF 		bl	pd_execute_data_swap
 801              	.LVL69:
1281:Src/usb_pd_protocol.c **** }
 802              		.loc 1 1281 0
 803 0010 2000     		movs	r0, r4
 804 0012 FFF7FEFF 		bl	pd_update_roles
 805              	.LVL70:
1282:Src/usb_pd_protocol.c **** 
 806              		.loc 1 1282 0
 807              		@ sp needed
 808              	.LVL71:
 809 0016 10BD     		pop	{r4, pc}
 810              	.L81:
 811              		.align	2
 812              	.L80:
 813 0018 00000000 		.word	pd
 814              		.cfi_endproc
 815              	.LFE43:
 817              		.section	.text.pd_dr_swap,"ax",%progbits
 818              		.align	1
 819              		.syntax unified
 820              		.code	16
 821              		.thumb_func
 822              		.fpu softvfp
 824              	pd_dr_swap:
 825              	.LFB44:
1285:Src/usb_pd_protocol.c **** 	pd_set_data_role(port, !pd[port].data_role);
 826              		.loc 1 1285 0
 827              		.cfi_startproc
 828              		@ args = 0, pretend = 0, frame = 0
 829              		@ frame_needed = 0, uses_anonymous_args = 0
 830              	.LVL72:
 831 0000 10B5     		push	{r4, lr}
 832              	.LCFI7:
 833              		.cfi_def_cfa_offset 8
 834              		.cfi_offset 4, -8
 835              		.cfi_offset 14, -4
1286:Src/usb_pd_protocol.c **** 	pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 836              		.loc 1 1286 0
 837 0002 C301     		lsls	r3, r0, #7
 838 0004 054C     		ldr	r4, .L83
 839 0006 E418     		adds	r4, r4, r3
 840 0008 6178     		ldrb	r1, [r4, #1]
 841 000a 4B42     		rsbs	r3, r1, #0
 842 000c 5941     		adcs	r1, r1, r3
 843 000e FFF7FEFF 		bl	pd_set_data_role
ARM GAS  /tmp/ccWvVg6G.s 			page 53


 844              	.LVL73:
1287:Src/usb_pd_protocol.c **** }
 845              		.loc 1 1287 0
 846 0012 0823     		movs	r3, #8
 847 0014 A268     		ldr	r2, [r4, #8]
 848 0016 1343     		orrs	r3, r2
 849 0018 A360     		str	r3, [r4, #8]
1288:Src/usb_pd_protocol.c **** 
 850              		.loc 1 1288 0
 851              		@ sp needed
 852 001a 10BD     		pop	{r4, pc}
 853              	.L84:
 854              		.align	2
 855              	.L83:
 856 001c 00000000 		.word	pd
 857              		.cfi_endproc
 858              	.LFE44:
 860              		.section	.text.pd_restart_tcpc,"ax",%progbits
 861              		.align	1
 862              		.syntax unified
 863              		.code	16
 864              		.thumb_func
 865              		.fpu softvfp
 867              	pd_restart_tcpc:
 868              	.LFB65:
1993:Src/usb_pd_protocol.c **** 
1994:Src/usb_pd_protocol.c **** /**
1995:Src/usb_pd_protocol.c ****  * Signal power request to indicate a charger update that affects the port.
1996:Src/usb_pd_protocol.c ****  */
1997:Src/usb_pd_protocol.c **** void pd_set_new_power_request(int port)
1998:Src/usb_pd_protocol.c **** {
1999:Src/usb_pd_protocol.c **** 	pd[port].new_power_request = 1;
2000:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
2001:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
2002:Src/usb_pd_protocol.c **** }
2003:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
2004:Src/usb_pd_protocol.c **** 
2005:Src/usb_pd_protocol.c **** #if defined(CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP) && defined(CONFIG_USBC_SS_MUX)
2006:Src/usb_pd_protocol.c **** /*
2007:Src/usb_pd_protocol.c ****  * Backwards compatible DFP does not support USB SS because it applies VBUS
2008:Src/usb_pd_protocol.c ****  * before debouncing CC and setting USB SS muxes, but SS detection will fail
2009:Src/usb_pd_protocol.c ****  * before we are done debouncing CC.
2010:Src/usb_pd_protocol.c ****  */
2011:Src/usb_pd_protocol.c **** #error "Backwards compatible DFP does not support USB"
2012:Src/usb_pd_protocol.c **** #endif
2013:Src/usb_pd_protocol.c **** 
2014:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
2015:Src/usb_pd_protocol.c **** 
2016:Src/usb_pd_protocol.c **** /* Initialize globals based on system state. */
2017:Src/usb_pd_protocol.c **** static void pd_init_tasks(void)
2018:Src/usb_pd_protocol.c **** {
2019:Src/usb_pd_protocol.c **** 	static int initialized;
2020:Src/usb_pd_protocol.c **** 	int enable = 1;
2021:Src/usb_pd_protocol.c **** 	int i;
2022:Src/usb_pd_protocol.c **** 
2023:Src/usb_pd_protocol.c **** 	/* Initialize globals once, for all PD tasks.  */
2024:Src/usb_pd_protocol.c **** 	if (initialized)
ARM GAS  /tmp/ccWvVg6G.s 			page 54


2025:Src/usb_pd_protocol.c **** 		return;
2026:Src/usb_pd_protocol.c **** 
2027:Src/usb_pd_protocol.c **** #if defined(HAS_TASK_CHIPSET) && defined(CONFIG_USB_PD_DUAL_ROLE)
2028:Src/usb_pd_protocol.c **** 	/* Set dual-role state based on chipset power state */
2029:Src/usb_pd_protocol.c **** 	if (chipset_in_state(CHIPSET_STATE_ANY_OFF))
2030:Src/usb_pd_protocol.c **** 		drp_state = PD_DRP_FORCE_SINK;
2031:Src/usb_pd_protocol.c **** 	else if (chipset_in_state(CHIPSET_STATE_SUSPEND))
2032:Src/usb_pd_protocol.c **** 		drp_state = PD_DRP_TOGGLE_OFF;
2033:Src/usb_pd_protocol.c **** 	else /* CHIPSET_STATE_ON */
2034:Src/usb_pd_protocol.c **** 		drp_state = PD_DRP_TOGGLE_ON;
2035:Src/usb_pd_protocol.c **** #endif
2036:Src/usb_pd_protocol.c **** 
2037:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_COMM_DISABLED)
2038:Src/usb_pd_protocol.c **** 	enable = 0;
2039:Src/usb_pd_protocol.c **** #elif defined(CONFIG_USB_PD_COMM_LOCKED)
2040:Src/usb_pd_protocol.c **** 	/* Disable PD communication at init if we're in RO and locked. */
2041:Src/usb_pd_protocol.c **** 	if (!system_is_in_rw() && system_is_locked())
2042:Src/usb_pd_protocol.c **** 		enable = 0;
2043:Src/usb_pd_protocol.c **** #endif
2044:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++)
2045:Src/usb_pd_protocol.c **** 		pd_comm_enabled[i] = enable;
2046:Src/usb_pd_protocol.c **** 	CPRINTS("PD comm %sabled", enable ? "en" : "dis");
2047:Src/usb_pd_protocol.c **** 
2048:Src/usb_pd_protocol.c **** 	initialized = 1;
2049:Src/usb_pd_protocol.c **** }
2050:Src/usb_pd_protocol.c **** #endif /* CONFIG_COMMON_RUNTIME */
2051:Src/usb_pd_protocol.c **** 
2052:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
2053:Src/usb_pd_protocol.c **** static int pd_restart_tcpc(int port)
2054:Src/usb_pd_protocol.c **** {
 869              		.loc 1 2054 0
 870              		.cfi_startproc
 871              		@ args = 0, pretend = 0, frame = 0
 872              		@ frame_needed = 0, uses_anonymous_args = 0
 873              	.LVL74:
 874 0000 10B5     		push	{r4, lr}
 875              	.LCFI8:
 876              		.cfi_def_cfa_offset 8
 877              		.cfi_offset 4, -8
 878              		.cfi_offset 14, -4
 879 0002 0400     		movs	r4, r0
2055:Src/usb_pd_protocol.c **** 	if (board_set_tcpc_power_mode) {
 880              		.loc 1 2055 0
 881 0004 0A4B     		ldr	r3, .L88
 882 0006 002B     		cmp	r3, #0
 883 0008 02D0     		beq	.L86
2056:Src/usb_pd_protocol.c **** 		/* force chip reset */
2057:Src/usb_pd_protocol.c **** 		board_set_tcpc_power_mode(port, 0);
 884              		.loc 1 2057 0
 885 000a 0021     		movs	r1, #0
 886 000c FFF7FEFF 		bl	board_set_tcpc_power_mode
 887              	.LVL75:
 888              	.L86:
 889              	.LBB160:
 890              	.LBB161:
  38:Inc/tcpm.h    **** 	if (rv)
 891              		.loc 2 38 0
ARM GAS  /tmp/ccWvVg6G.s 			page 55


 892 0010 2201     		lsls	r2, r4, #4
 893 0012 084B     		ldr	r3, .L88+4
 894 0014 9B18     		adds	r3, r3, r2
 895 0016 9B68     		ldr	r3, [r3, #8]
 896 0018 1B68     		ldr	r3, [r3]
 897 001a 2000     		movs	r0, r4
 898 001c 9847     		blx	r3
 899              	.LVL76:
  39:Inc/tcpm.h    **** 		return rv;
 900              		.loc 2 39 0
 901 001e 0028     		cmp	r0, #0
 902 0020 05D1     		bne	.L85
  43:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
 903              		.loc 2 43 0
 904 0022 054B     		ldr	r3, .L88+8
 905 0024 002B     		cmp	r3, #0
 906 0026 02D0     		beq	.L85
  44:Inc/tcpm.h    **** 
 907              		.loc 2 44 0
 908 0028 2000     		movs	r0, r4
 909              	.LVL77:
 910 002a FFF7FEFF 		bl	board_tcpc_post_init
 911              	.LVL78:
 912              	.L85:
 913              	.LBE161:
 914              	.LBE160:
2058:Src/usb_pd_protocol.c **** 	}
2059:Src/usb_pd_protocol.c **** 	return tcpm_init(port);
2060:Src/usb_pd_protocol.c **** }
 915              		.loc 1 2060 0
 916              		@ sp needed
 917              	.LVL79:
 918 002e 10BD     		pop	{r4, pc}
 919              	.L89:
 920              		.align	2
 921              	.L88:
 922 0030 00000000 		.word	board_set_tcpc_power_mode
 923 0034 00000000 		.word	tcpc_config
 924 0038 00000000 		.word	board_tcpc_post_init
 925              		.cfi_endproc
 926              	.LFE65:
 928              		.section	.text.execute_soft_reset,"ax",%progbits
 929              		.align	1
 930              		.syntax unified
 931              		.code	16
 932              		.thumb_func
 933              		.fpu softvfp
 935              	execute_soft_reset:
 936              	.LFB36:
 951:Src/usb_pd_protocol.c **** 	pd[port].msg_id = 0;
 937              		.loc 1 951 0
 938              		.cfi_startproc
 939              		@ args = 0, pretend = 0, frame = 0
 940              		@ frame_needed = 0, uses_anonymous_args = 0
 941              	.LVL80:
 942 0000 70B5     		push	{r4, r5, r6, lr}
 943              	.LCFI9:
ARM GAS  /tmp/ccWvVg6G.s 			page 56


 944              		.cfi_def_cfa_offset 16
 945              		.cfi_offset 4, -16
 946              		.cfi_offset 5, -12
 947              		.cfi_offset 6, -8
 948              		.cfi_offset 14, -4
 949 0002 0400     		movs	r4, r0
 952:Src/usb_pd_protocol.c **** 	set_state(port, DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_DISCOVERY,
 950              		.loc 1 952 0
 951 0004 1E4B     		ldr	r3, .L102
 952 0006 C201     		lsls	r2, r0, #7
 953 0008 9918     		adds	r1, r3, r2
 954 000a 0020     		movs	r0, #0
 955              	.LVL81:
 956 000c 8870     		strb	r0, [r1, #2]
 953:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 957              		.loc 1 953 0
 958 000e D35C     		ldrb	r3, [r2, r3]
 959 0010 002B     		cmp	r3, #0
 960 0012 28D0     		beq	.L98
 961 0014 1222     		movs	r2, #18
 962              	.L91:
 963              	.LVL82:
 964              	.LBB168:
 965              	.LBB169:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 966              		.loc 1 346 0 discriminator 4
 967 0016 E101     		lsls	r1, r4, #7
 968 0018 194B     		ldr	r3, .L102
 969 001a 5B18     		adds	r3, r3, r1
 970 001c 1D79     		ldrb	r5, [r3, #4]
 971              	.LVL83:
 972              	.LBB170:
 973              	.LBB171:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 974              		.loc 1 283 0 discriminator 4
 975 001e 0020     		movs	r0, #0
 976 0020 0021     		movs	r1, #0
 977 0022 1861     		str	r0, [r3, #16]
 978 0024 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 979              		.loc 1 284 0 discriminator 4
 980 0026 0021     		movs	r1, #0
 981 0028 D971     		strb	r1, [r3, #7]
 982              	.LVL84:
 983              	.LBE171:
 984              	.LBE170:
 352:Src/usb_pd_protocol.c **** 
 985              		.loc 1 352 0 discriminator 4
 986 002a 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 987              		.loc 1 354 0 discriminator 4
 988 002c AA42     		cmp	r2, r5
 989 002e 19D0     		beq	.L90
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 990              		.loc 1 365 0
 991 0030 022D     		cmp	r5, #2
 992 0032 1AD0     		beq	.L99
ARM GAS  /tmp/ccWvVg6G.s 			page 57


 993              	.L93:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 994              		.loc 1 366 0
 995 0034 0E2D     		cmp	r5, #14
 996 0036 1BD0     		beq	.L100
 997              	.L94:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 998              		.loc 1 371 0
 999 0038 0E2A     		cmp	r2, #14
 1000 003a 01D0     		beq	.L95
 1001 003c 022A     		cmp	r2, #2
 1002 003e 11D1     		bne	.L90
 1003              	.L95:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1004              		.loc 1 374 0
 1005 0040 0022     		movs	r2, #0
 1006              	.LVL85:
 1007 0042 0021     		movs	r1, #0
 1008 0044 2000     		movs	r0, r4
 1009 0046 FFF7FEFF 		bl	pd_set_input_current_limit
 1010              	.LVL86:
 391:Src/usb_pd_protocol.c **** 			/*
 1011              		.loc 1 391 0
 1012 004a E301     		lsls	r3, r4, #7
 1013 004c 0C4A     		ldr	r2, .L102
 1014 004e 9B5C     		ldrb	r3, [r3, r2]
 1015 0050 012B     		cmp	r3, #1
 1016 0052 10D0     		beq	.L101
 1017              	.L96:
 1018              	.LVL87:
 1019              	.LBB172:
 1020              	.LBB173:
 1021              		.loc 2 92 0
 1022 0054 2201     		lsls	r2, r4, #4
 1023 0056 0B4B     		ldr	r3, .L102+4
 1024 0058 9B18     		adds	r3, r3, r2
 1025 005a 9B68     		ldr	r3, [r3, #8]
 1026 005c 5B6A     		ldr	r3, [r3, #36]
 1027 005e 0021     		movs	r1, #0
 1028 0060 2000     		movs	r0, r4
 1029 0062 9847     		blx	r3
 1030              	.LVL88:
 1031              	.L90:
 1032              	.LBE173:
 1033              	.LBE172:
 1034              	.LBE169:
 1035              	.LBE168:
 956:Src/usb_pd_protocol.c **** 
 1036              		.loc 1 956 0
 1037              		@ sp needed
 1038              	.LVL89:
 1039 0064 70BD     		pop	{r4, r5, r6, pc}
 1040              	.LVL90:
 1041              	.L98:
 953:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 1042              		.loc 1 953 0
 1043 0066 0522     		movs	r2, #5
ARM GAS  /tmp/ccWvVg6G.s 			page 58


 1044 0068 D5E7     		b	.L91
 1045              	.LVL91:
 1046              	.L99:
 1047              	.LBB175:
 1048              	.LBB174:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 1049              		.loc 1 365 0
 1050 006a 0E2A     		cmp	r2, #14
 1051 006c E2D1     		bne	.L93
 1052 006e F9E7     		b	.L90
 1053              	.L100:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 1054              		.loc 1 367 0
 1055 0070 022A     		cmp	r2, #2
 1056 0072 E1D1     		bne	.L94
 1057 0074 F6E7     		b	.L90
 1058              	.LVL92:
 1059              	.L101:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 1060              		.loc 1 396 0
 1061 0076 2000     		movs	r0, r4
 1062 0078 FFF7FEFF 		bl	pd_power_supply_reset
 1063              	.LVL93:
 1064 007c EAE7     		b	.L96
 1065              	.L103:
 1066 007e C046     		.align	2
 1067              	.L102:
 1068 0080 00000000 		.word	pd
 1069 0084 00000000 		.word	tcpc_config
 1070              	.LBE174:
 1071              	.LBE175:
 1072              		.cfi_endproc
 1073              	.LFE36:
 1075              		.section	.text.pd_comm_is_enabled,"ax",%progbits
 1076              		.align	1
 1077              		.global	pd_comm_is_enabled
 1078              		.syntax unified
 1079              		.code	16
 1080              		.thumb_func
 1081              		.fpu softvfp
 1083              	pd_comm_is_enabled:
 1084              	.LFB18:
 271:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 1085              		.loc 1 271 0
 1086              		.cfi_startproc
 1087              		@ args = 0, pretend = 0, frame = 0
 1088              		@ frame_needed = 0, uses_anonymous_args = 0
 1089              		@ link register save eliminated.
 1090              	.LVL94:
 277:Src/usb_pd_protocol.c **** 
 1091              		.loc 1 277 0
 1092 0000 0120     		movs	r0, #1
 1093              	.LVL95:
 1094              		@ sp needed
 1095 0002 7047     		bx	lr
 1096              		.cfi_endproc
 1097              	.LFE18:
ARM GAS  /tmp/ccWvVg6G.s 			page 59


 1099              		.section	.text.pd_transmit,"ax",%progbits
 1100              		.align	1
 1101              		.syntax unified
 1102              		.code	16
 1103              		.thumb_func
 1104              		.fpu softvfp
 1106              	pd_transmit:
 1107              	.LFB27:
 476:Src/usb_pd_protocol.c **** 	int evt;
 1108              		.loc 1 476 0
 1109              		.cfi_startproc
 1110              		@ args = 0, pretend = 0, frame = 8
 1111              		@ frame_needed = 0, uses_anonymous_args = 0
 1112              	.LVL96:
 1113 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1114              	.LCFI10:
 1115              		.cfi_def_cfa_offset 20
 1116              		.cfi_offset 4, -20
 1117              		.cfi_offset 5, -16
 1118              		.cfi_offset 6, -12
 1119              		.cfi_offset 7, -8
 1120              		.cfi_offset 14, -4
 1121 0002 83B0     		sub	sp, sp, #12
 1122              	.LCFI11:
 1123              		.cfi_def_cfa_offset 32
 1124 0004 0400     		movs	r4, r0
 1125 0006 0191     		str	r1, [sp, #4]
 1126 0008 1600     		movs	r6, r2
 1127 000a 1F00     		movs	r7, r3
 480:Src/usb_pd_protocol.c **** 		return -1;
 1128              		.loc 1 480 0
 1129 000c FFF7FEFF 		bl	pd_comm_is_enabled
 1130              	.LVL97:
 1131 0010 0028     		cmp	r0, #0
 1132 0012 13D0     		beq	.L107
 1133              	.LVL98:
 1134              	.LBB176:
 1135              	.LBB177:
  93:Inc/tcpm.h    **** }
  94:Inc/tcpm.h    **** 
  95:Inc/tcpm.h    **** static inline int tcpm_get_message(int port, uint32_t *payload, int *head)
  96:Inc/tcpm.h    **** {
  97:Inc/tcpm.h    **** 	return tcpc_config[port].drv->get_message(port, payload, head);
  98:Inc/tcpm.h    **** }
  99:Inc/tcpm.h    **** 
 100:Inc/tcpm.h    **** static inline int tcpm_transmit(int port, enum tcpm_transmit_type type,
 101:Inc/tcpm.h    **** 		  uint16_t header, const uint32_t *data)
 102:Inc/tcpm.h    **** {
 103:Inc/tcpm.h    **** 	return tcpc_config[port].drv->transmit(port, type, header, data);
 1136              		.loc 2 103 0
 1137 0014 2201     		lsls	r2, r4, #4
 1138 0016 0C4B     		ldr	r3, .L109
 1139 0018 9B18     		adds	r3, r3, r2
 1140 001a 9B68     		ldr	r3, [r3, #8]
 1141 001c DD6A     		ldr	r5, [r3, #44]
 1142 001e 3B00     		movs	r3, r7
 1143 0020 3200     		movs	r2, r6
ARM GAS  /tmp/ccWvVg6G.s 			page 60


 1144 0022 0199     		ldr	r1, [sp, #4]
 1145 0024 2000     		movs	r0, r4
 1146 0026 A847     		blx	r5
 1147              	.LVL99:
 1148              	.LBE177:
 1149              	.LBE176:
 558:Src/usb_pd_protocol.c **** }
 1150              		.loc 1 558 0
 1151 0028 E401     		lsls	r4, r4, #7
 1152              	.LVL100:
 1153 002a 084B     		ldr	r3, .L109+4
 1154 002c 1C19     		adds	r4, r3, r4
 1155 002e 2934     		adds	r4, r4, #41
 1156 0030 2378     		ldrb	r3, [r4]
 1157 0032 002B     		cmp	r3, #0
 1158 0034 05D1     		bne	.L108
 1159 0036 0120     		movs	r0, #1
 1160              	.L105:
 559:Src/usb_pd_protocol.c **** 
 1161              		.loc 1 559 0
 1162 0038 03B0     		add	sp, sp, #12
 1163              		@ sp needed
 1164              	.LVL101:
 1165 003a F0BD     		pop	{r4, r5, r6, r7, pc}
 1166              	.LVL102:
 1167              	.L107:
 481:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 1168              		.loc 1 481 0
 1169 003c 0120     		movs	r0, #1
 1170 003e 4042     		rsbs	r0, r0, #0
 1171 0040 FAE7     		b	.L105
 1172              	.LVL103:
 1173              	.L108:
 558:Src/usb_pd_protocol.c **** }
 1174              		.loc 1 558 0
 1175 0042 0120     		movs	r0, #1
 1176 0044 4042     		rsbs	r0, r0, #0
 1177 0046 F7E7     		b	.L105
 1178              	.L110:
 1179              		.align	2
 1180              	.L109:
 1181 0048 00000000 		.word	tcpc_config
 1182 004c 00000000 		.word	pd
 1183              		.cfi_endproc
 1184              	.LFE27:
 1186              		.section	.text.send_sink_cap,"ax",%progbits
 1187              		.align	1
 1188              		.syntax unified
 1189              		.code	16
 1190              		.thumb_func
 1191              		.fpu softvfp
 1193              	send_sink_cap:
 1194              	.LFB31:
 791:Src/usb_pd_protocol.c **** 	int bit_len;
 1195              		.loc 1 791 0
 1196              		.cfi_startproc
 1197              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /tmp/ccWvVg6G.s 			page 61


 1198              		@ frame_needed = 0, uses_anonymous_args = 0
 1199              	.LVL104:
 1200 0000 70B5     		push	{r4, r5, r6, lr}
 1201              	.LCFI12:
 1202              		.cfi_def_cfa_offset 16
 1203              		.cfi_offset 4, -16
 1204              		.cfi_offset 5, -12
 1205              		.cfi_offset 6, -8
 1206              		.cfi_offset 14, -4
 793:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, pd_snk_pdo_cnt,
 1207              		.loc 1 793 0
 1208 0002 0D4B     		ldr	r3, .L112
 1209 0004 C401     		lsls	r4, r0, #7
 1210 0006 1919     		adds	r1, r3, r4
 1211 0008 4A78     		ldrb	r2, [r1, #1]
 1212 000a 5201     		lsls	r2, r2, #5
 1213 000c 4425     		movs	r5, #68
 1214 000e 2A43     		orrs	r2, r5
 1215 0010 E35C     		ldrb	r3, [r4, r3]
 1216 0012 1B02     		lsls	r3, r3, #8
 1217 0014 1A43     		orrs	r2, r3
 1218 0016 12B2     		sxth	r2, r2
 1219 0018 8B78     		ldrb	r3, [r1, #2]
 1220 001a 5B02     		lsls	r3, r3, #9
 1221 001c 1A43     		orrs	r2, r3
 1222 001e 12B2     		sxth	r2, r2
 1223 0020 064B     		ldr	r3, .L112+4
 1224 0022 1B68     		ldr	r3, [r3]
 1225 0024 1B03     		lsls	r3, r3, #12
 1226 0026 1A43     		orrs	r2, r3
 1227 0028 12B2     		sxth	r2, r2
 1228 002a 92B2     		uxth	r2, r2
 1229              	.LVL105:
 797:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1230              		.loc 1 797 0
 1231 002c 044B     		ldr	r3, .L112+8
 1232 002e 0021     		movs	r1, #0
 1233 0030 FFF7FEFF 		bl	pd_transmit
 1234              	.LVL106:
 800:Src/usb_pd_protocol.c **** 
 1235              		.loc 1 800 0
 1236              		@ sp needed
 1237 0034 70BD     		pop	{r4, r5, r6, pc}
 1238              	.L113:
 1239 0036 C046     		.align	2
 1240              	.L112:
 1241 0038 00000000 		.word	pd
 1242 003c 00000000 		.word	pd_snk_pdo_cnt
 1243 0040 00000000 		.word	pd_snk_pdo
 1244              		.cfi_endproc
 1245              	.LFE31:
 1247              		.section	.text.send_source_cap,"ax",%progbits
 1248              		.align	1
 1249              		.syntax unified
 1250              		.code	16
 1251              		.thumb_func
 1252              		.fpu softvfp
ARM GAS  /tmp/ccWvVg6G.s 			page 62


 1254              	send_source_cap:
 1255              	.LFB30:
 605:Src/usb_pd_protocol.c **** 	int bit_len;
 1256              		.loc 1 605 0
 1257              		.cfi_startproc
 1258              		@ args = 0, pretend = 0, frame = 0
 1259              		@ frame_needed = 0, uses_anonymous_args = 0
 1260              	.LVL107:
 1261 0000 70B5     		push	{r4, r5, r6, lr}
 1262              	.LCFI13:
 1263              		.cfi_def_cfa_offset 16
 1264              		.cfi_offset 4, -16
 1265              		.cfi_offset 5, -12
 1266              		.cfi_offset 6, -8
 1267              		.cfi_offset 14, -4
 1268              	.LVL108:
 613:Src/usb_pd_protocol.c **** #endif
 1269              		.loc 1 613 0
 1270 0002 164B     		ldr	r3, .L118
 1271 0004 1968     		ldr	r1, [r3]
 1272              	.LVL109:
 617:Src/usb_pd_protocol.c **** 		/* No source capabilities defined, sink only */
 1273              		.loc 1 617 0
 1274 0006 0029     		cmp	r1, #0
 1275 0008 17D0     		beq	.L117
 623:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 1276              		.loc 1 623 0
 1277 000a 154D     		ldr	r5, .L118+4
 1278 000c C601     		lsls	r6, r0, #7
 1279 000e AC19     		adds	r4, r5, r6
 1280 0010 6378     		ldrb	r3, [r4, #1]
 1281 0012 5B01     		lsls	r3, r3, #5
 1282 0014 4122     		movs	r2, #65
 1283 0016 1343     		orrs	r3, r2
 1284 0018 725D     		ldrb	r2, [r6, r5]
 1285 001a 1202     		lsls	r2, r2, #8
 1286 001c 1343     		orrs	r3, r2
 1287 001e 1BB2     		sxth	r3, r3
 1288 0020 A278     		ldrb	r2, [r4, #2]
 1289 0022 5202     		lsls	r2, r2, #9
 1290 0024 1A43     		orrs	r2, r3
 1291 0026 12B2     		sxth	r2, r2
 1292 0028 0903     		lsls	r1, r1, #12
 1293              	.LVL110:
 1294 002a 0A43     		orrs	r2, r1
 1295 002c 12B2     		sxth	r2, r2
 1296 002e 92B2     		uxth	r2, r2
 1297              	.LVL111:
 1298              	.L116:
 627:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1299              		.loc 1 627 0
 1300 0030 0C4B     		ldr	r3, .L118+8
 1301 0032 0021     		movs	r1, #0
 1302 0034 FFF7FEFF 		bl	pd_transmit
 1303              	.LVL112:
 632:Src/usb_pd_protocol.c **** 
 1304              		.loc 1 632 0
ARM GAS  /tmp/ccWvVg6G.s 			page 63


 1305              		@ sp needed
 1306 0038 70BD     		pop	{r4, r5, r6, pc}
 1307              	.LVL113:
 1308              	.L117:
 619:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 0,
 1309              		.loc 1 619 0
 1310 003a 094B     		ldr	r3, .L118+4
 1311 003c C401     		lsls	r4, r0, #7
 1312 003e 1919     		adds	r1, r3, r4
 1313              	.LVL114:
 1314 0040 4A78     		ldrb	r2, [r1, #1]
 1315 0042 5201     		lsls	r2, r2, #5
 1316 0044 4425     		movs	r5, #68
 1317 0046 2A43     		orrs	r2, r5
 1318 0048 E35C     		ldrb	r3, [r4, r3]
 1319 004a 1B02     		lsls	r3, r3, #8
 1320 004c 1A43     		orrs	r2, r3
 1321 004e 12B2     		sxth	r2, r2
 1322 0050 8B78     		ldrb	r3, [r1, #2]
 1323 0052 5B02     		lsls	r3, r3, #9
 1324 0054 1A43     		orrs	r2, r3
 1325 0056 12B2     		sxth	r2, r2
 1326 0058 92B2     		uxth	r2, r2
 1327              	.LVL115:
 1328 005a E9E7     		b	.L116
 1329              	.L119:
 1330              		.align	2
 1331              	.L118:
 1332 005c 00000000 		.word	pd_src_pdo_cnt
 1333 0060 00000000 		.word	pd
 1334 0064 00000000 		.word	pd_src_pdo
 1335              		.cfi_endproc
 1336              	.LFE30:
 1338              		.section	.text.send_request,"ax",%progbits
 1339              		.align	1
 1340              		.syntax unified
 1341              		.code	16
 1342              		.thumb_func
 1343              		.fpu softvfp
 1345              	send_request:
 1346              	.LFB32:
 803:Src/usb_pd_protocol.c **** 	int bit_len;
 1347              		.loc 1 803 0
 1348              		.cfi_startproc
 1349              		@ args = 0, pretend = 0, frame = 8
 1350              		@ frame_needed = 0, uses_anonymous_args = 0
 1351              	.LVL116:
 1352 0000 30B5     		push	{r4, r5, lr}
 1353              	.LCFI14:
 1354              		.cfi_def_cfa_offset 12
 1355              		.cfi_offset 4, -12
 1356              		.cfi_offset 5, -8
 1357              		.cfi_offset 14, -4
 1358 0002 83B0     		sub	sp, sp, #12
 1359              	.LCFI15:
 1360              		.cfi_def_cfa_offset 24
 1361 0004 0191     		str	r1, [sp, #4]
ARM GAS  /tmp/ccWvVg6G.s 			page 64


 805:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 1362              		.loc 1 805 0
 1363 0006 0C4B     		ldr	r3, .L121
 1364 0008 C401     		lsls	r4, r0, #7
 1365 000a 1919     		adds	r1, r3, r4
 1366              	.LVL117:
 1367 000c 4A78     		ldrb	r2, [r1, #1]
 1368 000e 5201     		lsls	r2, r2, #5
 1369 0010 4225     		movs	r5, #66
 1370 0012 2A43     		orrs	r2, r5
 1371 0014 E35C     		ldrb	r3, [r4, r3]
 1372 0016 1B02     		lsls	r3, r3, #8
 1373 0018 1A43     		orrs	r2, r3
 1374 001a 12B2     		sxth	r2, r2
 1375 001c 8B78     		ldrb	r3, [r1, #2]
 1376 001e 5B02     		lsls	r3, r3, #9
 1377 0020 1A43     		orrs	r2, r3
 1378 0022 12B2     		sxth	r2, r2
 1379 0024 8023     		movs	r3, #128
 1380 0026 5B01     		lsls	r3, r3, #5
 1381 0028 1A43     		orrs	r2, r3
 1382 002a 92B2     		uxth	r2, r2
 1383              	.LVL118:
 809:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1384              		.loc 1 809 0
 1385 002c 01AB     		add	r3, sp, #4
 1386              	.LVL119:
 1387 002e 0021     		movs	r1, #0
 1388 0030 FFF7FEFF 		bl	pd_transmit
 1389              	.LVL120:
 814:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
 1390              		.loc 1 814 0
 1391 0034 03B0     		add	sp, sp, #12
 1392              		@ sp needed
 1393 0036 30BD     		pop	{r4, r5, pc}
 1394              	.L122:
 1395              		.align	2
 1396              	.L121:
 1397 0038 00000000 		.word	pd
 1398              		.cfi_endproc
 1399              	.LFE32:
 1401              		.section	.text.pd_send_request_msg,"ax",%progbits
 1402              		.align	1
 1403              		.syntax unified
 1404              		.code	16
 1405              		.thumb_func
 1406              		.fpu softvfp
 1408              	pd_send_request_msg:
 1409              	.LFB38:
 976:Src/usb_pd_protocol.c **** 	uint32_t rdo, curr_limit, supply_voltage;
 1410              		.loc 1 976 0
 1411              		.cfi_startproc
 1412              		@ args = 0, pretend = 0, frame = 16
 1413              		@ frame_needed = 0, uses_anonymous_args = 0
 1414              	.LVL121:
 1415 0000 70B5     		push	{r4, r5, r6, lr}
 1416              	.LCFI16:
ARM GAS  /tmp/ccWvVg6G.s 			page 65


 1417              		.cfi_def_cfa_offset 16
 1418              		.cfi_offset 4, -16
 1419              		.cfi_offset 5, -12
 1420              		.cfi_offset 6, -8
 1421              		.cfi_offset 14, -4
 1422 0002 86B0     		sub	sp, sp, #24
 1423              	.LCFI17:
 1424              		.cfi_def_cfa_offset 40
 1425 0004 0400     		movs	r4, r0
 1426 0006 0E00     		movs	r6, r1
 1427              	.LVL122:
 994:Src/usb_pd_protocol.c **** 
 1428              		.loc 1 994 0
 1429 0008 C201     		lsls	r2, r0, #7
 1430 000a 1B4B     		ldr	r3, .L128
 1431 000c 9B18     		adds	r3, r3, r2
 1432 000e 0022     		movs	r2, #0
 1433 0010 9A63     		str	r2, [r3, #56]
1001:Src/usb_pd_protocol.c **** 			       charging && max_request_allowed ?
 1434              		.loc 1 1001 0
 1435 0012 0123     		movs	r3, #1
 1436 0014 0093     		str	r3, [sp]
 1437 0016 03AB     		add	r3, sp, #12
 1438 0018 04AA     		add	r2, sp, #16
 1439 001a 05A9     		add	r1, sp, #20
 1440              	.LVL123:
 1441 001c FFF7FEFF 		bl	pd_build_request
 1442              	.LVL124:
 1443 0020 051E     		subs	r5, r0, #0
 1444              	.LVL125:
1005:Src/usb_pd_protocol.c **** 		/*
 1445              		.loc 1 1005 0
 1446 0022 24D1     		bne	.L126
1012:Src/usb_pd_protocol.c **** 		/* Don't re-request the same voltage */
 1447              		.loc 1 1012 0
 1448 0024 002E     		cmp	r6, #0
 1449 0026 06D1     		bne	.L125
1014:Src/usb_pd_protocol.c **** 			return EC_SUCCESS;
 1450              		.loc 1 1014 0
 1451 0028 E201     		lsls	r2, r4, #7
 1452 002a 134B     		ldr	r3, .L128
 1453 002c 9B18     		adds	r3, r3, r2
 1454 002e DB6B     		ldr	r3, [r3, #60]
 1455 0030 039A     		ldr	r2, [sp, #12]
 1456 0032 9342     		cmp	r3, r2
 1457 0034 1ED0     		beq	.L127
 1458              	.L125:
1029:Src/usb_pd_protocol.c **** 	pd[port].supply_voltage = supply_voltage;
 1459              		.loc 1 1029 0
 1460 0036 E201     		lsls	r2, r4, #7
 1461 0038 0F4B     		ldr	r3, .L128
 1462 003a 9B18     		adds	r3, r3, r2
 1463 003c 049A     		ldr	r2, [sp, #16]
 1464 003e 1A63     		str	r2, [r3, #48]
1030:Src/usb_pd_protocol.c **** 	pd[port].prev_request_mv = supply_voltage;
 1465              		.loc 1 1030 0
 1466 0040 039A     		ldr	r2, [sp, #12]
ARM GAS  /tmp/ccWvVg6G.s 			page 66


 1467 0042 5A63     		str	r2, [r3, #52]
1031:Src/usb_pd_protocol.c **** 	res = send_request(port, rdo);
 1468              		.loc 1 1031 0
 1469 0044 DA63     		str	r2, [r3, #60]
1032:Src/usb_pd_protocol.c **** 	if (res < 0)
 1470              		.loc 1 1032 0
 1471 0046 0599     		ldr	r1, [sp, #20]
 1472 0048 2000     		movs	r0, r4
 1473              	.LVL126:
 1474 004a FFF7FEFF 		bl	send_request
 1475              	.LVL127:
1033:Src/usb_pd_protocol.c **** 		return res;
 1476              		.loc 1 1033 0
 1477 004e 0028     		cmp	r0, #0
 1478 0050 0BDB     		blt	.L123
 1479              	.LVL128:
 1480              	.LBB184:
 1481              	.LBB185:
 1482              	.LBB186:
 1483              	.LBB187:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1484              		.loc 1 283 0
 1485 0052 E401     		lsls	r4, r4, #7
 1486              	.LVL129:
 1487 0054 084B     		ldr	r3, .L128
 1488 0056 1C19     		adds	r4, r3, r4
 1489 0058 0022     		movs	r2, #0
 1490 005a 0023     		movs	r3, #0
 1491 005c 2261     		str	r2, [r4, #16]
 1492 005e 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 1493              		.loc 1 284 0
 1494 0060 0023     		movs	r3, #0
 1495 0062 E371     		strb	r3, [r4, #7]
 1496              	.LVL130:
 1497              	.LBE187:
 1498              	.LBE186:
 352:Src/usb_pd_protocol.c **** 
 1499              		.loc 1 352 0
 1500 0064 0633     		adds	r3, r3, #6
 1501 0066 2371     		strb	r3, [r4, #4]
 1502              	.LVL131:
 1503              	.LBE185:
 1504              	.LBE184:
1036:Src/usb_pd_protocol.c **** }
 1505              		.loc 1 1036 0
 1506 0068 2800     		movs	r0, r5
 1507              	.LVL132:
 1508              	.L123:
1037:Src/usb_pd_protocol.c **** #endif
 1509              		.loc 1 1037 0
 1510 006a 06B0     		add	sp, sp, #24
 1511              		@ sp needed
 1512              	.LVL133:
 1513 006c 70BD     		pop	{r4, r5, r6, pc}
 1514              	.LVL134:
 1515              	.L126:
ARM GAS  /tmp/ccWvVg6G.s 			page 67


1010:Src/usb_pd_protocol.c **** 
 1516              		.loc 1 1010 0
 1517 006e 0120     		movs	r0, #1
 1518              	.LVL135:
 1519 0070 4042     		rsbs	r0, r0, #0
 1520 0072 FAE7     		b	.L123
 1521              	.LVL136:
 1522              	.L127:
1015:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1523              		.loc 1 1015 0
 1524 0074 3000     		movs	r0, r6
 1525              	.LVL137:
 1526 0076 F8E7     		b	.L123
 1527              	.L129:
 1528              		.align	2
 1529              	.L128:
 1530 0078 00000000 		.word	pd
 1531              		.cfi_endproc
 1532              	.LFE38:
 1534              		.section	.text.send_control,"ax",%progbits
 1535              		.align	1
 1536              		.syntax unified
 1537              		.code	16
 1538              		.thumb_func
 1539              		.fpu softvfp
 1541              	send_control:
 1542              	.LFB29:
 591:Src/usb_pd_protocol.c **** 	int bit_len;
 1543              		.loc 1 591 0
 1544              		.cfi_startproc
 1545              		@ args = 0, pretend = 0, frame = 0
 1546              		@ frame_needed = 0, uses_anonymous_args = 0
 1547              	.LVL138:
 1548 0000 70B5     		push	{r4, r5, r6, lr}
 1549              	.LCFI18:
 1550              		.cfi_def_cfa_offset 16
 1551              		.cfi_offset 4, -16
 1552              		.cfi_offset 5, -12
 1553              		.cfi_offset 6, -8
 1554              		.cfi_offset 14, -4
 593:Src/usb_pd_protocol.c **** 				pd[port].data_role, pd[port].msg_id, 0,
 1555              		.loc 1 593 0
 1556 0002 4022     		movs	r2, #64
 1557 0004 0A43     		orrs	r2, r1
 1558 0006 12B2     		sxth	r2, r2
 1559 0008 094C     		ldr	r4, .L131
 1560 000a C501     		lsls	r5, r0, #7
 1561 000c 6319     		adds	r3, r4, r5
 1562 000e 5978     		ldrb	r1, [r3, #1]
 1563              	.LVL139:
 1564 0010 4901     		lsls	r1, r1, #5
 1565 0012 0A43     		orrs	r2, r1
 1566 0014 295D     		ldrb	r1, [r5, r4]
 1567 0016 0902     		lsls	r1, r1, #8
 1568 0018 0A43     		orrs	r2, r1
 1569 001a 12B2     		sxth	r2, r2
 1570 001c 9B78     		ldrb	r3, [r3, #2]
ARM GAS  /tmp/ccWvVg6G.s 			page 68


 1571 001e 5B02     		lsls	r3, r3, #9
 1572 0020 1A43     		orrs	r2, r3
 1573 0022 92B2     		uxth	r2, r2
 1574              	.LVL140:
 597:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1575              		.loc 1 597 0
 1576 0024 0023     		movs	r3, #0
 1577 0026 0021     		movs	r1, #0
 1578 0028 FFF7FEFF 		bl	pd_transmit
 1579              	.LVL141:
 602:Src/usb_pd_protocol.c **** 
 1580              		.loc 1 602 0
 1581              		@ sp needed
 1582 002c 70BD     		pop	{r4, r5, r6, pc}
 1583              	.L132:
 1584 002e C046     		.align	2
 1585              	.L131:
 1586 0030 00000000 		.word	pd
 1587              		.cfi_endproc
 1588              	.LFE29:
 1590              		.section	.text.handle_ctrl_request,"ax",%progbits
 1591              		.align	1
 1592              		.syntax unified
 1593              		.code	16
 1594              		.thumb_func
 1595              		.fpu softvfp
 1597              	handle_ctrl_request:
 1598              	.LFB45:
1292:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
 1599              		.loc 1 1292 0
 1600              		.cfi_startproc
 1601              		@ args = 0, pretend = 0, frame = 8
 1602              		@ frame_needed = 0, uses_anonymous_args = 0
 1603              	.LVL142:
 1604 0000 70B5     		push	{r4, r5, r6, lr}
 1605              	.LCFI19:
 1606              		.cfi_def_cfa_offset 16
 1607              		.cfi_offset 4, -16
 1608              		.cfi_offset 5, -12
 1609              		.cfi_offset 6, -8
 1610              		.cfi_offset 14, -4
 1611 0002 82B0     		sub	sp, sp, #8
 1612              	.LCFI20:
 1613              		.cfi_def_cfa_offset 24
 1614 0004 0400     		movs	r4, r0
 1615 0006 0F23     		movs	r3, #15
 1616 0008 1940     		ands	r1, r3
 1617              	.LVL143:
1296:Src/usb_pd_protocol.c **** 	case PD_CTRL_GOOD_CRC:
 1618              		.loc 1 1296 0
 1619 000a CB1E     		subs	r3, r1, #3
 1620 000c 9AB2     		uxth	r2, r3
 1621              	.LVL144:
 1622 000e 0A2A     		cmp	r2, #10
 1623 0010 1AD8     		bhi	.L133
 1624 0012 9300     		lsls	r3, r2, #2
 1625 0014 C24A     		ldr	r2, .L200
ARM GAS  /tmp/ccWvVg6G.s 			page 69


 1626 0016 D358     		ldr	r3, [r2, r3]
 1627 0018 9F46     		mov	pc, r3
 1628              		.section	.rodata.handle_ctrl_request,"a",%progbits
 1629              		.align	2
 1630              	.L136:
 1631 0000 06020000 		.word	.L135
 1632 0004 DE000000 		.word	.L137
 1633 0008 48000000 		.word	.L133
 1634 000c 4C000000 		.word	.L138
 1635 0010 1A000000 		.word	.L139
 1636 0014 44000000 		.word	.L140
 1637 0018 CC030000 		.word	.L141
 1638 001c 30030000 		.word	.L142
 1639 0020 0A040000 		.word	.L143
 1640 0024 DE000000 		.word	.L137
 1641 0028 12030000 		.word	.L144
 1642              		.section	.text.handle_ctrl_request
 1643              	.L139:
1304:Src/usb_pd_protocol.c **** 		if ((res >= 0) &&
 1644              		.loc 1 1304 0
 1645 001a FFF7FEFF 		bl	send_source_cap
 1646              	.LVL145:
1305:Src/usb_pd_protocol.c **** 		    (pd[port].task_state == PD_STATE_SRC_DISCOVERY))
 1647              		.loc 1 1305 0
 1648 001e 0028     		cmp	r0, #0
 1649 0020 12DB     		blt	.L133
1306:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_NEGOCIATE);
 1650              		.loc 1 1306 0 discriminator 1
 1651 0022 E201     		lsls	r2, r4, #7
 1652 0024 BF4B     		ldr	r3, .L200+4
 1653 0026 9B18     		adds	r3, r3, r2
 1654 0028 1B79     		ldrb	r3, [r3, #4]
1305:Src/usb_pd_protocol.c **** 		    (pd[port].task_state == PD_STATE_SRC_DISCOVERY))
 1655              		.loc 1 1305 0 discriminator 1
 1656 002a 122B     		cmp	r3, #18
 1657 002c 0CD1     		bne	.L133
 1658              	.LVL146:
 1659              	.LBB280:
 1660              	.LBB281:
 1661              	.LBB282:
 1662              	.LBB283:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1663              		.loc 1 283 0
 1664 002e BD4B     		ldr	r3, .L200+4
 1665 0030 9C18     		adds	r4, r3, r2
 1666              	.LVL147:
 1667 0032 0022     		movs	r2, #0
 1668 0034 0023     		movs	r3, #0
 1669 0036 2261     		str	r2, [r4, #16]
 1670 0038 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 1671              		.loc 1 284 0
 1672 003a 0023     		movs	r3, #0
 1673 003c E371     		strb	r3, [r4, #7]
 1674              	.LVL148:
 1675              	.LBE283:
 1676              	.LBE282:
ARM GAS  /tmp/ccWvVg6G.s 			page 70


 352:Src/usb_pd_protocol.c **** 
 1677              		.loc 1 352 0
 1678 003e 1333     		adds	r3, r3, #19
 1679 0040 2371     		strb	r3, [r4, #4]
 1680 0042 01E0     		b	.L133
 1681              	.LVL149:
 1682              	.L140:
 1683              	.LBE281:
 1684              	.LBE280:
1311:Src/usb_pd_protocol.c **** #else
 1685              		.loc 1 1311 0
 1686 0044 FFF7FEFF 		bl	send_sink_cap
 1687              	.LVL150:
 1688              	.L133:
1530:Src/usb_pd_protocol.c **** 
 1689              		.loc 1 1530 0
 1690 0048 02B0     		add	sp, sp, #8
 1691              		@ sp needed
 1692 004a 70BD     		pop	{r4, r5, r6, pc}
 1693              	.LVL151:
 1694              	.L138:
1335:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_STANDBY);
 1695              		.loc 1 1335 0
 1696 004c C201     		lsls	r2, r0, #7
 1697 004e B54B     		ldr	r3, .L200+4
 1698 0050 9B18     		adds	r3, r3, r2
 1699 0052 1B79     		ldrb	r3, [r3, #4]
 1700 0054 0B2B     		cmp	r3, #11
 1701 0056 1BD0     		beq	.L177
1337:Src/usb_pd_protocol.c **** 			/* reset message ID and swap roles */
 1702              		.loc 1 1337 0
 1703 0058 1D2B     		cmp	r3, #29
 1704 005a 24D0     		beq	.L178
1352:Src/usb_pd_protocol.c **** 			/* Don't know what power source is ready. Reset. */
 1705              		.loc 1 1352 0
 1706 005c 052B     		cmp	r3, #5
 1707 005e 32D0     		beq	.L179
1355:Src/usb_pd_protocol.c **** 			/* Do nothing, assume this is a redundant PD_RDY */
 1708              		.loc 1 1355 0
 1709 0060 0C2B     		cmp	r3, #12
 1710 0062 F1D0     		beq	.L133
1357:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
 1711              		.loc 1 1357 0
 1712 0064 C301     		lsls	r3, r0, #7
 1713 0066 AF4A     		ldr	r2, .L200+4
 1714 0068 9B5C     		ldrb	r3, [r3, r2]
 1715 006a 002B     		cmp	r3, #0
 1716 006c ECD1     		bne	.L133
 1717              	.LVL152:
 1718              	.LBB284:
 1719              	.LBB285:
 1720              	.LBB286:
 1721              	.LBB287:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1722              		.loc 1 283 0
 1723 006e C201     		lsls	r2, r0, #7
 1724 0070 AC4B     		ldr	r3, .L200+4
ARM GAS  /tmp/ccWvVg6G.s 			page 71


 1725 0072 9B18     		adds	r3, r3, r2
 1726 0074 0020     		movs	r0, #0
 1727              	.LVL153:
 1728 0076 0021     		movs	r1, #0
 1729              	.LVL154:
 1730 0078 1861     		str	r0, [r3, #16]
 1731 007a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 1732              		.loc 1 284 0
 1733 007c 0022     		movs	r2, #0
 1734 007e DA71     		strb	r2, [r3, #7]
 1735              	.LVL155:
 1736              	.LBE287:
 1737              	.LBE286:
 352:Src/usb_pd_protocol.c **** 
 1738              		.loc 1 352 0
 1739 0080 0832     		adds	r2, r2, #8
 1740 0082 1A71     		strb	r2, [r3, #4]
 1741              	.LVL156:
 1742              	.LBE285:
 1743              	.LBE284:
1359:Src/usb_pd_protocol.c **** 						   pd[port].supply_voltage);
 1744              		.loc 1 1359 0
 1745 0084 5A6B     		ldr	r2, [r3, #52]
 1746 0086 196B     		ldr	r1, [r3, #48]
 1747 0088 2000     		movs	r0, r4
 1748 008a FFF7FEFF 		bl	pd_set_input_current_limit
 1749              	.LVL157:
 1750 008e DBE7     		b	.L133
 1751              	.LVL158:
 1752              	.L177:
 1753              	.LBB288:
 1754              	.LBB289:
 1755              	.LBB290:
 1756              	.LBB291:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1757              		.loc 1 283 0
 1758 0090 A44B     		ldr	r3, .L200+4
 1759 0092 9C18     		adds	r4, r3, r2
 1760 0094 0022     		movs	r2, #0
 1761 0096 0023     		movs	r3, #0
 1762 0098 2261     		str	r2, [r4, #16]
 1763 009a 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 1764              		.loc 1 284 0
 1765 009c 0023     		movs	r3, #0
 1766 009e E371     		strb	r3, [r4, #7]
 1767              	.LVL159:
 1768              	.LBE291:
 1769              	.LBE290:
 352:Src/usb_pd_protocol.c **** 
 1770              		.loc 1 352 0
 1771 00a0 0C33     		adds	r3, r3, #12
 1772 00a2 2371     		strb	r3, [r4, #4]
 1773 00a4 D0E7     		b	.L133
 1774              	.LVL160:
 1775              	.L178:
ARM GAS  /tmp/ccWvVg6G.s 			page 72


 1776              	.LBE289:
 1777              	.LBE288:
1339:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
 1778              		.loc 1 1339 0
 1779 00a6 9F4B     		ldr	r3, .L200+4
 1780 00a8 C201     		lsls	r2, r0, #7
 1781 00aa 9D18     		adds	r5, r3, r2
 1782 00ac 0026     		movs	r6, #0
 1783 00ae AE70     		strb	r6, [r5, #2]
1340:Src/usb_pd_protocol.c **** 			pd_update_roles(port);
 1784              		.loc 1 1340 0
 1785 00b0 D654     		strb	r6, [r2, r3]
1341:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
 1786              		.loc 1 1341 0
 1787 00b2 FFF7FEFF 		bl	pd_update_roles
 1788              	.LVL161:
 1789              	.LBB292:
 1790              	.LBB293:
 1791              	.LBB294:
 1792              	.LBB295:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1793              		.loc 1 283 0
 1794 00b6 0022     		movs	r2, #0
 1795 00b8 0023     		movs	r3, #0
 1796 00ba 2A61     		str	r2, [r5, #16]
 1797 00bc 6B61     		str	r3, [r5, #20]
 284:Src/usb_pd_protocol.c **** }
 1798              		.loc 1 284 0
 1799 00be EE71     		strb	r6, [r5, #7]
 1800              	.LVL162:
 1801              	.LBE295:
 1802              	.LBE294:
 352:Src/usb_pd_protocol.c **** 
 1803              		.loc 1 352 0
 1804 00c0 0523     		movs	r3, #5
 1805 00c2 2B71     		strb	r3, [r5, #4]
 1806 00c4 C0E7     		b	.L133
 1807              	.LVL163:
 1808              	.L179:
 1809              	.LBE293:
 1810              	.LBE292:
 1811              	.LBB296:
 1812              	.LBB297:
 1813              	.LBB298:
 1814              	.LBB299:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1815              		.loc 1 283 0
 1816 00c6 C401     		lsls	r4, r0, #7
 1817 00c8 964B     		ldr	r3, .L200+4
 1818 00ca 1C19     		adds	r4, r3, r4
 1819 00cc 0022     		movs	r2, #0
 1820 00ce 0023     		movs	r3, #0
 1821 00d0 2261     		str	r2, [r4, #16]
 1822 00d2 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 1823              		.loc 1 284 0
 1824 00d4 0023     		movs	r3, #0
ARM GAS  /tmp/ccWvVg6G.s 			page 73


 1825 00d6 E371     		strb	r3, [r4, #7]
 1826              	.LVL164:
 1827              	.LBE299:
 1828              	.LBE298:
 352:Src/usb_pd_protocol.c **** 
 1829              		.loc 1 352 0
 1830 00d8 1F33     		adds	r3, r3, #31
 1831 00da 2371     		strb	r3, [r4, #4]
 1832              	.LVL165:
 1833 00dc B4E7     		b	.L133
 1834              	.LVL166:
 1835              	.L137:
 1836              	.LBE297:
 1837              	.LBE296:
1372:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
 1838              		.loc 1 1372 0
 1839 00de C201     		lsls	r2, r0, #7
 1840 00e0 904B     		ldr	r3, .L200+4
 1841 00e2 9B18     		adds	r3, r3, r2
 1842 00e4 1B79     		ldrb	r3, [r3, #4]
 1843 00e6 192B     		cmp	r3, #25
 1844 00e8 19D0     		beq	.L180
1379:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 1845              		.loc 1 1379 0
 1846 00ea 1A2B     		cmp	r3, #26
 1847 00ec 53D0     		beq	.L181
1381:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
 1848              		.loc 1 1381 0
 1849 00ee 092B     		cmp	r3, #9
 1850 00f0 5DD0     		beq	.L182
1383:Src/usb_pd_protocol.c **** 			/*
 1851              		.loc 1 1383 0
 1852 00f2 062B     		cmp	r3, #6
 1853 00f4 A8D1     		bne	.L133
1399:Src/usb_pd_protocol.c **** 				/* We have an explicit contract */
 1854              		.loc 1 1399 0
 1855 00f6 C201     		lsls	r2, r0, #7
 1856 00f8 8A4B     		ldr	r3, .L200+4
 1857 00fa 9B18     		adds	r3, r3, r2
 1858 00fc 9B68     		ldr	r3, [r3, #8]
 1859 00fe 5B06     		lsls	r3, r3, #25
 1860 0100 75D5     		bpl	.L156
1401:Src/usb_pd_protocol.c **** 					/*
 1861              		.loc 1 1401 0
 1862 0102 0C29     		cmp	r1, #12
 1863 0104 5FD0     		beq	.L183
 1864              	.LVL167:
 1865              	.LBB300:
 1866              	.LBB301:
 1867              	.LBB302:
 1868              	.LBB303:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1869              		.loc 1 283 0
 1870 0106 C401     		lsls	r4, r0, #7
 1871 0108 864B     		ldr	r3, .L200+4
 1872 010a 1C19     		adds	r4, r3, r4
 1873 010c 0022     		movs	r2, #0
ARM GAS  /tmp/ccWvVg6G.s 			page 74


 1874 010e 0023     		movs	r3, #0
 1875 0110 2261     		str	r2, [r4, #16]
 1876 0112 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 1877              		.loc 1 284 0
 1878 0114 0023     		movs	r3, #0
 1879 0116 E371     		strb	r3, [r4, #7]
 1880              	.LVL168:
 1881              	.LBE303:
 1882              	.LBE302:
 352:Src/usb_pd_protocol.c **** 
 1883              		.loc 1 352 0
 1884 0118 0833     		adds	r3, r3, #8
 1885 011a 2371     		strb	r3, [r4, #4]
 1886              	.LVL169:
 1887 011c 94E7     		b	.L133
 1888              	.LVL170:
 1889              	.L180:
 1890              	.LBE301:
 1891              	.LBE300:
1373:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 1892              		.loc 1 1373 0
 1893 011e 1300     		movs	r3, r2
 1894 0120 804A     		ldr	r2, .L200+4
 1895 0122 9B5C     		ldrb	r3, [r3, r2]
 1896 0124 002B     		cmp	r3, #0
 1897 0126 2AD0     		beq	.L184
 1898 0128 1722     		movs	r2, #23
 1899              	.L149:
 1900              	.LVL171:
 1901              	.LBB304:
 1902              	.LBB305:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 1903              		.loc 1 346 0 discriminator 4
 1904 012a E101     		lsls	r1, r4, #7
 1905              	.LVL172:
 1906 012c 7D4B     		ldr	r3, .L200+4
 1907 012e 5B18     		adds	r3, r3, r1
 1908 0130 1D79     		ldrb	r5, [r3, #4]
 1909              	.LVL173:
 1910              	.LBB306:
 1911              	.LBB307:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1912              		.loc 1 283 0 discriminator 4
 1913 0132 0020     		movs	r0, #0
 1914              	.LVL174:
 1915 0134 0021     		movs	r1, #0
 1916 0136 1861     		str	r0, [r3, #16]
 1917 0138 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 1918              		.loc 1 284 0 discriminator 4
 1919 013a 0021     		movs	r1, #0
 1920 013c D971     		strb	r1, [r3, #7]
 1921              	.LVL175:
 1922              	.LBE307:
 1923              	.LBE306:
 352:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccWvVg6G.s 			page 75


 1924              		.loc 1 352 0 discriminator 4
 1925 013e 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 1926              		.loc 1 354 0 discriminator 4
 1927 0140 AA42     		cmp	r2, r5
 1928 0142 00D1     		bne	.LCB1973
 1929 0144 80E7     		b	.L133	@long jump
 1930              	.LCB1973:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 1931              		.loc 1 365 0
 1932 0146 022D     		cmp	r5, #2
 1933 0148 1BD0     		beq	.L185
 1934              	.L150:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 1935              		.loc 1 366 0
 1936 014a 0E2D     		cmp	r5, #14
 1937 014c 1CD0     		beq	.L186
 1938              	.L151:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 1939              		.loc 1 371 0
 1940 014e 0E2A     		cmp	r2, #14
 1941 0150 02D0     		beq	.L152
 1942 0152 022A     		cmp	r2, #2
 1943 0154 00D0     		beq	.LCB1984
 1944 0156 77E7     		b	.L133	@long jump
 1945              	.LCB1984:
 1946              	.L152:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1947              		.loc 1 374 0
 1948 0158 0022     		movs	r2, #0
 1949              	.LVL176:
 1950 015a 0021     		movs	r1, #0
 1951 015c 2000     		movs	r0, r4
 1952 015e FFF7FEFF 		bl	pd_set_input_current_limit
 1953              	.LVL177:
 391:Src/usb_pd_protocol.c **** 			/*
 1954              		.loc 1 391 0
 1955 0162 E301     		lsls	r3, r4, #7
 1956 0164 6F4A     		ldr	r2, .L200+4
 1957 0166 9B5C     		ldrb	r3, [r3, r2]
 1958 0168 012B     		cmp	r3, #1
 1959 016a 10D0     		beq	.L187
 1960              	.L153:
 1961              	.LVL178:
 1962              	.LBB308:
 1963              	.LBB309:
  92:Inc/tcpm.h    **** }
 1964              		.loc 2 92 0
 1965 016c 2201     		lsls	r2, r4, #4
 1966 016e 6E4B     		ldr	r3, .L200+8
 1967 0170 9B18     		adds	r3, r3, r2
 1968 0172 9B68     		ldr	r3, [r3, #8]
 1969 0174 5B6A     		ldr	r3, [r3, #36]
 1970 0176 0021     		movs	r1, #0
 1971 0178 2000     		movs	r0, r4
 1972 017a 9847     		blx	r3
 1973              	.LVL179:
ARM GAS  /tmp/ccWvVg6G.s 			page 76


 1974 017c 64E7     		b	.L133
 1975              	.LVL180:
 1976              	.L184:
 1977              	.LBE309:
 1978              	.LBE308:
 1979              	.LBE305:
 1980              	.LBE304:
1373:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 1981              		.loc 1 1373 0
 1982 017e 0822     		movs	r2, #8
 1983 0180 D3E7     		b	.L149
 1984              	.LVL181:
 1985              	.L185:
 1986              	.LBB311:
 1987              	.LBB310:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 1988              		.loc 1 365 0
 1989 0182 0E2A     		cmp	r2, #14
 1990 0184 E1D1     		bne	.L150
 1991 0186 5FE7     		b	.L133
 1992              	.L186:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 1993              		.loc 1 367 0
 1994 0188 022A     		cmp	r2, #2
 1995 018a E0D1     		bne	.L151
 1996 018c 5CE7     		b	.L133
 1997              	.LVL182:
 1998              	.L187:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 1999              		.loc 1 396 0
 2000 018e 2000     		movs	r0, r4
 2001 0190 FFF7FEFF 		bl	pd_power_supply_reset
 2002              	.LVL183:
 2003 0194 EAE7     		b	.L153
 2004              	.LVL184:
 2005              	.L181:
 2006              	.LBE310:
 2007              	.LBE311:
 2008              	.LBB312:
 2009              	.LBB313:
 2010              	.LBB314:
 2011              	.LBB315:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2012              		.loc 1 283 0
 2013 0196 C401     		lsls	r4, r0, #7
 2014 0198 624B     		ldr	r3, .L200+4
 2015 019a 1C19     		adds	r4, r3, r4
 2016 019c 0022     		movs	r2, #0
 2017 019e 0023     		movs	r3, #0
 2018 01a0 2261     		str	r2, [r4, #16]
 2019 01a2 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2020              		.loc 1 284 0
 2021 01a4 0023     		movs	r3, #0
 2022 01a6 E371     		strb	r3, [r4, #7]
 2023              	.LVL185:
 2024              	.LBE315:
ARM GAS  /tmp/ccWvVg6G.s 			page 77


 2025              	.LBE314:
 352:Src/usb_pd_protocol.c **** 
 2026              		.loc 1 352 0
 2027 01a8 1733     		adds	r3, r3, #23
 2028 01aa 2371     		strb	r3, [r4, #4]
 2029              	.LVL186:
 2030 01ac 4CE7     		b	.L133
 2031              	.LVL187:
 2032              	.L182:
 2033              	.LBE313:
 2034              	.LBE312:
 2035              	.LBB316:
 2036              	.LBB317:
 2037              	.LBB318:
 2038              	.LBB319:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2039              		.loc 1 283 0
 2040 01ae C401     		lsls	r4, r0, #7
 2041 01b0 5C4B     		ldr	r3, .L200+4
 2042 01b2 1C19     		adds	r4, r3, r4
 2043 01b4 0022     		movs	r2, #0
 2044 01b6 0023     		movs	r3, #0
 2045 01b8 2261     		str	r2, [r4, #16]
 2046 01ba 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2047              		.loc 1 284 0
 2048 01bc 0023     		movs	r3, #0
 2049 01be E371     		strb	r3, [r4, #7]
 2050              	.LVL188:
 2051              	.LBE319:
 2052              	.LBE318:
 352:Src/usb_pd_protocol.c **** 
 2053              		.loc 1 352 0
 2054 01c0 0833     		adds	r3, r3, #8
 2055 01c2 2371     		strb	r3, [r4, #4]
 2056              	.LVL189:
 2057 01c4 40E7     		b	.L133
 2058              	.LVL190:
 2059              	.L183:
 2060              	.LBE317:
 2061              	.LBE316:
1406:Src/usb_pd_protocol.c **** 
 2062              		.loc 1 1406 0
 2063 01c6 574B     		ldr	r3, .L200+4
 2064 01c8 9C18     		adds	r4, r3, r2
 2065 01ca 0123     		movs	r3, #1
 2066 01cc A363     		str	r3, [r4, #56]
1412:Src/usb_pd_protocol.c **** 
 2067              		.loc 1 1412 0
 2068 01ce 0023     		movs	r3, #0
 2069 01d0 E363     		str	r3, [r4, #60]
1418:Src/usb_pd_protocol.c **** 							PD_T_SINK_REQUEST,
 2070              		.loc 1 1418 0
 2071 01d2 6846     		mov	r0, sp
 2072              	.LVL191:
 2073 01d4 FFF7FEFF 		bl	get_time
 2074              	.LVL192:
ARM GAS  /tmp/ccWvVg6G.s 			page 78


 2075 01d8 544A     		ldr	r2, .L200+12
 2076 01da 0023     		movs	r3, #0
 2077 01dc 0098     		ldr	r0, [sp]
 2078 01de 0199     		ldr	r1, [sp, #4]
 2079 01e0 1218     		adds	r2, r2, r0
 2080 01e2 4B41     		adcs	r3, r3, r1
 2081              	.LVL193:
 2082              	.LBB320:
 2083              	.LBB321:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2084              		.loc 1 283 0
 2085 01e4 2261     		str	r2, [r4, #16]
 2086 01e6 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2087              		.loc 1 284 0
 2088 01e8 0823     		movs	r3, #8
 2089 01ea E371     		strb	r3, [r4, #7]
 2090 01ec 2CE7     		b	.L133
 2091              	.LVL194:
 2092              	.L156:
 2093              	.LBE321:
 2094              	.LBE320:
 2095              	.LBB322:
 2096              	.LBB323:
 2097              	.LBB324:
 2098              	.LBB325:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2099              		.loc 1 283 0
 2100 01ee C401     		lsls	r4, r0, #7
 2101 01f0 4C4B     		ldr	r3, .L200+4
 2102 01f2 1C19     		adds	r4, r3, r4
 2103 01f4 0022     		movs	r2, #0
 2104 01f6 0023     		movs	r3, #0
 2105 01f8 2261     		str	r2, [r4, #16]
 2106 01fa 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2107              		.loc 1 284 0
 2108 01fc 0023     		movs	r3, #0
 2109 01fe E371     		strb	r3, [r4, #7]
 2110              	.LVL195:
 2111              	.LBE325:
 2112              	.LBE324:
 352:Src/usb_pd_protocol.c **** 
 2113              		.loc 1 352 0
 2114 0200 0533     		adds	r3, r3, #5
 2115 0202 2371     		strb	r3, [r4, #4]
 2116              	.LVL196:
 2117 0204 20E7     		b	.L133
 2118              	.LVL197:
 2119              	.L135:
 2120              	.LBE323:
 2121              	.LBE322:
1433:Src/usb_pd_protocol.c **** 			/*
 2122              		.loc 1 1433 0
 2123 0206 C201     		lsls	r2, r0, #7
 2124 0208 464B     		ldr	r3, .L200+4
 2125 020a 9B18     		adds	r3, r3, r2
ARM GAS  /tmp/ccWvVg6G.s 			page 79


 2126 020c 1B79     		ldrb	r3, [r3, #4]
 2127 020e 1E2B     		cmp	r3, #30
 2128 0210 18D0     		beq	.L188
1440:Src/usb_pd_protocol.c **** 			/* switch data role */
 2129              		.loc 1 1440 0
 2130 0212 192B     		cmp	r3, #25
 2131 0214 1FD0     		beq	.L189
1450:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
 2132              		.loc 1 1450 0
 2133 0216 1A2B     		cmp	r3, #26
 2134 0218 5BD0     		beq	.L190
1454:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
 2135              		.loc 1 1454 0
 2136 021a 092B     		cmp	r3, #9
 2137 021c 69D0     		beq	.L191
1458:Src/usb_pd_protocol.c **** 			/* explicit contract is now in place */
 2138              		.loc 1 1458 0
 2139 021e 062B     		cmp	r3, #6
 2140 0220 00D0     		beq	.LCB2225
 2141 0222 11E7     		b	.L133	@long jump
 2142              	.LCB2225:
1460:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
 2143              		.loc 1 1460 0
 2144 0224 C401     		lsls	r4, r0, #7
 2145 0226 3F4B     		ldr	r3, .L200+4
 2146 0228 1C19     		adds	r4, r3, r4
 2147 022a 4023     		movs	r3, #64
 2148 022c A268     		ldr	r2, [r4, #8]
 2149 022e 1343     		orrs	r3, r2
 2150 0230 A360     		str	r3, [r4, #8]
 2151              	.LVL198:
 2152              	.LBB326:
 2153              	.LBB327:
 2154              	.LBB328:
 2155              	.LBB329:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2156              		.loc 1 283 0
 2157 0232 0022     		movs	r2, #0
 2158 0234 0023     		movs	r3, #0
 2159 0236 2261     		str	r2, [r4, #16]
 2160 0238 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2161              		.loc 1 284 0
 2162 023a 0023     		movs	r3, #0
 2163 023c E371     		strb	r3, [r4, #7]
 2164              	.LVL199:
 2165              	.LBE329:
 2166              	.LBE328:
 352:Src/usb_pd_protocol.c **** 
 2167              		.loc 1 352 0
 2168 023e 0733     		adds	r3, r3, #7
 2169 0240 2371     		strb	r3, [r4, #4]
 2170              	.LVL200:
 2171 0242 01E7     		b	.L133
 2172              	.LVL201:
 2173              	.L188:
 2174              	.LBE327:
ARM GAS  /tmp/ccWvVg6G.s 			page 80


 2175              	.LBE326:
1438:Src/usb_pd_protocol.c **** 			execute_soft_reset(port);
 2176              		.loc 1 1438 0
 2177 0244 374B     		ldr	r3, .L200+4
 2178 0246 9B18     		adds	r3, r3, r2
 2179 0248 8022     		movs	r2, #128
 2180 024a 9968     		ldr	r1, [r3, #8]
 2181              	.LVL202:
 2182 024c 9143     		bics	r1, r2
 2183 024e 9960     		str	r1, [r3, #8]
1439:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_DR_SWAP) {
 2184              		.loc 1 1439 0
 2185 0250 FFF7FEFF 		bl	execute_soft_reset
 2186              	.LVL203:
 2187 0254 F8E6     		b	.L133
 2188              	.LVL204:
 2189              	.L189:
1442:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
 2190              		.loc 1 1442 0
 2191 0256 FFF7FEFF 		bl	pd_dr_swap
 2192              	.LVL205:
1443:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 2193              		.loc 1 1443 0
 2194 025a E301     		lsls	r3, r4, #7
 2195 025c 314A     		ldr	r2, .L200+4
 2196 025e 9B5C     		ldrb	r3, [r3, r2]
 2197 0260 002B     		cmp	r3, #0
 2198 0262 2AD0     		beq	.L192
 2199 0264 1722     		movs	r2, #23
 2200              	.L160:
 2201              	.LVL206:
 2202              	.LBB330:
 2203              	.LBB331:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2204              		.loc 1 346 0 discriminator 4
 2205 0266 E101     		lsls	r1, r4, #7
 2206 0268 2E4B     		ldr	r3, .L200+4
 2207 026a 5B18     		adds	r3, r3, r1
 2208 026c 1D79     		ldrb	r5, [r3, #4]
 2209              	.LVL207:
 2210              	.LBB332:
 2211              	.LBB333:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2212              		.loc 1 283 0 discriminator 4
 2213 026e 0020     		movs	r0, #0
 2214 0270 0021     		movs	r1, #0
 2215 0272 1861     		str	r0, [r3, #16]
 2216 0274 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 2217              		.loc 1 284 0 discriminator 4
 2218 0276 0021     		movs	r1, #0
 2219 0278 D971     		strb	r1, [r3, #7]
 2220              	.LVL208:
 2221              	.LBE333:
 2222              	.LBE332:
 352:Src/usb_pd_protocol.c **** 
 2223              		.loc 1 352 0 discriminator 4
ARM GAS  /tmp/ccWvVg6G.s 			page 81


 2224 027a 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 2225              		.loc 1 354 0 discriminator 4
 2226 027c AA42     		cmp	r2, r5
 2227 027e 00D1     		bne	.LCB2322
 2228 0280 E2E6     		b	.L133	@long jump
 2229              	.LCB2322:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2230              		.loc 1 365 0
 2231 0282 022D     		cmp	r5, #2
 2232 0284 1BD0     		beq	.L193
 2233              	.L161:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 2234              		.loc 1 366 0
 2235 0286 0E2D     		cmp	r5, #14
 2236 0288 1CD0     		beq	.L194
 2237              	.L162:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2238              		.loc 1 371 0
 2239 028a 0E2A     		cmp	r2, #14
 2240 028c 02D0     		beq	.L163
 2241 028e 022A     		cmp	r2, #2
 2242 0290 00D0     		beq	.LCB2333
 2243 0292 D9E6     		b	.L133	@long jump
 2244              	.LCB2333:
 2245              	.L163:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 2246              		.loc 1 374 0
 2247 0294 0022     		movs	r2, #0
 2248              	.LVL209:
 2249 0296 0021     		movs	r1, #0
 2250 0298 2000     		movs	r0, r4
 2251 029a FFF7FEFF 		bl	pd_set_input_current_limit
 2252              	.LVL210:
 391:Src/usb_pd_protocol.c **** 			/*
 2253              		.loc 1 391 0
 2254 029e E301     		lsls	r3, r4, #7
 2255 02a0 204A     		ldr	r2, .L200+4
 2256 02a2 9B5C     		ldrb	r3, [r3, r2]
 2257 02a4 012B     		cmp	r3, #1
 2258 02a6 10D0     		beq	.L195
 2259              	.L164:
 2260              	.LVL211:
 2261              	.LBB334:
 2262              	.LBB335:
  92:Inc/tcpm.h    **** }
 2263              		.loc 2 92 0
 2264 02a8 2201     		lsls	r2, r4, #4
 2265 02aa 1F4B     		ldr	r3, .L200+8
 2266 02ac 9B18     		adds	r3, r3, r2
 2267 02ae 9B68     		ldr	r3, [r3, #8]
 2268 02b0 5B6A     		ldr	r3, [r3, #36]
 2269 02b2 0021     		movs	r1, #0
 2270 02b4 2000     		movs	r0, r4
 2271 02b6 9847     		blx	r3
 2272              	.LVL212:
 2273 02b8 C6E6     		b	.L133
ARM GAS  /tmp/ccWvVg6G.s 			page 82


 2274              	.LVL213:
 2275              	.L192:
 2276              	.LBE335:
 2277              	.LBE334:
 2278              	.LBE331:
 2279              	.LBE330:
1443:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 2280              		.loc 1 1443 0
 2281 02ba 0822     		movs	r2, #8
 2282 02bc D3E7     		b	.L160
 2283              	.LVL214:
 2284              	.L193:
 2285              	.LBB337:
 2286              	.LBB336:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2287              		.loc 1 365 0
 2288 02be 0E2A     		cmp	r2, #14
 2289 02c0 E1D1     		bne	.L161
 2290 02c2 C1E6     		b	.L133
 2291              	.L194:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 2292              		.loc 1 367 0
 2293 02c4 022A     		cmp	r2, #2
 2294 02c6 E0D1     		bne	.L162
 2295 02c8 BEE6     		b	.L133
 2296              	.LVL215:
 2297              	.L195:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 2298              		.loc 1 396 0
 2299 02ca 2000     		movs	r0, r4
 2300 02cc FFF7FEFF 		bl	pd_power_supply_reset
 2301              	.LVL216:
 2302 02d0 EAE7     		b	.L164
 2303              	.LVL217:
 2304              	.L190:
 2305              	.LBE336:
 2306              	.LBE337:
1452:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_SWAP_SNK_DISABLE);
 2307              		.loc 1 1452 0
 2308 02d2 C401     		lsls	r4, r0, #7
 2309 02d4 134B     		ldr	r3, .L200+4
 2310 02d6 1C19     		adds	r4, r3, r4
 2311 02d8 4023     		movs	r3, #64
 2312 02da A268     		ldr	r2, [r4, #8]
 2313 02dc 9A43     		bics	r2, r3
 2314 02de A260     		str	r2, [r4, #8]
 2315              	.LVL218:
 2316              	.LBB338:
 2317              	.LBB339:
 2318              	.LBB340:
 2319              	.LBB341:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2320              		.loc 1 283 0
 2321 02e0 0022     		movs	r2, #0
 2322 02e2 0023     		movs	r3, #0
 2323 02e4 2261     		str	r2, [r4, #16]
 2324 02e6 6361     		str	r3, [r4, #20]
ARM GAS  /tmp/ccWvVg6G.s 			page 83


 284:Src/usb_pd_protocol.c **** }
 2325              		.loc 1 284 0
 2326 02e8 0023     		movs	r3, #0
 2327 02ea E371     		strb	r3, [r4, #7]
 2328              	.LVL219:
 2329              	.LBE341:
 2330              	.LBE340:
 352:Src/usb_pd_protocol.c **** 
 2331              		.loc 1 352 0
 2332 02ec 1B33     		adds	r3, r3, #27
 2333 02ee 2371     		strb	r3, [r4, #4]
 2334              	.LVL220:
 2335 02f0 AAE6     		b	.L133
 2336              	.LVL221:
 2337              	.L191:
 2338              	.LBE339:
 2339              	.LBE338:
1456:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_SNK_DISABLE);
 2340              		.loc 1 1456 0
 2341 02f2 C401     		lsls	r4, r0, #7
 2342 02f4 0B4B     		ldr	r3, .L200+4
 2343 02f6 1C19     		adds	r4, r3, r4
 2344 02f8 4023     		movs	r3, #64
 2345 02fa A268     		ldr	r2, [r4, #8]
 2346 02fc 9A43     		bics	r2, r3
 2347 02fe A260     		str	r2, [r4, #8]
 2348              	.LVL222:
 2349              	.LBB342:
 2350              	.LBB343:
 2351              	.LBB344:
 2352              	.LBB345:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2353              		.loc 1 283 0
 2354 0300 0022     		movs	r2, #0
 2355 0302 0023     		movs	r3, #0
 2356 0304 2261     		str	r2, [r4, #16]
 2357 0306 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2358              		.loc 1 284 0
 2359 0308 0023     		movs	r3, #0
 2360 030a E371     		strb	r3, [r4, #7]
 2361              	.LVL223:
 2362              	.LBE345:
 2363              	.LBE344:
 352:Src/usb_pd_protocol.c **** 
 2364              		.loc 1 352 0
 2365 030c 0A33     		adds	r3, r3, #10
 2366 030e 2371     		strb	r3, [r4, #4]
 2367              	.LVL224:
 2368 0310 9AE6     		b	.L133
 2369              	.LVL225:
 2370              	.L144:
 2371              	.LBE343:
 2372              	.LBE342:
1469:Src/usb_pd_protocol.c **** 		/* We are done, acknowledge with an Accept packet */
 2373              		.loc 1 1469 0
 2374 0312 FFF7FEFF 		bl	execute_soft_reset
ARM GAS  /tmp/ccWvVg6G.s 			page 84


 2375              	.LVL226:
1471:Src/usb_pd_protocol.c **** 		break;
 2376              		.loc 1 1471 0
 2377 0316 0321     		movs	r1, #3
 2378 0318 2000     		movs	r0, r4
 2379 031a FFF7FEFF 		bl	send_control
 2380              	.LVL227:
1472:Src/usb_pd_protocol.c **** 	case PD_CTRL_PR_SWAP:
 2381              		.loc 1 1472 0
 2382 031e 93E6     		b	.L133
 2383              	.L201:
 2384              		.align	2
 2385              	.L200:
 2386 0320 00000000 		.word	.L136
 2387 0324 00000000 		.word	pd
 2388 0328 00000000 		.word	tcpc_config
 2389 032c A0860100 		.word	100000
 2390              	.LVL228:
 2391              	.L142:
1475:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_ACCEPT);
 2392              		.loc 1 1475 0
 2393 0330 FFF7FEFF 		bl	pd_check_power_swap
 2394              	.LVL229:
 2395 0334 0028     		cmp	r0, #0
 2396 0336 44D0     		beq	.L167
1476:Src/usb_pd_protocol.c **** 			/*
 2397              		.loc 1 1476 0
 2398 0338 0321     		movs	r1, #3
 2399 033a 2000     		movs	r0, r4
 2400 033c FFF7FEFF 		bl	send_control
 2401              	.LVL230:
1481:Src/usb_pd_protocol.c **** 			set_state(port,
 2402              		.loc 1 1481 0
 2403 0340 344A     		ldr	r2, .L202
 2404 0342 E101     		lsls	r1, r4, #7
 2405 0344 5018     		adds	r0, r2, r1
 2406 0346 344B     		ldr	r3, .L202+4
 2407 0348 8568     		ldr	r5, [r0, #8]
 2408 034a 2B40     		ands	r3, r5
 2409 034c 8360     		str	r3, [r0, #8]
1483:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_SWAP_SNK_DISABLE,
 2410              		.loc 1 1483 0
 2411 034e 8B5C     		ldrb	r3, [r1, r2]
1482:Src/usb_pd_protocol.c **** 				  DUAL_ROLE_IF_ELSE(port,
 2412              		.loc 1 1482 0
 2413 0350 002B     		cmp	r3, #0
 2414 0352 2AD0     		beq	.L196
 2415 0354 1B22     		movs	r2, #27
 2416              	.L168:
 2417              	.LVL231:
 2418              	.LBB346:
 2419              	.LBB347:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2420              		.loc 1 346 0 discriminator 4
 2421 0356 E101     		lsls	r1, r4, #7
 2422 0358 2E4B     		ldr	r3, .L202
 2423 035a 5B18     		adds	r3, r3, r1
ARM GAS  /tmp/ccWvVg6G.s 			page 85


 2424 035c 1D79     		ldrb	r5, [r3, #4]
 2425              	.LVL232:
 2426              	.LBB348:
 2427              	.LBB349:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2428              		.loc 1 283 0 discriminator 4
 2429 035e 0020     		movs	r0, #0
 2430 0360 0021     		movs	r1, #0
 2431 0362 1861     		str	r0, [r3, #16]
 2432 0364 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 2433              		.loc 1 284 0 discriminator 4
 2434 0366 0021     		movs	r1, #0
 2435 0368 D971     		strb	r1, [r3, #7]
 2436              	.LVL233:
 2437              	.LBE349:
 2438              	.LBE348:
 352:Src/usb_pd_protocol.c **** 
 2439              		.loc 1 352 0 discriminator 4
 2440 036a 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 2441              		.loc 1 354 0 discriminator 4
 2442 036c AA42     		cmp	r2, r5
 2443 036e 00D1     		bne	.LCB2571
 2444 0370 6AE6     		b	.L133	@long jump
 2445              	.LCB2571:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2446              		.loc 1 365 0
 2447 0372 022D     		cmp	r5, #2
 2448 0374 1BD0     		beq	.L197
 2449              	.L169:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 2450              		.loc 1 366 0
 2451 0376 0E2D     		cmp	r5, #14
 2452 0378 1CD0     		beq	.L198
 2453              	.L170:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2454              		.loc 1 371 0
 2455 037a 0E2A     		cmp	r2, #14
 2456 037c 02D0     		beq	.L171
 2457 037e 022A     		cmp	r2, #2
 2458 0380 00D0     		beq	.LCB2582
 2459 0382 61E6     		b	.L133	@long jump
 2460              	.LCB2582:
 2461              	.L171:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 2462              		.loc 1 374 0
 2463 0384 0022     		movs	r2, #0
 2464              	.LVL234:
 2465 0386 0021     		movs	r1, #0
 2466 0388 2000     		movs	r0, r4
 2467 038a FFF7FEFF 		bl	pd_set_input_current_limit
 2468              	.LVL235:
 391:Src/usb_pd_protocol.c **** 			/*
 2469              		.loc 1 391 0
 2470 038e E301     		lsls	r3, r4, #7
 2471 0390 204A     		ldr	r2, .L202
ARM GAS  /tmp/ccWvVg6G.s 			page 86


 2472 0392 9B5C     		ldrb	r3, [r3, r2]
 2473 0394 012B     		cmp	r3, #1
 2474 0396 10D0     		beq	.L199
 2475              	.L172:
 2476              	.LVL236:
 2477              	.LBB350:
 2478              	.LBB351:
  92:Inc/tcpm.h    **** }
 2479              		.loc 2 92 0
 2480 0398 2201     		lsls	r2, r4, #4
 2481 039a 204B     		ldr	r3, .L202+8
 2482 039c 9B18     		adds	r3, r3, r2
 2483 039e 9B68     		ldr	r3, [r3, #8]
 2484 03a0 5B6A     		ldr	r3, [r3, #36]
 2485 03a2 0021     		movs	r1, #0
 2486 03a4 2000     		movs	r0, r4
 2487 03a6 9847     		blx	r3
 2488              	.LVL237:
 2489 03a8 4EE6     		b	.L133
 2490              	.LVL238:
 2491              	.L196:
 2492              	.LBE351:
 2493              	.LBE350:
 2494              	.LBE347:
 2495              	.LBE346:
1482:Src/usb_pd_protocol.c **** 				  DUAL_ROLE_IF_ELSE(port,
 2496              		.loc 1 1482 0
 2497 03aa 0A22     		movs	r2, #10
 2498 03ac D3E7     		b	.L168
 2499              	.LVL239:
 2500              	.L197:
 2501              	.LBB353:
 2502              	.LBB352:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2503              		.loc 1 365 0
 2504 03ae 0E2A     		cmp	r2, #14
 2505 03b0 E1D1     		bne	.L169
 2506 03b2 49E6     		b	.L133
 2507              	.L198:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 2508              		.loc 1 367 0
 2509 03b4 022A     		cmp	r2, #2
 2510 03b6 E0D1     		bne	.L170
 2511 03b8 46E6     		b	.L133
 2512              	.LVL240:
 2513              	.L199:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 2514              		.loc 1 396 0
 2515 03ba 2000     		movs	r0, r4
 2516 03bc FFF7FEFF 		bl	pd_power_supply_reset
 2517              	.LVL241:
 2518 03c0 EAE7     		b	.L172
 2519              	.LVL242:
 2520              	.L167:
 2521              	.LBE352:
 2522              	.LBE353:
1487:Src/usb_pd_protocol.c **** 		}
ARM GAS  /tmp/ccWvVg6G.s 			page 87


 2523              		.loc 1 1487 0
 2524 03c2 0421     		movs	r1, #4
 2525 03c4 2000     		movs	r0, r4
 2526 03c6 FFF7FEFF 		bl	send_control
 2527              	.LVL243:
 2528 03ca 3DE6     		b	.L133
 2529              	.LVL244:
 2530              	.L141:
1494:Src/usb_pd_protocol.c **** 			/*
 2531              		.loc 1 1494 0
 2532 03cc C201     		lsls	r2, r0, #7
 2533 03ce 114B     		ldr	r3, .L202
 2534 03d0 9B18     		adds	r3, r3, r2
 2535 03d2 5978     		ldrb	r1, [r3, #1]
 2536              	.LVL245:
 2537 03d4 FFF7FEFF 		bl	pd_check_data_swap
 2538              	.LVL246:
 2539 03d8 0028     		cmp	r0, #0
 2540 03da 11D0     		beq	.L173
1500:Src/usb_pd_protocol.c **** 			if (send_control(port, PD_CTRL_ACCEPT) >= 0)
 2541              		.loc 1 1500 0
 2542 03dc E201     		lsls	r2, r4, #7
 2543 03de 0D4B     		ldr	r3, .L202
 2544 03e0 9B18     		adds	r3, r3, r2
 2545 03e2 0F4A     		ldr	r2, .L202+12
 2546 03e4 9968     		ldr	r1, [r3, #8]
 2547 03e6 0A40     		ands	r2, r1
 2548 03e8 9A60     		str	r2, [r3, #8]
1501:Src/usb_pd_protocol.c **** 				pd_dr_swap(port);
 2549              		.loc 1 1501 0
 2550 03ea 0321     		movs	r1, #3
 2551 03ec 2000     		movs	r0, r4
 2552 03ee FFF7FEFF 		bl	send_control
 2553              	.LVL247:
 2554 03f2 0028     		cmp	r0, #0
 2555 03f4 00DA     		bge	.LCB2697
 2556 03f6 27E6     		b	.L133	@long jump
 2557              	.LCB2697:
1502:Src/usb_pd_protocol.c **** 		} else {
 2558              		.loc 1 1502 0
 2559 03f8 2000     		movs	r0, r4
 2560 03fa FFF7FEFF 		bl	pd_dr_swap
 2561              	.LVL248:
 2562 03fe 23E6     		b	.L133
 2563              	.L173:
1504:Src/usb_pd_protocol.c **** 
 2564              		.loc 1 1504 0
 2565 0400 0421     		movs	r1, #4
 2566 0402 2000     		movs	r0, r4
 2567 0404 FFF7FEFF 		bl	send_control
 2568              	.LVL249:
 2569 0408 1EE6     		b	.L133
 2570              	.LVL250:
 2571              	.L143:
1521:Src/usb_pd_protocol.c **** #endif
 2572              		.loc 1 1521 0
 2573 040a 0421     		movs	r1, #4
ARM GAS  /tmp/ccWvVg6G.s 			page 88


 2574              	.LVL251:
 2575 040c FFF7FEFF 		bl	send_control
 2576              	.LVL252:
1530:Src/usb_pd_protocol.c **** 
 2577              		.loc 1 1530 0
 2578 0410 1AE6     		b	.L133
 2579              	.L203:
 2580 0412 C046     		.align	2
 2581              	.L202:
 2582 0414 00000000 		.word	pd
 2583 0418 FFFDFFFF 		.word	-513
 2584 041c 00000000 		.word	tcpc_config
 2585 0420 FFFBFFFF 		.word	-1025
 2586              		.cfi_endproc
 2587              	.LFE45:
 2589              		.section	.text.handle_data_request,"ax",%progbits
 2590              		.align	1
 2591              		.syntax unified
 2592              		.code	16
 2593              		.thumb_func
 2594              		.fpu softvfp
 2596              	handle_data_request:
 2597              	.LFB40:
1099:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
 2598              		.loc 1 1099 0
 2599              		.cfi_startproc
 2600              		@ args = 0, pretend = 0, frame = 0
 2601              		@ frame_needed = 0, uses_anonymous_args = 0
 2602              	.LVL253:
 2603 0000 70B5     		push	{r4, r5, r6, lr}
 2604              	.LCFI21:
 2605              		.cfi_def_cfa_offset 16
 2606              		.cfi_offset 4, -16
 2607              		.cfi_offset 5, -12
 2608              		.cfi_offset 6, -8
 2609              		.cfi_offset 14, -4
 2610 0002 0400     		movs	r4, r0
 2611 0004 1600     		movs	r6, r2
 2612              	.LVL254:
1101:Src/usb_pd_protocol.c **** 
 2613              		.loc 1 1101 0
 2614 0006 0B0B     		lsrs	r3, r1, #12
 2615 0008 0725     		movs	r5, #7
 2616 000a 1D40     		ands	r5, r3
 2617              	.LVL255:
1103:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 2618              		.loc 1 1103 0
 2619 000c 0F23     		movs	r3, #15
 2620 000e 1940     		ands	r1, r3
 2621              	.LVL256:
 2622 0010 8900     		lsls	r1, r1, #2
 2623 0012 6D4B     		ldr	r3, .L227
 2624 0014 5B58     		ldr	r3, [r3, r1]
 2625 0016 9F46     		mov	pc, r3
 2626              		.section	.rodata.handle_data_request,"a",%progbits
 2627              		.align	2
 2628              	.L207:
ARM GAS  /tmp/ccWvVg6G.s 			page 89


 2629 0000 C6010000 		.word	.L204
 2630 0004 18000000 		.word	.L206
 2631 0008 64000000 		.word	.L208
 2632 000c D6000000 		.word	.L209
 2633 0010 8E010000 		.word	.L210
 2634 0014 C6010000 		.word	.L204
 2635 0018 C6010000 		.word	.L204
 2636 001c C6010000 		.word	.L204
 2637 0020 C6010000 		.word	.L204
 2638 0024 C6010000 		.word	.L204
 2639 0028 C6010000 		.word	.L204
 2640 002c C6010000 		.word	.L204
 2641 0030 C6010000 		.word	.L204
 2642 0034 C6010000 		.word	.L204
 2643 0038 C6010000 		.word	.L204
 2644 003c C0010000 		.word	.L211
 2645              		.section	.text.handle_data_request
 2646              	.L206:
1106:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_TRANSITION)
 2647              		.loc 1 1106 0
 2648 0018 C201     		lsls	r2, r0, #7
 2649              	.LVL257:
 2650 001a 6C4B     		ldr	r3, .L227+4
 2651 001c 9B18     		adds	r3, r3, r2
 2652 001e 1B79     		ldrb	r3, [r3, #4]
 2653 0020 052B     		cmp	r3, #5
 2654 0022 04D0     		beq	.L212
1107:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_NONE
 2655              		.loc 1 1107 0
 2656 0024 072B     		cmp	r3, #7
 2657 0026 02D0     		beq	.L212
1112:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 2658              		.loc 1 1112 0
 2659 0028 082B     		cmp	r3, #8
 2660 002a 00D0     		beq	.LCB2783
 2661 002c CBE0     		b	.L204	@long jump
 2662              	.LCB2783:
 2663              	.L212:
1121:Src/usb_pd_protocol.c **** 
 2664              		.loc 1 1121 0
 2665 002e E201     		lsls	r2, r4, #7
 2666 0030 664B     		ldr	r3, .L227+4
 2667 0032 9B18     		adds	r3, r3, r2
 2668 0034 8022     		movs	r2, #128
 2669 0036 5200     		lsls	r2, r2, #1
 2670 0038 9968     		ldr	r1, [r3, #8]
 2671 003a 0A43     		orrs	r2, r1
 2672 003c 9A60     		str	r2, [r3, #8]
1124:Src/usb_pd_protocol.c **** 
 2673              		.loc 1 1124 0
 2674 003e 3168     		ldr	r1, [r6]
 2675 0040 2000     		movs	r0, r4
 2676              	.LVL258:
 2677 0042 FFF7FEFF 		bl	pd_update_pdo_flags
 2678              	.LVL259:
1126:Src/usb_pd_protocol.c **** 			pd_process_source_cap_callback(port, cnt, payload);
 2679              		.loc 1 1126 0
ARM GAS  /tmp/ccWvVg6G.s 			page 90


 2680 0046 3200     		movs	r2, r6
 2681 0048 2900     		movs	r1, r5
 2682 004a 2000     		movs	r0, r4
 2683 004c FFF7FEFF 		bl	pd_process_source_cap
 2684              	.LVL260:
1127:Src/usb_pd_protocol.c **** 
 2685              		.loc 1 1127 0
 2686 0050 3200     		movs	r2, r6
 2687 0052 2900     		movs	r1, r5
 2688 0054 2000     		movs	r0, r4
 2689 0056 FFF7FEFF 		bl	pd_process_source_cap_callback
 2690              	.LVL261:
1130:Src/usb_pd_protocol.c **** 		}
 2691              		.loc 1 1130 0
 2692 005a 0121     		movs	r1, #1
 2693 005c 2000     		movs	r0, r4
 2694 005e FFF7FEFF 		bl	pd_send_request_msg
 2695              	.LVL262:
 2696 0062 B0E0     		b	.L204
 2697              	.LVL263:
 2698              	.L208:
1135:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 2699              		.loc 1 1135 0
 2700 0064 C301     		lsls	r3, r0, #7
 2701 0066 594A     		ldr	r2, .L227+4
 2702              	.LVL264:
 2703 0068 9B5C     		ldrb	r3, [r3, r2]
 2704 006a 012B     		cmp	r3, #1
 2705 006c 01D1     		bne	.L213
1135:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 2706              		.loc 1 1135 0 is_stmt 0 discriminator 1
 2707 006e 012D     		cmp	r5, #1
 2708 0070 0FD0     		beq	.L222
 2709              	.LVL265:
 2710              	.L213:
1174:Src/usb_pd_protocol.c **** 		/* keep last contract in place (whether implicit or explicit) */
 2711              		.loc 1 1174 0 is_stmt 1
 2712 0072 0421     		movs	r1, #4
 2713 0074 2000     		movs	r0, r4
 2714 0076 FFF7FEFF 		bl	send_control
 2715              	.LVL266:
 2716              	.LBB378:
 2717              	.LBB379:
 2718              	.LBB380:
 2719              	.LBB381:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2720              		.loc 1 283 0
 2721 007a E401     		lsls	r4, r4, #7
 2722              	.LVL267:
 2723 007c 534B     		ldr	r3, .L227+4
 2724 007e 1C19     		adds	r4, r3, r4
 2725 0080 0022     		movs	r2, #0
 2726 0082 0023     		movs	r3, #0
 2727 0084 2261     		str	r2, [r4, #16]
 2728 0086 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2729              		.loc 1 284 0
ARM GAS  /tmp/ccWvVg6G.s 			page 91


 2730 0088 0023     		movs	r3, #0
 2731 008a E371     		strb	r3, [r4, #7]
 2732              	.LVL268:
 2733              	.LBE381:
 2734              	.LBE380:
 352:Src/usb_pd_protocol.c **** 
 2735              		.loc 1 352 0
 2736 008c 1733     		adds	r3, r3, #23
 2737 008e 2371     		strb	r3, [r4, #4]
 2738              	.LVL269:
 2739 0090 99E0     		b	.L204
 2740              	.LVL270:
 2741              	.L222:
 2742              	.LBE379:
 2743              	.LBE378:
1143:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
 2744              		.loc 1 1143 0
 2745 0092 0100     		movs	r1, r0
 2746 0094 3068     		ldr	r0, [r6]
 2747              	.LVL271:
 2748 0096 FFF7FEFF 		bl	pd_check_requested_voltage
 2749              	.LVL272:
 2750 009a 0028     		cmp	r0, #0
 2751 009c E9D1     		bne	.L213
1144:Src/usb_pd_protocol.c **** 					/*
 2752              		.loc 1 1144 0
 2753 009e 0321     		movs	r1, #3
 2754 00a0 2000     		movs	r0, r4
 2755 00a2 FFF7FEFF 		bl	send_control
 2756              	.LVL273:
 2757 00a6 0028     		cmp	r0, #0
 2758 00a8 00DA     		bge	.LCB2888
 2759 00aa 8CE0     		b	.L204	@long jump
 2760              	.LCB2888:
1153:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 2761              		.loc 1 1153 0
 2762 00ac E401     		lsls	r4, r4, #7
 2763              	.LVL274:
 2764 00ae 474B     		ldr	r3, .L227+4
 2765 00b0 1C19     		adds	r4, r3, r4
 2766 00b2 4023     		movs	r3, #64
 2767 00b4 A268     		ldr	r2, [r4, #8]
 2768 00b6 1343     		orrs	r3, r2
 2769 00b8 A360     		str	r3, [r4, #8]
1168:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_ACCEPTED);
 2770              		.loc 1 1168 0
 2771 00ba 3268     		ldr	r2, [r6]
 2772 00bc 120F     		lsrs	r2, r2, #28
 2773 00be 0723     		movs	r3, #7
 2774 00c0 1340     		ands	r3, r2
 2775 00c2 E362     		str	r3, [r4, #44]
 2776              	.LVL275:
 2777              	.LBB382:
 2778              	.LBB383:
 2779              	.LBB384:
 2780              	.LBB385:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
ARM GAS  /tmp/ccWvVg6G.s 			page 92


 2781              		.loc 1 283 0
 2782 00c4 0022     		movs	r2, #0
 2783 00c6 0023     		movs	r3, #0
 2784 00c8 2261     		str	r2, [r4, #16]
 2785 00ca 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2786              		.loc 1 284 0
 2787 00cc 0023     		movs	r3, #0
 2788 00ce E371     		strb	r3, [r4, #7]
 2789              	.LVL276:
 2790              	.LBE385:
 2791              	.LBE384:
 352:Src/usb_pd_protocol.c **** 
 2792              		.loc 1 352 0
 2793 00d0 1433     		adds	r3, r3, #20
 2794 00d2 2371     		strb	r3, [r4, #4]
 2795              	.LVL277:
 2796 00d4 77E0     		b	.L204
 2797              	.LVL278:
 2798              	.L209:
 2799              	.LBE383:
 2800              	.LBE382:
1180:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 2801              		.loc 1 1180 0
 2802 00d6 C301     		lsls	r3, r0, #7
 2803 00d8 3C4A     		ldr	r2, .L227+4
 2804              	.LVL279:
 2805 00da 9B5C     		ldrb	r3, [r3, r2]
 2806 00dc 002B     		cmp	r3, #0
 2807 00de 41D1     		bne	.L214
1180:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 2808              		.loc 1 1180 0 is_stmt 0 discriminator 1
 2809 00e0 C201     		lsls	r2, r0, #7
 2810 00e2 3A4B     		ldr	r3, .L227+4
 2811 00e4 9B18     		adds	r3, r3, r2
 2812 00e6 1B79     		ldrb	r3, [r3, #4]
 2813 00e8 083B     		subs	r3, r3, #8
 2814 00ea 5A42     		rsbs	r2, r3, #0
 2815 00ec 5341     		adcs	r3, r3, r2
 2816 00ee DBB2     		uxtb	r3, r3
 2817              	.L215:
1180:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 2818              		.loc 1 1180 0 discriminator 4
 2819 00f0 002B     		cmp	r3, #0
 2820 00f2 68D0     		beq	.L204
1184:Src/usb_pd_protocol.c **** 				/* bist data object mode is 2 */
 2821              		.loc 1 1184 0 is_stmt 1
 2822 00f4 3368     		ldr	r3, [r6]
 2823 00f6 1B0F     		lsrs	r3, r3, #28
 2824 00f8 052B     		cmp	r3, #5
 2825 00fa 64D1     		bne	.L204
1186:Src/usb_pd_protocol.c **** 					    NULL);
 2826              		.loc 1 1186 0
 2827 00fc 0023     		movs	r3, #0
 2828 00fe 0022     		movs	r2, #0
 2829 0100 0721     		movs	r1, #7
 2830 0102 2000     		movs	r0, r4
ARM GAS  /tmp/ccWvVg6G.s 			page 93


 2831              	.LVL280:
 2832 0104 FFF7FEFF 		bl	pd_transmit
 2833              	.LVL281:
1189:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
 2834              		.loc 1 1189 0
 2835 0108 E301     		lsls	r3, r4, #7
 2836 010a 304A     		ldr	r2, .L227+4
 2837 010c 9B5C     		ldrb	r3, [r3, r2]
 2838 010e 002B     		cmp	r3, #0
 2839 0110 31D0     		beq	.L223
 2840 0112 0E22     		movs	r2, #14
 2841              	.L216:
 2842              	.LVL282:
 2843              	.LBB386:
 2844              	.LBB387:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2845              		.loc 1 346 0 discriminator 4
 2846 0114 E101     		lsls	r1, r4, #7
 2847 0116 2D4B     		ldr	r3, .L227+4
 2848 0118 5B18     		adds	r3, r3, r1
 2849 011a 1D79     		ldrb	r5, [r3, #4]
 2850              	.LVL283:
 2851              	.LBB388:
 2852              	.LBB389:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2853              		.loc 1 283 0 discriminator 4
 2854 011c 0020     		movs	r0, #0
 2855 011e 0021     		movs	r1, #0
 2856 0120 1861     		str	r0, [r3, #16]
 2857 0122 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 2858              		.loc 1 284 0 discriminator 4
 2859 0124 0021     		movs	r1, #0
 2860 0126 D971     		strb	r1, [r3, #7]
 2861              	.LVL284:
 2862              	.LBE389:
 2863              	.LBE388:
 352:Src/usb_pd_protocol.c **** 
 2864              		.loc 1 352 0 discriminator 4
 2865 0128 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 2866              		.loc 1 354 0 discriminator 4
 2867 012a AA42     		cmp	r2, r5
 2868 012c 4BD0     		beq	.L204
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2869              		.loc 1 365 0
 2870 012e 022D     		cmp	r5, #2
 2871 0130 23D0     		beq	.L224
 2872              	.L217:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 2873              		.loc 1 366 0
 2874 0132 0E2D     		cmp	r5, #14
 2875 0134 24D0     		beq	.L225
 2876              	.L218:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2877              		.loc 1 371 0
 2878 0136 0E2A     		cmp	r2, #14
ARM GAS  /tmp/ccWvVg6G.s 			page 94


 2879 0138 01D0     		beq	.L219
 2880 013a 022A     		cmp	r2, #2
 2881 013c 43D1     		bne	.L204
 2882              	.L219:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 2883              		.loc 1 374 0
 2884 013e 0022     		movs	r2, #0
 2885              	.LVL285:
 2886 0140 0021     		movs	r1, #0
 2887 0142 2000     		movs	r0, r4
 2888 0144 FFF7FEFF 		bl	pd_set_input_current_limit
 2889              	.LVL286:
 391:Src/usb_pd_protocol.c **** 			/*
 2890              		.loc 1 391 0
 2891 0148 E301     		lsls	r3, r4, #7
 2892 014a 204A     		ldr	r2, .L227+4
 2893 014c 9B5C     		ldrb	r3, [r3, r2]
 2894 014e 012B     		cmp	r3, #1
 2895 0150 19D0     		beq	.L226
 2896              	.L220:
 2897              	.LVL287:
 2898              	.LBB390:
 2899              	.LBB391:
  92:Inc/tcpm.h    **** }
 2900              		.loc 2 92 0
 2901 0152 2201     		lsls	r2, r4, #4
 2902 0154 1E4B     		ldr	r3, .L227+8
 2903 0156 9B18     		adds	r3, r3, r2
 2904 0158 9B68     		ldr	r3, [r3, #8]
 2905 015a 5B6A     		ldr	r3, [r3, #36]
 2906 015c 0021     		movs	r1, #0
 2907 015e 2000     		movs	r0, r4
 2908 0160 9847     		blx	r3
 2909              	.LVL288:
 2910 0162 30E0     		b	.L204
 2911              	.LVL289:
 2912              	.L214:
 2913              	.LBE391:
 2914              	.LBE390:
 2915              	.LBE387:
 2916              	.LBE386:
1180:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 2917              		.loc 1 1180 0 discriminator 2
 2918 0164 C201     		lsls	r2, r0, #7
 2919 0166 194B     		ldr	r3, .L227+4
 2920 0168 9B18     		adds	r3, r3, r2
 2921 016a 1B79     		ldrb	r3, [r3, #4]
 2922 016c 173B     		subs	r3, r3, #23
 2923 016e 5A42     		rsbs	r2, r3, #0
 2924 0170 5341     		adcs	r3, r3, r2
 2925 0172 DBB2     		uxtb	r3, r3
 2926 0174 BCE7     		b	.L215
 2927              	.LVL290:
 2928              	.L223:
1189:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
 2929              		.loc 1 1189 0
 2930 0176 0222     		movs	r2, #2
ARM GAS  /tmp/ccWvVg6G.s 			page 95


 2931 0178 CCE7     		b	.L216
 2932              	.LVL291:
 2933              	.L224:
 2934              	.LBB393:
 2935              	.LBB392:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2936              		.loc 1 365 0
 2937 017a 0E2A     		cmp	r2, #14
 2938 017c D9D1     		bne	.L217
 2939 017e 22E0     		b	.L204
 2940              	.L225:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 2941              		.loc 1 367 0
 2942 0180 022A     		cmp	r2, #2
 2943 0182 D8D1     		bne	.L218
 2944 0184 1FE0     		b	.L204
 2945              	.LVL292:
 2946              	.L226:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 2947              		.loc 1 396 0
 2948 0186 2000     		movs	r0, r4
 2949 0188 FFF7FEFF 		bl	pd_power_supply_reset
 2950              	.LVL293:
 2951 018c E1E7     		b	.L220
 2952              	.LVL294:
 2953              	.L210:
 2954              	.LBE392:
 2955              	.LBE393:
1196:Src/usb_pd_protocol.c **** 		/* snk cap 0 should be fixed PDO */
 2956              		.loc 1 1196 0
 2957 018e C301     		lsls	r3, r0, #7
 2958 0190 0E4D     		ldr	r5, .L227+4
 2959              	.LVL295:
 2960 0192 ED18     		adds	r5, r5, r3
 2961 0194 1023     		movs	r3, #16
 2962 0196 AA68     		ldr	r2, [r5, #8]
 2963              	.LVL296:
 2964 0198 1343     		orrs	r3, r2
 2965 019a AB60     		str	r3, [r5, #8]
1198:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SRC_GET_SINK_CAP)
 2966              		.loc 1 1198 0
 2967 019c 3168     		ldr	r1, [r6]
 2968 019e FFF7FEFF 		bl	pd_update_pdo_flags
 2969              	.LVL297:
1199:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 2970              		.loc 1 1199 0
 2971 01a2 2B79     		ldrb	r3, [r5, #4]
 2972 01a4 182B     		cmp	r3, #24
 2973 01a6 0ED1     		bne	.L204
 2974              	.LVL298:
 2975              	.LBB394:
 2976              	.LBB395:
 2977              	.LBB396:
 2978              	.LBB397:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2979              		.loc 1 283 0
 2980 01a8 E401     		lsls	r4, r4, #7
ARM GAS  /tmp/ccWvVg6G.s 			page 96


 2981              	.LVL299:
 2982 01aa 084B     		ldr	r3, .L227+4
 2983 01ac 1C19     		adds	r4, r3, r4
 2984 01ae 0022     		movs	r2, #0
 2985 01b0 0023     		movs	r3, #0
 2986 01b2 2261     		str	r2, [r4, #16]
 2987 01b4 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 2988              		.loc 1 284 0
 2989 01b6 0023     		movs	r3, #0
 2990 01b8 E371     		strb	r3, [r4, #7]
 2991              	.LVL300:
 2992              	.LBE397:
 2993              	.LBE396:
 352:Src/usb_pd_protocol.c **** 
 2994              		.loc 1 352 0
 2995 01ba 1733     		adds	r3, r3, #23
 2996 01bc 2371     		strb	r3, [r4, #4]
 2997              	.LVL301:
 2998 01be 02E0     		b	.L204
 2999              	.LVL302:
 3000              	.L211:
 3001              	.LBE395:
 3002              	.LBE394:
1207:Src/usb_pd_protocol.c **** 		break;
 3003              		.loc 1 1207 0
 3004 01c0 2900     		movs	r1, r5
 3005 01c2 FFF7FEFF 		bl	handle_vdm_request
 3006              	.LVL303:
 3007              	.L204:
1212:Src/usb_pd_protocol.c **** 
 3008              		.loc 1 1212 0
 3009              		@ sp needed
 3010              	.LVL304:
 3011 01c6 70BD     		pop	{r4, r5, r6, pc}
 3012              	.L228:
 3013              		.align	2
 3014              	.L227:
 3015 01c8 00000000 		.word	.L207
 3016 01cc 00000000 		.word	pd
 3017 01d0 00000000 		.word	tcpc_config
 3018              		.cfi_endproc
 3019              	.LFE40:
 3021              		.section	.text.pd_is_connected,"ax",%progbits
 3022              		.align	1
 3023              		.global	pd_is_connected
 3024              		.syntax unified
 3025              		.code	16
 3026              		.thumb_func
 3027              		.fpu softvfp
 3029              	pd_is_connected:
 3030              	.LFB20:
 301:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_DISABLED)
 3031              		.loc 1 301 0
 3032              		.cfi_startproc
 3033              		@ args = 0, pretend = 0, frame = 0
 3034              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccWvVg6G.s 			page 97


 3035              		@ link register save eliminated.
 3036              	.LVL305:
 302:Src/usb_pd_protocol.c **** 		return 0;
 3037              		.loc 1 302 0
 3038 0000 C201     		lsls	r2, r0, #7
 3039 0002 0D4B     		ldr	r3, .L234
 3040 0004 9B18     		adds	r3, r3, r2
 3041 0006 1B79     		ldrb	r3, [r3, #4]
 3042 0008 002B     		cmp	r3, #0
 3043 000a 12D0     		beq	.L232
 310:Src/usb_pd_protocol.c **** 		/* sink */
 3044              		.loc 1 310 0
 3045 000c 1000     		movs	r0, r2
 3046              	.LVL306:
 3047 000e 0A4A     		ldr	r2, .L234
 3048 0010 825C     		ldrb	r2, [r0, r2]
 3049 0012 002A     		cmp	r2, #0
 3050 0014 06D0     		beq	.L233
 310:Src/usb_pd_protocol.c **** 		/* sink */
 3051              		.loc 1 310 0 is_stmt 0 discriminator 2
 3052 0016 0E3B     		subs	r3, r3, #14
 3053 0018 DBB2     		uxtb	r3, r3
 3054 001a 0120     		movs	r0, #1
 3055 001c 9842     		cmp	r0, r3
 3056 001e 8041     		sbcs	r0, r0, r0
 3057 0020 4042     		rsbs	r0, r0, #0
 3058 0022 07E0     		b	.L229
 3059              	.L233:
 310:Src/usb_pd_protocol.c **** 		/* sink */
 3060              		.loc 1 310 0 discriminator 1
 3061 0024 023B     		subs	r3, r3, #2
 3062 0026 DBB2     		uxtb	r3, r3
 3063 0028 0120     		movs	r0, #1
 3064 002a 9842     		cmp	r0, r3
 3065 002c 8041     		sbcs	r0, r0, r0
 3066 002e 4042     		rsbs	r0, r0, #0
 3067 0030 00E0     		b	.L229
 3068              	.LVL307:
 3069              	.L232:
 303:Src/usb_pd_protocol.c **** 
 3070              		.loc 1 303 0 is_stmt 1
 3071 0032 0020     		movs	r0, #0
 3072              	.LVL308:
 3073              	.L229:
 317:Src/usb_pd_protocol.c **** 
 3074              		.loc 1 317 0
 3075              		@ sp needed
 3076 0034 7047     		bx	lr
 3077              	.L235:
 3078 0036 C046     		.align	2
 3079              	.L234:
 3080 0038 00000000 		.word	pd
 3081              		.cfi_endproc
 3082              	.LFE20:
 3084              		.section	.text.pd_vdm_send_state_machine,"ax",%progbits
 3085              		.align	1
 3086              		.syntax unified
ARM GAS  /tmp/ccWvVg6G.s 			page 98


 3087              		.code	16
 3088              		.thumb_func
 3089              		.fpu softvfp
 3091              	pd_vdm_send_state_machine:
 3092              	.LFB50:
1648:Src/usb_pd_protocol.c **** 	int res;
 3093              		.loc 1 1648 0
 3094              		.cfi_startproc
 3095              		@ args = 0, pretend = 0, frame = 8
 3096              		@ frame_needed = 0, uses_anonymous_args = 0
 3097              	.LVL309:
 3098 0000 30B5     		push	{r4, r5, lr}
 3099              	.LCFI22:
 3100              		.cfi_def_cfa_offset 12
 3101              		.cfi_offset 4, -12
 3102              		.cfi_offset 5, -8
 3103              		.cfi_offset 14, -4
 3104 0002 83B0     		sub	sp, sp, #12
 3105              	.LCFI23:
 3106              		.cfi_def_cfa_offset 24
 3107 0004 0400     		movs	r4, r0
1652:Src/usb_pd_protocol.c **** 	case VDM_STATE_READY:
 3108              		.loc 1 1652 0
 3109 0006 C201     		lsls	r2, r0, #7
 3110 0008 4D4B     		ldr	r3, .L253
 3111 000a 9B18     		adds	r3, r3, r2
 3112 000c 4833     		adds	r3, r3, #72
 3113 000e 1B78     		ldrb	r3, [r3]
 3114 0010 5BB2     		sxtb	r3, r3
 3115 0012 022B     		cmp	r3, #2
 3116 0014 00D1     		bne	.LCB3273
 3117 0016 70E0     		b	.L238	@long jump
 3118              	.LCB3273:
 3119 0018 032B     		cmp	r3, #3
 3120 001a 53D0     		beq	.L239
 3121 001c 012B     		cmp	r3, #1
 3122 001e 01D0     		beq	.L250
 3123              	.LVL310:
 3124              	.L236:
1700:Src/usb_pd_protocol.c **** 
 3125              		.loc 1 1700 0
 3126 0020 03B0     		add	sp, sp, #12
 3127              		@ sp needed
 3128 0022 30BD     		pop	{r4, r5, pc}
 3129              	.LVL311:
 3130              	.L250:
1655:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_BUSY;
 3131              		.loc 1 1655 0
 3132 0024 FFF7FEFF 		bl	pd_is_connected
 3133              	.LVL312:
 3134 0028 0028     		cmp	r0, #0
 3135 002a 30D0     		beq	.L251
 3136              	.LVL313:
 3137              	.LBB398:
 3138              	.LBB399:
1614:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 3139              		.loc 1 1614 0
ARM GAS  /tmp/ccWvVg6G.s 			page 99


 3140 002c E201     		lsls	r2, r4, #7
 3141 002e 444B     		ldr	r3, .L253
 3142 0030 9B18     		adds	r3, r3, r2
 3143 0032 1A79     		ldrb	r2, [r3, #4]
 3144 0034 1300     		movs	r3, r2
 3145 0036 173B     		subs	r3, r3, #23
 3146 0038 591E     		subs	r1, r3, #1
 3147 003a 8B41     		sbcs	r3, r3, r1
 3148 003c DBB2     		uxtb	r3, r3
 3149              	.LVL314:
 3150              	.LBE399:
 3151              	.LBE398:
1664:Src/usb_pd_protocol.c **** 			break;
 3152              		.loc 1 1664 0
 3153 003e 082A     		cmp	r2, #8
 3154 0040 01D0     		beq	.L247
 3155 0042 002B     		cmp	r3, #0
 3156 0044 ECD1     		bne	.L236
 3157              	.L247:
1668:Src/usb_pd_protocol.c **** 				   pd[port].data_role, pd[port].msg_id,
 3158              		.loc 1 1668 0
 3159 0046 3E4B     		ldr	r3, .L253
 3160 0048 E101     		lsls	r1, r4, #7
 3161 004a 5818     		adds	r0, r3, r1
 3162 004c 4278     		ldrb	r2, [r0, #1]
 3163 004e 5201     		lsls	r2, r2, #5
 3164 0050 4F25     		movs	r5, #79
 3165 0052 2A43     		orrs	r2, r5
 3166 0054 CD5C     		ldrb	r5, [r1, r3]
 3167 0056 2D02     		lsls	r5, r5, #8
 3168 0058 2A43     		orrs	r2, r5
 3169 005a 12B2     		sxth	r2, r2
 3170 005c 8578     		ldrb	r5, [r0, #2]
 3171 005e 6D02     		lsls	r5, r5, #9
 3172 0060 2A43     		orrs	r2, r5
 3173 0062 12B2     		sxth	r2, r2
 3174 0064 7430     		adds	r0, r0, #116
 3175 0066 0078     		ldrb	r0, [r0]
 3176 0068 0003     		lsls	r0, r0, #12
 3177 006a 0243     		orrs	r2, r0
 3178 006c 12B2     		sxth	r2, r2
 3179 006e 92B2     		uxth	r2, r2
 3180              	.LVL315:
1673:Src/usb_pd_protocol.c **** 		if (res < 0) {
 3181              		.loc 1 1673 0
 3182 0070 5831     		adds	r1, r1, #88
 3183 0072 CB18     		adds	r3, r1, r3
1672:Src/usb_pd_protocol.c **** 				  pd[port].vdo_data);
 3184              		.loc 1 1672 0
 3185 0074 0021     		movs	r1, #0
 3186 0076 2000     		movs	r0, r4
 3187 0078 FFF7FEFF 		bl	pd_transmit
 3188              	.LVL316:
1674:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_SEND;
 3189              		.loc 1 1674 0
 3190 007c 0028     		cmp	r0, #0
 3191 007e 0DDA     		bge	.L243
ARM GAS  /tmp/ccWvVg6G.s 			page 100


1675:Src/usb_pd_protocol.c **** 		} else {
 3192              		.loc 1 1675 0
 3193 0080 E401     		lsls	r4, r4, #7
 3194              	.LVL317:
 3195 0082 2F4B     		ldr	r3, .L253
 3196 0084 1C19     		adds	r4, r3, r4
 3197 0086 4834     		adds	r4, r4, #72
 3198 0088 FE22     		movs	r2, #254
 3199 008a 2270     		strb	r2, [r4]
 3200 008c C8E7     		b	.L236
 3201              	.LVL318:
 3202              	.L251:
1656:Src/usb_pd_protocol.c **** 			break;
 3203              		.loc 1 1656 0
 3204 008e E301     		lsls	r3, r4, #7
 3205 0090 2B4C     		ldr	r4, .L253
 3206              	.LVL319:
 3207 0092 E418     		adds	r4, r4, r3
 3208 0094 4834     		adds	r4, r4, #72
 3209 0096 FD23     		movs	r3, #253
 3210 0098 2370     		strb	r3, [r4]
1657:Src/usb_pd_protocol.c **** 		}
 3211              		.loc 1 1657 0
 3212 009a C1E7     		b	.L236
 3213              	.LVL320:
 3214              	.L243:
1677:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 3215              		.loc 1 1677 0
 3216 009c E401     		lsls	r4, r4, #7
 3217              	.LVL321:
 3218 009e 284B     		ldr	r3, .L253
 3219 00a0 1C19     		adds	r4, r3, r4
 3220 00a2 2300     		movs	r3, r4
 3221 00a4 4833     		adds	r3, r3, #72
 3222 00a6 0222     		movs	r2, #2
 3223 00a8 1A70     		strb	r2, [r3]
1678:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
 3224              		.loc 1 1678 0
 3225 00aa 6846     		mov	r0, sp
 3226              	.LVL322:
 3227 00ac FFF7FEFF 		bl	get_time
 3228              	.LVL323:
1679:Src/usb_pd_protocol.c **** 		}
 3229              		.loc 1 1679 0
 3230 00b0 A06D     		ldr	r0, [r4, #88]
 3231 00b2 FFF7FEFF 		bl	vdm_get_ready_timeout
 3232              	.LVL324:
1678:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
 3233              		.loc 1 1678 0
 3234 00b6 009A     		ldr	r2, [sp]
 3235 00b8 019B     		ldr	r3, [sp, #4]
 3236 00ba 8018     		adds	r0, r0, r2
 3237 00bc 5941     		adcs	r1, r1, r3
 3238 00be 2065     		str	r0, [r4, #80]
 3239 00c0 6165     		str	r1, [r4, #84]
 3240 00c2 ADE7     		b	.L236
 3241              	.LVL325:
ARM GAS  /tmp/ccWvVg6G.s 			page 101


 3242              	.L239:
1684:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
 3243              		.loc 1 1684 0
 3244 00c4 6846     		mov	r0, sp
 3245              	.LVL326:
 3246 00c6 FFF7FEFF 		bl	get_time
 3247              	.LVL327:
 3248 00ca 0098     		ldr	r0, [sp]
 3249 00cc 0199     		ldr	r1, [sp, #4]
 3250 00ce E201     		lsls	r2, r4, #7
 3251 00d0 1B4B     		ldr	r3, .L253
 3252 00d2 9B18     		adds	r3, r3, r2
 3253 00d4 1A6D     		ldr	r2, [r3, #80]
 3254 00d6 5B6D     		ldr	r3, [r3, #84]
 3255 00d8 9942     		cmp	r1, r3
 3256 00da 02D8     		bhi	.L248
 3257 00dc A0D1     		bne	.L236
 3258 00de 9042     		cmp	r0, r2
 3259 00e0 9ED9     		bls	.L236
 3260              	.L248:
1685:Src/usb_pd_protocol.c **** 			pd[port].vdo_count = 1;
 3261              		.loc 1 1685 0
 3262 00e2 E401     		lsls	r4, r4, #7
 3263              	.LVL328:
 3264 00e4 164B     		ldr	r3, .L253
 3265 00e6 1C19     		adds	r4, r3, r4
 3266 00e8 A36F     		ldr	r3, [r4, #120]
 3267 00ea A365     		str	r3, [r4, #88]
1686:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_READY;
 3268              		.loc 1 1686 0
 3269 00ec 2200     		movs	r2, r4
 3270 00ee 7432     		adds	r2, r2, #116
 3271 00f0 0123     		movs	r3, #1
 3272 00f2 1370     		strb	r3, [r2]
1687:Src/usb_pd_protocol.c **** 		}
 3273              		.loc 1 1687 0
 3274 00f4 4834     		adds	r4, r4, #72
 3275 00f6 2370     		strb	r3, [r4]
 3276 00f8 92E7     		b	.L236
 3277              	.LVL329:
 3278              	.L238:
1692:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 3279              		.loc 1 1692 0
 3280 00fa C201     		lsls	r2, r0, #7
 3281 00fc 104B     		ldr	r3, .L253
 3282 00fe 9B18     		adds	r3, r3, r2
 3283 0100 1A6D     		ldr	r2, [r3, #80]
 3284 0102 596D     		ldr	r1, [r3, #84]
 3285 0104 1300     		movs	r3, r2
 3286 0106 0B43     		orrs	r3, r1
 3287 0108 00D1     		bne	.LCB3451
 3288 010a 89E7     		b	.L236	@long jump
 3289              	.LCB3451:
1693:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_TMOUT;
 3290              		.loc 1 1693 0
 3291 010c 6846     		mov	r0, sp
 3292              	.LVL330:
ARM GAS  /tmp/ccWvVg6G.s 			page 102


 3293 010e FFF7FEFF 		bl	get_time
 3294              	.LVL331:
 3295 0112 0098     		ldr	r0, [sp]
 3296 0114 0199     		ldr	r1, [sp, #4]
 3297 0116 E201     		lsls	r2, r4, #7
 3298 0118 094B     		ldr	r3, .L253
 3299 011a 9B18     		adds	r3, r3, r2
 3300 011c 1A6D     		ldr	r2, [r3, #80]
 3301 011e 5B6D     		ldr	r3, [r3, #84]
1692:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 3302              		.loc 1 1692 0
 3303 0120 9942     		cmp	r1, r3
 3304 0122 06D9     		bls	.L252
 3305              	.L249:
1694:Src/usb_pd_protocol.c **** 		}
 3306              		.loc 1 1694 0
 3307 0124 E401     		lsls	r4, r4, #7
 3308              	.LVL332:
 3309 0126 064B     		ldr	r3, .L253
 3310 0128 1C19     		adds	r4, r3, r4
 3311 012a 4834     		adds	r4, r4, #72
 3312 012c FF23     		movs	r3, #255
 3313 012e 2370     		strb	r3, [r4]
1700:Src/usb_pd_protocol.c **** 
 3314              		.loc 1 1700 0
 3315 0130 76E7     		b	.L236
 3316              	.LVL333:
 3317              	.L252:
1692:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 3318              		.loc 1 1692 0 discriminator 1
 3319 0132 9942     		cmp	r1, r3
 3320 0134 00D0     		beq	.LCB3480
 3321 0136 73E7     		b	.L236	@long jump
 3322              	.LCB3480:
 3323 0138 9042     		cmp	r0, r2
 3324 013a F3D8     		bhi	.L249
 3325 013c 70E7     		b	.L236
 3326              	.L254:
 3327 013e C046     		.align	2
 3328              	.L253:
 3329 0140 00000000 		.word	pd
 3330              		.cfi_endproc
 3331              	.LFE50:
 3333              		.section	.text.handle_request,"ax",%progbits
 3334              		.align	1
 3335              		.syntax unified
 3336              		.code	16
 3337              		.thumb_func
 3338              		.fpu softvfp
 3340              	handle_request:
 3341              	.LFB46:
1554:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
 3342              		.loc 1 1554 0
 3343              		.cfi_startproc
 3344              		@ args = 0, pretend = 0, frame = 0
 3345              		@ frame_needed = 0, uses_anonymous_args = 0
 3346              	.LVL334:
ARM GAS  /tmp/ccWvVg6G.s 			page 103


 3347 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3348              	.LCFI24:
 3349              		.cfi_def_cfa_offset 24
 3350              		.cfi_offset 3, -24
 3351              		.cfi_offset 4, -20
 3352              		.cfi_offset 5, -16
 3353              		.cfi_offset 6, -12
 3354              		.cfi_offset 7, -8
 3355              		.cfi_offset 14, -4
 3356 0002 0500     		movs	r5, r0
 3357 0004 0E00     		movs	r6, r1
 3358 0006 1700     		movs	r7, r2
1555:Src/usb_pd_protocol.c **** 	int p;
 3359              		.loc 1 1555 0
 3360 0008 0B0B     		lsrs	r3, r1, #12
 3361 000a 0724     		movs	r4, #7
 3362 000c 1C40     		ands	r4, r3
 3363              	.LVL335:
1571:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_HARD_RESET_SEND);
 3364              		.loc 1 1571 0
 3365 000e FFF7FEFF 		bl	pd_is_connected
 3366              	.LVL336:
 3367 0012 0028     		cmp	r0, #0
 3368 0014 07D0     		beq	.L259
 3369              	.L256:
1581:Src/usb_pd_protocol.c **** 		handle_data_request(port, head, payload);
 3370              		.loc 1 1581 0
 3371 0016 002C     		cmp	r4, #0
 3372 0018 11D1     		bne	.L260
1584:Src/usb_pd_protocol.c **** }
 3373              		.loc 1 1584 0
 3374 001a 3A00     		movs	r2, r7
 3375 001c 3100     		movs	r1, r6
 3376 001e 2800     		movs	r0, r5
 3377 0020 FFF7FEFF 		bl	handle_ctrl_request
 3378              	.LVL337:
 3379              	.L255:
1585:Src/usb_pd_protocol.c **** 
 3380              		.loc 1 1585 0
 3381              		@ sp needed
 3382              	.LVL338:
 3383              	.LVL339:
 3384              	.LVL340:
 3385              	.LVL341:
 3386 0024 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3387              	.LVL342:
 3388              	.L259:
 3389              	.LBB406:
 3390              	.LBB407:
 3391              	.LBB408:
 3392              	.LBB409:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3393              		.loc 1 283 0
 3394 0026 EA01     		lsls	r2, r5, #7
 3395 0028 084B     		ldr	r3, .L261
 3396 002a 9B18     		adds	r3, r3, r2
 3397 002c 0020     		movs	r0, #0
ARM GAS  /tmp/ccWvVg6G.s 			page 104


 3398 002e 0021     		movs	r1, #0
 3399 0030 1861     		str	r0, [r3, #16]
 3400 0032 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 3401              		.loc 1 284 0
 3402 0034 0022     		movs	r2, #0
 3403 0036 DA71     		strb	r2, [r3, #7]
 3404              	.LVL343:
 3405              	.LBE409:
 3406              	.LBE408:
 352:Src/usb_pd_protocol.c **** 
 3407              		.loc 1 352 0
 3408 0038 1F32     		adds	r2, r2, #31
 3409 003a 1A71     		strb	r2, [r3, #4]
 3410              	.LVL344:
 3411 003c EBE7     		b	.L256
 3412              	.LVL345:
 3413              	.L260:
 3414              	.LBE407:
 3415              	.LBE406:
1582:Src/usb_pd_protocol.c **** 	else
 3416              		.loc 1 1582 0
 3417 003e 3A00     		movs	r2, r7
 3418 0040 3100     		movs	r1, r6
 3419 0042 2800     		movs	r0, r5
 3420 0044 FFF7FEFF 		bl	handle_data_request
 3421              	.LVL346:
 3422 0048 ECE7     		b	.L255
 3423              	.L262:
 3424 004a C046     		.align	2
 3425              	.L261:
 3426 004c 00000000 		.word	pd
 3427              		.cfi_endproc
 3428              	.LFE46:
 3430              		.section	.text.pd_ts_dts_plugged,"ax",%progbits
 3431              		.align	1
 3432              		.global	pd_ts_dts_plugged
 3433              		.syntax unified
 3434              		.code	16
 3435              		.thumb_func
 3436              		.fpu softvfp
 3438              	pd_ts_dts_plugged:
 3439              	.LFB21:
 324:Src/usb_pd_protocol.c **** 	return pd[port].flags & PD_FLAGS_TS_DTS_PARTNER;
 3440              		.loc 1 324 0
 3441              		.cfi_startproc
 3442              		@ args = 0, pretend = 0, frame = 0
 3443              		@ frame_needed = 0, uses_anonymous_args = 0
 3444              		@ link register save eliminated.
 3445              	.LVL347:
 325:Src/usb_pd_protocol.c **** }
 3446              		.loc 1 325 0
 3447 0000 C301     		lsls	r3, r0, #7
 3448 0002 0348     		ldr	r0, .L264
 3449              	.LVL348:
 3450 0004 C018     		adds	r0, r0, r3
 3451 0006 8068     		ldr	r0, [r0, #8]
ARM GAS  /tmp/ccWvVg6G.s 			page 105


 3452 0008 8023     		movs	r3, #128
 3453 000a 5B02     		lsls	r3, r3, #9
 3454 000c 1840     		ands	r0, r3
 326:Src/usb_pd_protocol.c **** 
 3455              		.loc 1 326 0
 3456              		@ sp needed
 3457 000e 7047     		bx	lr
 3458              	.L265:
 3459              		.align	2
 3460              	.L264:
 3461 0010 00000000 		.word	pd
 3462              		.cfi_endproc
 3463              	.LFE21:
 3465              		.section	.text.pd_vbus_low,"ax",%progbits
 3466              		.align	1
 3467              		.global	pd_vbus_low
 3468              		.syntax unified
 3469              		.code	16
 3470              		.thumb_func
 3471              		.fpu softvfp
 3473              	pd_vbus_low:
 3474              	.LFB22:
 330:Src/usb_pd_protocol.c **** 	pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
 3475              		.loc 1 330 0
 3476              		.cfi_startproc
 3477              		@ args = 0, pretend = 0, frame = 0
 3478              		@ frame_needed = 0, uses_anonymous_args = 0
 3479              		@ link register save eliminated.
 3480              	.LVL349:
 331:Src/usb_pd_protocol.c **** }
 3481              		.loc 1 331 0
 3482 0000 C301     		lsls	r3, r0, #7
 3483 0002 0348     		ldr	r0, .L267
 3484              	.LVL350:
 3485 0004 C018     		adds	r0, r0, r3
 3486 0006 8023     		movs	r3, #128
 3487 0008 8268     		ldr	r2, [r0, #8]
 3488 000a 9A43     		bics	r2, r3
 3489 000c 8260     		str	r2, [r0, #8]
 332:Src/usb_pd_protocol.c **** 
 3490              		.loc 1 332 0
 3491              		@ sp needed
 3492 000e 7047     		bx	lr
 3493              	.L268:
 3494              		.align	2
 3495              	.L267:
 3496 0010 00000000 		.word	pd
 3497              		.cfi_endproc
 3498              	.LFE22:
 3500              		.section	.text.pd_transmit_complete,"ax",%progbits
 3501              		.align	1
 3502              		.global	pd_transmit_complete
 3503              		.syntax unified
 3504              		.code	16
 3505              		.thumb_func
 3506              		.fpu softvfp
 3508              	pd_transmit_complete:
ARM GAS  /tmp/ccWvVg6G.s 			page 106


 3509              	.LFB26:
 465:Src/usb_pd_protocol.c **** 	if (status == TCPC_TX_COMPLETE_SUCCESS)
 3510              		.loc 1 465 0
 3511              		.cfi_startproc
 3512              		@ args = 0, pretend = 0, frame = 0
 3513              		@ frame_needed = 0, uses_anonymous_args = 0
 3514              	.LVL351:
 3515 0000 70B5     		push	{r4, r5, r6, lr}
 3516              	.LCFI25:
 3517              		.cfi_def_cfa_offset 16
 3518              		.cfi_offset 4, -16
 3519              		.cfi_offset 5, -12
 3520              		.cfi_offset 6, -8
 3521              		.cfi_offset 14, -4
 3522 0002 0400     		movs	r4, r0
 3523 0004 0D1E     		subs	r5, r1, #0
 466:Src/usb_pd_protocol.c **** 		inc_id(port);
 3524              		.loc 1 466 0
 3525 0006 09D0     		beq	.L271
 3526              	.LVL352:
 3527              	.L270:
 469:Src/usb_pd_protocol.c **** 	//task_set_event(PD_PORT_TO_TASK_ID(port), PD_EVENT_TX, 0);
 3528              		.loc 1 469 0
 3529 0008 E401     		lsls	r4, r4, #7
 3530              	.LVL353:
 3531 000a 0648     		ldr	r0, .L272
 3532 000c 0019     		adds	r0, r0, r4
 3533 000e 2930     		adds	r0, r0, #41
 3534 0010 0570     		strb	r5, [r0]
 471:Src/usb_pd_protocol.c **** }
 3535              		.loc 1 471 0
 3536 0012 0021     		movs	r1, #0
 3537 0014 0820     		movs	r0, #8
 3538 0016 FFF7FEFF 		bl	pd_task_set_event
 3539              	.LVL354:
 472:Src/usb_pd_protocol.c **** 
 3540              		.loc 1 472 0
 3541              		@ sp needed
 3542              	.LVL355:
 3543 001a 70BD     		pop	{r4, r5, r6, pc}
 3544              	.LVL356:
 3545              	.L271:
 467:Src/usb_pd_protocol.c **** 
 3546              		.loc 1 467 0
 3547 001c FFF7FEFF 		bl	inc_id
 3548              	.LVL357:
 3549 0020 F2E7     		b	.L270
 3550              	.L273:
 3551 0022 C046     		.align	2
 3552              	.L272:
 3553 0024 00000000 		.word	pd
 3554              		.cfi_endproc
 3555              	.LFE26:
 3557              		.section	.text.pd_execute_hard_reset,"ax",%progbits
 3558              		.align	1
 3559              		.global	pd_execute_hard_reset
 3560              		.syntax unified
ARM GAS  /tmp/ccWvVg6G.s 			page 107


 3561              		.code	16
 3562              		.thumb_func
 3563              		.fpu softvfp
 3565              	pd_execute_hard_reset:
 3566              	.LFB35:
 898:Src/usb_pd_protocol.c **** 	if (pd[port].last_state == PD_STATE_HARD_RESET_SEND)
 3567              		.loc 1 898 0
 3568              		.cfi_startproc
 3569              		@ args = 0, pretend = 0, frame = 8
 3570              		@ frame_needed = 0, uses_anonymous_args = 0
 3571              	.LVL358:
 3572 0000 10B5     		push	{r4, lr}
 3573              	.LCFI26:
 3574              		.cfi_def_cfa_offset 8
 3575              		.cfi_offset 4, -8
 3576              		.cfi_offset 14, -4
 3577 0002 82B0     		sub	sp, sp, #8
 3578              	.LCFI27:
 3579              		.cfi_def_cfa_offset 16
 3580 0004 0400     		movs	r4, r0
 904:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 3581              		.loc 1 904 0
 3582 0006 C201     		lsls	r2, r0, #7
 3583 0008 224B     		ldr	r3, .L279
 3584 000a 9B18     		adds	r3, r3, r2
 3585 000c 0022     		movs	r2, #0
 3586 000e 9A70     		strb	r2, [r3, #2]
 917:Src/usb_pd_protocol.c **** 
 3587              		.loc 1 917 0
 3588 0010 2032     		adds	r2, r2, #32
 3589 0012 5A71     		strb	r2, [r3, #5]
 924:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE) {
 3590              		.loc 1 924 0
 3591 0014 1B79     		ldrb	r3, [r3, #4]
 3592 0016 0C3B     		subs	r3, r3, #12
 3593 0018 DBB2     		uxtb	r3, r3
 3594 001a 012B     		cmp	r3, #1
 3595 001c 09D8     		bhi	.L275
 3596              	.LVL359:
 3597              	.LBB424:
 3598              	.LBB425:
  71:Inc/tcpm.h    **** }
 3599              		.loc 2 71 0
 3600 001e 0201     		lsls	r2, r0, #4
 3601 0020 1D4B     		ldr	r3, .L279+4
 3602 0022 9B18     		adds	r3, r3, r2
 3603 0024 9B68     		ldr	r3, [r3, #8]
 3604 0026 5B69     		ldr	r3, [r3, #20]
 3605 0028 0221     		movs	r1, #2
 3606 002a 9847     		blx	r3
 3607              	.LVL360:
 3608              	.LBE425:
 3609              	.LBE424:
 927:Src/usb_pd_protocol.c **** 	}
 3610              		.loc 1 927 0
 3611 002c 2000     		movs	r0, r4
 3612 002e FFF7FEFF 		bl	pd_power_supply_reset
ARM GAS  /tmp/ccWvVg6G.s 			page 108


 3613              	.LVL361:
 3614              	.L275:
 930:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 3615              		.loc 1 930 0
 3616 0032 E301     		lsls	r3, r4, #7
 3617 0034 174A     		ldr	r2, .L279
 3618 0036 9B5C     		ldrb	r3, [r3, r2]
 3619 0038 002B     		cmp	r3, #0
 3620 003a 1AD0     		beq	.L278
 945:Src/usb_pd_protocol.c **** 	pd[port].src_recover = get_time().val + PD_T_SRC_RECOVER;
 3621              		.loc 1 945 0
 3622 003c 2000     		movs	r0, r4
 3623 003e FFF7FEFF 		bl	pd_power_supply_reset
 3624              	.LVL362:
 946:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 3625              		.loc 1 946 0
 3626 0042 6846     		mov	r0, sp
 3627 0044 FFF7FEFF 		bl	get_time
 3628              	.LVL363:
 3629 0048 144A     		ldr	r2, .L279+8
 3630 004a 0023     		movs	r3, #0
 3631 004c 0098     		ldr	r0, [sp]
 3632 004e 0199     		ldr	r1, [sp, #4]
 3633 0050 1218     		adds	r2, r2, r0
 3634 0052 4B41     		adcs	r3, r3, r1
 3635 0054 E401     		lsls	r4, r4, #7
 3636              	.LVL364:
 3637 0056 0F49     		ldr	r1, .L279
 3638 0058 0C19     		adds	r4, r1, r4
 3639 005a A261     		str	r2, [r4, #24]
 3640 005c E361     		str	r3, [r4, #28]
 3641              	.LVL365:
 3642              	.LBB426:
 3643              	.LBB427:
 3644              	.LBB428:
 3645              	.LBB429:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3646              		.loc 1 283 0
 3647 005e 0022     		movs	r2, #0
 3648 0060 0023     		movs	r3, #0
 3649 0062 2261     		str	r2, [r4, #16]
 3650 0064 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 3651              		.loc 1 284 0
 3652 0066 0023     		movs	r3, #0
 3653 0068 E371     		strb	r3, [r4, #7]
 3654              	.LVL366:
 3655              	.LBE429:
 3656              	.LBE428:
 352:Src/usb_pd_protocol.c **** 
 3657              		.loc 1 352 0
 3658 006a 1033     		adds	r3, r3, #16
 3659 006c 2371     		strb	r3, [r4, #4]
 3660              	.LVL367:
 3661              	.L274:
 3662              	.LBE427:
 3663              	.LBE426:
ARM GAS  /tmp/ccWvVg6G.s 			page 109


 948:Src/usb_pd_protocol.c **** 
 3664              		.loc 1 948 0
 3665 006e 02B0     		add	sp, sp, #8
 3666              		@ sp needed
 3667 0070 10BD     		pop	{r4, pc}
 3668              	.LVL368:
 3669              	.L278:
 932:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 3670              		.loc 1 932 0
 3671 0072 0022     		movs	r2, #0
 3672 0074 0021     		movs	r1, #0
 3673 0076 2000     		movs	r0, r4
 3674 0078 FFF7FEFF 		bl	pd_set_input_current_limit
 3675              	.LVL369:
 3676              	.LBB430:
 3677              	.LBB431:
 3678              	.LBB432:
 3679              	.LBB433:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3680              		.loc 1 283 0
 3681 007c E401     		lsls	r4, r4, #7
 3682              	.LVL370:
 3683 007e 054B     		ldr	r3, .L279
 3684 0080 1C19     		adds	r4, r3, r4
 3685 0082 0022     		movs	r2, #0
 3686 0084 0023     		movs	r3, #0
 3687 0086 2261     		str	r2, [r4, #16]
 3688 0088 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 3689              		.loc 1 284 0
 3690 008a 0023     		movs	r3, #0
 3691 008c E371     		strb	r3, [r4, #7]
 3692              	.LVL371:
 3693              	.LBE433:
 3694              	.LBE432:
 352:Src/usb_pd_protocol.c **** 
 3695              		.loc 1 352 0
 3696 008e 0433     		adds	r3, r3, #4
 3697 0090 2371     		strb	r3, [r4, #4]
 3698              	.LVL372:
 3699 0092 ECE7     		b	.L274
 3700              	.L280:
 3701              		.align	2
 3702              	.L279:
 3703 0094 00000000 		.word	pd
 3704 0098 00000000 		.word	tcpc_config
 3705 009c C0980B00 		.word	760000
 3706              	.LBE431:
 3707              	.LBE430:
 3708              		.cfi_endproc
 3709              	.LFE35:
 3711              		.section	.text.pd_soft_reset,"ax",%progbits
 3712              		.align	1
 3713              		.global	pd_soft_reset
 3714              		.syntax unified
 3715              		.code	16
 3716              		.thumb_func
ARM GAS  /tmp/ccWvVg6G.s 			page 110


 3717              		.fpu softvfp
 3719              	pd_soft_reset:
 3720              	.LFB37:
 959:Src/usb_pd_protocol.c **** 	int i;
 3721              		.loc 1 959 0
 3722              		.cfi_startproc
 3723              		@ args = 0, pretend = 0, frame = 0
 3724              		@ frame_needed = 0, uses_anonymous_args = 0
 3725 0000 10B5     		push	{r4, lr}
 3726              	.LCFI28:
 3727              		.cfi_def_cfa_offset 8
 3728              		.cfi_offset 4, -8
 3729              		.cfi_offset 14, -4
 3730              	.LVL373:
 962:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 3731              		.loc 1 962 0
 3732 0002 0024     		movs	r4, #0
 3733              	.LVL374:
 3734              	.L282:
 962:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 3735              		.loc 1 962 0 is_stmt 0 discriminator 1
 3736 0004 002C     		cmp	r4, #0
 3737 0006 00DD     		ble	.L284
 968:Src/usb_pd_protocol.c **** 
 3738              		.loc 1 968 0 is_stmt 1
 3739              		@ sp needed
 3740              	.LVL375:
 3741 0008 10BD     		pop	{r4, pc}
 3742              	.LVL376:
 3743              	.L284:
 963:Src/usb_pd_protocol.c **** 			set_state(i, PD_STATE_SOFT_RESET);
 3744              		.loc 1 963 0
 3745 000a 2000     		movs	r0, r4
 3746 000c FFF7FEFF 		bl	pd_is_connected
 3747              	.LVL377:
 3748 0010 0028     		cmp	r0, #0
 3749 0012 01D1     		bne	.L285
 3750              	.L283:
 962:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 3751              		.loc 1 962 0 discriminator 2
 3752 0014 0134     		adds	r4, r4, #1
 3753              	.LVL378:
 3754 0016 F5E7     		b	.L282
 3755              	.L285:
 3756              	.LVL379:
 3757              	.LBB440:
 3758              	.LBB441:
 3759              	.LBB442:
 3760              	.LBB443:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3761              		.loc 1 283 0
 3762 0018 E201     		lsls	r2, r4, #7
 3763 001a 054B     		ldr	r3, .L286
 3764 001c 9B18     		adds	r3, r3, r2
 3765 001e 0020     		movs	r0, #0
 3766 0020 0021     		movs	r1, #0
 3767 0022 1861     		str	r0, [r3, #16]
ARM GAS  /tmp/ccWvVg6G.s 			page 111


 3768 0024 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 3769              		.loc 1 284 0
 3770 0026 0022     		movs	r2, #0
 3771 0028 DA71     		strb	r2, [r3, #7]
 3772              	.LVL380:
 3773              	.LBE443:
 3774              	.LBE442:
 352:Src/usb_pd_protocol.c **** 
 3775              		.loc 1 352 0
 3776 002a 1E32     		adds	r2, r2, #30
 3777 002c 1A71     		strb	r2, [r3, #4]
 3778              	.LVL381:
 3779 002e F1E7     		b	.L283
 3780              	.L287:
 3781              		.align	2
 3782              	.L286:
 3783 0030 00000000 		.word	pd
 3784              	.LBE441:
 3785              	.LBE440:
 3786              		.cfi_endproc
 3787              	.LFE37:
 3789              		.section	.text.pd_request_power_swap,"ax",%progbits
 3790              		.align	1
 3791              		.global	pd_request_power_swap
 3792              		.syntax unified
 3793              		.code	16
 3794              		.thumb_func
 3795              		.fpu softvfp
 3797              	pd_request_power_swap:
 3798              	.LFB41:
1216:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SRC_READY)
 3799              		.loc 1 1216 0
 3800              		.cfi_startproc
 3801              		@ args = 0, pretend = 0, frame = 0
 3802              		@ frame_needed = 0, uses_anonymous_args = 0
 3803              		@ link register save eliminated.
 3804              	.LVL382:
1217:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_SWAP_INIT);
 3805              		.loc 1 1217 0
 3806 0000 C201     		lsls	r2, r0, #7
 3807 0002 0F4B     		ldr	r3, .L293
 3808 0004 9B18     		adds	r3, r3, r2
 3809 0006 1B79     		ldrb	r3, [r3, #4]
 3810 0008 172B     		cmp	r3, #23
 3811 000a 02D0     		beq	.L291
1219:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_SWAP_INIT);
 3812              		.loc 1 1219 0
 3813 000c 082B     		cmp	r3, #8
 3814 000e 0BD0     		beq	.L292
 3815              	.LVL383:
 3816              	.L288:
1223:Src/usb_pd_protocol.c **** 
 3817              		.loc 1 1223 0
 3818              		@ sp needed
 3819 0010 7047     		bx	lr
 3820              	.LVL384:
ARM GAS  /tmp/ccWvVg6G.s 			page 112


 3821              	.L291:
 3822              	.LBB456:
 3823              	.LBB457:
 3824              	.LBB458:
 3825              	.LBB459:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3826              		.loc 1 283 0
 3827 0012 0B4B     		ldr	r3, .L293
 3828 0014 9818     		adds	r0, r3, r2
 3829              	.LVL385:
 3830 0016 0022     		movs	r2, #0
 3831 0018 0023     		movs	r3, #0
 3832 001a 0261     		str	r2, [r0, #16]
 3833 001c 4361     		str	r3, [r0, #20]
 284:Src/usb_pd_protocol.c **** }
 3834              		.loc 1 284 0
 3835 001e 0023     		movs	r3, #0
 3836 0020 C371     		strb	r3, [r0, #7]
 3837              	.LVL386:
 3838              	.LBE459:
 3839              	.LBE458:
 352:Src/usb_pd_protocol.c **** 
 3840              		.loc 1 352 0
 3841 0022 1A33     		adds	r3, r3, #26
 3842 0024 0371     		strb	r3, [r0, #4]
 3843 0026 F3E7     		b	.L288
 3844              	.LVL387:
 3845              	.L292:
 3846              	.LBE457:
 3847              	.LBE456:
 3848              	.LBB460:
 3849              	.LBB461:
 3850              	.LBB462:
 3851              	.LBB463:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3852              		.loc 1 283 0
 3853 0028 C001     		lsls	r0, r0, #7
 3854              	.LVL388:
 3855 002a 054B     		ldr	r3, .L293
 3856 002c 1818     		adds	r0, r3, r0
 3857 002e 0022     		movs	r2, #0
 3858 0030 0023     		movs	r3, #0
 3859 0032 0261     		str	r2, [r0, #16]
 3860 0034 4361     		str	r3, [r0, #20]
 284:Src/usb_pd_protocol.c **** }
 3861              		.loc 1 284 0
 3862 0036 0023     		movs	r3, #0
 3863 0038 C371     		strb	r3, [r0, #7]
 3864              	.LVL389:
 3865              	.LBE463:
 3866              	.LBE462:
 352:Src/usb_pd_protocol.c **** 
 3867              		.loc 1 352 0
 3868 003a 0933     		adds	r3, r3, #9
 3869 003c 0371     		strb	r3, [r0, #4]
 3870              	.LVL390:
 3871              	.LBE461:
ARM GAS  /tmp/ccWvVg6G.s 			page 113


 3872              	.LBE460:
1223:Src/usb_pd_protocol.c **** 
 3873              		.loc 1 1223 0
 3874 003e E7E7     		b	.L288
 3875              	.L294:
 3876              		.align	2
 3877              	.L293:
 3878 0040 00000000 		.word	pd
 3879              		.cfi_endproc
 3880              	.LFE41:
 3882              		.section	.text.pd_request_data_swap,"ax",%progbits
 3883              		.align	1
 3884              		.global	pd_request_data_swap
 3885              		.syntax unified
 3886              		.code	16
 3887              		.thumb_func
 3888              		.fpu softvfp
 3890              	pd_request_data_swap:
 3891              	.LFB42:
1250:Src/usb_pd_protocol.c **** 	if (DUAL_ROLE_IF_ELSE(port,
 3892              		.loc 1 1250 0
 3893              		.cfi_startproc
 3894              		@ args = 0, pretend = 0, frame = 0
 3895              		@ frame_needed = 0, uses_anonymous_args = 0
 3896              		@ link register save eliminated.
 3897              	.LVL391:
1251:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3898              		.loc 1 1251 0
 3899 0000 C201     		lsls	r2, r0, #7
 3900 0002 114B     		ldr	r3, .L300
 3901 0004 D35C     		ldrb	r3, [r2, r3]
 3902 0006 002B     		cmp	r3, #0
 3903 0008 09D1     		bne	.L296
1251:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3904              		.loc 1 1251 0 is_stmt 0 discriminator 1
 3905 000a 0F4B     		ldr	r3, .L300
 3906 000c 9B18     		adds	r3, r3, r2
 3907 000e 1B79     		ldrb	r3, [r3, #4]
 3908 0010 083B     		subs	r3, r3, #8
 3909 0012 5A42     		rsbs	r2, r3, #0
 3910 0014 5341     		adcs	r3, r3, r2
 3911 0016 DBB2     		uxtb	r3, r3
 3912              	.L297:
1251:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3913              		.loc 1 1251 0 discriminator 4
 3914 0018 002B     		cmp	r3, #0
 3915 001a 09D1     		bne	.L299
 3916              	.LVL392:
 3917              	.L295:
1257:Src/usb_pd_protocol.c **** 
 3918              		.loc 1 1257 0 is_stmt 1
 3919              		@ sp needed
 3920 001c 7047     		bx	lr
 3921              	.LVL393:
 3922              	.L296:
1251:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3923              		.loc 1 1251 0 discriminator 2
ARM GAS  /tmp/ccWvVg6G.s 			page 114


 3924 001e C201     		lsls	r2, r0, #7
 3925 0020 094B     		ldr	r3, .L300
 3926 0022 9B18     		adds	r3, r3, r2
 3927 0024 1B79     		ldrb	r3, [r3, #4]
 3928 0026 173B     		subs	r3, r3, #23
 3929 0028 5A42     		rsbs	r2, r3, #0
 3930 002a 5341     		adcs	r3, r3, r2
 3931 002c DBB2     		uxtb	r3, r3
 3932 002e F3E7     		b	.L297
 3933              	.L299:
 3934              	.LVL394:
 3935              	.LBB470:
 3936              	.LBB471:
 3937              	.LBB472:
 3938              	.LBB473:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3939              		.loc 1 283 0
 3940 0030 C001     		lsls	r0, r0, #7
 3941              	.LVL395:
 3942 0032 054B     		ldr	r3, .L300
 3943 0034 1818     		adds	r0, r3, r0
 3944 0036 0022     		movs	r2, #0
 3945 0038 0023     		movs	r3, #0
 3946 003a 0261     		str	r2, [r0, #16]
 3947 003c 4361     		str	r3, [r0, #20]
 284:Src/usb_pd_protocol.c **** }
 3948              		.loc 1 284 0
 3949 003e 0023     		movs	r3, #0
 3950 0040 C371     		strb	r3, [r0, #7]
 3951              	.LVL396:
 3952              	.LBE473:
 3953              	.LBE472:
 352:Src/usb_pd_protocol.c **** 
 3954              		.loc 1 352 0
 3955 0042 1933     		adds	r3, r3, #25
 3956 0044 0371     		strb	r3, [r0, #4]
 3957              	.LVL397:
 3958              	.LBE471:
 3959              	.LBE470:
1257:Src/usb_pd_protocol.c **** 
 3960              		.loc 1 1257 0
 3961 0046 E9E7     		b	.L295
 3962              	.L301:
 3963              		.align	2
 3964              	.L300:
 3965 0048 00000000 		.word	pd
 3966              		.cfi_endproc
 3967              	.LFE42:
 3969              		.section	.text.pd_send_vdm,"ax",%progbits
 3970              		.align	1
 3971              		.global	pd_send_vdm
 3972              		.syntax unified
 3973              		.code	16
 3974              		.thumb_func
 3975              		.fpu softvfp
 3977              	pd_send_vdm:
 3978              	.LFB47:
ARM GAS  /tmp/ccWvVg6G.s 			page 115


1589:Src/usb_pd_protocol.c **** 	if (count > VDO_MAX_SIZE - 1) {
 3979              		.loc 1 1589 0
 3980              		.cfi_startproc
 3981              		@ args = 4, pretend = 0, frame = 0
 3982              		@ frame_needed = 0, uses_anonymous_args = 0
 3983              	.LVL398:
 3984 0000 70B5     		push	{r4, r5, r6, lr}
 3985              	.LCFI29:
 3986              		.cfi_def_cfa_offset 16
 3987              		.cfi_offset 4, -16
 3988              		.cfi_offset 5, -12
 3989              		.cfi_offset 6, -8
 3990              		.cfi_offset 14, -4
 3991 0002 1D00     		movs	r5, r3
1590:Src/usb_pd_protocol.c **** 		CPRINTF("VDM over max size\n");
 3992              		.loc 1 1590 0
 3993 0004 049B     		ldr	r3, [sp, #16]
 3994              	.LVL399:
 3995 0006 062B     		cmp	r3, #6
 3996 0008 1CDC     		bgt	.L302
1596:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 3997              		.loc 1 1596 0
 3998 000a 0B04     		lsls	r3, r1, #16
 3999 000c FF24     		movs	r4, #255
 4000 000e 2402     		lsls	r4, r4, #8
 4001 0010 2140     		ands	r1, r4
 4002              	.LVL400:
 4003 0012 A142     		cmp	r1, r4
 4004 0014 05D0     		beq	.L305
1596:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4005              		.loc 1 1596 0 is_stmt 0 discriminator 2
 4006 0016 1F21     		movs	r1, #31
 4007 0018 1140     		ands	r1, r2
 4008 001a 0629     		cmp	r1, #6
 4009 001c 13DC     		bgt	.L306
1596:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4010              		.loc 1 1596 0
 4011 001e 0121     		movs	r1, #1
 4012 0020 00E0     		b	.L304
 4013              	.L305:
 4014 0022 0121     		movs	r1, #1
 4015              	.L304:
1596:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4016              		.loc 1 1596 0 discriminator 6
 4017 0024 C903     		lsls	r1, r1, #15
 4018 0026 1943     		orrs	r1, r3
 4019 0028 5304     		lsls	r3, r2, #17
 4020 002a 5B0C     		lsrs	r3, r3, #17
 4021 002c 0B43     		orrs	r3, r1
 4022 002e 074A     		ldr	r2, .L307
 4023              	.LVL401:
 4024 0030 C401     		lsls	r4, r0, #7
 4025 0032 1119     		adds	r1, r2, r4
 4026 0034 8B65     		str	r3, [r1, #88]
1601:Src/usb_pd_protocol.c **** 
 4027              		.loc 1 1601 0 is_stmt 1 discriminator 6
 4028 0036 2100     		movs	r1, r4
ARM GAS  /tmp/ccWvVg6G.s 			page 116


 4029 0038 5831     		adds	r1, r1, #88
 4030 003a 8918     		adds	r1, r1, r2
 4031 003c 049B     		ldr	r3, [sp, #16]
 4032 003e 2A00     		movs	r2, r5
 4033 0040 FFF7FEFF 		bl	queue_vdm
 4034              	.LVL402:
 4035              	.L302:
1605:Src/usb_pd_protocol.c **** 
 4036              		.loc 1 1605 0
 4037              		@ sp needed
 4038              	.LVL403:
 4039 0044 70BD     		pop	{r4, r5, r6, pc}
 4040              	.LVL404:
 4041              	.L306:
1596:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4042              		.loc 1 1596 0
 4043 0046 0021     		movs	r1, #0
 4044 0048 ECE7     		b	.L304
 4045              	.L308:
 4046 004a C046     		.align	2
 4047              	.L307:
 4048 004c 00000000 		.word	pd
 4049              		.cfi_endproc
 4050              	.LFE47:
 4052              		.section	.text.pd_dev_store_rw_hash,"ax",%progbits
 4053              		.align	1
 4054              		.global	pd_dev_store_rw_hash
 4055              		.syntax unified
 4056              		.code	16
 4057              		.thumb_func
 4058              		.fpu softvfp
 4060              	pd_dev_store_rw_hash:
 4061              	.LFB51:
1718:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 4062              		.loc 1 1718 0
 4063              		.cfi_startproc
 4064              		@ args = 0, pretend = 0, frame = 0
 4065              		@ frame_needed = 0, uses_anonymous_args = 0
 4066              		@ link register save eliminated.
 4067              	.LVL405:
1744:Src/usb_pd_protocol.c **** 
 4068              		.loc 1 1744 0
 4069 0000 0020     		movs	r0, #0
 4070              	.LVL406:
 4071              		@ sp needed
 4072 0002 7047     		bx	lr
 4073              		.cfi_endproc
 4074              	.LFE51:
 4076              		.section	.text.pd_get_dual_role,"ax",%progbits
 4077              		.align	1
 4078              		.global	pd_get_dual_role
 4079              		.syntax unified
 4080              		.code	16
 4081              		.thumb_func
 4082              		.fpu softvfp
 4084              	pd_get_dual_role:
 4085              	.LFB52:
ARM GAS  /tmp/ccWvVg6G.s 			page 117


1748:Src/usb_pd_protocol.c **** 	return drp_state;
 4086              		.loc 1 1748 0
 4087              		.cfi_startproc
 4088              		@ args = 0, pretend = 0, frame = 0
 4089              		@ frame_needed = 0, uses_anonymous_args = 0
 4090              		@ link register save eliminated.
1749:Src/usb_pd_protocol.c **** }
 4091              		.loc 1 1749 0
 4092 0000 014B     		ldr	r3, .L311
 4093 0002 1878     		ldrb	r0, [r3]
1750:Src/usb_pd_protocol.c **** 
 4094              		.loc 1 1750 0
 4095              		@ sp needed
 4096 0004 7047     		bx	lr
 4097              	.L312:
 4098 0006 C046     		.align	2
 4099              	.L311:
 4100 0008 00000000 		.word	.LANCHOR0
 4101              		.cfi_endproc
 4102              	.LFE52:
 4104              		.section	.text.pd_set_dual_role,"ax",%progbits
 4105              		.align	1
 4106              		.global	pd_set_dual_role
 4107              		.syntax unified
 4108              		.code	16
 4109              		.thumb_func
 4110              		.fpu softvfp
 4112              	pd_set_dual_role:
 4113              	.LFB53:
1792:Src/usb_pd_protocol.c **** 	int i;
 4114              		.loc 1 1792 0
 4115              		.cfi_startproc
 4116              		@ args = 0, pretend = 0, frame = 0
 4117              		@ frame_needed = 0, uses_anonymous_args = 0
 4118              		@ link register save eliminated.
 4119              	.LVL407:
1794:Src/usb_pd_protocol.c **** 
 4120              		.loc 1 1794 0
 4121 0000 034B     		ldr	r3, .L316
 4122 0002 1870     		strb	r0, [r3]
 4123              	.LVL408:
1801:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 4124              		.loc 1 1801 0
 4125 0004 0023     		movs	r3, #0
 4126              	.LVL409:
 4127              	.L314:
1801:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 4128              		.loc 1 1801 0 is_stmt 0 discriminator 1
 4129 0006 002B     		cmp	r3, #0
 4130 0008 00DD     		ble	.L315
1806:Src/usb_pd_protocol.c **** 
 4131              		.loc 1 1806 0 is_stmt 1
 4132              		@ sp needed
 4133 000a 7047     		bx	lr
 4134              	.L315:
1801:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 4135              		.loc 1 1801 0 discriminator 3
ARM GAS  /tmp/ccWvVg6G.s 			page 118


 4136 000c 0133     		adds	r3, r3, #1
 4137              	.LVL410:
 4138 000e FAE7     		b	.L314
 4139              	.L317:
 4140              		.align	2
 4141              	.L316:
 4142 0010 00000000 		.word	.LANCHOR0
 4143              		.cfi_endproc
 4144              	.LFE53:
 4146              		.section	.text.pd_update_dual_role_config,"ax",%progbits
 4147              		.align	1
 4148              		.global	pd_update_dual_role_config
 4149              		.syntax unified
 4150              		.code	16
 4151              		.thumb_func
 4152              		.fpu softvfp
 4154              	pd_update_dual_role_config:
 4155              	.LFB54:
1809:Src/usb_pd_protocol.c **** 	/*
 4156              		.loc 1 1809 0
 4157              		.cfi_startproc
 4158              		@ args = 0, pretend = 0, frame = 0
 4159              		@ frame_needed = 0, uses_anonymous_args = 0
 4160              	.LVL411:
 4161 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4162              	.LCFI30:
 4163              		.cfi_def_cfa_offset 24
 4164              		.cfi_offset 3, -24
 4165              		.cfi_offset 4, -20
 4166              		.cfi_offset 5, -16
 4167              		.cfi_offset 6, -12
 4168              		.cfi_offset 7, -8
 4169              		.cfi_offset 14, -4
 4170 0002 0400     		movs	r4, r0
1816:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
 4171              		.loc 1 1816 0
 4172 0004 C201     		lsls	r2, r0, #7
 4173 0006 414B     		ldr	r3, .L332
 4174 0008 D35C     		ldrb	r3, [r2, r3]
 4175 000a 012B     		cmp	r3, #1
 4176 000c 09D0     		beq	.L327
 4177              	.LVL412:
 4178              	.L319:
1831:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
 4179              		.loc 1 1831 0
 4180 000e E301     		lsls	r3, r4, #7
 4181 0010 3E4A     		ldr	r2, .L332
 4182 0012 9B5C     		ldrb	r3, [r3, r2]
 4183 0014 002B     		cmp	r3, #0
 4184 0016 03D1     		bne	.L318
1832:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
 4185              		.loc 1 1832 0 discriminator 1
 4186 0018 3D4B     		ldr	r3, .L332+4
 4187 001a 1B78     		ldrb	r3, [r3]
1831:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
 4188              		.loc 1 1831 0 discriminator 1
 4189 001c 042B     		cmp	r3, #4
ARM GAS  /tmp/ccWvVg6G.s 			page 119


 4190 001e 44D0     		beq	.L328
 4191              	.L318:
1843:Src/usb_pd_protocol.c **** 
 4192              		.loc 1 1843 0
 4193              		@ sp needed
 4194              	.LVL413:
 4195 0020 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4196              	.LVL414:
 4197              	.L327:
1817:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
 4198              		.loc 1 1817 0 discriminator 1
 4199 0022 3B4B     		ldr	r3, .L332+4
 4200 0024 1D78     		ldrb	r5, [r3]
1816:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
 4201              		.loc 1 1816 0 discriminator 1
 4202 0026 032D     		cmp	r5, #3
 4203 0028 08D0     		beq	.L329
 4204              	.LVL415:
 4205              	.L320:
1817:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
 4206              		.loc 1 1817 0 discriminator 1
 4207 002a 012D     		cmp	r5, #1
 4208 002c EFD1     		bne	.L319
1819:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SINK;
 4209              		.loc 1 1819 0
 4210 002e E201     		lsls	r2, r4, #7
 4211 0030 364B     		ldr	r3, .L332
 4212 0032 9B18     		adds	r3, r3, r2
 4213 0034 1B79     		ldrb	r3, [r3, #4]
 4214 0036 0E2B     		cmp	r3, #14
 4215 0038 E9D1     		bne	.L319
 4216 003a 03E0     		b	.L321
 4217              	.LVL416:
 4218              	.L329:
1817:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
 4219              		.loc 1 1817 0
 4220 003c FFF7FEFF 		bl	pd_ts_dts_plugged
 4221              	.LVL417:
 4222 0040 0028     		cmp	r0, #0
 4223 0042 F2D1     		bne	.L320
 4224              	.L321:
1820:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_DISCONNECTED);
 4225              		.loc 1 1820 0
 4226 0044 314B     		ldr	r3, .L332
 4227 0046 E201     		lsls	r2, r4, #7
 4228 0048 0021     		movs	r1, #0
 4229 004a D154     		strb	r1, [r2, r3]
 4230              	.LVL418:
 4231              	.LBB490:
 4232              	.LBB491:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4233              		.loc 1 346 0
 4234 004c 9B18     		adds	r3, r3, r2
 4235 004e 1A79     		ldrb	r2, [r3, #4]
 4236              	.LVL419:
 4237              	.LBB492:
 4238              	.LBB493:
ARM GAS  /tmp/ccWvVg6G.s 			page 120


 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4239              		.loc 1 283 0
 4240 0050 0026     		movs	r6, #0
 4241 0052 0027     		movs	r7, #0
 4242 0054 1E61     		str	r6, [r3, #16]
 4243 0056 5F61     		str	r7, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 4244              		.loc 1 284 0
 4245 0058 D971     		strb	r1, [r3, #7]
 4246              	.LVL420:
 4247              	.LBE493:
 4248              	.LBE492:
 352:Src/usb_pd_protocol.c **** 
 4249              		.loc 1 352 0
 4250 005a 0231     		adds	r1, r1, #2
 4251 005c 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 4252              		.loc 1 354 0
 4253 005e 022A     		cmp	r2, #2
 4254 0060 13D0     		beq	.L322
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 4255              		.loc 1 366 0
 4256 0062 0E2A     		cmp	r2, #14
 4257 0064 11D0     		beq	.L322
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 4258              		.loc 1 374 0
 4259 0066 0022     		movs	r2, #0
 4260              	.LVL421:
 4261 0068 0021     		movs	r1, #0
 4262 006a 2000     		movs	r0, r4
 4263 006c FFF7FEFF 		bl	pd_set_input_current_limit
 4264              	.LVL422:
 391:Src/usb_pd_protocol.c **** 			/*
 4265              		.loc 1 391 0
 4266 0070 E301     		lsls	r3, r4, #7
 4267 0072 264A     		ldr	r2, .L332
 4268 0074 9B5C     		ldrb	r3, [r3, r2]
 4269 0076 012B     		cmp	r3, #1
 4270 0078 13D0     		beq	.L330
 4271              	.L323:
 4272              	.LVL423:
 4273              	.LBB494:
 4274              	.LBB495:
  92:Inc/tcpm.h    **** }
 4275              		.loc 2 92 0
 4276 007a 2201     		lsls	r2, r4, #4
 4277 007c 254B     		ldr	r3, .L332+8
 4278 007e 9B18     		adds	r3, r3, r2
 4279 0080 9B68     		ldr	r3, [r3, #8]
 4280 0082 5B6A     		ldr	r3, [r3, #36]
 4281 0084 0021     		movs	r1, #0
 4282 0086 2000     		movs	r0, r4
 4283 0088 9847     		blx	r3
 4284              	.LVL424:
 4285              	.L322:
 4286              	.LBE495:
 4287              	.LBE494:
ARM GAS  /tmp/ccWvVg6G.s 			page 121


 4288              	.LBE491:
 4289              	.LBE490:
 4290              	.LBB497:
 4291              	.LBB498:
  71:Inc/tcpm.h    **** }
 4292              		.loc 2 71 0
 4293 008a 2201     		lsls	r2, r4, #4
 4294 008c 214B     		ldr	r3, .L332+8
 4295 008e 9B18     		adds	r3, r3, r2
 4296 0090 9B68     		ldr	r3, [r3, #8]
 4297 0092 5B69     		ldr	r3, [r3, #20]
 4298 0094 0221     		movs	r1, #2
 4299 0096 2000     		movs	r0, r4
 4300 0098 9847     		blx	r3
 4301              	.LVL425:
 4302              	.LBE498:
 4303              	.LBE497:
1824:Src/usb_pd_protocol.c **** 	}
 4304              		.loc 1 1824 0
 4305 009a 2000     		movs	r0, r4
 4306 009c FFF7FEFF 		bl	pd_power_supply_reset
 4307              	.LVL426:
 4308 00a0 B5E7     		b	.L319
 4309              	.LVL427:
 4310              	.L330:
 4311              	.LBB499:
 4312              	.LBB496:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 4313              		.loc 1 396 0
 4314 00a2 2000     		movs	r0, r4
 4315 00a4 FFF7FEFF 		bl	pd_power_supply_reset
 4316              	.LVL428:
 4317 00a8 E7E7     		b	.L323
 4318              	.LVL429:
 4319              	.L328:
 4320              	.LBE496:
 4321              	.LBE499:
1833:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCONNECTED);
 4322              		.loc 1 1833 0
 4323 00aa 1300     		movs	r3, r2
 4324 00ac E201     		lsls	r2, r4, #7
 4325 00ae 0121     		movs	r1, #1
 4326 00b0 D154     		strb	r1, [r2, r3]
 4327              	.LVL430:
 4328              	.LBB500:
 4329              	.LBB501:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4330              		.loc 1 346 0
 4331 00b2 9B18     		adds	r3, r3, r2
 4332 00b4 1A79     		ldrb	r2, [r3, #4]
 4333              	.LVL431:
 4334              	.LBB502:
 4335              	.LBB503:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4336              		.loc 1 283 0
 4337 00b6 0020     		movs	r0, #0
 4338 00b8 0021     		movs	r1, #0
ARM GAS  /tmp/ccWvVg6G.s 			page 122


 4339 00ba 1861     		str	r0, [r3, #16]
 4340 00bc 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 4341              		.loc 1 284 0
 4342 00be 0021     		movs	r1, #0
 4343 00c0 D971     		strb	r1, [r3, #7]
 4344              	.LVL432:
 4345              	.LBE503:
 4346              	.LBE502:
 352:Src/usb_pd_protocol.c **** 
 4347              		.loc 1 352 0
 4348 00c2 0E31     		adds	r1, r1, #14
 4349 00c4 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 4350              		.loc 1 354 0
 4351 00c6 0E2A     		cmp	r2, #14
 4352 00c8 13D0     		beq	.L325
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 4353              		.loc 1 365 0
 4354 00ca 022A     		cmp	r2, #2
 4355 00cc 11D0     		beq	.L325
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 4356              		.loc 1 374 0
 4357 00ce 0022     		movs	r2, #0
 4358              	.LVL433:
 4359 00d0 0021     		movs	r1, #0
 4360 00d2 2000     		movs	r0, r4
 4361 00d4 FFF7FEFF 		bl	pd_set_input_current_limit
 4362              	.LVL434:
 391:Src/usb_pd_protocol.c **** 			/*
 4363              		.loc 1 391 0
 4364 00d8 E301     		lsls	r3, r4, #7
 4365 00da 0C4A     		ldr	r2, .L332
 4366 00dc 9B5C     		ldrb	r3, [r3, r2]
 4367 00de 012B     		cmp	r3, #1
 4368 00e0 10D0     		beq	.L331
 4369              	.L326:
 4370              	.LVL435:
 4371              	.LBB504:
 4372              	.LBB505:
  92:Inc/tcpm.h    **** }
 4373              		.loc 2 92 0
 4374 00e2 2201     		lsls	r2, r4, #4
 4375 00e4 0B4B     		ldr	r3, .L332+8
 4376 00e6 9B18     		adds	r3, r3, r2
 4377 00e8 9B68     		ldr	r3, [r3, #8]
 4378 00ea 5B6A     		ldr	r3, [r3, #36]
 4379 00ec 0021     		movs	r1, #0
 4380 00ee 2000     		movs	r0, r4
 4381 00f0 9847     		blx	r3
 4382              	.LVL436:
 4383              	.L325:
 4384              	.LBE505:
 4385              	.LBE504:
 4386              	.LBE501:
 4387              	.LBE500:
 4388              	.LBB507:
ARM GAS  /tmp/ccWvVg6G.s 			page 123


 4389              	.LBB508:
  71:Inc/tcpm.h    **** }
 4390              		.loc 2 71 0
 4391 00f2 2201     		lsls	r2, r4, #4
 4392 00f4 074B     		ldr	r3, .L332+8
 4393 00f6 9B18     		adds	r3, r3, r2
 4394 00f8 9B68     		ldr	r3, [r3, #8]
 4395 00fa 5B69     		ldr	r3, [r3, #20]
 4396 00fc 0121     		movs	r1, #1
 4397 00fe 2000     		movs	r0, r4
 4398 0100 9847     		blx	r3
 4399              	.LVL437:
 4400              	.LBE508:
 4401              	.LBE507:
1843:Src/usb_pd_protocol.c **** 
 4402              		.loc 1 1843 0
 4403 0102 8DE7     		b	.L318
 4404              	.LVL438:
 4405              	.L331:
 4406              	.LBB509:
 4407              	.LBB506:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 4408              		.loc 1 396 0
 4409 0104 2000     		movs	r0, r4
 4410 0106 FFF7FEFF 		bl	pd_power_supply_reset
 4411              	.LVL439:
 4412 010a EAE7     		b	.L326
 4413              	.L333:
 4414              		.align	2
 4415              	.L332:
 4416 010c 00000000 		.word	pd
 4417 0110 00000000 		.word	.LANCHOR0
 4418 0114 00000000 		.word	tcpc_config
 4419              	.LBE506:
 4420              	.LBE509:
 4421              		.cfi_endproc
 4422              	.LFE54:
 4424              		.section	.text.pd_get_role,"ax",%progbits
 4425              		.align	1
 4426              		.global	pd_get_role
 4427              		.syntax unified
 4428              		.code	16
 4429              		.thumb_func
 4430              		.fpu softvfp
 4432              	pd_get_role:
 4433              	.LFB55:
1846:Src/usb_pd_protocol.c **** 	return pd[port].power_role;
 4434              		.loc 1 1846 0
 4435              		.cfi_startproc
 4436              		@ args = 0, pretend = 0, frame = 0
 4437              		@ frame_needed = 0, uses_anonymous_args = 0
 4438              		@ link register save eliminated.
 4439              	.LVL440:
1847:Src/usb_pd_protocol.c **** }
 4440              		.loc 1 1847 0
 4441 0000 C001     		lsls	r0, r0, #7
 4442              	.LVL441:
ARM GAS  /tmp/ccWvVg6G.s 			page 124


 4443 0002 014B     		ldr	r3, .L335
 4444 0004 C05C     		ldrb	r0, [r0, r3]
1848:Src/usb_pd_protocol.c **** 
 4445              		.loc 1 1848 0
 4446              		@ sp needed
 4447 0006 7047     		bx	lr
 4448              	.L336:
 4449              		.align	2
 4450              	.L335:
 4451 0008 00000000 		.word	pd
 4452              		.cfi_endproc
 4453              	.LFE55:
 4455              		.section	.text.pd_get_polarity,"ax",%progbits
 4456              		.align	1
 4457              		.global	pd_get_polarity
 4458              		.syntax unified
 4459              		.code	16
 4460              		.thumb_func
 4461              		.fpu softvfp
 4463              	pd_get_polarity:
 4464              	.LFB58:
1895:Src/usb_pd_protocol.c **** 	return pd[port].polarity;
 4465              		.loc 1 1895 0
 4466              		.cfi_startproc
 4467              		@ args = 0, pretend = 0, frame = 0
 4468              		@ frame_needed = 0, uses_anonymous_args = 0
 4469              		@ link register save eliminated.
 4470              	.LVL442:
1896:Src/usb_pd_protocol.c **** }
 4471              		.loc 1 1896 0
 4472 0000 C301     		lsls	r3, r0, #7
 4473 0002 0248     		ldr	r0, .L338
 4474              	.LVL443:
 4475 0004 C018     		adds	r0, r0, r3
 4476 0006 C078     		ldrb	r0, [r0, #3]
1897:Src/usb_pd_protocol.c **** 
 4477              		.loc 1 1897 0
 4478              		@ sp needed
 4479 0008 7047     		bx	lr
 4480              	.L339:
 4481 000a C046     		.align	2
 4482              	.L338:
 4483 000c 00000000 		.word	pd
 4484              		.cfi_endproc
 4485              	.LFE58:
 4487              		.section	.text.pd_get_partner_data_swap_capable,"ax",%progbits
 4488              		.align	1
 4489              		.global	pd_get_partner_data_swap_capable
 4490              		.syntax unified
 4491              		.code	16
 4492              		.thumb_func
 4493              		.fpu softvfp
 4495              	pd_get_partner_data_swap_capable:
 4496              	.LFB59:
1900:Src/usb_pd_protocol.c **** 	/* return data swap capable status of port partner */
 4497              		.loc 1 1900 0
 4498              		.cfi_startproc
ARM GAS  /tmp/ccWvVg6G.s 			page 125


 4499              		@ args = 0, pretend = 0, frame = 0
 4500              		@ frame_needed = 0, uses_anonymous_args = 0
 4501              		@ link register save eliminated.
 4502              	.LVL444:
1902:Src/usb_pd_protocol.c **** }
 4503              		.loc 1 1902 0
 4504 0000 C301     		lsls	r3, r0, #7
 4505 0002 0348     		ldr	r0, .L341
 4506              	.LVL445:
 4507 0004 C018     		adds	r0, r0, r3
 4508 0006 8368     		ldr	r3, [r0, #8]
 4509 0008 0420     		movs	r0, #4
 4510 000a 1840     		ands	r0, r3
1903:Src/usb_pd_protocol.c **** 
 4511              		.loc 1 1903 0
 4512              		@ sp needed
 4513 000c 7047     		bx	lr
 4514              	.L342:
 4515 000e C046     		.align	2
 4516              	.L341:
 4517 0010 00000000 		.word	pd
 4518              		.cfi_endproc
 4519              	.LFE59:
 4521              		.section	.text.pd_ping_enable,"ax",%progbits
 4522              		.align	1
 4523              		.global	pd_ping_enable
 4524              		.syntax unified
 4525              		.code	16
 4526              		.thumb_func
 4527              		.fpu softvfp
 4529              	pd_ping_enable:
 4530              	.LFB60:
1929:Src/usb_pd_protocol.c **** 	if (enable)
 4531              		.loc 1 1929 0
 4532              		.cfi_startproc
 4533              		@ args = 0, pretend = 0, frame = 0
 4534              		@ frame_needed = 0, uses_anonymous_args = 0
 4535              		@ link register save eliminated.
 4536              	.LVL446:
1930:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PING_ENABLED;
 4537              		.loc 1 1930 0
 4538 0000 0029     		cmp	r1, #0
 4539 0002 07D1     		bne	.L346
1933:Src/usb_pd_protocol.c **** }
 4540              		.loc 1 1933 0
 4541 0004 C001     		lsls	r0, r0, #7
 4542              	.LVL447:
 4543 0006 074B     		ldr	r3, .L347
 4544 0008 1818     		adds	r0, r3, r0
 4545 000a 0123     		movs	r3, #1
 4546 000c 8268     		ldr	r2, [r0, #8]
 4547 000e 9A43     		bics	r2, r3
 4548 0010 8260     		str	r2, [r0, #8]
 4549              	.L343:
1934:Src/usb_pd_protocol.c **** 
 4550              		.loc 1 1934 0
 4551              		@ sp needed
ARM GAS  /tmp/ccWvVg6G.s 			page 126


 4552 0012 7047     		bx	lr
 4553              	.LVL448:
 4554              	.L346:
1931:Src/usb_pd_protocol.c **** 	else
 4555              		.loc 1 1931 0
 4556 0014 C001     		lsls	r0, r0, #7
 4557              	.LVL449:
 4558 0016 034B     		ldr	r3, .L347
 4559 0018 1818     		adds	r0, r3, r0
 4560 001a 0123     		movs	r3, #1
 4561 001c 8268     		ldr	r2, [r0, #8]
 4562 001e 1343     		orrs	r3, r2
 4563 0020 8360     		str	r3, [r0, #8]
 4564 0022 F6E7     		b	.L343
 4565              	.L348:
 4566              		.align	2
 4567              	.L347:
 4568 0024 00000000 		.word	pd
 4569              		.cfi_endproc
 4570              	.LFE60:
 4572              		.section	.text.pd_set_new_power_request,"ax",%progbits
 4573              		.align	1
 4574              		.global	pd_set_new_power_request
 4575              		.syntax unified
 4576              		.code	16
 4577              		.thumb_func
 4578              		.fpu softvfp
 4580              	pd_set_new_power_request:
 4581              	.LFB64:
1998:Src/usb_pd_protocol.c **** 	pd[port].new_power_request = 1;
 4582              		.loc 1 1998 0
 4583              		.cfi_startproc
 4584              		@ args = 0, pretend = 0, frame = 0
 4585              		@ frame_needed = 0, uses_anonymous_args = 0
 4586              		@ link register save eliminated.
 4587              	.LVL450:
1999:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
 4588              		.loc 1 1999 0
 4589 0000 C301     		lsls	r3, r0, #7
 4590 0002 0248     		ldr	r0, .L350
 4591              	.LVL451:
 4592 0004 C018     		adds	r0, r0, r3
 4593 0006 0123     		movs	r3, #1
 4594 0008 8363     		str	r3, [r0, #56]
2002:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
 4595              		.loc 1 2002 0
 4596              		@ sp needed
 4597 000a 7047     		bx	lr
 4598              	.L351:
 4599              		.align	2
 4600              	.L350:
 4601 000c 00000000 		.word	pd
 4602              		.cfi_endproc
 4603              	.LFE64:
 4605              		.section	.text.pd_init,"ax",%progbits
 4606              		.align	1
 4607              		.global	pd_init
ARM GAS  /tmp/ccWvVg6G.s 			page 127


 4608              		.syntax unified
 4609              		.code	16
 4610              		.thumb_func
 4611              		.fpu softvfp
 4613              	pd_init:
 4614              	.LFB66:
2061:Src/usb_pd_protocol.c **** #endif
2062:Src/usb_pd_protocol.c **** 
2063:Src/usb_pd_protocol.c **** void pd_init(int port)
2064:Src/usb_pd_protocol.c **** {
 4615              		.loc 1 2064 0
 4616              		.cfi_startproc
 4617              		@ args = 0, pretend = 0, frame = 8
 4618              		@ frame_needed = 0, uses_anonymous_args = 0
 4619              	.LVL452:
 4620 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4621              	.LCFI31:
 4622              		.cfi_def_cfa_offset 20
 4623              		.cfi_offset 4, -20
 4624              		.cfi_offset 5, -16
 4625              		.cfi_offset 6, -12
 4626              		.cfi_offset 7, -8
 4627              		.cfi_offset 14, -4
 4628 0002 CE46     		mov	lr, r9
 4629 0004 4746     		mov	r7, r8
 4630 0006 80B5     		push	{r7, lr}
 4631              	.LCFI32:
 4632              		.cfi_def_cfa_offset 28
 4633              		.cfi_offset 8, -28
 4634              		.cfi_offset 9, -24
 4635 0008 83B0     		sub	sp, sp, #12
 4636              	.LCFI33:
 4637              		.cfi_def_cfa_offset 40
 4638 000a 0400     		movs	r4, r0
2065:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
2066:Src/usb_pd_protocol.c **** 	pd_init_tasks();
2067:Src/usb_pd_protocol.c **** #endif
2068:Src/usb_pd_protocol.c **** 
2069:Src/usb_pd_protocol.c **** 	/* Ensure the power supply is in the default state */
2070:Src/usb_pd_protocol.c **** 	pd_power_supply_reset(port);
 4639              		.loc 1 2070 0
 4640 000c FFF7FEFF 		bl	pd_power_supply_reset
 4641              	.LVL453:
 4642              	.LBB527:
 4643              	.LBB528:
  38:Inc/tcpm.h    **** 	if (rv)
 4644              		.loc 2 38 0
 4645 0010 2201     		lsls	r2, r4, #4
 4646 0012 3C4B     		ldr	r3, .L366
 4647 0014 9B18     		adds	r3, r3, r2
 4648 0016 9B68     		ldr	r3, [r3, #8]
 4649 0018 1B68     		ldr	r3, [r3]
 4650 001a 2000     		movs	r0, r4
 4651 001c 9847     		blx	r3
 4652              	.LVL454:
  39:Inc/tcpm.h    **** 		return rv;
 4653              		.loc 2 39 0
ARM GAS  /tmp/ccWvVg6G.s 			page 128


 4654 001e 0028     		cmp	r0, #0
 4655 0020 05D1     		bne	.L353
  43:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
 4656              		.loc 2 43 0
 4657 0022 394B     		ldr	r3, .L366+4
 4658 0024 002B     		cmp	r3, #0
 4659 0026 02D0     		beq	.L353
  44:Inc/tcpm.h    **** 
 4660              		.loc 2 44 0
 4661 0028 2000     		movs	r0, r4
 4662              	.LVL455:
 4663 002a FFF7FEFF 		bl	board_tcpc_post_init
 4664              	.LVL456:
 4665              	.L353:
 4666              	.LBE528:
 4667              	.LBE527:
2071:Src/usb_pd_protocol.c **** 
2072:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC_BOARD_INIT
2073:Src/usb_pd_protocol.c **** 	/* Board specific TCPC init */
2074:Src/usb_pd_protocol.c **** 	board_tcpc_init();
2075:Src/usb_pd_protocol.c **** #endif
2076:Src/usb_pd_protocol.c **** 
2077:Src/usb_pd_protocol.c **** 	/* Initialize TCPM driver and wait for TCPC to be ready */
2078:Src/usb_pd_protocol.c **** 	res = tcpm_init(port);
2079:Src/usb_pd_protocol.c **** 
2080:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2081:Src/usb_pd_protocol.c **** 	//pd_partner_port_reset(port);
2082:Src/usb_pd_protocol.c **** #endif
2083:Src/usb_pd_protocol.c **** 
2084:Src/usb_pd_protocol.c **** 	CPRINTS("TCPC p%d init %s", port, res ? "failed" : "ready");
2085:Src/usb_pd_protocol.c **** 	this_state = res ? PD_STATE_SUSPENDED : PD_DEFAULT_STATE(port);
 4668              		.loc 1 2085 0
 4669 002e 0028     		cmp	r0, #0
 4670 0030 5CD0     		beq	.L362
 4671 0032 0122     		movs	r2, #1
 4672              	.L354:
 4673              		.loc 1 2085 0 is_stmt 0 discriminator 4
 4674 0034 354B     		ldr	r3, .L366+8
 4675 0036 1A70     		strb	r2, [r3]
2086:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
2087:Src/usb_pd_protocol.c **** 	if (!res) {
 4676              		.loc 1 2087 0 is_stmt 1 discriminator 4
 4677 0038 0028     		cmp	r0, #0
 4678 003a 0AD1     		bne	.L355
 4679              	.LVL457:
 4680              	.LBB529:
 4681              	.LBB530:
 4682              	.LBB531:
 104:Inc/tcpm.h    **** }
 105:Inc/tcpm.h    **** 
 106:Inc/tcpm.h    **** static inline void tcpc_alert(int port)
 107:Inc/tcpm.h    **** {
 108:Inc/tcpm.h    **** 	tcpc_config[port].drv->tcpc_alert(port);
 109:Inc/tcpm.h    **** }
 110:Inc/tcpm.h    **** 
 111:Inc/tcpm.h    **** static inline void tcpc_discharge_vbus(int port, int enable)
 112:Inc/tcpm.h    **** {
ARM GAS  /tmp/ccWvVg6G.s 			page 129


 113:Inc/tcpm.h    **** 	tcpc_config[port].drv->tcpc_discharge_vbus(port, enable);
 114:Inc/tcpm.h    **** }
 115:Inc/tcpm.h    **** 
 116:Inc/tcpm.h    **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 117:Inc/tcpm.h    **** static inline int tcpm_auto_toggle_supported(int port)
 118:Inc/tcpm.h    **** {
 119:Inc/tcpm.h    **** 	return !!tcpc_config[port].drv->drp_toggle;
 120:Inc/tcpm.h    **** }
 121:Inc/tcpm.h    **** 
 122:Inc/tcpm.h    **** static inline int tcpm_set_drp_toggle(int port, int enable)
 123:Inc/tcpm.h    **** {
 124:Inc/tcpm.h    **** 	return tcpc_config[port].drv->drp_toggle(port, enable);
 125:Inc/tcpm.h    **** }
 126:Inc/tcpm.h    **** #endif
 127:Inc/tcpm.h    **** 
 128:Inc/tcpm.h    **** #ifdef CONFIG_CMD_I2C_STRESS_TEST_TCPC
 129:Inc/tcpm.h    **** static inline int tcpc_i2c_read(const int port, const int addr,
 130:Inc/tcpm.h    **** 				const int reg, int *data)
 131:Inc/tcpm.h    **** {
 132:Inc/tcpm.h    **** 	return tcpc_read(port, reg, data);
 133:Inc/tcpm.h    **** }
 134:Inc/tcpm.h    **** 
 135:Inc/tcpm.h    **** static inline int tcpc_i2c_write(const int port, const int addr,
 136:Inc/tcpm.h    **** 				 const int reg, int data)
 137:Inc/tcpm.h    **** {
 138:Inc/tcpm.h    **** 	return tcpc_write(port, reg, data);
 139:Inc/tcpm.h    **** }
 140:Inc/tcpm.h    **** #endif
 141:Inc/tcpm.h    **** 
 142:Inc/tcpm.h    **** static inline int tcpm_get_chip_info(int port, int renew,
 143:Inc/tcpm.h    **** 				     struct ec_response_pd_chip_info **info)
 144:Inc/tcpm.h    **** {
 145:Inc/tcpm.h    **** 	if (tcpc_config[port].drv->get_chip_info)
 4683              		.loc 2 145 0
 4684 003c 2201     		lsls	r2, r4, #4
 4685 003e 314B     		ldr	r3, .L366
 4686 0040 9B18     		adds	r3, r3, r2
 4687 0042 9B68     		ldr	r3, [r3, #8]
 4688 0044 9B6B     		ldr	r3, [r3, #56]
 4689 0046 002B     		cmp	r3, #0
 4690 0048 03D0     		beq	.L355
 146:Inc/tcpm.h    **** 		return tcpc_config[port].drv->get_chip_info(port, renew, info);
 4691              		.loc 2 146 0
 4692 004a 01AA     		add	r2, sp, #4
 4693              	.LVL458:
 4694 004c 0021     		movs	r1, #0
 4695 004e 2000     		movs	r0, r4
 4696 0050 9847     		blx	r3
 4697              	.LVL459:
 4698              	.L355:
 4699              	.LBE531:
 4700              	.LBE530:
 4701              	.LBE529:
2088:Src/usb_pd_protocol.c **** 		struct ec_response_pd_chip_info *info;
2089:Src/usb_pd_protocol.c **** 		tcpm_get_chip_info(port, 0, &info);
2090:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d VID:0x%x PID:0x%x DID:0x%x FWV:0x%lx",
2091:Src/usb_pd_protocol.c **** 			port, info->vendor_id, info->product_id,
ARM GAS  /tmp/ccWvVg6G.s 			page 130


2092:Src/usb_pd_protocol.c **** 			info->device_id, info->fw_version_number);
2093:Src/usb_pd_protocol.c **** 	}
2094:Src/usb_pd_protocol.c **** #endif
2095:Src/usb_pd_protocol.c **** 
2096:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
2097:Src/usb_pd_protocol.c **** 	/* Set Revision to highest */
2098:Src/usb_pd_protocol.c **** 	pd[port].rev = PD_REV30;
2099:Src/usb_pd_protocol.c **** 	pd_ca_reset(port);
2100:Src/usb_pd_protocol.c **** #endif
2101:Src/usb_pd_protocol.c **** 
2102:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2103:Src/usb_pd_protocol.c **** 	/*
2104:Src/usb_pd_protocol.c **** 	 * If VBUS is high, then initialize flag for VBUS has always been
2105:Src/usb_pd_protocol.c **** 	 * present. This flag is used to maintain a PD connection after a
2106:Src/usb_pd_protocol.c **** 	 * reset by sending a soft reset.
2107:Src/usb_pd_protocol.c **** 	 */
2108:Src/usb_pd_protocol.c **** 	//pd[port].flags = pd_is_vbus_present(port) ? PD_FLAGS_VBUS_NEVER_LOW : 0;
2109:Src/usb_pd_protocol.c **** 	pd[port].flags = 0;
 4702              		.loc 1 2109 0
 4703 0052 2F4B     		ldr	r3, .L366+12
 4704 0054 9846     		mov	r8, r3
 4705 0056 E301     		lsls	r3, r4, #7
 4706 0058 9946     		mov	r9, r3
 4707 005a 4546     		mov	r5, r8
 4708 005c 4D44     		add	r5, r5, r9
 4709 005e 0026     		movs	r6, #0
 4710 0060 AE60     		str	r6, [r5, #8]
 4711              	.LVL460:
 4712              	.LBB532:
 4713              	.LBB533:
  92:Inc/tcpm.h    **** }
 4714              		.loc 2 92 0
 4715 0062 2201     		lsls	r2, r4, #4
 4716 0064 274B     		ldr	r3, .L366
 4717 0066 9B18     		adds	r3, r3, r2
 4718 0068 9F68     		ldr	r7, [r3, #8]
 4719 006a 0021     		movs	r1, #0
 4720 006c 2000     		movs	r0, r4
 4721 006e 7B6A     		ldr	r3, [r7, #36]
 4722 0070 9847     		blx	r3
 4723              	.LVL461:
 4724              	.LBE533:
 4725              	.LBE532:
2110:Src/usb_pd_protocol.c **** #endif
2111:Src/usb_pd_protocol.c **** 
2112:Src/usb_pd_protocol.c **** 	/* Disable TCPC RX until connection is established */
2113:Src/usb_pd_protocol.c **** 	tcpm_set_rx_enable(port, 0);
2114:Src/usb_pd_protocol.c **** 
2115:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
2116:Src/usb_pd_protocol.c **** 	/* Initialize USB mux to its default state */
2117:Src/usb_pd_protocol.c **** 	usb_mux_init(port);
2118:Src/usb_pd_protocol.c **** #endif
2119:Src/usb_pd_protocol.c **** 
2120:Src/usb_pd_protocol.c **** 	/* Initialize PD protocol state variables for each port. */
2121:Src/usb_pd_protocol.c **** 	pd[port].power_role = PD_ROLE_DEFAULT(port);
 4726              		.loc 1 2121 0
 4727 0072 4346     		mov	r3, r8
ARM GAS  /tmp/ccWvVg6G.s 			page 131


 4728 0074 4A46     		mov	r2, r9
 4729 0076 D654     		strb	r6, [r2, r3]
2122:Src/usb_pd_protocol.c **** 	pd[port].vdm_state = VDM_STATE_DONE;
 4730              		.loc 1 2122 0
 4731 0078 2B00     		movs	r3, r5
 4732 007a 4833     		adds	r3, r3, #72
 4733 007c 1E70     		strb	r6, [r3]
2123:Src/usb_pd_protocol.c **** 	set_state(port, this_state);
 4734              		.loc 1 2123 0
 4735 007e 234B     		ldr	r3, .L366+8
 4736 0080 1B78     		ldrb	r3, [r3]
 4737              	.LVL462:
 4738              	.LBB534:
 4739              	.LBB535:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4740              		.loc 1 346 0
 4741 0082 2A79     		ldrb	r2, [r5, #4]
 4742              	.LVL463:
 4743              	.LBB536:
 4744              	.LBB537:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4745              		.loc 1 283 0
 4746 0084 0020     		movs	r0, #0
 4747 0086 0021     		movs	r1, #0
 4748 0088 2861     		str	r0, [r5, #16]
 4749 008a 6961     		str	r1, [r5, #20]
 284:Src/usb_pd_protocol.c **** }
 4750              		.loc 1 284 0
 4751 008c EE71     		strb	r6, [r5, #7]
 4752              	.LVL464:
 4753              	.LBE537:
 4754              	.LBE536:
 352:Src/usb_pd_protocol.c **** 
 4755              		.loc 1 352 0
 4756 008e 2B71     		strb	r3, [r5, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 4757              		.loc 1 354 0
 4758 0090 9342     		cmp	r3, r2
 4759 0092 19D0     		beq	.L357
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 4760              		.loc 1 365 0
 4761 0094 022A     		cmp	r2, #2
 4762 0096 2BD0     		beq	.L363
 4763              	.L358:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 4764              		.loc 1 366 0
 4765 0098 0E2A     		cmp	r2, #14
 4766 009a 2CD0     		beq	.L364
 4767              	.L359:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 4768              		.loc 1 371 0
 4769 009c 0E2B     		cmp	r3, #14
 4770 009e 01D0     		beq	.L360
 4771 00a0 022B     		cmp	r3, #2
 4772 00a2 11D1     		bne	.L357
 4773              	.L360:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
ARM GAS  /tmp/ccWvVg6G.s 			page 132


 4774              		.loc 1 374 0
 4775 00a4 0022     		movs	r2, #0
 4776              	.LVL465:
 4777 00a6 0021     		movs	r1, #0
 4778 00a8 2000     		movs	r0, r4
 4779 00aa FFF7FEFF 		bl	pd_set_input_current_limit
 4780              	.LVL466:
 391:Src/usb_pd_protocol.c **** 			/*
 4781              		.loc 1 391 0
 4782 00ae E301     		lsls	r3, r4, #7
 4783 00b0 174A     		ldr	r2, .L366+12
 4784 00b2 9B5C     		ldrb	r3, [r3, r2]
 4785 00b4 012B     		cmp	r3, #1
 4786 00b6 21D0     		beq	.L365
 4787              	.L361:
 4788              	.LVL467:
 4789              	.LBB538:
 4790              	.LBB539:
  92:Inc/tcpm.h    **** }
 4791              		.loc 2 92 0
 4792 00b8 2201     		lsls	r2, r4, #4
 4793 00ba 124B     		ldr	r3, .L366
 4794 00bc 9B18     		adds	r3, r3, r2
 4795 00be 9B68     		ldr	r3, [r3, #8]
 4796 00c0 5B6A     		ldr	r3, [r3, #36]
 4797 00c2 0021     		movs	r1, #0
 4798 00c4 2000     		movs	r0, r4
 4799 00c6 9847     		blx	r3
 4800              	.LVL468:
 4801              	.L357:
 4802              	.LBE539:
 4803              	.LBE538:
 4804              	.LBE535:
 4805              	.LBE534:
 4806              	.LBB541:
 4807              	.LBB542:
  66:Inc/tcpm.h    **** }
 4808              		.loc 2 66 0
 4809 00c8 0021     		movs	r1, #0
 4810 00ca 2000     		movs	r0, r4
 4811 00cc 3B69     		ldr	r3, [r7, #16]
 4812 00ce 9847     		blx	r3
 4813              	.LVL469:
 4814              	.LBE542:
 4815              	.LBE541:
 4816              	.LBB543:
 4817              	.LBB544:
  71:Inc/tcpm.h    **** }
 4818              		.loc 2 71 0
 4819 00d0 7B69     		ldr	r3, [r7, #20]
 4820 00d2 0221     		movs	r1, #2
 4821 00d4 2000     		movs	r0, r4
 4822 00d6 9847     		blx	r3
 4823              	.LVL470:
 4824              	.LBE544:
 4825              	.LBE543:
2124:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT
ARM GAS  /tmp/ccWvVg6G.s 			page 133


2125:Src/usb_pd_protocol.c **** 	ASSERT(PD_ROLE_DEFAULT(port) == PD_ROLE_SINK);
2126:Src/usb_pd_protocol.c **** 	tcpm_select_rp_value(port, CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT);
2127:Src/usb_pd_protocol.c **** #else
2128:Src/usb_pd_protocol.c **** 	tcpm_select_rp_value(port, CONFIG_USB_PD_PULLUP);
2129:Src/usb_pd_protocol.c **** #endif
2130:Src/usb_pd_protocol.c **** 	tcpm_set_cc(port, PD_ROLE_DEFAULT(port) == PD_ROLE_SOURCE ?
2131:Src/usb_pd_protocol.c **** 		    TYPEC_CC_RP : TYPEC_CC_RD);
2132:Src/usb_pd_protocol.c **** 
2133:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
2134:Src/usb_pd_protocol.c **** 	/* Initialize PD Policy engine */
2135:Src/usb_pd_protocol.c **** 	pd_dfp_pe_init(port);
2136:Src/usb_pd_protocol.c **** #endif
2137:Src/usb_pd_protocol.c **** 
2138:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
2139:Src/usb_pd_protocol.c **** 	/* Initialize PD and type-C supplier current limits to 0 */
2140:Src/usb_pd_protocol.c **** 	pd_set_input_current_limit(port, 0, 0);
 4826              		.loc 1 2140 0
 4827 00d8 0022     		movs	r2, #0
 4828 00da 0021     		movs	r1, #0
 4829 00dc 2000     		movs	r0, r4
 4830 00de FFF7FEFF 		bl	pd_set_input_current_limit
 4831              	.LVL471:
2141:Src/usb_pd_protocol.c **** 	//typec_set_input_current_limit(port, 0, 0);
2142:Src/usb_pd_protocol.c **** 	//charge_manager_update_dualrole(port, CAP_UNKNOWN);
2143:Src/usb_pd_protocol.c **** #endif
2144:Src/usb_pd_protocol.c **** }
 4832              		.loc 1 2144 0
 4833 00e2 03B0     		add	sp, sp, #12
 4834              		@ sp needed
 4835              	.LVL472:
 4836 00e4 0CBC     		pop	{r2, r3}
 4837 00e6 9046     		mov	r8, r2
 4838 00e8 9946     		mov	r9, r3
 4839 00ea F0BD     		pop	{r4, r5, r6, r7, pc}
 4840              	.LVL473:
 4841              	.L362:
2085:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
 4842              		.loc 1 2085 0
 4843 00ec 0222     		movs	r2, #2
 4844 00ee A1E7     		b	.L354
 4845              	.LVL474:
 4846              	.L363:
 4847              	.LBB545:
 4848              	.LBB540:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 4849              		.loc 1 365 0
 4850 00f0 0E2B     		cmp	r3, #14
 4851 00f2 D1D1     		bne	.L358
 4852 00f4 E8E7     		b	.L357
 4853              	.L364:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 4854              		.loc 1 367 0
 4855 00f6 022B     		cmp	r3, #2
 4856 00f8 D0D1     		bne	.L359
 4857 00fa E5E7     		b	.L357
 4858              	.LVL475:
 4859              	.L365:
ARM GAS  /tmp/ccWvVg6G.s 			page 134


 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 4860              		.loc 1 396 0
 4861 00fc 2000     		movs	r0, r4
 4862 00fe FFF7FEFF 		bl	pd_power_supply_reset
 4863              	.LVL476:
 4864 0102 D9E7     		b	.L361
 4865              	.L367:
 4866              		.align	2
 4867              	.L366:
 4868 0104 00000000 		.word	tcpc_config
 4869 0108 00000000 		.word	board_tcpc_post_init
 4870 010c 00000000 		.word	.LANCHOR1
 4871 0110 00000000 		.word	pd
 4872              	.LBE540:
 4873              	.LBE545:
 4874              		.cfi_endproc
 4875              	.LFE66:
 4877              		.section	.text.pd_run_state_machine,"ax",%progbits
 4878              		.align	1
 4879              		.global	pd_run_state_machine
 4880              		.syntax unified
 4881              		.code	16
 4882              		.thumb_func
 4883              		.fpu softvfp
 4885              	pd_run_state_machine:
 4886              	.LFB67:
2145:Src/usb_pd_protocol.c **** 
2146:Src/usb_pd_protocol.c **** void pd_run_state_machine(int port)
2147:Src/usb_pd_protocol.c **** {
 4887              		.loc 1 2147 0
 4888              		.cfi_startproc
 4889              		@ args = 0, pretend = 0, frame = 8
 4890              		@ frame_needed = 0, uses_anonymous_args = 0
 4891              	.LVL477:
 4892 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 4893              	.LCFI34:
 4894              		.cfi_def_cfa_offset 20
 4895              		.cfi_offset 4, -20
 4896              		.cfi_offset 5, -16
 4897              		.cfi_offset 6, -12
 4898              		.cfi_offset 7, -8
 4899              		.cfi_offset 14, -4
 4900 0002 85B0     		sub	sp, sp, #20
 4901              	.LCFI35:
 4902              		.cfi_def_cfa_offset 40
 4903 0004 0600     		movs	r6, r0
2148:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
2149:Src/usb_pd_protocol.c **** 	/* send any pending messages */
2150:Src/usb_pd_protocol.c **** 	pd_ca_send_pending(port);
2151:Src/usb_pd_protocol.c **** #endif
2152:Src/usb_pd_protocol.c **** 	/* process VDM messages last */
2153:Src/usb_pd_protocol.c **** 	pd_vdm_send_state_machine(port);
 4904              		.loc 1 2153 0
 4905 0006 FFF7FEFF 		bl	pd_vdm_send_state_machine
 4906              	.LVL478:
2154:Src/usb_pd_protocol.c **** 
2155:Src/usb_pd_protocol.c **** 	/* Verify board specific health status : current, voltages... */
ARM GAS  /tmp/ccWvVg6G.s 			page 135


2156:Src/usb_pd_protocol.c **** 	res = pd_board_checks();
 4907              		.loc 1 2156 0
 4908 000a FFF7FEFF 		bl	pd_board_checks
 4909              	.LVL479:
2157:Src/usb_pd_protocol.c **** 	if (res != EC_SUCCESS) {
 4910              		.loc 1 2157 0
 4911 000e 0028     		cmp	r0, #0
 4912 0010 24D1     		bne	.L536
 4913              	.L369:
2158:Src/usb_pd_protocol.c **** 		/* cut the power */
2159:Src/usb_pd_protocol.c **** 		pd_execute_hard_reset(port);
2160:Src/usb_pd_protocol.c **** 		/* notify the other side of the issue */
2161:Src/usb_pd_protocol.c **** 		pd_transmit(port, TCPC_TX_HARD_RESET, 0, NULL);
2162:Src/usb_pd_protocol.c **** 	}
2163:Src/usb_pd_protocol.c **** 
2164:Src/usb_pd_protocol.c **** 	/* wait for next event/packet or timeout expiration */
2165:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
2166:Src/usb_pd_protocol.c **** 	//evt = task_wait_event(timeout);
2167:Src/usb_pd_protocol.c **** 
2168:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2169:Src/usb_pd_protocol.c **** 	if (evt & PD_EVENT_UPDATE_DUAL_ROLE)
2170:Src/usb_pd_protocol.c **** 		pd_update_dual_role_config(port);
2171:Src/usb_pd_protocol.c **** #endif
2172:Src/usb_pd_protocol.c **** 
2173:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC
2174:Src/usb_pd_protocol.c **** 	/*
2175:Src/usb_pd_protocol.c **** 		* run port controller task to check CC and/or read incoming
2176:Src/usb_pd_protocol.c **** 		* messages
2177:Src/usb_pd_protocol.c **** 		*/
2178:Src/usb_pd_protocol.c **** 	tcpc_run(port, evt);
2179:Src/usb_pd_protocol.c **** #else
2180:Src/usb_pd_protocol.c **** 	/* if TCPC has reset, then need to initialize it again */
2181:Src/usb_pd_protocol.c **** 	if (evt & PD_EVENT_TCPC_RESET) {
2182:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d reset!", port);
2183:Src/usb_pd_protocol.c **** 		if (tcpm_init(port) != EC_SUCCESS)
2184:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d init failed", port);
2185:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
2186:Src/usb_pd_protocol.c **** 	}
2187:Src/usb_pd_protocol.c **** 
2188:Src/usb_pd_protocol.c **** 	if ((evt & PD_EVENT_TCPC_RESET) &&
2189:Src/usb_pd_protocol.c **** 		(pd[port].task_state != PD_STATE_DRP_AUTO_TOGGLE)) {
2190:Src/usb_pd_protocol.c **** #endif
2191:Src/usb_pd_protocol.c **** 		/* Ensure CC termination is default */
2192:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, PD_ROLE_DEFAULT(port) ==
2193:Src/usb_pd_protocol.c **** 				PD_ROLE_SOURCE ? TYPEC_CC_RP : TYPEC_CC_RD);
2194:Src/usb_pd_protocol.c **** 
2195:Src/usb_pd_protocol.c **** 		/*
2196:Src/usb_pd_protocol.c **** 			* If we have a stable contract in the default role,
2197:Src/usb_pd_protocol.c **** 			* then simply update TCPC with some missing info
2198:Src/usb_pd_protocol.c **** 			* so that we can continue without resetting PD comms.
2199:Src/usb_pd_protocol.c **** 			* Otherwise, go to the default disconnected state
2200:Src/usb_pd_protocol.c **** 			* and force renegotiation.
2201:Src/usb_pd_protocol.c **** 			*/
2202:Src/usb_pd_protocol.c **** 		if (pd[port].vdm_state == VDM_STATE_DONE && (
2203:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2204:Src/usb_pd_protocol.c **** 			    (PD_ROLE_DEFAULT(port) == PD_ROLE_SINK &&
2205:Src/usb_pd_protocol.c **** 			    pd[port].task_state == PD_STATE_SNK_READY) ||
ARM GAS  /tmp/ccWvVg6G.s 			page 136


2206:Src/usb_pd_protocol.c **** #endif
2207:Src/usb_pd_protocol.c **** 			    (PD_ROLE_DEFAULT(port) == PD_ROLE_SOURCE &&
2208:Src/usb_pd_protocol.c **** 			    pd[port].task_state == PD_STATE_SRC_READY))) {
2209:Src/usb_pd_protocol.c **** 			tcpm_set_polarity(port, pd[port].polarity);
2210:Src/usb_pd_protocol.c **** 			tcpm_set_msg_header(port, pd[port].power_role,
2211:Src/usb_pd_protocol.c **** 						pd[port].data_role);
2212:Src/usb_pd_protocol.c **** 			tcpm_set_rx_enable(port, 1);
2213:Src/usb_pd_protocol.c **** 		} else {
2214:Src/usb_pd_protocol.c **** 			/* Ensure state variables are at default */
2215:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_DEFAULT(port);
2216:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_DONE;
2217:Src/usb_pd_protocol.c **** 			set_state(port, PD_DEFAULT_STATE(port));
2218:Src/usb_pd_protocol.c **** 		}
2219:Src/usb_pd_protocol.c **** 	}
2220:Src/usb_pd_protocol.c **** #endif
2221:Src/usb_pd_protocol.c **** 
2222:Src/usb_pd_protocol.c **** 	/* process any potential incoming message */
2223:Src/usb_pd_protocol.c **** 	incoming_packet = evt & PD_EVENT_RX;
 4914              		.loc 1 2223 0
 4915 0012 AF4B     		ldr	r3, .L596
 4916 0014 0022     		movs	r2, #0
 4917 0016 1A60     		str	r2, [r3]
 4918              	.LVL480:
 4919              	.LBB829:
 4920              	.LBB830:
  97:Inc/tcpm.h    **** }
 4921              		.loc 2 97 0
 4922 0018 3201     		lsls	r2, r6, #4
 4923 001a AE4B     		ldr	r3, .L596+4
 4924 001c 9B18     		adds	r3, r3, r2
 4925 001e 9C68     		ldr	r4, [r3, #8]
 4926 0020 AD4A     		ldr	r2, .L596+8
 4927 0022 AE49     		ldr	r1, .L596+12
 4928 0024 3000     		movs	r0, r6
 4929 0026 A36A     		ldr	r3, [r4, #40]
 4930 0028 9847     		blx	r3
 4931              	.LVL481:
 4932              	.LBE830:
 4933              	.LBE829:
2224:Src/usb_pd_protocol.c **** 	//if (incoming_packet) {
2225:Src/usb_pd_protocol.c **** 		if (!tcpm_get_message(port, payload, &head))
 4934              		.loc 1 2225 0
 4935 002a 0028     		cmp	r0, #0
 4936 002c 20D0     		beq	.L537
 4937              	.L370:
2226:Src/usb_pd_protocol.c **** 			handle_request(port, head, payload);
2227:Src/usb_pd_protocol.c **** 	//}
2228:Src/usb_pd_protocol.c **** 
2229:Src/usb_pd_protocol.c **** 	if (pd[port].req_suspend_state)
 4938              		.loc 1 2229 0
 4939 002e F201     		lsls	r2, r6, #7
 4940 0030 AB4B     		ldr	r3, .L596+16
 4941 0032 9B18     		adds	r3, r3, r2
 4942 0034 9B79     		ldrb	r3, [r3, #6]
 4943 0036 002B     		cmp	r3, #0
 4944 0038 21D1     		bne	.L538
 4945              	.L371:
ARM GAS  /tmp/ccWvVg6G.s 			page 137


2230:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SUSPENDED);
2231:Src/usb_pd_protocol.c **** 
2232:Src/usb_pd_protocol.c **** 	/* if nothing to do, verify the state of the world in 500ms */
2233:Src/usb_pd_protocol.c **** 	this_state = pd[port].task_state;
 4946              		.loc 1 2233 0
 4947 003a F201     		lsls	r2, r6, #7
 4948 003c A84B     		ldr	r3, .L596+16
 4949 003e 9B18     		adds	r3, r3, r2
 4950 0040 1B79     		ldrb	r3, [r3, #4]
 4951 0042 A84A     		ldr	r2, .L596+20
 4952 0044 1370     		strb	r3, [r2]
2234:Src/usb_pd_protocol.c **** 	timeout = 500*MSEC;
 4953              		.loc 1 2234 0
 4954 0046 A84A     		ldr	r2, .L596+24
 4955 0048 A849     		ldr	r1, .L596+28
 4956 004a 1160     		str	r1, [r2]
2235:Src/usb_pd_protocol.c **** 	switch (this_state) {
 4957              		.loc 1 2235 0
 4958 004c 202B     		cmp	r3, #32
 4959 004e 01D9     		bls	.LCB5078
 4960 0050 01F0DCF8 		bl	.L372	@far jump
 4961              	.LCB5078:
 4962 0054 9A00     		lsls	r2, r3, #2
 4963 0056 A649     		ldr	r1, .L596+32
 4964 0058 8A58     		ldr	r2, [r1, r2]
 4965 005a 9746     		mov	pc, r2
 4966              		.section	.rodata.pd_run_state_machine,"a",%progbits
 4967              		.align	2
 4968              	.L374:
 4969 0000 0C120000 		.word	.L372
 4970 0004 B00A0000 		.word	.L373
 4971 0008 220B0000 		.word	.L375
 4972 000c 240C0000 		.word	.L376
 4973 0010 040E0000 		.word	.L377
 4974 0014 C40E0000 		.word	.L378
 4975 0018 BC0F0000 		.word	.L379
 4976 001c F20F0000 		.word	.L380
 4977 0020 22100000 		.word	.L381
 4978 0024 38110000 		.word	.L382
 4979 0028 E6110000 		.word	.L383
 4980 002c BC120000 		.word	.L384
 4981 0030 EA120000 		.word	.L385
 4982 0034 8C130000 		.word	.L386
 4983 0038 94000000 		.word	.L387
 4984 003c EC010000 		.word	.L388
 4985 0040 E0030000 		.word	.L389
 4986 0044 8C040000 		.word	.L390
 4987 0048 D2040000 		.word	.L391
 4988 004c 70050000 		.word	.L392
 4989 0050 A4050000 		.word	.L393
 4990 0054 D8050000 		.word	.L394
 4991 0058 10060000 		.word	.L395
 4992 005c CC060000 		.word	.L396
 4993 0060 E0070000 		.word	.L397
 4994 0064 14080000 		.word	.L398
 4995 0068 F2080000 		.word	.L399
 4996 006c B4090000 		.word	.L400
ARM GAS  /tmp/ccWvVg6G.s 			page 138


 4997 0070 E8090000 		.word	.L401
 4998 0074 580A0000 		.word	.L402
 4999 0078 64140000 		.word	.L403
 5000 007c C6140000 		.word	.L404
 5001 0080 72150000 		.word	.L405
 5002              		.section	.text.pd_run_state_machine
 5003              	.L536:
2159:Src/usb_pd_protocol.c **** 		/* notify the other side of the issue */
 5004              		.loc 1 2159 0
 5005 005c 3000     		movs	r0, r6
 5006 005e FFF7FEFF 		bl	pd_execute_hard_reset
 5007              	.LVL482:
2161:Src/usb_pd_protocol.c **** 	}
 5008              		.loc 1 2161 0
 5009 0062 0023     		movs	r3, #0
 5010 0064 0022     		movs	r2, #0
 5011 0066 0521     		movs	r1, #5
 5012 0068 3000     		movs	r0, r6
 5013 006a FFF7FEFF 		bl	pd_transmit
 5014              	.LVL483:
 5015 006e D0E7     		b	.L369
 5016              	.L537:
2226:Src/usb_pd_protocol.c **** 	//}
 5017              		.loc 1 2226 0
 5018 0070 994B     		ldr	r3, .L596+8
 5019 0072 1988     		ldrh	r1, [r3]
 5020 0074 994A     		ldr	r2, .L596+12
 5021 0076 3000     		movs	r0, r6
 5022 0078 FFF7FEFF 		bl	handle_request
 5023              	.LVL484:
 5024 007c D7E7     		b	.L370
 5025              	.L538:
 5026              	.LVL485:
 5027              	.LBB831:
 5028              	.LBB832:
 5029              	.LBB833:
 5030              	.LBB834:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5031              		.loc 1 283 0
 5032 007e 984B     		ldr	r3, .L596+16
 5033 0080 9B18     		adds	r3, r3, r2
 5034 0082 0020     		movs	r0, #0
 5035 0084 0021     		movs	r1, #0
 5036 0086 1861     		str	r0, [r3, #16]
 5037 0088 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5038              		.loc 1 284 0
 5039 008a 0022     		movs	r2, #0
 5040 008c DA71     		strb	r2, [r3, #7]
 5041              	.LVL486:
 5042              	.LBE834:
 5043              	.LBE833:
 352:Src/usb_pd_protocol.c **** 
 5044              		.loc 1 352 0
 5045 008e 0132     		adds	r2, r2, #1
 5046 0090 1A71     		strb	r2, [r3, #4]
 5047              	.LVL487:
ARM GAS  /tmp/ccWvVg6G.s 			page 139


 5048 0092 D2E7     		b	.L371
 5049              	.LVL488:
 5050              	.L387:
 5051              	.LBE832:
 5052              	.LBE831:
2236:Src/usb_pd_protocol.c **** 	case PD_STATE_DISABLED:
2237:Src/usb_pd_protocol.c **** 		/* Nothing to do */
2238:Src/usb_pd_protocol.c **** 		break;
2239:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_DISCONNECTED:
2240:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC;
 5053              		.loc 1 2240 0
 5054 0094 944B     		ldr	r3, .L596+24
 5055 0096 974A     		ldr	r2, .L596+36
 5056 0098 1A60     		str	r2, [r3]
 5057              	.LVL489:
 5058              	.LBB835:
 5059              	.LBB836:
  56:Inc/tcpm.h    **** }
 5060              		.loc 2 56 0
 5061 009a A368     		ldr	r3, [r4, #8]
 5062 009c 964C     		ldr	r4, .L596+40
 5063 009e 974A     		ldr	r2, .L596+44
 5064 00a0 2100     		movs	r1, r4
 5065 00a2 3000     		movs	r0, r6
 5066 00a4 9847     		blx	r3
 5067              	.LVL490:
 5068              	.LBE836:
 5069              	.LBE835:
2241:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
2242:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
2243:Src/usb_pd_protocol.c **** 		/*
2244:Src/usb_pd_protocol.c **** 			* Attempt TCPC auto DRP toggle if it is
2245:Src/usb_pd_protocol.c **** 			* not already auto toggling and not try.src
2246:Src/usb_pd_protocol.c **** 			*/
2247:Src/usb_pd_protocol.c **** 		if (auto_toggle_supported &&
2248:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TCPC_DRP_TOGGLE) &&
2249:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
2250:Src/usb_pd_protocol.c **** 			(cc1 == TYPEC_CC_VOLT_OPEN &&
2251:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_OPEN)) {
2252:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_DRP_AUTO_TOGGLE);
2253:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC;
2254:Src/usb_pd_protocol.c **** 			break;
2255:Src/usb_pd_protocol.c **** 		}
2256:Src/usb_pd_protocol.c **** #endif
2257:Src/usb_pd_protocol.c **** 
2258:Src/usb_pd_protocol.c **** 		/* Vnc monitoring */
2259:Src/usb_pd_protocol.c **** 		if ((cc1 == TYPEC_CC_VOLT_RD ||
 5070              		.loc 1 2259 0
 5071 00a6 2368     		ldr	r3, [r4]
 5072 00a8 022B     		cmp	r3, #2
 5073 00aa 31D0     		beq	.L406
2260:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RD) ||
 5074              		.loc 1 2260 0 discriminator 1
 5075 00ac 934A     		ldr	r2, .L596+44
 5076 00ae 1268     		ldr	r2, [r2]
2259:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RD) ||
 5077              		.loc 1 2259 0 discriminator 1
ARM GAS  /tmp/ccWvVg6G.s 			page 140


 5078 00b0 022A     		cmp	r2, #2
 5079 00b2 2DD0     		beq	.L406
 5080              		.loc 1 2260 0
 5081 00b4 012B     		cmp	r3, #1
 5082 00b6 29D0     		beq	.L539
 5083              	.L407:
2261:Src/usb_pd_protocol.c **** 			(cc1 == TYPEC_CC_VOLT_RA &&
2262:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RA)) {
2263:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP
2264:Src/usb_pd_protocol.c **** 			/* Enable VBUS */
2265:Src/usb_pd_protocol.c **** 			if (pd_set_power_supply_ready(port))
2266:Src/usb_pd_protocol.c **** 				break;
2267:Src/usb_pd_protocol.c **** #endif
2268:Src/usb_pd_protocol.c **** 			pd[port].cc_state = PD_CC_NONE;
2269:Src/usb_pd_protocol.c **** 			set_state(port,
2270:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_DISCONNECTED_DEBOUNCE);
2271:Src/usb_pd_protocol.c **** 		}
2272:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_DUAL_ROLE)
2273:Src/usb_pd_protocol.c **** 		/*
2274:Src/usb_pd_protocol.c **** 			* Try.SRC state is embedded here. Wait for SNK
2275:Src/usb_pd_protocol.c **** 			* detect, or if timer expires, transition to
2276:Src/usb_pd_protocol.c **** 			* SNK_DISCONNETED.
2277:Src/usb_pd_protocol.c **** 			*
2278:Src/usb_pd_protocol.c **** 			* If Try.SRC state is not active, then this block
2279:Src/usb_pd_protocol.c **** 			* handles the normal DRP toggle from SRC->SNK
2280:Src/usb_pd_protocol.c **** 			*/
2281:Src/usb_pd_protocol.c **** 		else if ((pd[port].flags & PD_FLAGS_TRY_SRC &&
 5084              		.loc 1 2281 0
 5085 00b8 F201     		lsls	r2, r6, #7
 5086 00ba 894B     		ldr	r3, .L596+16
 5087 00bc 9B18     		adds	r3, r3, r2
 5088 00be 9B68     		ldr	r3, [r3, #8]
 5089 00c0 9B04     		lsls	r3, r3, #18
 5090 00c2 35D4     		bmi	.L540
 5091              	.L408:
2282:Src/usb_pd_protocol.c **** 				get_time().val >= pd[port].try_src_marker) ||
2283:Src/usb_pd_protocol.c **** 				(!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
 5092              		.loc 1 2283 0
 5093 00c4 F201     		lsls	r2, r6, #7
 5094 00c6 864B     		ldr	r3, .L596+16
 5095 00c8 9B18     		adds	r3, r3, r2
 5096 00ca 9B68     		ldr	r3, [r3, #8]
2282:Src/usb_pd_protocol.c **** 				get_time().val >= pd[port].try_src_marker) ||
 5097              		.loc 1 2282 0
 5098 00cc 9B04     		lsls	r3, r3, #18
 5099 00ce 01D5     		bpl	.LCB5198
 5100 00d0 01F09CF8 		bl	.L372	@far jump
 5101              	.LCB5198:
2284:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SOURCE &&
 5102              		.loc 1 2284 0
 5103 00d4 8A4B     		ldr	r3, .L596+48
 5104 00d6 1B78     		ldrb	r3, [r3]
2283:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SOURCE &&
 5105              		.loc 1 2283 0
 5106 00d8 042B     		cmp	r3, #4
 5107 00da 01D1     		bne	.LCB5202
 5108 00dc 01F096F8 		bl	.L372	@far jump
ARM GAS  /tmp/ccWvVg6G.s 			page 141


 5109              	.LCB5202:
 5110              		.loc 1 2284 0
 5111 00e0 022B     		cmp	r3, #2
 5112 00e2 01D1     		bne	.LCB5204
 5113 00e4 01F092F8 		bl	.L372	@far jump
 5114              	.LCB5204:
2285:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FREEZE &&
2286:Src/usb_pd_protocol.c **** 				get_time().val >= next_role_swap)) {
 5115              		.loc 1 2286 0
 5116 00e8 02A8     		add	r0, sp, #8
 5117 00ea FFF7FEFF 		bl	get_time
 5118              	.LVL491:
 5119 00ee 0299     		ldr	r1, [sp, #8]
 5120 00f0 039B     		ldr	r3, [sp, #12]
 5121 00f2 844A     		ldr	r2, .L596+52
 5122 00f4 1068     		ldr	r0, [r2]
 5123 00f6 5268     		ldr	r2, [r2, #4]
2285:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FREEZE &&
 5124              		.loc 1 2285 0
 5125 00f8 9A42     		cmp	r2, r3
 5126 00fa 01D9     		bls	.LCB5214
 5127 00fc 01F086F8 		bl	.L372	@far jump
 5128              	.LCB5214:
 5129 0100 25D1     		bne	.L409
 5130 0102 8842     		cmp	r0, r1
 5131 0104 01D9     		bls	.LCB5218
 5132 0106 01F081F8 		bl	.L372	@far jump
 5133              	.LCB5218:
 5134 010a 20E0     		b	.L409
 5135              	.L539:
2261:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RA)) {
 5136              		.loc 1 2261 0
 5137 010c 012A     		cmp	r2, #1
 5138 010e D3D1     		bne	.L407
 5139              	.L406:
2268:Src/usb_pd_protocol.c **** 			set_state(port,
 5140              		.loc 1 2268 0
 5141 0110 F201     		lsls	r2, r6, #7
 5142 0112 734B     		ldr	r3, .L596+16
 5143 0114 9B18     		adds	r3, r3, r2
 5144 0116 1900     		movs	r1, r3
 5145 0118 2831     		adds	r1, r1, #40
 5146 011a 0022     		movs	r2, #0
 5147 011c 0A70     		strb	r2, [r1]
 5148              	.LVL492:
 5149              	.LBB837:
 5150              	.LBB838:
 5151              	.LBB839:
 5152              	.LBB840:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5153              		.loc 1 283 0
 5154 011e 0020     		movs	r0, #0
 5155 0120 0021     		movs	r1, #0
 5156 0122 1861     		str	r0, [r3, #16]
 5157 0124 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5158              		.loc 1 284 0
ARM GAS  /tmp/ccWvVg6G.s 			page 142


 5159 0126 DA71     		strb	r2, [r3, #7]
 5160              	.LVL493:
 5161              	.LBE840:
 5162              	.LBE839:
 352:Src/usb_pd_protocol.c **** 
 5163              		.loc 1 352 0
 5164 0128 0F32     		adds	r2, r2, #15
 5165 012a 1A71     		strb	r2, [r3, #4]
 5166              	.LVL494:
 5167 012c 01F06EF8 		bl	.L372	@ far jump
 5168              	.LVL495:
 5169              	.L540:
 5170              	.LBE838:
 5171              	.LBE837:
2282:Src/usb_pd_protocol.c **** 				(!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
 5172              		.loc 1 2282 0 discriminator 1
 5173 0130 02A8     		add	r0, sp, #8
 5174 0132 FFF7FEFF 		bl	get_time
 5175              	.LVL496:
 5176 0136 0298     		ldr	r0, [sp, #8]
 5177 0138 0399     		ldr	r1, [sp, #12]
 5178 013a F201     		lsls	r2, r6, #7
 5179 013c 684B     		ldr	r3, .L596+16
 5180 013e 9B18     		adds	r3, r3, r2
 5181 0140 1A6C     		ldr	r2, [r3, #64]
 5182 0142 5B6C     		ldr	r3, [r3, #68]
2281:Src/usb_pd_protocol.c **** 				get_time().val >= pd[port].try_src_marker) ||
 5183              		.loc 1 2281 0 discriminator 1
 5184 0144 8B42     		cmp	r3, r1
 5185 0146 BDD8     		bhi	.L408
 5186 0148 01D1     		bne	.L409
 5187 014a 8242     		cmp	r2, r0
 5188 014c BAD8     		bhi	.L408
 5189              	.L409:
2287:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
 5190              		.loc 1 2287 0
 5191 014e 644B     		ldr	r3, .L596+16
 5192 0150 F201     		lsls	r2, r6, #7
 5193 0152 0021     		movs	r1, #0
 5194 0154 D154     		strb	r1, [r2, r3]
 5195              	.LVL497:
 5196              	.LBB841:
 5197              	.LBB842:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5198              		.loc 1 346 0
 5199 0156 9B18     		adds	r3, r3, r2
 5200 0158 1A79     		ldrb	r2, [r3, #4]
 5201              	.LVL498:
 5202              	.LBB843:
 5203              	.LBB844:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5204              		.loc 1 283 0
 5205 015a 0024     		movs	r4, #0
 5206 015c 0025     		movs	r5, #0
 5207 015e 1C61     		str	r4, [r3, #16]
 5208 0160 5D61     		str	r5, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccWvVg6G.s 			page 143


 5209              		.loc 1 284 0
 5210 0162 D971     		strb	r1, [r3, #7]
 5211              	.LVL499:
 5212              	.LBE844:
 5213              	.LBE843:
 352:Src/usb_pd_protocol.c **** 
 5214              		.loc 1 352 0
 5215 0164 0231     		adds	r1, r1, #2
 5216 0166 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 5217              		.loc 1 354 0
 5218 0168 022A     		cmp	r2, #2
 5219 016a 13D0     		beq	.L412
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 5220              		.loc 1 366 0
 5221 016c 0E2A     		cmp	r2, #14
 5222 016e 11D0     		beq	.L412
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5223              		.loc 1 374 0
 5224 0170 0022     		movs	r2, #0
 5225              	.LVL500:
 5226 0172 0021     		movs	r1, #0
 5227 0174 3000     		movs	r0, r6
 5228 0176 FFF7FEFF 		bl	pd_set_input_current_limit
 5229              	.LVL501:
 391:Src/usb_pd_protocol.c **** 			/*
 5230              		.loc 1 391 0
 5231 017a F301     		lsls	r3, r6, #7
 5232 017c 584A     		ldr	r2, .L596+16
 5233 017e 9B5C     		ldrb	r3, [r3, r2]
 5234 0180 012B     		cmp	r3, #1
 5235 0182 2FD0     		beq	.L541
 5236              	.L413:
 5237              	.LVL502:
 5238              	.LBB845:
 5239              	.LBB846:
  92:Inc/tcpm.h    **** }
 5240              		.loc 2 92 0
 5241 0184 3201     		lsls	r2, r6, #4
 5242 0186 534B     		ldr	r3, .L596+4
 5243 0188 9B18     		adds	r3, r3, r2
 5244 018a 9B68     		ldr	r3, [r3, #8]
 5245 018c 5B6A     		ldr	r3, [r3, #36]
 5246 018e 0021     		movs	r1, #0
 5247 0190 3000     		movs	r0, r6
 5248 0192 9847     		blx	r3
 5249              	.LVL503:
 5250              	.L412:
 5251              	.LBE846:
 5252              	.LBE845:
 5253              	.LBE842:
 5254              	.LBE841:
 5255              	.LBB848:
 5256              	.LBB849:
  71:Inc/tcpm.h    **** }
 5257              		.loc 2 71 0
 5258 0194 3201     		lsls	r2, r6, #4
ARM GAS  /tmp/ccWvVg6G.s 			page 144


 5259 0196 4F4B     		ldr	r3, .L596+4
 5260 0198 9B18     		adds	r3, r3, r2
 5261 019a 9B68     		ldr	r3, [r3, #8]
 5262 019c 5B69     		ldr	r3, [r3, #20]
 5263 019e 0221     		movs	r1, #2
 5264 01a0 3000     		movs	r0, r6
 5265 01a2 9847     		blx	r3
 5266              	.LVL504:
 5267              	.LBE849:
 5268              	.LBE848:
2288:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
2289:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
2290:Src/usb_pd_protocol.c **** 			next_role_swap = get_time().val + PD_T_DRP_SNK;
 5269              		.loc 1 2290 0
 5270 01a4 02A8     		add	r0, sp, #8
 5271 01a6 FFF7FEFF 		bl	get_time
 5272              	.LVL505:
 5273 01aa 574A     		ldr	r2, .L596+56
 5274 01ac 0023     		movs	r3, #0
 5275 01ae 0298     		ldr	r0, [sp, #8]
 5276 01b0 0399     		ldr	r1, [sp, #12]
 5277 01b2 1218     		adds	r2, r2, r0
 5278 01b4 4B41     		adcs	r3, r3, r1
 5279 01b6 5349     		ldr	r1, .L596+52
 5280 01b8 0A60     		str	r2, [r1]
 5281 01ba 4B60     		str	r3, [r1, #4]
2291:Src/usb_pd_protocol.c **** 			pd[port].try_src_marker = get_time().val
 5282              		.loc 1 2291 0
 5283 01bc 02A8     		add	r0, sp, #8
 5284 01be FFF7FEFF 		bl	get_time
 5285              	.LVL506:
2292:Src/usb_pd_protocol.c **** 				+ PD_T_TRY_WAIT;
 5286              		.loc 1 2292 0
 5287 01c2 5248     		ldr	r0, .L596+60
 5288 01c4 0021     		movs	r1, #0
 5289 01c6 029B     		ldr	r3, [sp, #8]
 5290 01c8 039C     		ldr	r4, [sp, #12]
 5291 01ca C018     		adds	r0, r0, r3
 5292 01cc 6141     		adcs	r1, r1, r4
2291:Src/usb_pd_protocol.c **** 			pd[port].try_src_marker = get_time().val
 5293              		.loc 1 2291 0
 5294 01ce F201     		lsls	r2, r6, #7
 5295 01d0 434B     		ldr	r3, .L596+16
 5296 01d2 9B18     		adds	r3, r3, r2
 5297 01d4 1864     		str	r0, [r3, #64]
 5298 01d6 5964     		str	r1, [r3, #68]
2293:Src/usb_pd_protocol.c **** 
2294:Src/usb_pd_protocol.c **** 			/* Swap states quickly */
2295:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC;
 5299              		.loc 1 2295 0
 5300 01d8 434B     		ldr	r3, .L596+24
 5301 01da FA22     		movs	r2, #250
 5302 01dc D200     		lsls	r2, r2, #3
 5303 01de 1A60     		str	r2, [r3]
 5304 01e0 01F014F8 		bl	.L372	@ far jump
 5305              	.LVL507:
 5306              	.L541:
ARM GAS  /tmp/ccWvVg6G.s 			page 145


 5307              	.LBB850:
 5308              	.LBB847:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 5309              		.loc 1 396 0
 5310 01e4 3000     		movs	r0, r6
 5311 01e6 FFF7FEFF 		bl	pd_power_supply_reset
 5312              	.LVL508:
 5313 01ea CBE7     		b	.L413
 5314              	.LVL509:
 5315              	.L388:
 5316              	.LBE847:
 5317              	.LBE850:
2296:Src/usb_pd_protocol.c **** 		}
2297:Src/usb_pd_protocol.c **** #endif
2298:Src/usb_pd_protocol.c **** 		break;
2299:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_DISCONNECTED_DEBOUNCE:
2300:Src/usb_pd_protocol.c **** 		timeout = 20*MSEC;
 5318              		.loc 1 2300 0
 5319 01ec 3E4B     		ldr	r3, .L596+24
 5320 01ee 484A     		ldr	r2, .L596+64
 5321 01f0 1A60     		str	r2, [r3]
 5322              	.LVL510:
 5323              	.LBB851:
 5324              	.LBB852:
  56:Inc/tcpm.h    **** }
 5325              		.loc 2 56 0
 5326 01f2 414D     		ldr	r5, .L596+40
 5327 01f4 414A     		ldr	r2, .L596+44
 5328 01f6 2900     		movs	r1, r5
 5329 01f8 3000     		movs	r0, r6
 5330 01fa A368     		ldr	r3, [r4, #8]
 5331 01fc 9847     		blx	r3
 5332              	.LVL511:
 5333              	.LBE852:
 5334              	.LBE851:
2301:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
2302:Src/usb_pd_protocol.c **** 
2303:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_RD &&
 5335              		.loc 1 2303 0
 5336 01fe 2B68     		ldr	r3, [r5]
 5337 0200 022B     		cmp	r3, #2
 5338 0202 30D0     		beq	.L542
 5339              	.L414:
2304:Src/usb_pd_protocol.c **** 			cc2 == TYPEC_CC_VOLT_RD) {
2305:Src/usb_pd_protocol.c **** 			/* Debug accessory */
2306:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_DEBUG_ACC;
2307:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RD ||
 5340              		.loc 1 2307 0
 5341 0204 022B     		cmp	r3, #2
 5342 0206 36D0     		beq	.L416
2308:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RD) {
 5343              		.loc 1 2308 0 discriminator 1
 5344 0208 3C4A     		ldr	r2, .L596+44
 5345 020a 1268     		ldr	r2, [r2]
2307:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RD) {
 5346              		.loc 1 2307 0 discriminator 1
 5347 020c 022A     		cmp	r2, #2
ARM GAS  /tmp/ccWvVg6G.s 			page 146


 5348 020e 32D0     		beq	.L416
2309:Src/usb_pd_protocol.c **** 			/* UFP attached */
2310:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_UFP_ATTACHED;
2311:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RA &&
 5349              		.loc 1 2311 0
 5350 0210 012B     		cmp	r3, #1
 5351 0212 01D1     		bne	.L418
 5352              		.loc 1 2311 0 is_stmt 0 discriminator 1
 5353 0214 012A     		cmp	r2, #1
 5354 0216 53D0     		beq	.L543
 5355              	.L418:
 5356              	.LVL512:
 5357              	.LBB853:
 5358              	.LBB854:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5359              		.loc 1 346 0 is_stmt 1
 5360 0218 F201     		lsls	r2, r6, #7
 5361 021a 314B     		ldr	r3, .L596+16
 5362 021c 9B18     		adds	r3, r3, r2
 5363 021e 1A79     		ldrb	r2, [r3, #4]
 5364              	.LVL513:
 5365              	.LBB855:
 5366              	.LBB856:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5367              		.loc 1 283 0
 5368 0220 0020     		movs	r0, #0
 5369 0222 0021     		movs	r1, #0
 5370 0224 1861     		str	r0, [r3, #16]
 5371 0226 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5372              		.loc 1 284 0
 5373 0228 0021     		movs	r1, #0
 5374 022a D971     		strb	r1, [r3, #7]
 5375              	.LVL514:
 5376              	.LBE856:
 5377              	.LBE855:
 352:Src/usb_pd_protocol.c **** 
 5378              		.loc 1 352 0
 5379 022c 0E31     		adds	r1, r1, #14
 5380 022e 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 5381              		.loc 1 354 0
 5382 0230 0E2A     		cmp	r2, #14
 5383 0232 13D0     		beq	.L419
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5384              		.loc 1 365 0
 5385 0234 022A     		cmp	r2, #2
 5386 0236 11D0     		beq	.L419
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5387              		.loc 1 374 0
 5388 0238 0022     		movs	r2, #0
 5389              	.LVL515:
 5390 023a 0021     		movs	r1, #0
 5391 023c 3000     		movs	r0, r6
 5392 023e FFF7FEFF 		bl	pd_set_input_current_limit
 5393              	.LVL516:
 391:Src/usb_pd_protocol.c **** 			/*
ARM GAS  /tmp/ccWvVg6G.s 			page 147


 5394              		.loc 1 391 0
 5395 0242 F301     		lsls	r3, r6, #7
 5396 0244 264A     		ldr	r2, .L596+16
 5397 0246 9B5C     		ldrb	r3, [r3, r2]
 5398 0248 012B     		cmp	r3, #1
 5399 024a 3DD0     		beq	.L544
 5400              	.L420:
 5401              	.LVL517:
 5402              	.LBB857:
 5403              	.LBB858:
  92:Inc/tcpm.h    **** }
 5404              		.loc 2 92 0
 5405 024c 3201     		lsls	r2, r6, #4
 5406 024e 214B     		ldr	r3, .L596+4
 5407 0250 9B18     		adds	r3, r3, r2
 5408 0252 9B68     		ldr	r3, [r3, #8]
 5409 0254 5B6A     		ldr	r3, [r3, #36]
 5410 0256 0021     		movs	r1, #0
 5411 0258 3000     		movs	r0, r6
 5412 025a 9847     		blx	r3
 5413              	.LVL518:
 5414              	.L419:
 5415              	.LBE858:
 5416              	.LBE857:
 5417              	.LBE854:
 5418              	.LBE853:
2312:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RA) {
2313:Src/usb_pd_protocol.c **** 			/* Audio accessory */
2314:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_AUDIO_ACC;
2315:Src/usb_pd_protocol.c **** 		} else {
2316:Src/usb_pd_protocol.c **** 			/* No UFP */
2317:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
2318:Src/usb_pd_protocol.c **** 			timeout = 5*MSEC;
 5419              		.loc 1 2318 0
 5420 025c 224B     		ldr	r3, .L596+24
 5421 025e 2D4A     		ldr	r2, .L596+68
 5422 0260 1A60     		str	r2, [r3]
2319:Src/usb_pd_protocol.c **** 			break;
 5423              		.loc 1 2319 0
 5424 0262 00F0D3FF 		bl	.L372	@ far jump
 5425              	.L542:
2304:Src/usb_pd_protocol.c **** 			/* Debug accessory */
 5426              		.loc 1 2304 0 discriminator 1
 5427 0266 254A     		ldr	r2, .L596+44
 5428 0268 1268     		ldr	r2, [r2]
2303:Src/usb_pd_protocol.c **** 			cc2 == TYPEC_CC_VOLT_RD) {
 5429              		.loc 1 2303 0 discriminator 1
 5430 026a 022A     		cmp	r2, #2
 5431 026c CAD1     		bne	.L414
2306:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RD ||
 5432              		.loc 1 2306 0
 5433 026e 2A4B     		ldr	r3, .L596+72
 5434 0270 0132     		adds	r2, r2, #1
 5435 0272 1A70     		strb	r2, [r3]
 5436 0274 02E0     		b	.L415
 5437              	.L416:
2310:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RA &&
ARM GAS  /tmp/ccWvVg6G.s 			page 148


 5438              		.loc 1 2310 0
 5439 0276 284B     		ldr	r3, .L596+72
 5440 0278 0422     		movs	r2, #4
 5441 027a 1A70     		strb	r2, [r3]
 5442              	.L415:
2320:Src/usb_pd_protocol.c **** 		}
2321:Src/usb_pd_protocol.c **** 		/* If in Try.SRC state, then don't need to debounce */
2322:Src/usb_pd_protocol.c **** 		if (!(pd[port].flags & PD_FLAGS_TRY_SRC)) {
 5443              		.loc 1 2322 0
 5444 027c F201     		lsls	r2, r6, #7
 5445 027e 184B     		ldr	r3, .L596+16
 5446 0280 9B18     		adds	r3, r3, r2
 5447 0282 9B68     		ldr	r3, [r3, #8]
 5448 0284 9B04     		lsls	r3, r3, #18
 5449 0286 5ED4     		bmi	.L421
2323:Src/usb_pd_protocol.c **** 			/* Debounce the cc state */
2324:Src/usb_pd_protocol.c **** 			if (new_cc_state != pd[port].cc_state) {
 5450              		.loc 1 2324 0
 5451 0288 154B     		ldr	r3, .L596+16
 5452 028a 9B18     		adds	r3, r3, r2
 5453 028c 2833     		adds	r3, r3, #40
 5454 028e 1A78     		ldrb	r2, [r3]
 5455 0290 214B     		ldr	r3, .L596+72
 5456 0292 1B78     		ldrb	r3, [r3]
 5457 0294 9A42     		cmp	r2, r3
 5458 0296 43D0     		beq	.L422
2325:Src/usb_pd_protocol.c **** 				pd[port].cc_debounce = get_time().val +
 5459              		.loc 1 2325 0
 5460 0298 02A8     		add	r0, sp, #8
 5461 029a FFF7FEFF 		bl	get_time
 5462              	.LVL519:
 5463 029e 1F48     		ldr	r0, .L596+76
 5464 02a0 0021     		movs	r1, #0
 5465 02a2 029B     		ldr	r3, [sp, #8]
 5466 02a4 039C     		ldr	r4, [sp, #12]
 5467 02a6 C018     		adds	r0, r0, r3
 5468 02a8 6141     		adcs	r1, r1, r4
 5469 02aa F201     		lsls	r2, r6, #7
 5470 02ac 0C4B     		ldr	r3, .L596+16
 5471 02ae 9B18     		adds	r3, r3, r2
 5472 02b0 1862     		str	r0, [r3, #32]
 5473 02b2 5962     		str	r1, [r3, #36]
2326:Src/usb_pd_protocol.c **** 					PD_T_CC_DEBOUNCE;
2327:Src/usb_pd_protocol.c **** 				pd[port].cc_state = new_cc_state;
 5474              		.loc 1 2327 0
 5475 02b4 2833     		adds	r3, r3, #40
 5476 02b6 184A     		ldr	r2, .L596+72
 5477 02b8 1278     		ldrb	r2, [r2]
 5478 02ba 1A70     		strb	r2, [r3]
2328:Src/usb_pd_protocol.c **** 				break;
 5479              		.loc 1 2328 0
 5480 02bc 00F0A6FF 		bl	.L372	@ far jump
 5481              	.L543:
2314:Src/usb_pd_protocol.c **** 		} else {
 5482              		.loc 1 2314 0
 5483 02c0 154B     		ldr	r3, .L596+72
 5484 02c2 0132     		adds	r2, r2, #1
ARM GAS  /tmp/ccWvVg6G.s 			page 149


 5485 02c4 1A70     		strb	r2, [r3]
 5486 02c6 D9E7     		b	.L415
 5487              	.LVL520:
 5488              	.L544:
 5489              	.LBB860:
 5490              	.LBB859:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 5491              		.loc 1 396 0
 5492 02c8 3000     		movs	r0, r6
 5493 02ca FFF7FEFF 		bl	pd_power_supply_reset
 5494              	.LVL521:
 5495 02ce BDE7     		b	.L420
 5496              	.L597:
 5497              		.align	2
 5498              	.L596:
 5499 02d0 00000000 		.word	.LANCHOR2
 5500 02d4 00000000 		.word	tcpc_config
 5501 02d8 00000000 		.word	.LANCHOR3
 5502 02dc 00000000 		.word	.LANCHOR4
 5503 02e0 00000000 		.word	pd
 5504 02e4 00000000 		.word	.LANCHOR1
 5505 02e8 00000000 		.word	.LANCHOR5
 5506 02ec 20A10700 		.word	500000
 5507 02f0 00000000 		.word	.L374
 5508 02f4 10270000 		.word	10000
 5509 02f8 00000000 		.word	.LANCHOR7
 5510 02fc 00000000 		.word	.LANCHOR6
 5511 0300 00000000 		.word	.LANCHOR0
 5512 0304 00000000 		.word	.LANCHOR8
 5513 0308 409C0000 		.word	40000
 5514 030c C0270900 		.word	600000
 5515 0310 204E0000 		.word	20000
 5516 0314 88130000 		.word	5000
 5517 0318 00000000 		.word	.LANCHOR9
 5518 031c A0860100 		.word	100000
 5519              	.LVL522:
 5520              	.L422:
 5521              	.LBE859:
 5522              	.LBE860:
2329:Src/usb_pd_protocol.c **** 			} else if (get_time().val <
 5523              		.loc 1 2329 0
 5524 0320 02A8     		add	r0, sp, #8
 5525 0322 FFF7FEFF 		bl	get_time
 5526              	.LVL523:
 5527 0326 0298     		ldr	r0, [sp, #8]
 5528 0328 0399     		ldr	r1, [sp, #12]
2330:Src/usb_pd_protocol.c **** 					pd[port].cc_debounce) {
 5529              		.loc 1 2330 0
 5530 032a F201     		lsls	r2, r6, #7
 5531 032c D94B     		ldr	r3, .L598
 5532 032e 9B18     		adds	r3, r3, r2
 5533 0330 1A6A     		ldr	r2, [r3, #32]
 5534 0332 5B6A     		ldr	r3, [r3, #36]
2329:Src/usb_pd_protocol.c **** 			} else if (get_time().val <
 5535              		.loc 1 2329 0
 5536 0334 8B42     		cmp	r3, r1
 5537 0336 01D9     		bls	.LCB5651
ARM GAS  /tmp/ccWvVg6G.s 			page 150


 5538 0338 00F068FF 		bl	.L372	@far jump
 5539              	.LCB5651:
 5540 033c 03D1     		bne	.L421
 5541 033e 8242     		cmp	r2, r0
 5542 0340 01D9     		bls	.LCB5655
 5543 0342 00F063FF 		bl	.L372	@far jump
 5544              	.LCB5655:
 5545              	.L421:
2331:Src/usb_pd_protocol.c **** 				break;
2332:Src/usb_pd_protocol.c **** 			}
2333:Src/usb_pd_protocol.c **** 		}
2334:Src/usb_pd_protocol.c **** 
2335:Src/usb_pd_protocol.c **** 		/* Debounce complete */
2336:Src/usb_pd_protocol.c **** 		/* UFP is attached */
2337:Src/usb_pd_protocol.c **** 		if (new_cc_state == PD_CC_UFP_ATTACHED ||
 5546              		.loc 1 2337 0
 5547 0346 D44B     		ldr	r3, .L598+4
 5548 0348 1B78     		ldrb	r3, [r3]
 5549 034a 033B     		subs	r3, r3, #3
 5550 034c DBB2     		uxtb	r3, r3
 5551 034e 012B     		cmp	r3, #1
 5552 0350 01D9     		bls	.LCB5663
 5553 0352 00F05BFF 		bl	.L372	@far jump
 5554              	.LCB5663:
2338:Src/usb_pd_protocol.c **** 			new_cc_state == PD_CC_DEBUG_ACC) {
2339:Src/usb_pd_protocol.c **** 			pd[port].polarity = (cc1 != TYPEC_CC_VOLT_RD);
 5555              		.loc 1 2339 0
 5556 0356 D14B     		ldr	r3, .L598+8
 5557 0358 1968     		ldr	r1, [r3]
 5558 035a 0239     		subs	r1, r1, #2
 5559 035c 4B1E     		subs	r3, r1, #1
 5560 035e 9941     		sbcs	r1, r1, r3
 5561 0360 C9B2     		uxtb	r1, r1
 5562 0362 F201     		lsls	r2, r6, #7
 5563 0364 CB4B     		ldr	r3, .L598
 5564 0366 9B18     		adds	r3, r3, r2
 5565 0368 D970     		strb	r1, [r3, #3]
 5566              	.LVL524:
 5567              	.LBB861:
 5568              	.LBB862:
  76:Inc/tcpm.h    **** }
 5569              		.loc 2 76 0
 5570 036a 3000     		movs	r0, r6
 5571 036c A369     		ldr	r3, [r4, #24]
 5572 036e 9847     		blx	r3
 5573              	.LVL525:
 5574              	.LBE862:
 5575              	.LBE861:
2340:Src/usb_pd_protocol.c **** 			tcpm_set_polarity(port, pd[port].polarity);
2341:Src/usb_pd_protocol.c **** 
2342:Src/usb_pd_protocol.c **** 			/* initial data role for source is DFP */
2343:Src/usb_pd_protocol.c **** 			pd_set_data_role(port, PD_ROLE_DFP);
 5576              		.loc 1 2343 0
 5577 0370 0121     		movs	r1, #1
 5578 0372 3000     		movs	r0, r6
 5579 0374 FFF7FEFF 		bl	pd_set_data_role
 5580              	.LVL526:
ARM GAS  /tmp/ccWvVg6G.s 			page 151


2344:Src/usb_pd_protocol.c **** 
2345:Src/usb_pd_protocol.c **** 			if (new_cc_state == PD_CC_DEBUG_ACC)
 5581              		.loc 1 2345 0
 5582 0378 C74B     		ldr	r3, .L598+4
 5583 037a 1B78     		ldrb	r3, [r3]
 5584 037c 032B     		cmp	r3, #3
 5585 037e 26D0     		beq	.L545
 5586              	.L424:
2346:Src/usb_pd_protocol.c **** 				pd[port].flags |=
2347:Src/usb_pd_protocol.c **** 					PD_FLAGS_TS_DTS_PARTNER;
2348:Src/usb_pd_protocol.c **** 
2349:Src/usb_pd_protocol.c **** #ifndef CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP
2350:Src/usb_pd_protocol.c **** 			/* Enable VBUS */
2351:Src/usb_pd_protocol.c **** 			if (pd_set_power_supply_ready(port)) {
 5587              		.loc 1 2351 0
 5588 0380 3000     		movs	r0, r6
 5589 0382 FFF7FEFF 		bl	pd_set_power_supply_ready
 5590              	.LVL527:
 5591 0386 0028     		cmp	r0, #0
 5592 0388 01D0     		beq	.LCB5700
 5593 038a 00F03FFF 		bl	.L372	@far jump
 5594              	.LCB5700:
2352:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
2353:Src/usb_pd_protocol.c **** 				usb_mux_set(port, TYPEC_MUX_NONE,
2354:Src/usb_pd_protocol.c **** 						USB_SWITCH_DISCONNECT,
2355:Src/usb_pd_protocol.c **** 						pd[port].polarity);
2356:Src/usb_pd_protocol.c **** #endif
2357:Src/usb_pd_protocol.c **** 				break;
2358:Src/usb_pd_protocol.c **** 			}
2359:Src/usb_pd_protocol.c **** #endif
2360:Src/usb_pd_protocol.c **** 			/* If PD comm is enabled, enable TCPC RX */
2361:Src/usb_pd_protocol.c **** 			if (pd_comm_is_enabled(port))
 5595              		.loc 1 2361 0
 5596 038e 3000     		movs	r0, r6
 5597 0390 FFF7FEFF 		bl	pd_comm_is_enabled
 5598              	.LVL528:
 5599 0394 0028     		cmp	r0, #0
 5600 0396 03D0     		beq	.L425
 5601              	.LVL529:
 5602              	.LBB863:
 5603              	.LBB864:
  92:Inc/tcpm.h    **** }
 5604              		.loc 2 92 0
 5605 0398 636A     		ldr	r3, [r4, #36]
 5606 039a 0121     		movs	r1, #1
 5607 039c 3000     		movs	r0, r6
 5608 039e 9847     		blx	r3
 5609              	.LVL530:
 5610              	.L425:
 5611              	.LBE864:
 5612              	.LBE863:
2362:Src/usb_pd_protocol.c **** 				tcpm_set_rx_enable(port, 1);
2363:Src/usb_pd_protocol.c **** 
2364:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN
2365:Src/usb_pd_protocol.c **** 			tcpm_set_vconn(port, 1);
2366:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_VCONN_ON;
2367:Src/usb_pd_protocol.c **** #endif
ARM GAS  /tmp/ccWvVg6G.s 			page 152


2368:Src/usb_pd_protocol.c **** 
2369:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_PR_ROLE |
 5613              		.loc 1 2369 0
 5614 03a0 F201     		lsls	r2, r6, #7
 5615 03a2 BC4B     		ldr	r3, .L598
 5616 03a4 9B18     		adds	r3, r3, r2
 5617 03a6 C022     		movs	r2, #192
 5618 03a8 D200     		lsls	r2, r2, #3
 5619 03aa 9968     		ldr	r1, [r3, #8]
 5620 03ac 0A43     		orrs	r2, r1
 5621 03ae 9A60     		str	r2, [r3, #8]
2370:Src/usb_pd_protocol.c **** 						PD_FLAGS_CHECK_DR_ROLE;
2371:Src/usb_pd_protocol.c **** 			hard_reset_count = 0;
 5622              		.loc 1 2371 0
 5623 03b0 0022     		movs	r2, #0
 5624 03b2 BB49     		ldr	r1, .L598+12
 5625 03b4 0A60     		str	r2, [r1]
2372:Src/usb_pd_protocol.c **** 			timeout = 5*MSEC;
 5626              		.loc 1 2372 0
 5627 03b6 BB49     		ldr	r1, .L598+16
 5628 03b8 BB48     		ldr	r0, .L598+20
 5629 03ba 0860     		str	r0, [r1]
 5630              	.LVL531:
 5631              	.LBB865:
 5632              	.LBB866:
 5633              	.LBB867:
 5634              	.LBB868:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5635              		.loc 1 283 0
 5636 03bc 0020     		movs	r0, #0
 5637 03be 0021     		movs	r1, #0
 5638 03c0 1861     		str	r0, [r3, #16]
 5639 03c2 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5640              		.loc 1 284 0
 5641 03c4 DA71     		strb	r2, [r3, #7]
 5642              	.LVL532:
 5643              	.LBE868:
 5644              	.LBE867:
 352:Src/usb_pd_protocol.c **** 
 5645              		.loc 1 352 0
 5646 03c6 1132     		adds	r2, r2, #17
 5647 03c8 1A71     		strb	r2, [r3, #4]
 5648              	.LVL533:
 5649 03ca 00F01FFF 		bl	.L372	@ far jump
 5650              	.LVL534:
 5651              	.L545:
 5652              	.LBE866:
 5653              	.LBE865:
2346:Src/usb_pd_protocol.c **** 					PD_FLAGS_TS_DTS_PARTNER;
 5654              		.loc 1 2346 0
 5655 03ce F201     		lsls	r2, r6, #7
 5656 03d0 B04B     		ldr	r3, .L598
 5657 03d2 9B18     		adds	r3, r3, r2
 5658 03d4 8022     		movs	r2, #128
 5659 03d6 5202     		lsls	r2, r2, #9
 5660 03d8 9968     		ldr	r1, [r3, #8]
ARM GAS  /tmp/ccWvVg6G.s 			page 153


 5661 03da 0A43     		orrs	r2, r1
 5662 03dc 9A60     		str	r2, [r3, #8]
 5663 03de CFE7     		b	.L424
 5664              	.L389:
2373:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_STARTUP);
2374:Src/usb_pd_protocol.c **** 		}
2375:Src/usb_pd_protocol.c **** 		/*
2376:Src/usb_pd_protocol.c **** 			* AUDIO_ACC will remain in this state indefinitely
2377:Src/usb_pd_protocol.c **** 			* until disconnect.
2378:Src/usb_pd_protocol.c **** 			*/
2379:Src/usb_pd_protocol.c **** 		break;
2380:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_HARD_RESET_RECOVER:
2381:Src/usb_pd_protocol.c **** 		/* Do not continue until hard reset recovery time */
2382:Src/usb_pd_protocol.c **** 		if (get_time().val < pd[port].src_recover) {
 5665              		.loc 1 2382 0
 5666 03e0 02A8     		add	r0, sp, #8
 5667 03e2 FFF7FEFF 		bl	get_time
 5668              	.LVL535:
 5669 03e6 0298     		ldr	r0, [sp, #8]
 5670 03e8 0399     		ldr	r1, [sp, #12]
 5671 03ea F201     		lsls	r2, r6, #7
 5672 03ec A94B     		ldr	r3, .L598
 5673 03ee 9B18     		adds	r3, r3, r2
 5674 03f0 9A69     		ldr	r2, [r3, #24]
 5675 03f2 DB69     		ldr	r3, [r3, #28]
 5676 03f4 8B42     		cmp	r3, r1
 5677 03f6 04D9     		bls	.L546
 5678              	.L530:
2383:Src/usb_pd_protocol.c **** 			timeout = 50*MSEC;
 5679              		.loc 1 2383 0
 5680 03f8 AA4B     		ldr	r3, .L598+16
 5681 03fa AC4A     		ldr	r2, .L598+24
 5682 03fc 1A60     		str	r2, [r3]
2384:Src/usb_pd_protocol.c **** 			break;
 5683              		.loc 1 2384 0
 5684 03fe 00F005FF 		bl	.L372	@ far jump
 5685              	.L546:
2382:Src/usb_pd_protocol.c **** 			timeout = 50*MSEC;
 5686              		.loc 1 2382 0
 5687 0402 8B42     		cmp	r3, r1
 5688 0404 01D1     		bne	.L426
 5689 0406 8242     		cmp	r2, r0
 5690 0408 F6D8     		bhi	.L530
 5691              	.L426:
2385:Src/usb_pd_protocol.c **** 		}
2386:Src/usb_pd_protocol.c **** 
2387:Src/usb_pd_protocol.c **** 		/* Enable VBUS */
2388:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC;
 5692              		.loc 1 2388 0
 5693 040a A64B     		ldr	r3, .L598+16
 5694 040c A84A     		ldr	r2, .L598+28
 5695 040e 1A60     		str	r2, [r3]
2389:Src/usb_pd_protocol.c **** 		if (pd_set_power_supply_ready(port)) {
 5696              		.loc 1 2389 0
 5697 0410 3000     		movs	r0, r6
 5698 0412 FFF7FEFF 		bl	pd_set_power_supply_ready
 5699              	.LVL536:
ARM GAS  /tmp/ccWvVg6G.s 			page 154


 5700 0416 0028     		cmp	r0, #0
 5701 0418 2BD0     		beq	.L428
 5702              	.LVL537:
 5703              	.LBB869:
 5704              	.LBB870:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5705              		.loc 1 346 0
 5706 041a F201     		lsls	r2, r6, #7
 5707 041c 9D4B     		ldr	r3, .L598
 5708 041e 9B18     		adds	r3, r3, r2
 5709 0420 1A79     		ldrb	r2, [r3, #4]
 5710              	.LVL538:
 5711              	.LBB871:
 5712              	.LBB872:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5713              		.loc 1 283 0
 5714 0422 0020     		movs	r0, #0
 5715 0424 0021     		movs	r1, #0
 5716 0426 1861     		str	r0, [r3, #16]
 5717 0428 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5718              		.loc 1 284 0
 5719 042a 0021     		movs	r1, #0
 5720 042c D971     		strb	r1, [r3, #7]
 5721              	.LVL539:
 5722              	.LBE872:
 5723              	.LBE871:
 352:Src/usb_pd_protocol.c **** 
 5724              		.loc 1 352 0
 5725 042e 0E31     		adds	r1, r1, #14
 5726 0430 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 5727              		.loc 1 354 0
 5728 0432 0E2A     		cmp	r2, #14
 5729 0434 01D1     		bne	.LCB5843
 5730 0436 00F0E9FE 		bl	.L372	@far jump
 5731              	.LCB5843:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5732              		.loc 1 365 0
 5733 043a 022A     		cmp	r2, #2
 5734 043c 01D1     		bne	.LCB5845
 5735 043e 00F0E5FE 		bl	.L372	@far jump
 5736              	.LCB5845:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5737              		.loc 1 374 0
 5738 0442 0022     		movs	r2, #0
 5739              	.LVL540:
 5740 0444 0021     		movs	r1, #0
 5741 0446 3000     		movs	r0, r6
 5742 0448 FFF7FEFF 		bl	pd_set_input_current_limit
 5743              	.LVL541:
 391:Src/usb_pd_protocol.c **** 			/*
 5744              		.loc 1 391 0
 5745 044c F301     		lsls	r3, r6, #7
 5746 044e 914A     		ldr	r2, .L598
 5747 0450 9B5C     		ldrb	r3, [r3, r2]
 5748 0452 012B     		cmp	r3, #1
ARM GAS  /tmp/ccWvVg6G.s 			page 155


 5749 0454 09D0     		beq	.L547
 5750              	.L429:
 5751              	.LVL542:
 5752              	.LBB873:
 5753              	.LBB874:
  92:Inc/tcpm.h    **** }
 5754              		.loc 2 92 0
 5755 0456 3201     		lsls	r2, r6, #4
 5756 0458 964B     		ldr	r3, .L598+32
 5757 045a 9B18     		adds	r3, r3, r2
 5758 045c 9B68     		ldr	r3, [r3, #8]
 5759 045e 5B6A     		ldr	r3, [r3, #36]
 5760 0460 0021     		movs	r1, #0
 5761 0462 3000     		movs	r0, r6
 5762 0464 9847     		blx	r3
 5763              	.LVL543:
 5764 0466 00F0D1FE 		bl	.L372	@ far jump
 5765              	.LVL544:
 5766              	.L547:
 5767              	.LBE874:
 5768              	.LBE873:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 5769              		.loc 1 396 0
 5770 046a 3000     		movs	r0, r6
 5771 046c FFF7FEFF 		bl	pd_power_supply_reset
 5772              	.LVL545:
 5773 0470 F1E7     		b	.L429
 5774              	.LVL546:
 5775              	.L428:
 5776              	.LBE870:
 5777              	.LBE869:
 5778              	.LBB875:
 5779              	.LBB876:
 5780              	.LBB877:
 5781              	.LBB878:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5782              		.loc 1 283 0
 5783 0472 F201     		lsls	r2, r6, #7
 5784 0474 874B     		ldr	r3, .L598
 5785 0476 9B18     		adds	r3, r3, r2
 5786 0478 0020     		movs	r0, #0
 5787 047a 0021     		movs	r1, #0
 5788 047c 1861     		str	r0, [r3, #16]
 5789 047e 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5790              		.loc 1 284 0
 5791 0480 0022     		movs	r2, #0
 5792 0482 DA71     		strb	r2, [r3, #7]
 5793              	.LVL547:
 5794              	.LBE878:
 5795              	.LBE877:
 352:Src/usb_pd_protocol.c **** 
 5796              		.loc 1 352 0
 5797 0484 1132     		adds	r2, r2, #17
 5798 0486 1A71     		strb	r2, [r3, #4]
 5799              	.LVL548:
 5800 0488 00F0C0FE 		bl	.L372	@ far jump
ARM GAS  /tmp/ccWvVg6G.s 			page 156


 5801              	.LVL549:
 5802              	.L390:
 5803              	.LBE876:
 5804              	.LBE875:
2390:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
2391:Src/usb_pd_protocol.c **** 			break;
2392:Src/usb_pd_protocol.c **** 		}
2393:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPM_TCPCI
2394:Src/usb_pd_protocol.c **** 		/*
2395:Src/usb_pd_protocol.c **** 			* After transmitting hard reset, TCPM writes
2396:Src/usb_pd_protocol.c **** 			* to RECEIVE_DETECT register to enable
2397:Src/usb_pd_protocol.c **** 			* PD message passing.
2398:Src/usb_pd_protocol.c **** 			*/
2399:Src/usb_pd_protocol.c **** 		if (pd_comm_is_enabled(port))
2400:Src/usb_pd_protocol.c **** 			tcpm_set_rx_enable(port, 1);
2401:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_TCPM_TCPCI */
2402:Src/usb_pd_protocol.c **** 
2403:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_STARTUP);
2404:Src/usb_pd_protocol.c **** 		break;
2405:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_STARTUP:
2406:Src/usb_pd_protocol.c **** 		/* Wait for power source to enable */
2407:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 5805              		.loc 1 2407 0
 5806 048c F101     		lsls	r1, r6, #7
 5807 048e 814A     		ldr	r2, .L598
 5808 0490 5218     		adds	r2, r2, r1
 5809 0492 5279     		ldrb	r2, [r2, #5]
 5810 0494 9342     		cmp	r3, r2
 5811 0496 01D1     		bne	.LCB5936
 5812 0498 00F0B8FE 		bl	.L372	@far jump
 5813              	.LCB5936:
2408:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 5814              		.loc 1 2408 0
 5815 049c 7D4C     		ldr	r4, .L598
 5816 049e 6418     		adds	r4, r4, r1
 5817 04a0 0823     		movs	r3, #8
 5818 04a2 A268     		ldr	r2, [r4, #8]
 5819 04a4 1343     		orrs	r3, r2
 5820 04a6 A360     		str	r3, [r4, #8]
2409:Src/usb_pd_protocol.c **** 			/* reset various counters */
2410:Src/usb_pd_protocol.c **** 			caps_count = 0;
 5821              		.loc 1 2410 0
 5822 04a8 0023     		movs	r3, #0
 5823 04aa 834A     		ldr	r2, .L598+36
 5824 04ac 1360     		str	r3, [r2]
2411:Src/usb_pd_protocol.c **** 			pd[port].msg_id = 0;
 5825              		.loc 1 2411 0
 5826 04ae A370     		strb	r3, [r4, #2]
2412:Src/usb_pd_protocol.c **** 			snk_cap_count = 0;
 5827              		.loc 1 2412 0
 5828 04b0 824A     		ldr	r2, .L598+40
 5829 04b2 1360     		str	r3, [r2]
2413:Src/usb_pd_protocol.c **** 			set_state_timeout(
2414:Src/usb_pd_protocol.c **** 				port,
2415:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP
2416:Src/usb_pd_protocol.c **** 				/*
2417:Src/usb_pd_protocol.c **** 					* delay for power supply to start up.
ARM GAS  /tmp/ccWvVg6G.s 			page 157


2418:Src/usb_pd_protocol.c **** 					* subtract out debounce time if coming
2419:Src/usb_pd_protocol.c **** 					* from debounce state since vbus is
2420:Src/usb_pd_protocol.c **** 					* on during debounce.
2421:Src/usb_pd_protocol.c **** 					*/
2422:Src/usb_pd_protocol.c **** 				get_time().val +
2423:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY -
2424:Src/usb_pd_protocol.c **** 					(pd[port].last_state ==
2425:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_DISCONNECTED_DEBOUNCE
2426:Src/usb_pd_protocol.c **** 					? PD_T_CC_DEBOUNCE : 0),
2427:Src/usb_pd_protocol.c **** #else
2428:Src/usb_pd_protocol.c **** 				get_time().val +
 5830              		.loc 1 2428 0
 5831 04b4 02A8     		add	r0, sp, #8
 5832 04b6 FFF7FEFF 		bl	get_time
 5833              	.LVL550:
2413:Src/usb_pd_protocol.c **** 			set_state_timeout(
 5834              		.loc 1 2413 0
 5835 04ba 7D4A     		ldr	r2, .L598+28
 5836 04bc 0023     		movs	r3, #0
 5837 04be 0298     		ldr	r0, [sp, #8]
 5838 04c0 0399     		ldr	r1, [sp, #12]
 5839 04c2 1218     		adds	r2, r2, r0
 5840 04c4 4B41     		adcs	r3, r3, r1
 5841              	.LVL551:
 5842              	.LBB879:
 5843              	.LBB880:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5844              		.loc 1 283 0
 5845 04c6 2261     		str	r2, [r4, #16]
 5846 04c8 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 5847              		.loc 1 284 0
 5848 04ca 1223     		movs	r3, #18
 5849 04cc E371     		strb	r3, [r4, #7]
 5850 04ce 00F09DFE 		bl	.L372	@ far jump
 5851              	.LVL552:
 5852              	.L391:
 5853              	.LBE880:
 5854              	.LBE879:
2429:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
2430:Src/usb_pd_protocol.c **** #endif
2431:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_DISCOVERY);
2432:Src/usb_pd_protocol.c **** 		}
2433:Src/usb_pd_protocol.c **** 		break;
2434:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_DISCOVERY:
2435:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 5855              		.loc 1 2435 0
 5856 04d2 F101     		lsls	r1, r6, #7
 5857 04d4 6F4A     		ldr	r2, .L598
 5858 04d6 5218     		adds	r2, r2, r1
 5859 04d8 5279     		ldrb	r2, [r2, #5]
 5860 04da 9342     		cmp	r3, r2
 5861 04dc 04D0     		beq	.L430
2436:Src/usb_pd_protocol.c **** 			/*
2437:Src/usb_pd_protocol.c **** 				* If we have had PD connection with this port
2438:Src/usb_pd_protocol.c **** 				* partner, then start NoResponseTimer.
2439:Src/usb_pd_protocol.c **** 				*/
ARM GAS  /tmp/ccWvVg6G.s 			page 158


2440:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_PREVIOUS_PD_CONN)
 5862              		.loc 1 2440 0
 5863 04de 6D4B     		ldr	r3, .L598
 5864 04e0 5B18     		adds	r3, r3, r1
 5865 04e2 9B68     		ldr	r3, [r3, #8]
 5866 04e4 DB05     		lsls	r3, r3, #23
 5867 04e6 13D4     		bmi	.L548
 5868              	.L430:
2441:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2442:Src/usb_pd_protocol.c **** 					get_time().val +
2443:Src/usb_pd_protocol.c **** 					PD_T_NO_RESPONSE,
2444:Src/usb_pd_protocol.c **** 					hard_reset_count <
2445:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
2446:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND :
2447:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED);
2448:Src/usb_pd_protocol.c **** 		}
2449:Src/usb_pd_protocol.c **** 
2450:Src/usb_pd_protocol.c **** 		/* Send source cap some minimum number of times */
2451:Src/usb_pd_protocol.c **** 		if (caps_count < PD_CAPS_COUNT) {
 5869              		.loc 1 2451 0
 5870 04e8 734B     		ldr	r3, .L598+36
 5871 04ea 1B68     		ldr	r3, [r3]
 5872 04ec 312B     		cmp	r3, #49
 5873 04ee 01DD     		ble	.LCB5993
 5874 04f0 00F08CFE 		bl	.L372	@far jump
 5875              	.LCB5993:
2452:Src/usb_pd_protocol.c **** 			/* Query capabilities of the other side */
2453:Src/usb_pd_protocol.c **** 			res = send_source_cap(port);
 5876              		.loc 1 2453 0
 5877 04f4 3000     		movs	r0, r6
 5878 04f6 FFF7FEFF 		bl	send_source_cap
 5879              	.LVL553:
2454:Src/usb_pd_protocol.c **** 			/* packet was acked => PD capable device) */
2455:Src/usb_pd_protocol.c **** 			if (res >= 0) {
 5880              		.loc 1 2455 0
 5881 04fa 0028     		cmp	r0, #0
 5882 04fc 1FDA     		bge	.L549
2456:Src/usb_pd_protocol.c **** 				set_state(port,
2457:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_NEGOCIATE);
2458:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
2459:Src/usb_pd_protocol.c **** 				hard_reset_count = 0;
2460:Src/usb_pd_protocol.c **** 				caps_count = 0;
2461:Src/usb_pd_protocol.c **** 				/* Port partner is PD capable */
2462:Src/usb_pd_protocol.c **** 				pd[port].flags |=
2463:Src/usb_pd_protocol.c **** 					PD_FLAGS_PREVIOUS_PD_CONN;
2464:Src/usb_pd_protocol.c **** 			} else { /* failed, retry later */
2465:Src/usb_pd_protocol.c **** 				timeout = PD_T_SEND_SOURCE_CAP;
 5883              		.loc 1 2465 0
 5884 04fe 694B     		ldr	r3, .L598+16
 5885 0500 6F4A     		ldr	r2, .L598+44
 5886 0502 1A60     		str	r2, [r3]
2466:Src/usb_pd_protocol.c **** 				caps_count++;
 5887              		.loc 1 2466 0
 5888 0504 6C4A     		ldr	r2, .L598+36
 5889 0506 1368     		ldr	r3, [r2]
 5890 0508 0133     		adds	r3, r3, #1
 5891 050a 1360     		str	r3, [r2]
ARM GAS  /tmp/ccWvVg6G.s 			page 159


 5892 050c 00F07EFE 		bl	.L372	@ far jump
 5893              	.L548:
2442:Src/usb_pd_protocol.c **** 					PD_T_NO_RESPONSE,
 5894              		.loc 1 2442 0
 5895 0510 02A8     		add	r0, sp, #8
 5896 0512 FFF7FEFF 		bl	get_time
 5897              	.LVL554:
2441:Src/usb_pd_protocol.c **** 					get_time().val +
 5898              		.loc 1 2441 0
 5899 0516 6B48     		ldr	r0, .L598+48
 5900 0518 0021     		movs	r1, #0
 5901 051a 029B     		ldr	r3, [sp, #8]
 5902 051c 039C     		ldr	r4, [sp, #12]
 5903 051e C018     		adds	r0, r0, r3
 5904 0520 6141     		adcs	r1, r1, r4
2444:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
 5905              		.loc 1 2444 0
 5906 0522 5F4B     		ldr	r3, .L598+12
 5907 0524 1B68     		ldr	r3, [r3]
2441:Src/usb_pd_protocol.c **** 					get_time().val +
 5908              		.loc 1 2441 0
 5909 0526 012B     		cmp	r3, #1
 5910 0528 07DD     		ble	.L550
 5911 052a 0E24     		movs	r4, #14
 5912              	.L431:
 5913              	.LVL555:
 5914              	.LBB881:
 5915              	.LBB882:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5916              		.loc 1 283 0 discriminator 4
 5917 052c F201     		lsls	r2, r6, #7
 5918 052e 594B     		ldr	r3, .L598
 5919 0530 9B18     		adds	r3, r3, r2
 5920 0532 1861     		str	r0, [r3, #16]
 5921 0534 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5922              		.loc 1 284 0 discriminator 4
 5923 0536 DC71     		strb	r4, [r3, #7]
 5924 0538 D6E7     		b	.L430
 5925              	.LVL556:
 5926              	.L550:
 5927              	.LBE882:
 5928              	.LBE881:
2441:Src/usb_pd_protocol.c **** 					get_time().val +
 5929              		.loc 1 2441 0
 5930 053a 1F24     		movs	r4, #31
 5931 053c F6E7     		b	.L431
 5932              	.L549:
 5933              	.LVL557:
 5934              	.LBB883:
 5935              	.LBB884:
 5936              	.LBB885:
 5937              	.LBB886:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5938              		.loc 1 283 0
 5939 053e F201     		lsls	r2, r6, #7
 5940 0540 544B     		ldr	r3, .L598
ARM GAS  /tmp/ccWvVg6G.s 			page 160


 5941 0542 9B18     		adds	r3, r3, r2
 5942 0544 0020     		movs	r0, #0
 5943 0546 0021     		movs	r1, #0
 5944 0548 1861     		str	r0, [r3, #16]
 5945 054a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 5946              		.loc 1 284 0
 5947 054c 0022     		movs	r2, #0
 5948 054e DA71     		strb	r2, [r3, #7]
 5949              	.LVL558:
 5950              	.LBE886:
 5951              	.LBE885:
 352:Src/usb_pd_protocol.c **** 
 5952              		.loc 1 352 0
 5953 0550 1321     		movs	r1, #19
 5954 0552 1971     		strb	r1, [r3, #4]
 5955              	.LVL559:
 5956              	.LBE884:
 5957              	.LBE883:
2458:Src/usb_pd_protocol.c **** 				hard_reset_count = 0;
 5958              		.loc 1 2458 0
 5959 0554 5349     		ldr	r1, .L598+16
 5960 0556 5648     		ldr	r0, .L598+28
 5961 0558 0860     		str	r0, [r1]
2459:Src/usb_pd_protocol.c **** 				caps_count = 0;
 5962              		.loc 1 2459 0
 5963 055a 5149     		ldr	r1, .L598+12
 5964 055c 0A60     		str	r2, [r1]
2460:Src/usb_pd_protocol.c **** 				/* Port partner is PD capable */
 5965              		.loc 1 2460 0
 5966 055e 5649     		ldr	r1, .L598+36
 5967 0560 0A60     		str	r2, [r1]
2462:Src/usb_pd_protocol.c **** 					PD_FLAGS_PREVIOUS_PD_CONN;
 5968              		.loc 1 2462 0
 5969 0562 0132     		adds	r2, r2, #1
 5970 0564 FF32     		adds	r2, r2, #255
 5971 0566 9968     		ldr	r1, [r3, #8]
 5972 0568 0A43     		orrs	r2, r1
 5973 056a 9A60     		str	r2, [r3, #8]
 5974 056c 00F04EFE 		bl	.L372	@ far jump
 5975              	.L392:
2467:Src/usb_pd_protocol.c **** 			}
2468:Src/usb_pd_protocol.c **** 		}
2469:Src/usb_pd_protocol.c **** 		break;
2470:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_NEGOCIATE:
2471:Src/usb_pd_protocol.c **** 		/* wait for a "Request" message */
2472:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 5976              		.loc 1 2472 0
 5977 0570 F101     		lsls	r1, r6, #7
 5978 0572 484A     		ldr	r2, .L598
 5979 0574 5218     		adds	r2, r2, r1
 5980 0576 5279     		ldrb	r2, [r2, #5]
 5981 0578 9342     		cmp	r3, r2
 5982 057a 01D1     		bne	.LCB6107
 5983 057c 00F046FE 		bl	.L372	@far jump
 5984              	.LCB6107:
2473:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
ARM GAS  /tmp/ccWvVg6G.s 			page 161


2474:Src/usb_pd_protocol.c **** 						get_time().val +
 5985              		.loc 1 2474 0
 5986 0580 02A8     		add	r0, sp, #8
 5987 0582 FFF7FEFF 		bl	get_time
 5988              	.LVL560:
2473:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 5989              		.loc 1 2473 0
 5990 0586 4E48     		ldr	r0, .L598+44
 5991 0588 0021     		movs	r1, #0
 5992 058a 029B     		ldr	r3, [sp, #8]
 5993 058c 039C     		ldr	r4, [sp, #12]
 5994 058e C018     		adds	r0, r0, r3
 5995 0590 6141     		adcs	r1, r1, r4
 5996              	.LVL561:
 5997              	.LBB887:
 5998              	.LBB888:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5999              		.loc 1 283 0
 6000 0592 F201     		lsls	r2, r6, #7
 6001 0594 3F4B     		ldr	r3, .L598
 6002 0596 9B18     		adds	r3, r3, r2
 6003 0598 1861     		str	r0, [r3, #16]
 6004 059a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6005              		.loc 1 284 0
 6006 059c 1F22     		movs	r2, #31
 6007 059e DA71     		strb	r2, [r3, #7]
 6008 05a0 00F034FE 		bl	.L372	@ far jump
 6009              	.LVL562:
 6010              	.L393:
 6011              	.LBE888:
 6012              	.LBE887:
2475:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2476:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
2477:Src/usb_pd_protocol.c **** 		break;
2478:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_ACCEPTED:
2479:Src/usb_pd_protocol.c **** 		/* Accept sent, wait for enabling the new voltage */
2480:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 6013              		.loc 1 2480 0
 6014 05a4 F101     		lsls	r1, r6, #7
 6015 05a6 3B4A     		ldr	r2, .L598
 6016 05a8 5218     		adds	r2, r2, r1
 6017 05aa 5279     		ldrb	r2, [r2, #5]
 6018 05ac 9342     		cmp	r3, r2
 6019 05ae 01D1     		bne	.LCB6142
 6020 05b0 00F02CFE 		bl	.L372	@far jump
 6021              	.LCB6142:
2481:Src/usb_pd_protocol.c **** 			set_state_timeout(
2482:Src/usb_pd_protocol.c **** 				port,
2483:Src/usb_pd_protocol.c **** 				get_time().val +
 6022              		.loc 1 2483 0
 6023 05b4 02A8     		add	r0, sp, #8
 6024 05b6 FFF7FEFF 		bl	get_time
 6025              	.LVL563:
2481:Src/usb_pd_protocol.c **** 			set_state_timeout(
 6026              		.loc 1 2481 0
 6027 05ba 4348     		ldr	r0, .L598+52
ARM GAS  /tmp/ccWvVg6G.s 			page 162


 6028 05bc 0021     		movs	r1, #0
 6029 05be 029B     		ldr	r3, [sp, #8]
 6030 05c0 039C     		ldr	r4, [sp, #12]
 6031 05c2 C018     		adds	r0, r0, r3
 6032 05c4 6141     		adcs	r1, r1, r4
 6033              	.LVL564:
 6034              	.LBB889:
 6035              	.LBB890:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6036              		.loc 1 283 0
 6037 05c6 F201     		lsls	r2, r6, #7
 6038 05c8 324B     		ldr	r3, .L598
 6039 05ca 9B18     		adds	r3, r3, r2
 6040 05cc 1861     		str	r0, [r3, #16]
 6041 05ce 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6042              		.loc 1 284 0
 6043 05d0 1522     		movs	r2, #21
 6044 05d2 DA71     		strb	r2, [r3, #7]
 6045 05d4 00F01AFE 		bl	.L372	@ far jump
 6046              	.LVL565:
 6047              	.L394:
 6048              	.LBE890:
 6049              	.LBE889:
2484:Src/usb_pd_protocol.c **** 				PD_T_SINK_TRANSITION,
2485:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_POWERED);
2486:Src/usb_pd_protocol.c **** 		break;
2487:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_POWERED:
2488:Src/usb_pd_protocol.c **** 		/* Switch to the new requested voltage */
2489:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 6050              		.loc 1 2489 0
 6051 05d8 F101     		lsls	r1, r6, #7
 6052 05da 2E4A     		ldr	r2, .L598
 6053 05dc 5218     		adds	r2, r2, r1
 6054 05de 5279     		ldrb	r2, [r2, #5]
 6055 05e0 9342     		cmp	r3, r2
 6056 05e2 01D1     		bne	.LCB6177
 6057 05e4 00F012FE 		bl	.L372	@far jump
 6058              	.LCB6177:
2490:Src/usb_pd_protocol.c **** 			pd_transition_voltage(pd[port].requested_idx);
 6059              		.loc 1 2490 0
 6060 05e8 2A4C     		ldr	r4, .L598
 6061 05ea 6418     		adds	r4, r4, r1
 6062 05ec E06A     		ldr	r0, [r4, #44]
 6063 05ee FFF7FEFF 		bl	pd_transition_voltage
 6064              	.LVL566:
2491:Src/usb_pd_protocol.c **** 			set_state_timeout(
2492:Src/usb_pd_protocol.c **** 				port,
2493:Src/usb_pd_protocol.c **** 				get_time().val +
 6065              		.loc 1 2493 0
 6066 05f2 02A8     		add	r0, sp, #8
 6067 05f4 FFF7FEFF 		bl	get_time
 6068              	.LVL567:
2491:Src/usb_pd_protocol.c **** 			set_state_timeout(
 6069              		.loc 1 2491 0
 6070 05f8 2D4A     		ldr	r2, .L598+28
 6071 05fa 0023     		movs	r3, #0
ARM GAS  /tmp/ccWvVg6G.s 			page 163


 6072 05fc 0298     		ldr	r0, [sp, #8]
 6073 05fe 0399     		ldr	r1, [sp, #12]
 6074 0600 1218     		adds	r2, r2, r0
 6075 0602 4B41     		adcs	r3, r3, r1
 6076              	.LVL568:
 6077              	.LBB891:
 6078              	.LBB892:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6079              		.loc 1 283 0
 6080 0604 2261     		str	r2, [r4, #16]
 6081 0606 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 6082              		.loc 1 284 0
 6083 0608 1623     		movs	r3, #22
 6084 060a E371     		strb	r3, [r4, #7]
 6085 060c 00F0FEFD 		bl	.L372	@ far jump
 6086              	.LVL569:
 6087              	.L395:
 6088              	.LBE892:
 6089              	.LBE891:
2494:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
2495:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_TRANSITION);
2496:Src/usb_pd_protocol.c **** 		}
2497:Src/usb_pd_protocol.c **** 		break;
2498:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_TRANSITION:
2499:Src/usb_pd_protocol.c **** 		/* the voltage output is good, notify the source */
2500:Src/usb_pd_protocol.c **** 		res = send_control(port, PD_CTRL_PS_RDY);
 6090              		.loc 1 2500 0
 6091 0610 0621     		movs	r1, #6
 6092 0612 3000     		movs	r0, r6
 6093 0614 FFF7FEFF 		bl	send_control
 6094              	.LVL570:
2501:Src/usb_pd_protocol.c **** 		if (res >= 0) {
 6095              		.loc 1 2501 0
 6096 0618 0028     		cmp	r0, #0
 6097 061a 0FDB     		blt	.L433
2502:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC;
 6098              		.loc 1 2502 0
 6099 061c 214B     		ldr	r3, .L598+16
 6100 061e 244A     		ldr	r2, .L598+28
 6101 0620 1A60     		str	r2, [r3]
 6102              	.LVL571:
 6103              	.LBB893:
 6104              	.LBB894:
 6105              	.LBB895:
 6106              	.LBB896:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6107              		.loc 1 283 0
 6108 0622 F201     		lsls	r2, r6, #7
 6109 0624 1B4B     		ldr	r3, .L598
 6110 0626 9B18     		adds	r3, r3, r2
 6111 0628 0020     		movs	r0, #0
 6112 062a 0021     		movs	r1, #0
 6113 062c 1861     		str	r0, [r3, #16]
 6114 062e 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6115              		.loc 1 284 0
ARM GAS  /tmp/ccWvVg6G.s 			page 164


 6116 0630 0022     		movs	r2, #0
 6117 0632 DA71     		strb	r2, [r3, #7]
 6118              	.LVL572:
 6119              	.LBE896:
 6120              	.LBE895:
 352:Src/usb_pd_protocol.c **** 
 6121              		.loc 1 352 0
 6122 0634 1732     		adds	r2, r2, #23
 6123 0636 1A71     		strb	r2, [r3, #4]
 6124              	.LVL573:
 6125 0638 00F0E8FD 		bl	.L372	@ far jump
 6126              	.LVL574:
 6127              	.L433:
 6128              	.LBE894:
 6129              	.LBE893:
 6130              	.LBB897:
 6131              	.LBB898:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6132              		.loc 1 346 0
 6133 063c F201     		lsls	r2, r6, #7
 6134 063e 154B     		ldr	r3, .L598
 6135 0640 9B18     		adds	r3, r3, r2
 6136 0642 1A79     		ldrb	r2, [r3, #4]
 6137              	.LVL575:
 6138              	.LBB899:
 6139              	.LBB900:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6140              		.loc 1 283 0
 6141 0644 0020     		movs	r0, #0
 6142 0646 0021     		movs	r1, #0
 6143 0648 1861     		str	r0, [r3, #16]
 6144 064a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6145              		.loc 1 284 0
 6146 064c 0021     		movs	r1, #0
 6147 064e D971     		strb	r1, [r3, #7]
 6148              	.LVL576:
 6149              	.LBE900:
 6150              	.LBE899:
 352:Src/usb_pd_protocol.c **** 
 6151              		.loc 1 352 0
 6152 0650 0E31     		adds	r1, r1, #14
 6153 0652 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 6154              		.loc 1 354 0
 6155 0654 0E2A     		cmp	r2, #14
 6156 0656 01D1     		bne	.LCB6281
 6157 0658 00F0D8FD 		bl	.L372	@far jump
 6158              	.LCB6281:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6159              		.loc 1 365 0
 6160 065c 022A     		cmp	r2, #2
 6161 065e 01D1     		bne	.LCB6283
 6162 0660 00F0D4FD 		bl	.L372	@far jump
 6163              	.LCB6283:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6164              		.loc 1 374 0
ARM GAS  /tmp/ccWvVg6G.s 			page 165


 6165 0664 0022     		movs	r2, #0
 6166              	.LVL577:
 6167 0666 0021     		movs	r1, #0
 6168 0668 3000     		movs	r0, r6
 6169 066a FFF7FEFF 		bl	pd_set_input_current_limit
 6170              	.LVL578:
 391:Src/usb_pd_protocol.c **** 			/*
 6171              		.loc 1 391 0
 6172 066e F301     		lsls	r3, r6, #7
 6173 0670 084A     		ldr	r2, .L598
 6174 0672 9B5C     		ldrb	r3, [r3, r2]
 6175 0674 012B     		cmp	r3, #1
 6176 0676 09D0     		beq	.L551
 6177              	.L434:
 6178              	.LVL579:
 6179              	.LBB901:
 6180              	.LBB902:
  92:Inc/tcpm.h    **** }
 6181              		.loc 2 92 0
 6182 0678 3201     		lsls	r2, r6, #4
 6183 067a 0E4B     		ldr	r3, .L598+32
 6184 067c 9B18     		adds	r3, r3, r2
 6185 067e 9B68     		ldr	r3, [r3, #8]
 6186 0680 5B6A     		ldr	r3, [r3, #36]
 6187 0682 0021     		movs	r1, #0
 6188 0684 3000     		movs	r0, r6
 6189 0686 9847     		blx	r3
 6190              	.LVL580:
 6191 0688 00F0C0FD 		bl	.L372	@ far jump
 6192              	.LVL581:
 6193              	.L551:
 6194              	.LBE902:
 6195              	.LBE901:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 6196              		.loc 1 396 0
 6197 068c 3000     		movs	r0, r6
 6198 068e FFF7FEFF 		bl	pd_power_supply_reset
 6199              	.LVL582:
 6200 0692 F1E7     		b	.L434
 6201              	.L599:
 6202              		.align	2
 6203              	.L598:
 6204 0694 00000000 		.word	pd
 6205 0698 00000000 		.word	.LANCHOR9
 6206 069c 00000000 		.word	.LANCHOR7
 6207 06a0 00000000 		.word	.LANCHOR10
 6208 06a4 00000000 		.word	.LANCHOR5
 6209 06a8 88130000 		.word	5000
 6210 06ac 50C30000 		.word	50000
 6211 06b0 10270000 		.word	10000
 6212 06b4 00000000 		.word	tcpc_config
 6213 06b8 00000000 		.word	.LANCHOR11
 6214 06bc 00000000 		.word	.LANCHOR12
 6215 06c0 A0860100 		.word	100000
 6216 06c4 60EC5300 		.word	5500000
 6217 06c8 B8880000 		.word	35000
 6218              	.LVL583:
ARM GAS  /tmp/ccWvVg6G.s 			page 166


 6219              	.L396:
 6220              	.LBE898:
 6221              	.LBE897:
2503:Src/usb_pd_protocol.c **** 			/* it'a time to ping regularly the sink */
2504:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
2505:Src/usb_pd_protocol.c **** 		} else {
2506:Src/usb_pd_protocol.c **** 			/* The sink did not ack, cut the power... */
2507:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
2508:Src/usb_pd_protocol.c **** 		}
2509:Src/usb_pd_protocol.c **** 		break;
2510:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_READY:
2511:Src/usb_pd_protocol.c **** 		timeout = PD_T_SOURCE_ACTIVITY;
 6222              		.loc 1 2511 0
 6223 06cc D54B     		ldr	r3, .L600
 6224 06ce D64A     		ldr	r2, .L600+4
 6225 06d0 1A60     		str	r2, [r3]
2512:Src/usb_pd_protocol.c **** 
2513:Src/usb_pd_protocol.c **** 		/*
2514:Src/usb_pd_protocol.c **** 			* Don't send any PD traffic if we woke up due to
2515:Src/usb_pd_protocol.c **** 			* incoming packet or if VDO response pending to avoid
2516:Src/usb_pd_protocol.c **** 			* collisions.
2517:Src/usb_pd_protocol.c **** 			*/
2518:Src/usb_pd_protocol.c **** 		if (incoming_packet ||
 6226              		.loc 1 2518 0
 6227 06d2 D64B     		ldr	r3, .L600+8
 6228 06d4 1B68     		ldr	r3, [r3]
 6229 06d6 002B     		cmp	r3, #0
 6230 06d8 01D0     		beq	.LCB6358
 6231 06da 00F097FD 		bl	.L372	@far jump
 6232              	.LCB6358:
2519:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 6233              		.loc 1 2519 0 discriminator 1
 6234 06de F201     		lsls	r2, r6, #7
 6235 06e0 D34B     		ldr	r3, .L600+12
 6236 06e2 9B18     		adds	r3, r3, r2
 6237 06e4 4833     		adds	r3, r3, #72
 6238 06e6 1B78     		ldrb	r3, [r3]
 6239 06e8 5BB2     		sxtb	r3, r3
2518:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 6240              		.loc 1 2518 0 discriminator 1
 6241 06ea 022B     		cmp	r3, #2
 6242 06ec 01D1     		bne	.LCB6366
 6243 06ee 00F08DFD 		bl	.L372	@far jump
 6244              	.LCB6366:
2520:Src/usb_pd_protocol.c **** 			break;
2521:Src/usb_pd_protocol.c **** 
2522:Src/usb_pd_protocol.c **** 		/* Send updated source capabilities to our partner */
2523:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_UPDATE_SRC_CAPS) {
 6245              		.loc 1 2523 0
 6246 06f2 CF4B     		ldr	r3, .L600+12
 6247 06f4 9B18     		adds	r3, r3, r2
 6248 06f6 9A68     		ldr	r2, [r3, #8]
 6249 06f8 1304     		lsls	r3, r2, #16
 6250 06fa 26D4     		bmi	.L552
2524:Src/usb_pd_protocol.c **** 			res = send_source_cap(port);
2525:Src/usb_pd_protocol.c **** 			if (res >= 0) {
2526:Src/usb_pd_protocol.c **** 				set_state(port,
ARM GAS  /tmp/ccWvVg6G.s 			page 167


2527:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_NEGOCIATE);
2528:Src/usb_pd_protocol.c **** 				pd[port].flags &=
2529:Src/usb_pd_protocol.c **** 					~PD_FLAGS_UPDATE_SRC_CAPS;
2530:Src/usb_pd_protocol.c **** 			}
2531:Src/usb_pd_protocol.c **** 			break;
2532:Src/usb_pd_protocol.c **** 		}
2533:Src/usb_pd_protocol.c **** 
2534:Src/usb_pd_protocol.c **** 		/* Send get sink cap if haven't received it yet */
2535:Src/usb_pd_protocol.c **** 		if (!(pd[port].flags & PD_FLAGS_SNK_CAP_RECVD)) {
 6251              		.loc 1 2535 0
 6252 06fc D306     		lsls	r3, r2, #27
 6253 06fe 05D4     		bmi	.L436
2536:Src/usb_pd_protocol.c **** 			if (++snk_cap_count <= PD_SNK_CAP_RETRIES) {
 6254              		.loc 1 2536 0
 6255 0700 CC49     		ldr	r1, .L600+16
 6256 0702 0B68     		ldr	r3, [r1]
 6257 0704 0133     		adds	r3, r3, #1
 6258 0706 0B60     		str	r3, [r1]
 6259 0708 032B     		cmp	r3, #3
 6260 070a 32DD     		ble	.L553
 6261              	.L436:
2537:Src/usb_pd_protocol.c **** 				/* Get sink cap to know if dual-role device */
2538:Src/usb_pd_protocol.c **** 				send_control(port, PD_CTRL_GET_SINK_CAP);
2539:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_GET_SINK_CAP);
2540:Src/usb_pd_protocol.c **** 				break;
2541:Src/usb_pd_protocol.c **** 			} else if (debug_level >= 2 &&
2542:Src/usb_pd_protocol.c **** 					snk_cap_count == PD_SNK_CAP_RETRIES+1) {
2543:Src/usb_pd_protocol.c **** 				CPRINTF("ERR SNK_CAP\n");
2544:Src/usb_pd_protocol.c **** 			}
2545:Src/usb_pd_protocol.c **** 		}
2546:Src/usb_pd_protocol.c **** 
2547:Src/usb_pd_protocol.c **** 		/* Check power role policy, which may trigger a swap */
2548:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_PR_ROLE) {
 6262              		.loc 1 2548 0
 6263 070c 9305     		lsls	r3, r2, #22
 6264 070e 3AD4     		bmi	.L554
2549:Src/usb_pd_protocol.c **** 			pd_check_pr_role(port, PD_ROLE_SOURCE,
2550:Src/usb_pd_protocol.c **** 						pd[port].flags);
2551:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_PR_ROLE;
2552:Src/usb_pd_protocol.c **** 			break;
2553:Src/usb_pd_protocol.c **** 		}
2554:Src/usb_pd_protocol.c **** 
2555:Src/usb_pd_protocol.c **** 		/* Check data role policy, which may trigger a swap */
2556:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_DR_ROLE) {
 6265              		.loc 1 2556 0
 6266 0710 5305     		lsls	r3, r2, #21
 6267 0712 45D4     		bmi	.L555
2557:Src/usb_pd_protocol.c **** 			pd_check_dr_role(port, pd[port].data_role,
2558:Src/usb_pd_protocol.c **** 						pd[port].flags);
2559:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_DR_ROLE;
2560:Src/usb_pd_protocol.c **** 			break;
2561:Src/usb_pd_protocol.c **** 		}
2562:Src/usb_pd_protocol.c **** 
2563:Src/usb_pd_protocol.c **** 		/* Send discovery SVDMs last */
2564:Src/usb_pd_protocol.c **** 		if (pd[port].data_role == PD_ROLE_DFP &&
 6268              		.loc 1 2564 0
 6269 0714 F101     		lsls	r1, r6, #7
ARM GAS  /tmp/ccWvVg6G.s 			page 168


 6270 0716 C64B     		ldr	r3, .L600+12
 6271 0718 5B18     		adds	r3, r3, r1
 6272 071a 5B78     		ldrb	r3, [r3, #1]
 6273 071c 012B     		cmp	r3, #1
 6274 071e 4CD0     		beq	.L556
 6275              	.L439:
2565:Src/usb_pd_protocol.c **** 			(pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
2566:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_SIMPLE_DFP
2567:Src/usb_pd_protocol.c **** 			pd_send_vdm(port, USB_SID_PD,
2568:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
2569:Src/usb_pd_protocol.c **** #endif
2570:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_IDENTITY;
2571:Src/usb_pd_protocol.c **** 			break;
2572:Src/usb_pd_protocol.c **** 		}
2573:Src/usb_pd_protocol.c **** 
2574:Src/usb_pd_protocol.c **** 		if (!(pd[port].flags & PD_FLAGS_PING_ENABLED))
 6276              		.loc 1 2574 0
 6277 0720 D307     		lsls	r3, r2, #31
 6278 0722 01D4     		bmi	.LCB6404
 6279 0724 00F072FD 		bl	.L372	@far jump
 6280              	.LCB6404:
2575:Src/usb_pd_protocol.c **** 			break;
2576:Src/usb_pd_protocol.c **** 
2577:Src/usb_pd_protocol.c **** 		/* Verify that the sink is alive */
2578:Src/usb_pd_protocol.c **** 		res = send_control(port, PD_CTRL_PING);
 6281              		.loc 1 2578 0
 6282 0728 0521     		movs	r1, #5
 6283 072a 3000     		movs	r0, r6
 6284 072c FFF7FEFF 		bl	send_control
 6285              	.LVL584:
2579:Src/usb_pd_protocol.c **** 		if (res >= 0)
 6286              		.loc 1 2579 0
 6287 0730 0028     		cmp	r0, #0
 6288 0732 01DB     		blt	.LCB6410
 6289 0734 00F06AFD 		bl	.L372	@far jump
 6290              	.LCB6410:
2580:Src/usb_pd_protocol.c **** 			break;
2581:Src/usb_pd_protocol.c **** 
2582:Src/usb_pd_protocol.c **** 		/* Ping dropped. Try soft reset. */
2583:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SOFT_RESET);
 6291              		.loc 1 2583 0
 6292 0738 1E21     		movs	r1, #30
 6293 073a 3000     		movs	r0, r6
 6294 073c FFF7FEFF 		bl	set_state
 6295              	.LVL585:
2584:Src/usb_pd_protocol.c **** 		timeout = 10 * MSEC;
 6296              		.loc 1 2584 0
 6297 0740 B84B     		ldr	r3, .L600
 6298 0742 BD4A     		ldr	r2, .L600+20
 6299 0744 1A60     		str	r2, [r3]
2585:Src/usb_pd_protocol.c **** 		break;
 6300              		.loc 1 2585 0
 6301 0746 00F061FD 		bl	.L372	@ far jump
 6302              	.L552:
2524:Src/usb_pd_protocol.c **** 			if (res >= 0) {
 6303              		.loc 1 2524 0
 6304 074a 3000     		movs	r0, r6
ARM GAS  /tmp/ccWvVg6G.s 			page 169


 6305 074c FFF7FEFF 		bl	send_source_cap
 6306              	.LVL586:
2525:Src/usb_pd_protocol.c **** 				set_state(port,
 6307              		.loc 1 2525 0
 6308 0750 0028     		cmp	r0, #0
 6309 0752 01DA     		bge	.LCB6427
 6310 0754 00F05AFD 		bl	.L372	@far jump
 6311              	.LCB6427:
2526:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_NEGOCIATE);
 6312              		.loc 1 2526 0
 6313 0758 1321     		movs	r1, #19
 6314 075a 3000     		movs	r0, r6
 6315 075c FFF7FEFF 		bl	set_state
 6316              	.LVL587:
2528:Src/usb_pd_protocol.c **** 					~PD_FLAGS_UPDATE_SRC_CAPS;
 6317              		.loc 1 2528 0
 6318 0760 F201     		lsls	r2, r6, #7
 6319 0762 B34B     		ldr	r3, .L600+12
 6320 0764 9B18     		adds	r3, r3, r2
 6321 0766 B54A     		ldr	r2, .L600+24
 6322 0768 9968     		ldr	r1, [r3, #8]
 6323 076a 0A40     		ands	r2, r1
 6324 076c 9A60     		str	r2, [r3, #8]
 6325 076e 00F04DFD 		bl	.L372	@ far jump
 6326              	.L553:
2538:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_GET_SINK_CAP);
 6327              		.loc 1 2538 0
 6328 0772 0821     		movs	r1, #8
 6329 0774 3000     		movs	r0, r6
 6330 0776 FFF7FEFF 		bl	send_control
 6331              	.LVL588:
2539:Src/usb_pd_protocol.c **** 				break;
 6332              		.loc 1 2539 0
 6333 077a 1821     		movs	r1, #24
 6334 077c 3000     		movs	r0, r6
 6335 077e FFF7FEFF 		bl	set_state
 6336              	.LVL589:
2540:Src/usb_pd_protocol.c **** 			} else if (debug_level >= 2 &&
 6337              		.loc 1 2540 0
 6338 0782 00F043FD 		bl	.L372	@ far jump
 6339              	.L554:
2549:Src/usb_pd_protocol.c **** 						pd[port].flags);
 6340              		.loc 1 2549 0
 6341 0786 0121     		movs	r1, #1
 6342 0788 3000     		movs	r0, r6
 6343 078a FFF7FEFF 		bl	pd_check_pr_role
 6344              	.LVL590:
2551:Src/usb_pd_protocol.c **** 			break;
 6345              		.loc 1 2551 0
 6346 078e F201     		lsls	r2, r6, #7
 6347 0790 A74B     		ldr	r3, .L600+12
 6348 0792 9B18     		adds	r3, r3, r2
 6349 0794 AA4A     		ldr	r2, .L600+28
 6350 0796 9968     		ldr	r1, [r3, #8]
 6351 0798 0A40     		ands	r2, r1
 6352 079a 9A60     		str	r2, [r3, #8]
2552:Src/usb_pd_protocol.c **** 		}
ARM GAS  /tmp/ccWvVg6G.s 			page 170


 6353              		.loc 1 2552 0
 6354 079c 00F036FD 		bl	.L372	@ far jump
 6355              	.L555:
2557:Src/usb_pd_protocol.c **** 						pd[port].flags);
 6356              		.loc 1 2557 0
 6357 07a0 F301     		lsls	r3, r6, #7
 6358 07a2 A34C     		ldr	r4, .L600+12
 6359 07a4 E418     		adds	r4, r4, r3
 6360 07a6 6178     		ldrb	r1, [r4, #1]
 6361 07a8 3000     		movs	r0, r6
 6362 07aa FFF7FEFF 		bl	pd_check_dr_role
 6363              	.LVL591:
2559:Src/usb_pd_protocol.c **** 			break;
 6364              		.loc 1 2559 0
 6365 07ae A54B     		ldr	r3, .L600+32
 6366 07b0 A268     		ldr	r2, [r4, #8]
 6367 07b2 1340     		ands	r3, r2
 6368 07b4 A360     		str	r3, [r4, #8]
2560:Src/usb_pd_protocol.c **** 		}
 6369              		.loc 1 2560 0
 6370 07b6 00F029FD 		bl	.L372	@ far jump
 6371              	.L556:
2564:Src/usb_pd_protocol.c **** 			(pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
 6372              		.loc 1 2564 0 discriminator 1
 6373 07ba 1307     		lsls	r3, r2, #28
 6374 07bc B0D5     		bpl	.L439
2567:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
 6375              		.loc 1 2567 0
 6376 07be FF21     		movs	r1, #255
 6377 07c0 0023     		movs	r3, #0
 6378 07c2 0093     		str	r3, [sp]
 6379 07c4 0122     		movs	r2, #1
 6380 07c6 0902     		lsls	r1, r1, #8
 6381 07c8 3000     		movs	r0, r6
 6382 07ca FFF7FEFF 		bl	pd_send_vdm
 6383              	.LVL592:
2570:Src/usb_pd_protocol.c **** 			break;
 6384              		.loc 1 2570 0
 6385 07ce F201     		lsls	r2, r6, #7
 6386 07d0 974B     		ldr	r3, .L600+12
 6387 07d2 9B18     		adds	r3, r3, r2
 6388 07d4 0822     		movs	r2, #8
 6389 07d6 9968     		ldr	r1, [r3, #8]
 6390 07d8 9143     		bics	r1, r2
 6391 07da 9960     		str	r1, [r3, #8]
2571:Src/usb_pd_protocol.c **** 		}
 6392              		.loc 1 2571 0
 6393 07dc 00F016FD 		bl	.L372	@ far jump
 6394              	.L397:
2586:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_GET_SINK_CAP:
2587:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 6395              		.loc 1 2587 0
 6396 07e0 F101     		lsls	r1, r6, #7
 6397 07e2 934A     		ldr	r2, .L600+12
 6398 07e4 5218     		adds	r2, r2, r1
 6399 07e6 5279     		ldrb	r2, [r2, #5]
 6400 07e8 9342     		cmp	r3, r2
ARM GAS  /tmp/ccWvVg6G.s 			page 171


 6401 07ea 01D1     		bne	.LCB6522
 6402 07ec 00F00EFD 		bl	.L372	@far jump
 6403              	.LCB6522:
2588:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2589:Src/usb_pd_protocol.c **** 						get_time().val +
 6404              		.loc 1 2589 0
 6405 07f0 02A8     		add	r0, sp, #8
 6406 07f2 FFF7FEFF 		bl	get_time
 6407              	.LVL593:
2588:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 6408              		.loc 1 2588 0
 6409 07f6 9448     		ldr	r0, .L600+36
 6410 07f8 0021     		movs	r1, #0
 6411 07fa 029B     		ldr	r3, [sp, #8]
 6412 07fc 039C     		ldr	r4, [sp, #12]
 6413 07fe C018     		adds	r0, r0, r3
 6414 0800 6141     		adcs	r1, r1, r4
 6415              	.LVL594:
 6416              	.LBB903:
 6417              	.LBB904:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6418              		.loc 1 283 0
 6419 0802 F201     		lsls	r2, r6, #7
 6420 0804 8A4B     		ldr	r3, .L600+12
 6421 0806 9B18     		adds	r3, r3, r2
 6422 0808 1861     		str	r0, [r3, #16]
 6423 080a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6424              		.loc 1 284 0
 6425 080c 1722     		movs	r2, #23
 6426 080e DA71     		strb	r2, [r3, #7]
 6427 0810 00F0FCFC 		bl	.L372	@ far jump
 6428              	.LVL595:
 6429              	.L398:
 6430              	.LBE904:
 6431              	.LBE903:
2590:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2591:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_READY);
2592:Src/usb_pd_protocol.c **** 		break;
2593:Src/usb_pd_protocol.c **** 	case PD_STATE_DR_SWAP:
2594:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 6432              		.loc 1 2594 0
 6433 0814 F101     		lsls	r1, r6, #7
 6434 0816 864A     		ldr	r2, .L600+12
 6435 0818 5218     		adds	r2, r2, r1
 6436 081a 5279     		ldrb	r2, [r2, #5]
 6437 081c 9342     		cmp	r3, r2
 6438 081e 01D1     		bne	.LCB6557
 6439 0820 00F0F4FC 		bl	.L372	@far jump
 6440              	.LCB6557:
2595:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_DR_SWAP);
 6441              		.loc 1 2595 0
 6442 0824 0921     		movs	r1, #9
 6443 0826 3000     		movs	r0, r6
 6444 0828 FFF7FEFF 		bl	send_control
 6445              	.LVL596:
2596:Src/usb_pd_protocol.c **** 			if (res < 0) {
ARM GAS  /tmp/ccWvVg6G.s 			page 172


 6446              		.loc 1 2596 0
 6447 082c 0028     		cmp	r0, #0
 6448 082e 47DA     		bge	.L440
2597:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
 6449              		.loc 1 2597 0
 6450 0830 7C4B     		ldr	r3, .L600
 6451 0832 814A     		ldr	r2, .L600+20
 6452 0834 1A60     		str	r2, [r3]
2598:Src/usb_pd_protocol.c **** 				/*
2599:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
2600:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
2601:Src/usb_pd_protocol.c **** 					* failure.
2602:Src/usb_pd_protocol.c **** 					*/
2603:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
 6453              		.loc 1 2603 0
 6454 0836 431C     		adds	r3, r0, #1
 6455 0838 06D0     		beq	.L524
2604:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
2605:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
 6456              		.loc 1 2605 0
 6457 083a F301     		lsls	r3, r6, #7
 6458 083c 7C4A     		ldr	r2, .L600+12
 6459 083e 9B5C     		ldrb	r3, [r3, r2]
2604:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
 6460              		.loc 1 2604 0
 6461 0840 002B     		cmp	r3, #0
 6462 0842 2FD1     		bne	.L525
 6463 0844 0822     		movs	r2, #8
 6464 0846 00E0     		b	.L441
 6465              	.L524:
2603:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
 6466              		.loc 1 2603 0
 6467 0848 1E22     		movs	r2, #30
 6468              	.L441:
 6469              	.LVL597:
 6470              	.LBB905:
 6471              	.LBB906:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6472              		.loc 1 346 0 discriminator 3
 6473 084a F101     		lsls	r1, r6, #7
 6474 084c 784B     		ldr	r3, .L600+12
 6475 084e 5B18     		adds	r3, r3, r1
 6476 0850 1C79     		ldrb	r4, [r3, #4]
 6477              	.LVL598:
 6478              	.LBB907:
 6479              	.LBB908:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6480              		.loc 1 283 0 discriminator 3
 6481 0852 0020     		movs	r0, #0
 6482 0854 0021     		movs	r1, #0
 6483 0856 1861     		str	r0, [r3, #16]
 6484 0858 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6485              		.loc 1 284 0 discriminator 3
 6486 085a 0021     		movs	r1, #0
 6487 085c D971     		strb	r1, [r3, #7]
 6488              	.LVL599:
ARM GAS  /tmp/ccWvVg6G.s 			page 173


 6489              	.LBE908:
 6490              	.LBE907:
 352:Src/usb_pd_protocol.c **** 
 6491              		.loc 1 352 0 discriminator 3
 6492 085e 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 6493              		.loc 1 354 0 discriminator 3
 6494 0860 A242     		cmp	r2, r4
 6495 0862 01D1     		bne	.LCB6608
 6496 0864 00F0D2FC 		bl	.L372	@far jump
 6497              	.LCB6608:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6498              		.loc 1 365 0
 6499 0868 022C     		cmp	r4, #2
 6500 086a 1DD0     		beq	.L557
 6501              	.L442:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 6502              		.loc 1 366 0
 6503 086c 0E2C     		cmp	r4, #14
 6504 086e 1FD0     		beq	.L558
 6505              	.L443:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 6506              		.loc 1 371 0
 6507 0870 0E2A     		cmp	r2, #14
 6508 0872 03D0     		beq	.L444
 6509 0874 022A     		cmp	r2, #2
 6510 0876 01D0     		beq	.LCB6619
 6511 0878 00F0C8FC 		bl	.L372	@far jump
 6512              	.LCB6619:
 6513              	.L444:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6514              		.loc 1 374 0
 6515 087c 0022     		movs	r2, #0
 6516              	.LVL600:
 6517 087e 0021     		movs	r1, #0
 6518 0880 3000     		movs	r0, r6
 6519 0882 FFF7FEFF 		bl	pd_set_input_current_limit
 6520              	.LVL601:
 391:Src/usb_pd_protocol.c **** 			/*
 6521              		.loc 1 391 0
 6522 0886 F301     		lsls	r3, r6, #7
 6523 0888 694A     		ldr	r2, .L600+12
 6524 088a 9B5C     		ldrb	r3, [r3, r2]
 6525 088c 012B     		cmp	r3, #1
 6526 088e 13D0     		beq	.L559
 6527              	.L445:
 6528              	.LVL602:
 6529              	.LBB909:
 6530              	.LBB910:
  92:Inc/tcpm.h    **** }
 6531              		.loc 2 92 0
 6532 0890 3201     		lsls	r2, r6, #4
 6533 0892 6E4B     		ldr	r3, .L600+40
 6534 0894 9B18     		adds	r3, r3, r2
 6535 0896 9B68     		ldr	r3, [r3, #8]
 6536 0898 5B6A     		ldr	r3, [r3, #36]
 6537 089a 0021     		movs	r1, #0
ARM GAS  /tmp/ccWvVg6G.s 			page 174


 6538 089c 3000     		movs	r0, r6
 6539 089e 9847     		blx	r3
 6540              	.LVL603:
 6541 08a0 00F0B4FC 		bl	.L372	@ far jump
 6542              	.LVL604:
 6543              	.L525:
 6544              	.LBE910:
 6545              	.LBE909:
 6546              	.LBE906:
 6547              	.LBE905:
2604:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
 6548              		.loc 1 2604 0
 6549 08a4 1722     		movs	r2, #23
 6550 08a6 D0E7     		b	.L441
 6551              	.LVL605:
 6552              	.L557:
 6553              	.LBB912:
 6554              	.LBB911:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6555              		.loc 1 365 0
 6556 08a8 0E2A     		cmp	r2, #14
 6557 08aa DFD1     		bne	.L442
 6558 08ac 00F0AEFC 		bl	.L372	@ far jump
 6559              	.L558:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 6560              		.loc 1 367 0
 6561 08b0 022A     		cmp	r2, #2
 6562 08b2 DDD1     		bne	.L443
 6563 08b4 00F0AAFC 		bl	.L372	@ far jump
 6564              	.LVL606:
 6565              	.L559:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 6566              		.loc 1 396 0
 6567 08b8 3000     		movs	r0, r6
 6568 08ba FFF7FEFF 		bl	pd_power_supply_reset
 6569              	.LVL607:
 6570 08be E7E7     		b	.L445
 6571              	.LVL608:
 6572              	.L440:
 6573              	.LBE911:
 6574              	.LBE912:
2606:Src/usb_pd_protocol.c **** 				break;
2607:Src/usb_pd_protocol.c **** 			}
2608:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
2609:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2610:Src/usb_pd_protocol.c **** 						get_time().val +
 6575              		.loc 1 2610 0
 6576 08c0 02A8     		add	r0, sp, #8
 6577 08c2 FFF7FEFF 		bl	get_time
 6578              	.LVL609:
2609:Src/usb_pd_protocol.c **** 						get_time().val +
 6579              		.loc 1 2609 0
 6580 08c6 6048     		ldr	r0, .L600+36
 6581 08c8 0021     		movs	r1, #0
 6582 08ca 029B     		ldr	r3, [sp, #8]
 6583 08cc 039C     		ldr	r4, [sp, #12]
 6584 08ce C018     		adds	r0, r0, r3
ARM GAS  /tmp/ccWvVg6G.s 			page 175


 6585 08d0 6141     		adcs	r1, r1, r4
2611:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2612:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
 6586              		.loc 1 2612 0
 6587 08d2 F301     		lsls	r3, r6, #7
 6588 08d4 564A     		ldr	r2, .L600+12
 6589 08d6 9B5C     		ldrb	r3, [r3, r2]
2609:Src/usb_pd_protocol.c **** 						get_time().val +
 6590              		.loc 1 2609 0
 6591 08d8 002B     		cmp	r3, #0
 6592 08da 08D1     		bne	.L526
 6593 08dc 0824     		movs	r4, #8
 6594              	.L446:
 6595              	.LVL610:
 6596              	.LBB913:
 6597              	.LBB914:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6598              		.loc 1 283 0 discriminator 4
 6599 08de F201     		lsls	r2, r6, #7
 6600 08e0 534B     		ldr	r3, .L600+12
 6601 08e2 9B18     		adds	r3, r3, r2
 6602 08e4 1861     		str	r0, [r3, #16]
 6603 08e6 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6604              		.loc 1 284 0 discriminator 4
 6605 08e8 DC71     		strb	r4, [r3, #7]
 6606 08ea 00F08FFC 		bl	.L372	@ far jump
 6607              	.LVL611:
 6608              	.L526:
 6609              	.LBE914:
 6610              	.LBE913:
2609:Src/usb_pd_protocol.c **** 						get_time().val +
 6611              		.loc 1 2609 0
 6612 08ee 1724     		movs	r4, #23
 6613 08f0 F5E7     		b	.L446
 6614              	.L399:
2613:Src/usb_pd_protocol.c **** 		}
2614:Src/usb_pd_protocol.c **** 		break;
2615:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2616:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_INIT:
2617:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 6615              		.loc 1 2617 0
 6616 08f2 F101     		lsls	r1, r6, #7
 6617 08f4 4E4A     		ldr	r2, .L600+12
 6618 08f6 5218     		adds	r2, r2, r1
 6619 08f8 5279     		ldrb	r2, [r2, #5]
 6620 08fa 9342     		cmp	r3, r2
 6621 08fc 01D1     		bne	.LCB6748
 6622 08fe 00F085FC 		bl	.L372	@far jump
 6623              	.LCB6748:
2618:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_PR_SWAP);
 6624              		.loc 1 2618 0
 6625 0902 0A21     		movs	r1, #10
 6626 0904 3000     		movs	r0, r6
 6627 0906 FFF7FEFF 		bl	send_control
 6628              	.LVL612:
2619:Src/usb_pd_protocol.c **** 			if (res < 0) {
ARM GAS  /tmp/ccWvVg6G.s 			page 176


 6629              		.loc 1 2619 0
 6630 090a 0028     		cmp	r0, #0
 6631 090c 40DA     		bge	.L447
2620:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
 6632              		.loc 1 2620 0
 6633 090e 454B     		ldr	r3, .L600
 6634 0910 494A     		ldr	r2, .L600+20
 6635 0912 1A60     		str	r2, [r3]
2621:Src/usb_pd_protocol.c **** 				/*
2622:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
2623:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
2624:Src/usb_pd_protocol.c **** 					* failure.
2625:Src/usb_pd_protocol.c **** 					*/
2626:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
 6636              		.loc 1 2626 0
 6637 0914 431C     		adds	r3, r0, #1
 6638 0916 2DD0     		beq	.L560
 6639 0918 1722     		movs	r2, #23
 6640              	.L448:
 6641              	.LVL613:
 6642              	.LBB915:
 6643              	.LBB916:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6644              		.loc 1 346 0 discriminator 4
 6645 091a F101     		lsls	r1, r6, #7
 6646 091c 444B     		ldr	r3, .L600+12
 6647 091e 5B18     		adds	r3, r3, r1
 6648 0920 1C79     		ldrb	r4, [r3, #4]
 6649              	.LVL614:
 6650              	.LBB917:
 6651              	.LBB918:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6652              		.loc 1 283 0 discriminator 4
 6653 0922 0020     		movs	r0, #0
 6654 0924 0021     		movs	r1, #0
 6655 0926 1861     		str	r0, [r3, #16]
 6656 0928 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6657              		.loc 1 284 0 discriminator 4
 6658 092a 0021     		movs	r1, #0
 6659 092c D971     		strb	r1, [r3, #7]
 6660              	.LVL615:
 6661              	.LBE918:
 6662              	.LBE917:
 352:Src/usb_pd_protocol.c **** 
 6663              		.loc 1 352 0 discriminator 4
 6664 092e 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 6665              		.loc 1 354 0 discriminator 4
 6666 0930 A242     		cmp	r2, r4
 6667 0932 01D1     		bne	.LCB6789
 6668 0934 00F06AFC 		bl	.L372	@far jump
 6669              	.LCB6789:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6670              		.loc 1 365 0
 6671 0938 022C     		cmp	r4, #2
 6672 093a 1DD0     		beq	.L561
ARM GAS  /tmp/ccWvVg6G.s 			page 177


 6673              	.L449:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 6674              		.loc 1 366 0
 6675 093c 0E2C     		cmp	r4, #14
 6676 093e 1FD0     		beq	.L562
 6677              	.L450:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 6678              		.loc 1 371 0
 6679 0940 0E2A     		cmp	r2, #14
 6680 0942 03D0     		beq	.L451
 6681 0944 022A     		cmp	r2, #2
 6682 0946 01D0     		beq	.LCB6800
 6683 0948 00F060FC 		bl	.L372	@far jump
 6684              	.LCB6800:
 6685              	.L451:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6686              		.loc 1 374 0
 6687 094c 0022     		movs	r2, #0
 6688              	.LVL616:
 6689 094e 0021     		movs	r1, #0
 6690 0950 3000     		movs	r0, r6
 6691 0952 FFF7FEFF 		bl	pd_set_input_current_limit
 6692              	.LVL617:
 391:Src/usb_pd_protocol.c **** 			/*
 6693              		.loc 1 391 0
 6694 0956 F301     		lsls	r3, r6, #7
 6695 0958 354A     		ldr	r2, .L600+12
 6696 095a 9B5C     		ldrb	r3, [r3, r2]
 6697 095c 012B     		cmp	r3, #1
 6698 095e 13D0     		beq	.L563
 6699              	.L452:
 6700              	.LVL618:
 6701              	.LBB919:
 6702              	.LBB920:
  92:Inc/tcpm.h    **** }
 6703              		.loc 2 92 0
 6704 0960 3201     		lsls	r2, r6, #4
 6705 0962 3A4B     		ldr	r3, .L600+40
 6706 0964 9B18     		adds	r3, r3, r2
 6707 0966 9B68     		ldr	r3, [r3, #8]
 6708 0968 5B6A     		ldr	r3, [r3, #36]
 6709 096a 0021     		movs	r1, #0
 6710 096c 3000     		movs	r0, r6
 6711 096e 9847     		blx	r3
 6712              	.LVL619:
 6713 0970 00F04CFC 		bl	.L372	@ far jump
 6714              	.LVL620:
 6715              	.L560:
 6716              	.LBE920:
 6717              	.LBE919:
 6718              	.LBE916:
 6719              	.LBE915:
 6720              		.loc 1 2626 0
 6721 0974 1E22     		movs	r2, #30
 6722 0976 D0E7     		b	.L448
 6723              	.LVL621:
 6724              	.L561:
ARM GAS  /tmp/ccWvVg6G.s 			page 178


 6725              	.LBB922:
 6726              	.LBB921:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6727              		.loc 1 365 0
 6728 0978 0E2A     		cmp	r2, #14
 6729 097a DFD1     		bne	.L449
 6730 097c 00F046FC 		bl	.L372	@ far jump
 6731              	.L562:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 6732              		.loc 1 367 0
 6733 0980 022A     		cmp	r2, #2
 6734 0982 DDD1     		bne	.L450
 6735 0984 00F042FC 		bl	.L372	@ far jump
 6736              	.LVL622:
 6737              	.L563:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 6738              		.loc 1 396 0
 6739 0988 3000     		movs	r0, r6
 6740 098a FFF7FEFF 		bl	pd_power_supply_reset
 6741              	.LVL623:
 6742 098e E7E7     		b	.L452
 6743              	.LVL624:
 6744              	.L447:
 6745              	.LBE921:
 6746              	.LBE922:
2627:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
2628:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_READY);
2629:Src/usb_pd_protocol.c **** 				break;
2630:Src/usb_pd_protocol.c **** 			}
2631:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
2632:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2633:Src/usb_pd_protocol.c **** 						get_time().val +
 6747              		.loc 1 2633 0
 6748 0990 02A8     		add	r0, sp, #8
 6749 0992 FFF7FEFF 		bl	get_time
 6750              	.LVL625:
2632:Src/usb_pd_protocol.c **** 						get_time().val +
 6751              		.loc 1 2632 0
 6752 0996 2C48     		ldr	r0, .L600+36
 6753 0998 0021     		movs	r1, #0
 6754 099a 029B     		ldr	r3, [sp, #8]
 6755 099c 039C     		ldr	r4, [sp, #12]
 6756 099e C018     		adds	r0, r0, r3
 6757 09a0 6141     		adcs	r1, r1, r4
 6758              	.LVL626:
 6759              	.LBB923:
 6760              	.LBB924:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6761              		.loc 1 283 0
 6762 09a2 F201     		lsls	r2, r6, #7
 6763 09a4 224B     		ldr	r3, .L600+12
 6764 09a6 9B18     		adds	r3, r3, r2
 6765 09a8 1861     		str	r0, [r3, #16]
 6766 09aa 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6767              		.loc 1 284 0
 6768 09ac 1722     		movs	r2, #23
ARM GAS  /tmp/ccWvVg6G.s 			page 179


 6769 09ae DA71     		strb	r2, [r3, #7]
 6770 09b0 00F02CFC 		bl	.L372	@ far jump
 6771              	.LVL627:
 6772              	.L400:
 6773              	.LBE924:
 6774              	.LBE923:
2634:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2635:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_READY);
2636:Src/usb_pd_protocol.c **** 		}
2637:Src/usb_pd_protocol.c **** 		break;
2638:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_SNK_DISABLE:
2639:Src/usb_pd_protocol.c **** 		/* Give time for sink to stop drawing current */
2640:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 6775              		.loc 1 2640 0
 6776 09b4 F101     		lsls	r1, r6, #7
 6777 09b6 1E4A     		ldr	r2, .L600+12
 6778 09b8 5218     		adds	r2, r2, r1
 6779 09ba 5279     		ldrb	r2, [r2, #5]
 6780 09bc 9342     		cmp	r3, r2
 6781 09be 01D1     		bne	.LCB6916
 6782 09c0 00F024FC 		bl	.L372	@far jump
 6783              	.LCB6916:
2641:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2642:Src/usb_pd_protocol.c **** 						get_time().val +
 6784              		.loc 1 2642 0
 6785 09c4 02A8     		add	r0, sp, #8
 6786 09c6 FFF7FEFF 		bl	get_time
 6787              	.LVL628:
2641:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 6788              		.loc 1 2641 0
 6789 09ca 2148     		ldr	r0, .L600+44
 6790 09cc 0021     		movs	r1, #0
 6791 09ce 029B     		ldr	r3, [sp, #8]
 6792 09d0 039C     		ldr	r4, [sp, #12]
 6793 09d2 C018     		adds	r0, r0, r3
 6794 09d4 6141     		adcs	r1, r1, r4
 6795              	.LVL629:
 6796              	.LBB925:
 6797              	.LBB926:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6798              		.loc 1 283 0
 6799 09d6 F201     		lsls	r2, r6, #7
 6800 09d8 154B     		ldr	r3, .L600+12
 6801 09da 9B18     		adds	r3, r3, r2
 6802 09dc 1861     		str	r0, [r3, #16]
 6803 09de 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6804              		.loc 1 284 0
 6805 09e0 1C22     		movs	r2, #28
 6806 09e2 DA71     		strb	r2, [r3, #7]
 6807 09e4 00F012FC 		bl	.L372	@ far jump
 6808              	.LVL630:
 6809              	.L401:
 6810              	.LBE926:
 6811              	.LBE925:
2643:Src/usb_pd_protocol.c **** 						PD_T_SINK_TRANSITION,
2644:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_SWAP_SRC_DISABLE);
ARM GAS  /tmp/ccWvVg6G.s 			page 180


2645:Src/usb_pd_protocol.c **** 		break;
2646:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_SRC_DISABLE:
2647:Src/usb_pd_protocol.c **** 		/* Turn power off */
2648:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 6812              		.loc 1 2648 0
 6813 09e8 F101     		lsls	r1, r6, #7
 6814 09ea 114A     		ldr	r2, .L600+12
 6815 09ec 5218     		adds	r2, r2, r1
 6816 09ee 5279     		ldrb	r2, [r2, #5]
 6817 09f0 9342     		cmp	r3, r2
 6818 09f2 01D1     		bne	.LCB6951
 6819 09f4 00F00AFC 		bl	.L372	@far jump
 6820              	.LCB6951:
2649:Src/usb_pd_protocol.c **** 			pd_power_supply_reset(port);
 6821              		.loc 1 2649 0
 6822 09f8 3000     		movs	r0, r6
 6823 09fa FFF7FEFF 		bl	pd_power_supply_reset
 6824              	.LVL631:
2650:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2651:Src/usb_pd_protocol.c **** 						get_time().val +
 6825              		.loc 1 2651 0
 6826 09fe 02A8     		add	r0, sp, #8
 6827 0a00 FFF7FEFF 		bl	get_time
 6828              	.LVL632:
2650:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 6829              		.loc 1 2650 0
 6830 0a04 1348     		ldr	r0, .L600+48
 6831 0a06 0021     		movs	r1, #0
 6832 0a08 029B     		ldr	r3, [sp, #8]
 6833 0a0a 039C     		ldr	r4, [sp, #12]
 6834 0a0c C018     		adds	r0, r0, r3
 6835 0a0e 6141     		adcs	r1, r1, r4
 6836              	.LVL633:
 6837              	.LBB927:
 6838              	.LBB928:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6839              		.loc 1 283 0
 6840 0a10 F201     		lsls	r2, r6, #7
 6841 0a12 074B     		ldr	r3, .L600+12
 6842 0a14 9B18     		adds	r3, r3, r2
 6843 0a16 1861     		str	r0, [r3, #16]
 6844 0a18 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6845              		.loc 1 284 0
 6846 0a1a 1D22     		movs	r2, #29
 6847 0a1c DA71     		strb	r2, [r3, #7]
 6848 0a1e 00F0F5FB 		bl	.L372	@ far jump
 6849              	.L601:
 6850 0a22 C046     		.align	2
 6851              	.L600:
 6852 0a24 00000000 		.word	.LANCHOR5
 6853 0a28 C8AF0000 		.word	45000
 6854 0a2c 00000000 		.word	.LANCHOR2
 6855 0a30 00000000 		.word	pd
 6856 0a34 00000000 		.word	.LANCHOR12
 6857 0a38 10270000 		.word	10000
 6858 0a3c FF7FFFFF 		.word	-32769
ARM GAS  /tmp/ccWvVg6G.s 			page 181


 6859 0a40 FFFDFFFF 		.word	-513
 6860 0a44 FFFBFFFF 		.word	-1025
 6861 0a48 A0860100 		.word	100000
 6862 0a4c 00000000 		.word	tcpc_config
 6863 0a50 B8880000 		.word	35000
 6864 0a54 204E0000 		.word	20000
 6865              	.LVL634:
 6866              	.L402:
 6867              	.LBE928:
 6868              	.LBE927:
2652:Src/usb_pd_protocol.c **** 						PD_POWER_SUPPLY_TURN_OFF_DELAY,
2653:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_SWAP_STANDBY);
2654:Src/usb_pd_protocol.c **** 		}
2655:Src/usb_pd_protocol.c **** 		break;
2656:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_STANDBY:
2657:Src/usb_pd_protocol.c **** 		/* Send PS_RDY to let sink know our power is off */
2658:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 6869              		.loc 1 2658 0
 6870 0a58 F101     		lsls	r1, r6, #7
 6871 0a5a D54A     		ldr	r2, .L602
 6872 0a5c 5218     		adds	r2, r2, r1
 6873 0a5e 5279     		ldrb	r2, [r2, #5]
 6874 0a60 9342     		cmp	r3, r2
 6875 0a62 00D1     		bne	.LCB7007
 6876 0a64 D2E3     		b	.L372	@long jump
 6877              	.LCB7007:
2659:Src/usb_pd_protocol.c **** 			/* Send PS_RDY */
2660:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_PS_RDY);
 6878              		.loc 1 2660 0
 6879 0a66 0621     		movs	r1, #6
 6880 0a68 3000     		movs	r0, r6
 6881 0a6a FFF7FEFF 		bl	send_control
 6882              	.LVL635:
2661:Src/usb_pd_protocol.c **** 			if (res < 0) {
 6883              		.loc 1 2661 0
 6884 0a6e 0028     		cmp	r0, #0
 6885 0a70 16DB     		blt	.L564
 6886              	.LVL636:
 6887              	.LBB929:
 6888              	.LBB930:
  71:Inc/tcpm.h    **** }
 6889              		.loc 2 71 0
 6890 0a72 6369     		ldr	r3, [r4, #20]
 6891 0a74 0221     		movs	r1, #2
 6892 0a76 3000     		movs	r0, r6
 6893 0a78 9847     		blx	r3
 6894              	.LVL637:
 6895              	.LBE930:
 6896              	.LBE929:
2662:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
2663:Src/usb_pd_protocol.c **** 				set_state(port,
2664:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED);
2665:Src/usb_pd_protocol.c **** 				break;
2666:Src/usb_pd_protocol.c **** 			}
2667:Src/usb_pd_protocol.c **** 			/* Switch to Rd and swap roles to sink */
2668:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
2669:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
ARM GAS  /tmp/ccWvVg6G.s 			page 182


 6897              		.loc 1 2669 0
 6898 0a7a CD4C     		ldr	r4, .L602
 6899 0a7c F501     		lsls	r5, r6, #7
 6900 0a7e 0023     		movs	r3, #0
 6901 0a80 2B55     		strb	r3, [r5, r4]
2670:Src/usb_pd_protocol.c **** 			/* Wait for PS_RDY from new source */
2671:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2672:Src/usb_pd_protocol.c **** 						get_time().val +
 6902              		.loc 1 2672 0
 6903 0a82 02A8     		add	r0, sp, #8
 6904 0a84 FFF7FEFF 		bl	get_time
 6905              	.LVL638:
2671:Src/usb_pd_protocol.c **** 						get_time().val +
 6906              		.loc 1 2671 0
 6907 0a88 CA4A     		ldr	r2, .L602+4
 6908 0a8a 0023     		movs	r3, #0
 6909 0a8c 0298     		ldr	r0, [sp, #8]
 6910 0a8e 0399     		ldr	r1, [sp, #12]
 6911 0a90 1218     		adds	r2, r2, r0
 6912 0a92 4B41     		adcs	r3, r3, r1
 6913              	.LVL639:
 6914              	.LBB931:
 6915              	.LBB932:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6916              		.loc 1 283 0
 6917 0a94 6419     		adds	r4, r4, r5
 6918 0a96 2261     		str	r2, [r4, #16]
 6919 0a98 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 6920              		.loc 1 284 0
 6921 0a9a 0223     		movs	r3, #2
 6922 0a9c E371     		strb	r3, [r4, #7]
 6923 0a9e B5E3     		b	.L372
 6924              	.LVL640:
 6925              	.L564:
 6926              	.LBE932:
 6927              	.LBE931:
2662:Src/usb_pd_protocol.c **** 				set_state(port,
 6928              		.loc 1 2662 0
 6929 0aa0 C54B     		ldr	r3, .L602+8
 6930 0aa2 C64A     		ldr	r2, .L602+12
 6931 0aa4 1A60     		str	r2, [r3]
2663:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED);
 6932              		.loc 1 2663 0
 6933 0aa6 0E21     		movs	r1, #14
 6934 0aa8 3000     		movs	r0, r6
 6935 0aaa FFF7FEFF 		bl	set_state
 6936              	.LVL641:
2665:Src/usb_pd_protocol.c **** 			}
 6937              		.loc 1 2665 0
 6938 0aae ADE3     		b	.L372
 6939              	.L373:
 6940              	.LBB933:
2673:Src/usb_pd_protocol.c **** 						PD_T_PS_SOURCE_ON,
2674:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2675:Src/usb_pd_protocol.c **** 		}
2676:Src/usb_pd_protocol.c **** 		break;
ARM GAS  /tmp/ccWvVg6G.s 			page 183


2677:Src/usb_pd_protocol.c **** 	case PD_STATE_SUSPENDED: {
2678:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
2679:Src/usb_pd_protocol.c **** 		int rstatus;
2680:Src/usb_pd_protocol.c **** #endif
2681:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d suspended!", port);
2682:Src/usb_pd_protocol.c **** 		pd[port].req_suspend_state = 0;
 6941              		.loc 1 2682 0
 6942 0ab0 F201     		lsls	r2, r6, #7
 6943 0ab2 BF4B     		ldr	r3, .L602
 6944 0ab4 9B18     		adds	r3, r3, r2
 6945 0ab6 0022     		movs	r2, #0
 6946 0ab8 9A71     		strb	r2, [r3, #6]
 6947              	.LVL642:
 6948              	.LBB934:
 6949              	.LBB935:
  51:Inc/tcpm.h    **** }
 6950              		.loc 2 51 0
 6951 0aba 6368     		ldr	r3, [r4, #4]
 6952 0abc 3000     		movs	r0, r6
 6953 0abe 9847     		blx	r3
 6954              	.LVL643:
 6955              	.LBE935:
 6956              	.LBE934:
2683:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC
2684:Src/usb_pd_protocol.c **** 		pd_rx_disable_monitoring(port);
2685:Src/usb_pd_protocol.c **** 		pd_hw_release(port);
2686:Src/usb_pd_protocol.c **** 		pd_power_supply_reset(port);
2687:Src/usb_pd_protocol.c **** #else
2688:Src/usb_pd_protocol.c **** 		rstatus = tcpm_release(port);
2689:Src/usb_pd_protocol.c **** 		if (rstatus != 0 && rstatus != EC_ERROR_UNIMPLEMENTED)
2690:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d release failed!", port);
2691:Src/usb_pd_protocol.c **** #endif
2692:Src/usb_pd_protocol.c **** 		/* Wait for resume */
2693:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
2694:Src/usb_pd_protocol.c **** 		//while (pd[port].task_state == PD_STATE_SUSPENDED)
2695:Src/usb_pd_protocol.c **** 		//	task_wait_event(-1);
2696:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC
2697:Src/usb_pd_protocol.c **** 		pd_hw_init(port, PD_ROLE_DEFAULT(port));
2698:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d resumed!", port);
2699:Src/usb_pd_protocol.c **** #else
2700:Src/usb_pd_protocol.c **** 		if (rstatus != EC_ERROR_UNIMPLEMENTED &&
 6957              		.loc 1 2700 0
 6958 0ac0 0228     		cmp	r0, #2
 6959 0ac2 05D0     		beq	.L454
2701:Src/usb_pd_protocol.c **** 			pd_restart_tcpc(port) != 0) {
 6960              		.loc 1 2701 0 discriminator 1
 6961 0ac4 3000     		movs	r0, r6
 6962 0ac6 FFF7FEFF 		bl	pd_restart_tcpc
 6963              	.LVL644:
2700:Src/usb_pd_protocol.c **** 			pd_restart_tcpc(port) != 0) {
 6964              		.loc 1 2700 0 discriminator 1
 6965 0aca 0028     		cmp	r0, #0
 6966 0acc 00D0     		beq	.LCB7091
 6967 0ace 9DE3     		b	.L372	@long jump
 6968              	.LCB7091:
 6969              	.L454:
 6970              	.LVL645:
ARM GAS  /tmp/ccWvVg6G.s 			page 184


 6971              	.LBB936:
 6972              	.LBB937:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6973              		.loc 1 346 0
 6974 0ad0 F201     		lsls	r2, r6, #7
 6975 0ad2 B74B     		ldr	r3, .L602
 6976 0ad4 9B18     		adds	r3, r3, r2
 6977 0ad6 1A79     		ldrb	r2, [r3, #4]
 6978              	.LVL646:
 6979              	.LBB938:
 6980              	.LBB939:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6981              		.loc 1 283 0
 6982 0ad8 0020     		movs	r0, #0
 6983 0ada 0021     		movs	r1, #0
 6984 0adc 1861     		str	r0, [r3, #16]
 6985 0ade 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 6986              		.loc 1 284 0
 6987 0ae0 0021     		movs	r1, #0
 6988 0ae2 D971     		strb	r1, [r3, #7]
 6989              	.LVL647:
 6990              	.LBE939:
 6991              	.LBE938:
 352:Src/usb_pd_protocol.c **** 
 6992              		.loc 1 352 0
 6993 0ae4 0231     		adds	r1, r1, #2
 6994 0ae6 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 6995              		.loc 1 354 0
 6996 0ae8 022A     		cmp	r2, #2
 6997 0aea 00D1     		bne	.LCB7120
 6998 0aec 8EE3     		b	.L372	@long jump
 6999              	.LCB7120:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 7000              		.loc 1 366 0
 7001 0aee 0E2A     		cmp	r2, #14
 7002 0af0 00D1     		bne	.LCB7122
 7003 0af2 8BE3     		b	.L372	@long jump
 7004              	.LCB7122:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 7005              		.loc 1 374 0
 7006 0af4 0022     		movs	r2, #0
 7007              	.LVL648:
 7008 0af6 0021     		movs	r1, #0
 7009 0af8 3000     		movs	r0, r6
 7010 0afa FFF7FEFF 		bl	pd_set_input_current_limit
 7011              	.LVL649:
 391:Src/usb_pd_protocol.c **** 			/*
 7012              		.loc 1 391 0
 7013 0afe F301     		lsls	r3, r6, #7
 7014 0b00 AB4A     		ldr	r2, .L602
 7015 0b02 9B5C     		ldrb	r3, [r3, r2]
 7016 0b04 012B     		cmp	r3, #1
 7017 0b06 08D0     		beq	.L565
 7018              	.L455:
 7019              	.LVL650:
ARM GAS  /tmp/ccWvVg6G.s 			page 185


 7020              	.LBB940:
 7021              	.LBB941:
  92:Inc/tcpm.h    **** }
 7022              		.loc 2 92 0
 7023 0b08 3201     		lsls	r2, r6, #4
 7024 0b0a AD4B     		ldr	r3, .L602+16
 7025 0b0c 9B18     		adds	r3, r3, r2
 7026 0b0e 9B68     		ldr	r3, [r3, #8]
 7027 0b10 5B6A     		ldr	r3, [r3, #36]
 7028 0b12 0021     		movs	r1, #0
 7029 0b14 3000     		movs	r0, r6
 7030 0b16 9847     		blx	r3
 7031              	.LVL651:
 7032 0b18 78E3     		b	.L372
 7033              	.LVL652:
 7034              	.L565:
 7035              	.LBE941:
 7036              	.LBE940:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 7037              		.loc 1 396 0
 7038 0b1a 3000     		movs	r0, r6
 7039 0b1c FFF7FEFF 		bl	pd_power_supply_reset
 7040              	.LVL653:
 7041 0b20 F2E7     		b	.L455
 7042              	.LVL654:
 7043              	.L375:
 7044              	.LBE937:
 7045              	.LBE936:
 7046              	.LBE933:
2702:Src/usb_pd_protocol.c **** 			/* stay in PD_STATE_SUSPENDED */
2703:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d restart failed!", port);
2704:Src/usb_pd_protocol.c **** 			break;
2705:Src/usb_pd_protocol.c **** 		}
2706:Src/usb_pd_protocol.c **** 		set_state(port, PD_DEFAULT_STATE(port));
2707:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d resumed!", port);
2708:Src/usb_pd_protocol.c **** #endif
2709:Src/usb_pd_protocol.c **** 		break;
2710:Src/usb_pd_protocol.c **** 	}
2711:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_DISCONNECTED:
2712:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_LOW_POWER
2713:Src/usb_pd_protocol.c **** 		timeout = drp_state != PD_DRP_TOGGLE_ON ? SECOND
2714:Src/usb_pd_protocol.c **** 							: 10*MSEC;
2715:Src/usb_pd_protocol.c **** #else
2716:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC;
 7047              		.loc 1 2716 0
 7048 0b22 A54B     		ldr	r3, .L602+8
 7049 0b24 A54A     		ldr	r2, .L602+12
 7050 0b26 1A60     		str	r2, [r3]
 7051              	.LVL655:
 7052              	.LBB942:
 7053              	.LBB943:
  56:Inc/tcpm.h    **** }
 7054              		.loc 2 56 0
 7055 0b28 A64D     		ldr	r5, .L602+20
 7056 0b2a A74A     		ldr	r2, .L602+24
 7057 0b2c 2900     		movs	r1, r5
 7058 0b2e 3000     		movs	r0, r6
ARM GAS  /tmp/ccWvVg6G.s 			page 186


 7059 0b30 A368     		ldr	r3, [r4, #8]
 7060 0b32 9847     		blx	r3
 7061              	.LVL656:
 7062              	.LBE943:
 7063              	.LBE942:
2717:Src/usb_pd_protocol.c **** #endif
2718:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
2719:Src/usb_pd_protocol.c **** 
2720:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
2721:Src/usb_pd_protocol.c **** 		/*
2722:Src/usb_pd_protocol.c **** 			* Attempt TCPC auto DRP toggle if it is
2723:Src/usb_pd_protocol.c **** 			* not already auto toggling and not try.src
2724:Src/usb_pd_protocol.c **** 			*/
2725:Src/usb_pd_protocol.c **** 		if (auto_toggle_supported &&
2726:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TCPC_DRP_TOGGLE) &&
2727:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
2728:Src/usb_pd_protocol.c **** 			(cc1 == TYPEC_CC_VOLT_OPEN &&
2729:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_OPEN)) {
2730:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_DRP_AUTO_TOGGLE);
2731:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC;
2732:Src/usb_pd_protocol.c **** 			break;
2733:Src/usb_pd_protocol.c **** 		}
2734:Src/usb_pd_protocol.c **** #endif
2735:Src/usb_pd_protocol.c **** 
2736:Src/usb_pd_protocol.c **** 		/* Source connection monitoring */
2737:Src/usb_pd_protocol.c **** 		if (cc1 != TYPEC_CC_VOLT_OPEN ||
 7064              		.loc 1 2737 0
 7065 0b34 2B68     		ldr	r3, [r5]
 7066 0b36 002B     		cmp	r3, #0
 7067 0b38 03D1     		bne	.L456
2738:Src/usb_pd_protocol.c **** 			cc2 != TYPEC_CC_VOLT_OPEN) {
 7068              		.loc 1 2738 0 discriminator 1
 7069 0b3a A34B     		ldr	r3, .L602+24
 7070 0b3c 1B68     		ldr	r3, [r3]
2737:Src/usb_pd_protocol.c **** 			cc2 != TYPEC_CC_VOLT_OPEN) {
 7071              		.loc 1 2737 0 discriminator 1
 7072 0b3e 002B     		cmp	r3, #0
 7073 0b40 20D0     		beq	.L457
 7074              	.L456:
2739:Src/usb_pd_protocol.c **** 			pd[port].cc_state = PD_CC_NONE;
 7075              		.loc 1 2739 0
 7076 0b42 F301     		lsls	r3, r6, #7
 7077 0b44 9A4C     		ldr	r4, .L602
 7078 0b46 E418     		adds	r4, r4, r3
 7079 0b48 2300     		movs	r3, r4
 7080 0b4a 2833     		adds	r3, r3, #40
 7081 0b4c 0025     		movs	r5, #0
 7082 0b4e 1D70     		strb	r5, [r3]
2740:Src/usb_pd_protocol.c **** 			hard_reset_count = 0;
 7083              		.loc 1 2740 0
 7084 0b50 9E4B     		ldr	r3, .L602+28
 7085 0b52 1D60     		str	r5, [r3]
2741:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_NONE;
 7086              		.loc 1 2741 0
 7087 0b54 9E4B     		ldr	r3, .L602+32
 7088 0b56 1D70     		strb	r5, [r3]
2742:Src/usb_pd_protocol.c **** 			pd[port].cc_debounce = get_time().val +
ARM GAS  /tmp/ccWvVg6G.s 			page 187


 7089              		.loc 1 2742 0
 7090 0b58 02A8     		add	r0, sp, #8
 7091 0b5a FFF7FEFF 		bl	get_time
 7092              	.LVL657:
 7093 0b5e 9D4A     		ldr	r2, .L602+36
 7094 0b60 0023     		movs	r3, #0
 7095 0b62 0298     		ldr	r0, [sp, #8]
 7096 0b64 0399     		ldr	r1, [sp, #12]
 7097 0b66 1218     		adds	r2, r2, r0
 7098 0b68 4B41     		adcs	r3, r3, r1
 7099 0b6a 2262     		str	r2, [r4, #32]
 7100 0b6c 6362     		str	r3, [r4, #36]
 7101              	.LVL658:
 7102              	.LBB944:
 7103              	.LBB945:
 7104              	.LBB946:
 7105              	.LBB947:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7106              		.loc 1 283 0
 7107 0b6e 0022     		movs	r2, #0
 7108 0b70 0023     		movs	r3, #0
 7109 0b72 2261     		str	r2, [r4, #16]
 7110 0b74 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 7111              		.loc 1 284 0
 7112 0b76 E571     		strb	r5, [r4, #7]
 7113              	.LVL659:
 7114              	.LBE947:
 7115              	.LBE946:
 352:Src/usb_pd_protocol.c **** 
 7116              		.loc 1 352 0
 7117 0b78 0323     		movs	r3, #3
 7118 0b7a 2371     		strb	r3, [r4, #4]
 7119              	.LVL660:
 7120              	.LBE945:
 7121              	.LBE944:
2743:Src/usb_pd_protocol.c **** 						PD_T_CC_DEBOUNCE;
2744:Src/usb_pd_protocol.c **** 			set_state(port,
2745:Src/usb_pd_protocol.c **** 				PD_STATE_SNK_DISCONNECTED_DEBOUNCE);
2746:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC;
 7122              		.loc 1 2746 0
 7123 0b7c 8E4B     		ldr	r3, .L602+8
 7124 0b7e 8F4A     		ldr	r2, .L602+12
 7125 0b80 1A60     		str	r2, [r3]
2747:Src/usb_pd_protocol.c **** 			break;
 7126              		.loc 1 2747 0
 7127 0b82 43E3     		b	.L372
 7128              	.L457:
2748:Src/usb_pd_protocol.c **** 		}
2749:Src/usb_pd_protocol.c **** 
2750:Src/usb_pd_protocol.c **** 		/*
2751:Src/usb_pd_protocol.c **** 			* If Try.SRC is active and failed to detect a SNK,
2752:Src/usb_pd_protocol.c **** 			* then it transitions to TryWait.SNK. Need to prevent
2753:Src/usb_pd_protocol.c **** 			* normal dual role toggle until tDRPTryWait timer
2754:Src/usb_pd_protocol.c **** 			* expires.
2755:Src/usb_pd_protocol.c **** 			*/
2756:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_TRY_SRC) {
ARM GAS  /tmp/ccWvVg6G.s 			page 188


 7129              		.loc 1 2756 0
 7130 0b84 F201     		lsls	r2, r6, #7
 7131 0b86 8A4B     		ldr	r3, .L602
 7132 0b88 9B18     		adds	r3, r3, r2
 7133 0b8a 9B68     		ldr	r3, [r3, #8]
 7134 0b8c 9B04     		lsls	r3, r3, #18
 7135 0b8e 30D4     		bmi	.L566
2757:Src/usb_pd_protocol.c **** 			if (get_time().val > pd[port].try_src_marker)
2758:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
2759:Src/usb_pd_protocol.c **** 			break;
2760:Src/usb_pd_protocol.c **** 		}
2761:Src/usb_pd_protocol.c **** 
2762:Src/usb_pd_protocol.c **** 		/* If no source detected, check for role toggle. */
2763:Src/usb_pd_protocol.c **** 		if (drp_state == PD_DRP_TOGGLE_ON &&
 7136              		.loc 1 2763 0
 7137 0b90 914B     		ldr	r3, .L602+40
 7138 0b92 1B78     		ldrb	r3, [r3]
 7139 0b94 002B     		cmp	r3, #0
 7140 0b96 00D0     		beq	.LCB7268
 7141 0b98 38E3     		b	.L372	@long jump
 7142              	.LCB7268:
2764:Src/usb_pd_protocol.c **** 			get_time().val >= next_role_swap) {
 7143              		.loc 1 2764 0 discriminator 1
 7144 0b9a 02A8     		add	r0, sp, #8
 7145 0b9c FFF7FEFF 		bl	get_time
 7146              	.LVL661:
 7147 0ba0 0299     		ldr	r1, [sp, #8]
 7148 0ba2 039A     		ldr	r2, [sp, #12]
 7149 0ba4 8D4B     		ldr	r3, .L602+44
 7150 0ba6 1868     		ldr	r0, [r3]
 7151 0ba8 5B68     		ldr	r3, [r3, #4]
2763:Src/usb_pd_protocol.c **** 			get_time().val >= next_role_swap) {
 7152              		.loc 1 2763 0 discriminator 1
 7153 0baa 9342     		cmp	r3, r2
 7154 0bac 00D9     		bls	.LCB7278
 7155 0bae 2DE3     		b	.L372	@long jump
 7156              	.LCB7278:
 7157 0bb0 02D1     		bne	.L532
 7158 0bb2 8842     		cmp	r0, r1
 7159 0bb4 00D9     		bls	.LCB7282
 7160 0bb6 29E3     		b	.L372	@long jump
 7161              	.LCB7282:
 7162              	.L532:
2765:Src/usb_pd_protocol.c **** 			/* Swap roles to source */
2766:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SOURCE;
 7163              		.loc 1 2766 0
 7164 0bb8 F301     		lsls	r3, r6, #7
 7165 0bba 0125     		movs	r5, #1
 7166 0bbc 7C4A     		ldr	r2, .L602
 7167 0bbe 9D54     		strb	r5, [r3, r2]
2767:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
 7168              		.loc 1 2767 0
 7169 0bc0 0E21     		movs	r1, #14
 7170 0bc2 3000     		movs	r0, r6
 7171 0bc4 FFF7FEFF 		bl	set_state
 7172              	.LVL662:
 7173              	.LBB948:
ARM GAS  /tmp/ccWvVg6G.s 			page 189


 7174              	.LBB949:
  71:Inc/tcpm.h    **** }
 7175              		.loc 2 71 0
 7176 0bc8 6369     		ldr	r3, [r4, #20]
 7177 0bca 2900     		movs	r1, r5
 7178 0bcc 3000     		movs	r0, r6
 7179 0bce 9847     		blx	r3
 7180              	.LVL663:
 7181              	.LBE949:
 7182              	.LBE948:
2768:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
2769:Src/usb_pd_protocol.c **** 			next_role_swap = get_time().val + PD_T_DRP_SRC;
 7183              		.loc 1 2769 0
 7184 0bd0 02A8     		add	r0, sp, #8
 7185 0bd2 FFF7FEFF 		bl	get_time
 7186              	.LVL664:
 7187 0bd6 824A     		ldr	r2, .L602+48
 7188 0bd8 0023     		movs	r3, #0
 7189 0bda 0298     		ldr	r0, [sp, #8]
 7190 0bdc 0399     		ldr	r1, [sp, #12]
 7191 0bde 1218     		adds	r2, r2, r0
 7192 0be0 4B41     		adcs	r3, r3, r1
 7193 0be2 7E49     		ldr	r1, .L602+44
 7194 0be4 0A60     		str	r2, [r1]
 7195 0be6 4B60     		str	r3, [r1, #4]
2770:Src/usb_pd_protocol.c **** 
2771:Src/usb_pd_protocol.c **** 			/* Swap states quickly */
2772:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC;
 7196              		.loc 1 2772 0
 7197 0be8 734B     		ldr	r3, .L602+8
 7198 0bea FA22     		movs	r2, #250
 7199 0bec D200     		lsls	r2, r2, #3
 7200 0bee 1A60     		str	r2, [r3]
 7201 0bf0 0CE3     		b	.L372
 7202              	.L566:
2757:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
 7203              		.loc 1 2757 0
 7204 0bf2 02A8     		add	r0, sp, #8
 7205 0bf4 FFF7FEFF 		bl	get_time
 7206              	.LVL665:
 7207 0bf8 0298     		ldr	r0, [sp, #8]
 7208 0bfa 0399     		ldr	r1, [sp, #12]
 7209 0bfc F201     		lsls	r2, r6, #7
 7210 0bfe 6C4B     		ldr	r3, .L602
 7211 0c00 9B18     		adds	r3, r3, r2
 7212 0c02 1A6C     		ldr	r2, [r3, #64]
 7213 0c04 5B6C     		ldr	r3, [r3, #68]
 7214 0c06 9942     		cmp	r1, r3
 7215 0c08 04D8     		bhi	.L531
 7216 0c0a 00D0     		beq	.LCB7338
 7217 0c0c FEE2     		b	.L372	@long jump
 7218              	.LCB7338:
 7219 0c0e 9042     		cmp	r0, r2
 7220 0c10 00D8     		bhi	.LCB7340
 7221 0c12 FBE2     		b	.L372	@long jump
 7222              	.LCB7340:
 7223              	.L531:
ARM GAS  /tmp/ccWvVg6G.s 			page 190


2758:Src/usb_pd_protocol.c **** 			break;
 7224              		.loc 1 2758 0
 7225 0c14 F201     		lsls	r2, r6, #7
 7226 0c16 664B     		ldr	r3, .L602
 7227 0c18 9B18     		adds	r3, r3, r2
 7228 0c1a 724A     		ldr	r2, .L602+52
 7229 0c1c 9968     		ldr	r1, [r3, #8]
 7230 0c1e 0A40     		ands	r2, r1
 7231 0c20 9A60     		str	r2, [r3, #8]
 7232 0c22 F3E2     		b	.L372
 7233              	.L376:
 7234              	.LVL666:
 7235              	.LBB950:
 7236              	.LBB951:
  56:Inc/tcpm.h    **** }
 7237              		.loc 2 56 0
 7238 0c24 A368     		ldr	r3, [r4, #8]
 7239 0c26 674C     		ldr	r4, .L602+20
 7240 0c28 674A     		ldr	r2, .L602+24
 7241 0c2a 2100     		movs	r1, r4
 7242 0c2c 3000     		movs	r0, r6
 7243 0c2e 9847     		blx	r3
 7244              	.LVL667:
 7245              	.LBE951:
 7246              	.LBE950:
2773:Src/usb_pd_protocol.c **** 		}
2774:Src/usb_pd_protocol.c **** 		break;
2775:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_DISCONNECTED_DEBOUNCE:
2776:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
2777:Src/usb_pd_protocol.c **** 
2778:Src/usb_pd_protocol.c **** 		if (cc_is_rp(cc1) && cc_is_rp(cc2)) {
 7247              		.loc 1 2778 0
 7248 0c30 2368     		ldr	r3, [r4]
 7249              	.LVL668:
 7250              	.LBB952:
 7251              	.LBB953:
1941:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 7252              		.loc 1 1941 0
 7253 0c32 053B     		subs	r3, r3, #5
 7254              	.LVL669:
 7255              	.LBE953:
 7256              	.LBE952:
 7257              		.loc 1 2778 0
 7258 0c34 022B     		cmp	r3, #2
 7259 0c36 08D8     		bhi	.L461
 7260              		.loc 1 2778 0 is_stmt 0 discriminator 1
 7261 0c38 634A     		ldr	r2, .L602+24
 7262 0c3a 1268     		ldr	r2, [r2]
 7263              	.LVL670:
 7264              	.LBB954:
 7265              	.LBB955:
1941:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 7266              		.loc 1 1941 0 is_stmt 1 discriminator 1
 7267 0c3c 053A     		subs	r2, r2, #5
 7268              	.LVL671:
 7269              	.LBE955:
 7270              	.LBE954:
ARM GAS  /tmp/ccWvVg6G.s 			page 191


 7271              		.loc 1 2778 0 discriminator 1
 7272 0c3e 022A     		cmp	r2, #2
 7273 0c40 03D8     		bhi	.L461
2779:Src/usb_pd_protocol.c **** 			/* Debug accessory */
2780:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_DEBUG_ACC;
 7274              		.loc 1 2780 0
 7275 0c42 634B     		ldr	r3, .L602+32
 7276 0c44 0322     		movs	r2, #3
 7277 0c46 1A70     		strb	r2, [r3]
 7278 0c48 09E0     		b	.L462
 7279              	.L461:
2781:Src/usb_pd_protocol.c **** 		} else if (cc_is_rp(cc1) || cc_is_rp(cc2)) {
 7280              		.loc 1 2781 0
 7281 0c4a 022B     		cmp	r3, #2
 7282 0c4c 04D9     		bls	.L463
 7283              		.loc 1 2781 0 is_stmt 0 discriminator 1
 7284 0c4e 5E4B     		ldr	r3, .L602+24
 7285 0c50 1B68     		ldr	r3, [r3]
 7286              	.LVL672:
 7287              	.LBB956:
 7288              	.LBB957:
1941:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 7289              		.loc 1 1941 0 is_stmt 1 discriminator 1
 7290 0c52 053B     		subs	r3, r3, #5
 7291              	.LVL673:
 7292              	.LBE957:
 7293              	.LBE956:
 7294              		.loc 1 2781 0 discriminator 1
 7295 0c54 022B     		cmp	r3, #2
 7296 0c56 21D8     		bhi	.L464
 7297              	.L463:
2782:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_DFP_ATTACHED;
 7298              		.loc 1 2782 0
 7299 0c58 5D4B     		ldr	r3, .L602+32
 7300 0c5a 0522     		movs	r2, #5
 7301 0c5c 1A70     		strb	r2, [r3]
 7302              	.L462:
2783:Src/usb_pd_protocol.c **** 		} else {
2784:Src/usb_pd_protocol.c **** 			/* No connection any more */
2785:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
2786:Src/usb_pd_protocol.c **** 			timeout = 5*MSEC;
2787:Src/usb_pd_protocol.c **** 			break;
2788:Src/usb_pd_protocol.c **** 		}
2789:Src/usb_pd_protocol.c **** 
2790:Src/usb_pd_protocol.c **** 		timeout = 20*MSEC;
 7303              		.loc 1 2790 0
 7304 0c5e 564B     		ldr	r3, .L602+8
 7305 0c60 614A     		ldr	r2, .L602+56
 7306 0c62 1A60     		str	r2, [r3]
2791:Src/usb_pd_protocol.c **** 
2792:Src/usb_pd_protocol.c **** 		/* Debounce the cc state */
2793:Src/usb_pd_protocol.c **** 		if (new_cc_state != pd[port].cc_state) {
 7307              		.loc 1 2793 0
 7308 0c64 F201     		lsls	r2, r6, #7
 7309 0c66 524B     		ldr	r3, .L602
 7310 0c68 9B18     		adds	r3, r3, r2
 7311 0c6a 2833     		adds	r3, r3, #40
ARM GAS  /tmp/ccWvVg6G.s 			page 192


 7312 0c6c 1A78     		ldrb	r2, [r3]
 7313 0c6e 584B     		ldr	r3, .L602+32
 7314 0c70 1B78     		ldrb	r3, [r3]
 7315 0c72 9A42     		cmp	r2, r3
 7316 0c74 3CD0     		beq	.L467
2794:Src/usb_pd_protocol.c **** 			pd[port].cc_debounce = get_time().val +
 7317              		.loc 1 2794 0
 7318 0c76 02A8     		add	r0, sp, #8
 7319 0c78 FFF7FEFF 		bl	get_time
 7320              	.LVL674:
 7321 0c7c 5548     		ldr	r0, .L602+36
 7322 0c7e 0021     		movs	r1, #0
 7323 0c80 029B     		ldr	r3, [sp, #8]
 7324 0c82 039C     		ldr	r4, [sp, #12]
 7325 0c84 C018     		adds	r0, r0, r3
 7326 0c86 6141     		adcs	r1, r1, r4
 7327 0c88 F201     		lsls	r2, r6, #7
 7328 0c8a 494B     		ldr	r3, .L602
 7329 0c8c 9B18     		adds	r3, r3, r2
 7330 0c8e 1862     		str	r0, [r3, #32]
 7331 0c90 5962     		str	r1, [r3, #36]
2795:Src/usb_pd_protocol.c **** 				PD_T_CC_DEBOUNCE;
2796:Src/usb_pd_protocol.c **** 			pd[port].cc_state = new_cc_state;
 7332              		.loc 1 2796 0
 7333 0c92 2833     		adds	r3, r3, #40
 7334 0c94 4E4A     		ldr	r2, .L602+32
 7335 0c96 1278     		ldrb	r2, [r2]
 7336 0c98 1A70     		strb	r2, [r3]
2797:Src/usb_pd_protocol.c **** 			break;
 7337              		.loc 1 2797 0
 7338 0c9a B7E2     		b	.L372
 7339              	.L464:
 7340              	.LVL675:
 7341              	.LBB958:
 7342              	.LBB959:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7343              		.loc 1 346 0
 7344 0c9c F201     		lsls	r2, r6, #7
 7345 0c9e 444B     		ldr	r3, .L602
 7346 0ca0 9B18     		adds	r3, r3, r2
 7347 0ca2 1A79     		ldrb	r2, [r3, #4]
 7348              	.LVL676:
 7349              	.LBB960:
 7350              	.LBB961:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7351              		.loc 1 283 0
 7352 0ca4 0020     		movs	r0, #0
 7353 0ca6 0021     		movs	r1, #0
 7354 0ca8 1861     		str	r0, [r3, #16]
 7355 0caa 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 7356              		.loc 1 284 0
 7357 0cac 0021     		movs	r1, #0
 7358 0cae D971     		strb	r1, [r3, #7]
 7359              	.LVL677:
 7360              	.LBE961:
 7361              	.LBE960:
ARM GAS  /tmp/ccWvVg6G.s 			page 193


 352:Src/usb_pd_protocol.c **** 
 7362              		.loc 1 352 0
 7363 0cb0 0231     		adds	r1, r1, #2
 7364 0cb2 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 7365              		.loc 1 354 0
 7366 0cb4 022A     		cmp	r2, #2
 7367 0cb6 13D0     		beq	.L465
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 7368              		.loc 1 366 0
 7369 0cb8 0E2A     		cmp	r2, #14
 7370 0cba 11D0     		beq	.L465
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 7371              		.loc 1 374 0
 7372 0cbc 0022     		movs	r2, #0
 7373              	.LVL678:
 7374 0cbe 0021     		movs	r1, #0
 7375 0cc0 3000     		movs	r0, r6
 7376 0cc2 FFF7FEFF 		bl	pd_set_input_current_limit
 7377              	.LVL679:
 391:Src/usb_pd_protocol.c **** 			/*
 7378              		.loc 1 391 0
 7379 0cc6 F301     		lsls	r3, r6, #7
 7380 0cc8 394A     		ldr	r2, .L602
 7381 0cca 9B5C     		ldrb	r3, [r3, r2]
 7382 0ccc 012B     		cmp	r3, #1
 7383 0cce 0BD0     		beq	.L567
 7384              	.L466:
 7385              	.LVL680:
 7386              	.LBB962:
 7387              	.LBB963:
  92:Inc/tcpm.h    **** }
 7388              		.loc 2 92 0
 7389 0cd0 3201     		lsls	r2, r6, #4
 7390 0cd2 3B4B     		ldr	r3, .L602+16
 7391 0cd4 9B18     		adds	r3, r3, r2
 7392 0cd6 9B68     		ldr	r3, [r3, #8]
 7393 0cd8 5B6A     		ldr	r3, [r3, #36]
 7394 0cda 0021     		movs	r1, #0
 7395 0cdc 3000     		movs	r0, r6
 7396 0cde 9847     		blx	r3
 7397              	.LVL681:
 7398              	.L465:
 7399              	.LBE963:
 7400              	.LBE962:
 7401              	.LBE959:
 7402              	.LBE958:
2786:Src/usb_pd_protocol.c **** 			break;
 7403              		.loc 1 2786 0
 7404 0ce0 354B     		ldr	r3, .L602+8
 7405 0ce2 424A     		ldr	r2, .L602+60
 7406 0ce4 1A60     		str	r2, [r3]
2787:Src/usb_pd_protocol.c **** 		}
 7407              		.loc 1 2787 0
 7408 0ce6 91E2     		b	.L372
 7409              	.LVL682:
 7410              	.L567:
ARM GAS  /tmp/ccWvVg6G.s 			page 194


 7411              	.LBB965:
 7412              	.LBB964:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 7413              		.loc 1 396 0
 7414 0ce8 3000     		movs	r0, r6
 7415 0cea FFF7FEFF 		bl	pd_power_supply_reset
 7416              	.LVL683:
 7417 0cee EFE7     		b	.L466
 7418              	.LVL684:
 7419              	.L467:
 7420              	.LBE964:
 7421              	.LBE965:
2798:Src/usb_pd_protocol.c **** 		}
2799:Src/usb_pd_protocol.c **** 		/* Wait for CC debounce and VBUS present */
2800:Src/usb_pd_protocol.c **** 		if (get_time().val < pd[port].cc_debounce ||
 7422              		.loc 1 2800 0
 7423 0cf0 02A8     		add	r0, sp, #8
 7424 0cf2 FFF7FEFF 		bl	get_time
 7425              	.LVL685:
 7426 0cf6 0298     		ldr	r0, [sp, #8]
 7427 0cf8 0399     		ldr	r1, [sp, #12]
 7428 0cfa F201     		lsls	r2, r6, #7
 7429 0cfc 2C4B     		ldr	r3, .L602
 7430 0cfe 9B18     		adds	r3, r3, r2
 7431 0d00 1A6A     		ldr	r2, [r3, #32]
 7432 0d02 5B6A     		ldr	r3, [r3, #36]
 7433 0d04 8B42     		cmp	r3, r1
 7434 0d06 00D9     		bls	.LCB7561
 7435 0d08 80E2     		b	.L372	@long jump
 7436              	.LCB7561:
 7437 0d0a 02D1     		bne	.L533
 7438 0d0c 8242     		cmp	r2, r0
 7439 0d0e 00D9     		bls	.LCB7565
 7440 0d10 7CE2     		b	.L372	@long jump
 7441              	.LCB7565:
 7442              	.L533:
 7443              	.LVL686:
 7444              	.LBB966:
 7445              	.LBB967:
 339:Src/usb_pd_protocol.c **** #endif
 7446              		.loc 1 339 0
 7447 0d12 3000     		movs	r0, r6
 7448 0d14 FFF7FEFF 		bl	pd_snk_is_vbus_provided
 7449              	.LVL687:
 7450              	.LBE967:
 7451              	.LBE966:
 7452              		.loc 1 2800 0
 7453 0d18 0028     		cmp	r0, #0
 7454 0d1a 00D1     		bne	.LCB7577
 7455 0d1c 76E2     		b	.L372	@long jump
 7456              	.LCB7577:
2801:Src/usb_pd_protocol.c **** 			!pd_is_vbus_present(port))
2802:Src/usb_pd_protocol.c **** 			break;
2803:Src/usb_pd_protocol.c **** 
2804:Src/usb_pd_protocol.c **** 		if (pd_try_src_enable &&
2805:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TRY_SRC)) {
2806:Src/usb_pd_protocol.c **** 			/*
ARM GAS  /tmp/ccWvVg6G.s 			page 195


2807:Src/usb_pd_protocol.c **** 				* If TRY_SRC is enabled, but not active,
2808:Src/usb_pd_protocol.c **** 				* then force attempt to connect as source.
2809:Src/usb_pd_protocol.c **** 				*/
2810:Src/usb_pd_protocol.c **** 			pd[port].try_src_marker = get_time().val
2811:Src/usb_pd_protocol.c **** 				+ PD_T_TRY_SRC;
2812:Src/usb_pd_protocol.c **** 			/* Swap roles to source */
2813:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SOURCE;
2814:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
2815:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC;
2816:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
2817:Src/usb_pd_protocol.c **** 			/* Set flag after the state change */
2818:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_TRY_SRC;
2819:Src/usb_pd_protocol.c **** 			break;
2820:Src/usb_pd_protocol.c **** 		}
2821:Src/usb_pd_protocol.c **** 
2822:Src/usb_pd_protocol.c **** 		/* We are attached */
2823:Src/usb_pd_protocol.c **** 		pd[port].polarity = get_snk_polarity(cc1, cc2);
 7457              		.loc 1 2823 0
 7458 0d1e 294B     		ldr	r3, .L602+20
 7459 0d20 1968     		ldr	r1, [r3]
 7460 0d22 294B     		ldr	r3, .L602+24
 7461 0d24 1A68     		ldr	r2, [r3]
 7462              	.LVL688:
 7463              	.LBB968:
 7464              	.LBB969:
1968:Src/usb_pd_protocol.c **** }
 7465              		.loc 1 1968 0
 7466 0d26 0123     		movs	r3, #1
 7467 0d28 9142     		cmp	r1, r2
 7468 0d2a 00DB     		blt	.L469
 7469 0d2c 0023     		movs	r3, #0
 7470              	.L469:
 7471 0d2e D9B2     		uxtb	r1, r3
 7472              	.LVL689:
 7473              	.LBE969:
 7474              	.LBE968:
 7475              		.loc 1 2823 0
 7476 0d30 F201     		lsls	r2, r6, #7
 7477 0d32 1F4C     		ldr	r4, .L602
 7478 0d34 A418     		adds	r4, r4, r2
 7479 0d36 E370     		strb	r3, [r4, #3]
 7480              	.LVL690:
 7481              	.LBB970:
 7482              	.LBB971:
  76:Inc/tcpm.h    **** }
 7483              		.loc 2 76 0
 7484 0d38 3201     		lsls	r2, r6, #4
 7485 0d3a 214B     		ldr	r3, .L602+16
 7486 0d3c 9B18     		adds	r3, r3, r2
 7487 0d3e 9D68     		ldr	r5, [r3, #8]
 7488 0d40 3000     		movs	r0, r6
 7489 0d42 AB69     		ldr	r3, [r5, #24]
 7490 0d44 9847     		blx	r3
 7491              	.LVL691:
 7492              	.LBE971:
 7493              	.LBE970:
2824:Src/usb_pd_protocol.c **** 		tcpm_set_polarity(port, pd[port].polarity);
ARM GAS  /tmp/ccWvVg6G.s 			page 196


2825:Src/usb_pd_protocol.c **** 		/* reset message ID  on connection */
2826:Src/usb_pd_protocol.c **** 		pd[port].msg_id = 0;
 7494              		.loc 1 2826 0
 7495 0d46 0023     		movs	r3, #0
 7496 0d48 A370     		strb	r3, [r4, #2]
2827:Src/usb_pd_protocol.c **** 		/* initial data role for sink is UFP */
2828:Src/usb_pd_protocol.c **** 		pd_set_data_role(port, PD_ROLE_UFP);
 7497              		.loc 1 2828 0
 7498 0d4a 0021     		movs	r1, #0
 7499 0d4c 3000     		movs	r0, r6
 7500 0d4e FFF7FEFF 		bl	pd_set_data_role
 7501              	.LVL692:
2829:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
2830:Src/usb_pd_protocol.c **** 		typec_curr = get_typec_current_limit(pd[port].polarity,
 7502              		.loc 1 2830 0
 7503 0d52 E078     		ldrb	r0, [r4, #3]
 7504 0d54 1C4B     		ldr	r3, .L602+24
 7505 0d56 1A68     		ldr	r2, [r3]
 7506 0d58 1A4B     		ldr	r3, .L602+20
 7507 0d5a 1968     		ldr	r1, [r3]
 7508 0d5c FFF7FEFF 		bl	get_typec_current_limit
 7509              	.LVL693:
 7510 0d60 234B     		ldr	r3, .L602+64
 7511 0d62 1860     		str	r0, [r3]
2831:Src/usb_pd_protocol.c **** 							    cc1, cc2);
2832:Src/usb_pd_protocol.c **** 		//typec_set_input_current_limit(
2833:Src/usb_pd_protocol.c **** 		//	port, typec_curr, TYPE_C_VOLTAGE);
2834:Src/usb_pd_protocol.c **** #endif
2835:Src/usb_pd_protocol.c **** 		/* If PD comm is enabled, enable TCPC RX */
2836:Src/usb_pd_protocol.c **** 		if (pd_comm_is_enabled(port))
 7512              		.loc 1 2836 0
 7513 0d64 3000     		movs	r0, r6
 7514 0d66 FFF7FEFF 		bl	pd_comm_is_enabled
 7515              	.LVL694:
 7516 0d6a 0028     		cmp	r0, #0
 7517 0d6c 03D0     		beq	.L470
 7518              	.LVL695:
 7519              	.LBB972:
 7520              	.LBB973:
  92:Inc/tcpm.h    **** }
 7521              		.loc 2 92 0
 7522 0d6e 6B6A     		ldr	r3, [r5, #36]
 7523 0d70 0121     		movs	r1, #1
 7524 0d72 3000     		movs	r0, r6
 7525 0d74 9847     		blx	r3
 7526              	.LVL696:
 7527              	.L470:
 7528              	.LBE973:
 7529              	.LBE972:
2837:Src/usb_pd_protocol.c **** 			tcpm_set_rx_enable(port, 1);
2838:Src/usb_pd_protocol.c **** 
2839:Src/usb_pd_protocol.c **** 		/* DFP is attached */
2840:Src/usb_pd_protocol.c **** 		if (new_cc_state == PD_CC_DFP_ATTACHED ||
 7530              		.loc 1 2840 0
 7531 0d76 164B     		ldr	r3, .L602+32
 7532 0d78 1978     		ldrb	r1, [r3]
 7533 0d7a 0529     		cmp	r1, #5
ARM GAS  /tmp/ccWvVg6G.s 			page 197


 7534 0d7c 02D0     		beq	.L471
 7535              		.loc 1 2840 0 is_stmt 0 discriminator 1
 7536 0d7e 0329     		cmp	r1, #3
 7537 0d80 00D0     		beq	.LCB7661
 7538 0d82 43E2     		b	.L372	@long jump
 7539              	.LCB7661:
 7540              	.L471:
2841:Src/usb_pd_protocol.c **** 			new_cc_state == PD_CC_DEBUG_ACC) {
2842:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_PR_ROLE |
 7541              		.loc 1 2842 0 is_stmt 1
 7542 0d84 F301     		lsls	r3, r6, #7
 7543 0d86 0A4A     		ldr	r2, .L602
 7544 0d88 D218     		adds	r2, r2, r3
 7545 0d8a C123     		movs	r3, #193
 7546 0d8c DB00     		lsls	r3, r3, #3
 7547 0d8e 9068     		ldr	r0, [r2, #8]
 7548 0d90 0343     		orrs	r3, r0
 7549 0d92 9360     		str	r3, [r2, #8]
2843:Src/usb_pd_protocol.c **** 						PD_FLAGS_CHECK_DR_ROLE |
2844:Src/usb_pd_protocol.c **** 						PD_FLAGS_CHECK_IDENTITY;
2845:Src/usb_pd_protocol.c **** 			if (new_cc_state == PD_CC_DEBUG_ACC)
 7550              		.loc 1 2845 0
 7551 0d94 0329     		cmp	r1, #3
 7552 0d96 2DD0     		beq	.L568
 7553              	.L472:
2846:Src/usb_pd_protocol.c **** 				pd[port].flags |=
2847:Src/usb_pd_protocol.c **** 					PD_FLAGS_TS_DTS_PARTNER;
2848:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_GET_SOURCE_CAP);
 7554              		.loc 1 2848 0
 7555 0d98 0721     		movs	r1, #7
 7556 0d9a 3000     		movs	r0, r6
 7557 0d9c FFF7FEFF 		bl	send_control
 7558              	.LVL697:
2849:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
 7559              		.loc 1 2849 0
 7560 0da0 0521     		movs	r1, #5
 7561 0da2 3000     		movs	r0, r6
 7562 0da4 FFF7FEFF 		bl	set_state
 7563              	.LVL698:
2850:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC;
 7564              		.loc 1 2850 0
 7565 0da8 034B     		ldr	r3, .L602+8
 7566 0daa 044A     		ldr	r2, .L602+12
 7567 0dac 1A60     		str	r2, [r3]
 7568 0dae 2DE2     		b	.L372
 7569              	.L603:
 7570              		.align	2
 7571              	.L602:
 7572 0db0 00000000 		.word	pd
 7573 0db4 00530700 		.word	480000
 7574 0db8 00000000 		.word	.LANCHOR5
 7575 0dbc 10270000 		.word	10000
 7576 0dc0 00000000 		.word	tcpc_config
 7577 0dc4 00000000 		.word	.LANCHOR7
 7578 0dc8 00000000 		.word	.LANCHOR6
 7579 0dcc 00000000 		.word	.LANCHOR10
 7580 0dd0 00000000 		.word	.LANCHOR9
ARM GAS  /tmp/ccWvVg6G.s 			page 198


 7581 0dd4 A0860100 		.word	100000
 7582 0dd8 00000000 		.word	.LANCHOR0
 7583 0ddc 00000000 		.word	.LANCHOR8
 7584 0de0 30750000 		.word	30000
 7585 0de4 FFDFFFFF 		.word	-8193
 7586 0de8 204E0000 		.word	20000
 7587 0dec 88130000 		.word	5000
 7588 0df0 00000000 		.word	.LANCHOR13
 7589              	.L568:
2846:Src/usb_pd_protocol.c **** 				pd[port].flags |=
 7590              		.loc 1 2846 0
 7591 0df4 F101     		lsls	r1, r6, #7
 7592 0df6 BA4A     		ldr	r2, .L604
 7593 0df8 5218     		adds	r2, r2, r1
 7594 0dfa 8021     		movs	r1, #128
 7595 0dfc 4902     		lsls	r1, r1, #9
 7596 0dfe 0B43     		orrs	r3, r1
 7597 0e00 9360     		str	r3, [r2, #8]
 7598 0e02 C9E7     		b	.L472
 7599              	.L377:
2851:Src/usb_pd_protocol.c **** 			//hook_call_deferred(
2852:Src/usb_pd_protocol.c **** 			//	&pd_usb_billboard_deferred_data,
2853:Src/usb_pd_protocol.c **** 			//	PD_T_AME);
2854:Src/usb_pd_protocol.c **** 		}
2855:Src/usb_pd_protocol.c **** 		break;
2856:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_HARD_RESET_RECOVER:
2857:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 7600              		.loc 1 2857 0
 7601 0e04 F101     		lsls	r1, r6, #7
 7602 0e06 B64A     		ldr	r2, .L604
 7603 0e08 5218     		adds	r2, r2, r1
 7604 0e0a 5179     		ldrb	r1, [r2, #5]
 7605 0e0c 8B42     		cmp	r3, r1
 7606 0e0e 06D0     		beq	.L473
2858:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 7607              		.loc 1 2858 0
 7608 0e10 F001     		lsls	r0, r6, #7
 7609 0e12 B34A     		ldr	r2, .L604
 7610 0e14 1218     		adds	r2, r2, r0
 7611 0e16 0820     		movs	r0, #8
 7612 0e18 9468     		ldr	r4, [r2, #8]
 7613 0e1a 2043     		orrs	r0, r4
 7614 0e1c 9060     		str	r0, [r2, #8]
 7615              	.L473:
2859:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_NONE
2860:Src/usb_pd_protocol.c **** 		/*
2861:Src/usb_pd_protocol.c **** 			* Can't measure vbus state so this is the maximum
2862:Src/usb_pd_protocol.c **** 			* recovery time for the source.
2863:Src/usb_pd_protocol.c **** 			*/
2864:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
2865:Src/usb_pd_protocol.c **** 			set_state_timeout(port, get_time().val +
2866:Src/usb_pd_protocol.c **** 						PD_T_SAFE_0V +
2867:Src/usb_pd_protocol.c **** 						PD_T_SRC_RECOVER_MAX +
2868:Src/usb_pd_protocol.c **** 						PD_T_SRC_TURN_ON,
2869:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2870:Src/usb_pd_protocol.c **** #else
2871:Src/usb_pd_protocol.c **** 		/* Wait for VBUS to go low and then high*/
ARM GAS  /tmp/ccWvVg6G.s 			page 199


2872:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 7616              		.loc 1 2872 0
 7617 0e1e 8B42     		cmp	r3, r1
 7618 0e20 22D1     		bne	.L569
 7619              	.L474:
 7620              	.LVL699:
 7621              	.LBB974:
 7622              	.LBB975:
 339:Src/usb_pd_protocol.c **** #endif
 7623              		.loc 1 339 0
 7624 0e22 3000     		movs	r0, r6
 7625 0e24 FFF7FEFF 		bl	pd_snk_is_vbus_provided
 7626              	.LVL700:
 7627              	.LBE975:
 7628              	.LBE974:
2873:Src/usb_pd_protocol.c **** 			snk_hard_reset_vbus_off = 0;
2874:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2875:Src/usb_pd_protocol.c **** 						get_time().val +
2876:Src/usb_pd_protocol.c **** 						PD_T_SAFE_0V,
2877:Src/usb_pd_protocol.c **** 						hard_reset_count <
2878:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
2879:Src/usb_pd_protocol.c **** 						    PD_STATE_HARD_RESET_SEND :
2880:Src/usb_pd_protocol.c **** 						    PD_STATE_SNK_DISCOVERY);
2881:Src/usb_pd_protocol.c **** 		}
2882:Src/usb_pd_protocol.c **** 
2883:Src/usb_pd_protocol.c **** 		if (!pd_is_vbus_present(port) &&
 7629              		.loc 1 2883 0
 7630 0e28 0028     		cmp	r0, #0
 7631 0e2a 03D1     		bne	.L476
2884:Src/usb_pd_protocol.c **** 			!snk_hard_reset_vbus_off) {
 7632              		.loc 1 2884 0 discriminator 1
 7633 0e2c AD4B     		ldr	r3, .L604+4
 7634 0e2e 1B68     		ldr	r3, [r3]
2883:Src/usb_pd_protocol.c **** 			!snk_hard_reset_vbus_off) {
 7635              		.loc 1 2883 0 discriminator 1
 7636 0e30 002B     		cmp	r3, #0
 7637 0e32 33D0     		beq	.L570
 7638              	.L476:
 7639              	.LVL701:
 7640              	.LBB976:
 7641              	.LBB977:
 339:Src/usb_pd_protocol.c **** #endif
 7642              		.loc 1 339 0
 7643 0e34 3000     		movs	r0, r6
 7644 0e36 FFF7FEFF 		bl	pd_snk_is_vbus_provided
 7645              	.LVL702:
 7646              	.LBE977:
 7647              	.LBE976:
2885:Src/usb_pd_protocol.c **** 			/* VBUS has gone low, reset timeout */
2886:Src/usb_pd_protocol.c **** 			snk_hard_reset_vbus_off = 1;
2887:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2888:Src/usb_pd_protocol.c **** 						get_time().val +
2889:Src/usb_pd_protocol.c **** 						PD_T_SRC_RECOVER_MAX +
2890:Src/usb_pd_protocol.c **** 						PD_T_SRC_TURN_ON,
2891:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2892:Src/usb_pd_protocol.c **** 		}
2893:Src/usb_pd_protocol.c **** 		if (pd_is_vbus_present(port) &&
ARM GAS  /tmp/ccWvVg6G.s 			page 200


 7648              		.loc 1 2893 0
 7649 0e3a 0028     		cmp	r0, #0
 7650 0e3c 00D1     		bne	.LCB7770
 7651 0e3e E5E1     		b	.L372	@long jump
 7652              	.LCB7770:
 7653              		.loc 1 2893 0 is_stmt 0 discriminator 1
 7654 0e40 A84B     		ldr	r3, .L604+4
 7655 0e42 1B68     		ldr	r3, [r3]
 7656 0e44 002B     		cmp	r3, #0
 7657 0e46 00D1     		bne	.LCB7774
 7658 0e48 E0E1     		b	.L372	@long jump
 7659              	.LCB7774:
 7660              	.LVL703:
 7661              	.LBB978:
 7662              	.LBB979:
 7663              	.LBB980:
 7664              	.LBB981:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7665              		.loc 1 283 0 is_stmt 1
 7666 0e4a F201     		lsls	r2, r6, #7
 7667 0e4c A44B     		ldr	r3, .L604
 7668 0e4e 9B18     		adds	r3, r3, r2
 7669 0e50 0020     		movs	r0, #0
 7670 0e52 0021     		movs	r1, #0
 7671 0e54 1861     		str	r0, [r3, #16]
 7672 0e56 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 7673              		.loc 1 284 0
 7674 0e58 0022     		movs	r2, #0
 7675 0e5a DA71     		strb	r2, [r3, #7]
 7676              	.LVL704:
 7677              	.LBE981:
 7678              	.LBE980:
 352:Src/usb_pd_protocol.c **** 
 7679              		.loc 1 352 0
 7680 0e5c 0532     		adds	r2, r2, #5
 7681 0e5e 1A71     		strb	r2, [r3, #4]
 7682              	.LVL705:
 7683              	.LBE979:
 7684              	.LBE978:
2894:Src/usb_pd_protocol.c **** 			snk_hard_reset_vbus_off) {
2895:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPM_TCPCI
2896:Src/usb_pd_protocol.c **** 			/*
2897:Src/usb_pd_protocol.c **** 				* After transmitting hard reset, TCPM writes
2898:Src/usb_pd_protocol.c **** 				* to RECEIVE_MESSAGE register to enable
2899:Src/usb_pd_protocol.c **** 				* PD message passing.
2900:Src/usb_pd_protocol.c **** 				*/
2901:Src/usb_pd_protocol.c **** 			if (pd_comm_is_enabled(port))
2902:Src/usb_pd_protocol.c **** 				tcpm_set_rx_enable(port, 1);
2903:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_TCPM_TCPCI */
2904:Src/usb_pd_protocol.c **** 
2905:Src/usb_pd_protocol.c **** 			/* VBUS went high again */
2906:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
2907:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC;
 7685              		.loc 1 2907 0
 7686 0e60 A14B     		ldr	r3, .L604+8
 7687 0e62 A24A     		ldr	r2, .L604+12
ARM GAS  /tmp/ccWvVg6G.s 			page 201


 7688 0e64 1A60     		str	r2, [r3]
 7689 0e66 D1E1     		b	.L372
 7690              	.L569:
2873:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 7691              		.loc 1 2873 0
 7692 0e68 9E4B     		ldr	r3, .L604+4
 7693 0e6a 0022     		movs	r2, #0
 7694 0e6c 1A60     		str	r2, [r3]
2875:Src/usb_pd_protocol.c **** 						PD_T_SAFE_0V,
 7695              		.loc 1 2875 0
 7696 0e6e 02A8     		add	r0, sp, #8
 7697 0e70 FFF7FEFF 		bl	get_time
 7698              	.LVL706:
2874:Src/usb_pd_protocol.c **** 						get_time().val +
 7699              		.loc 1 2874 0
 7700 0e74 9E48     		ldr	r0, .L604+16
 7701 0e76 0021     		movs	r1, #0
 7702 0e78 029B     		ldr	r3, [sp, #8]
 7703 0e7a 039C     		ldr	r4, [sp, #12]
 7704 0e7c C018     		adds	r0, r0, r3
 7705 0e7e 6141     		adcs	r1, r1, r4
2877:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
 7706              		.loc 1 2877 0
 7707 0e80 9C4B     		ldr	r3, .L604+20
 7708 0e82 1B68     		ldr	r3, [r3]
2874:Src/usb_pd_protocol.c **** 						get_time().val +
 7709              		.loc 1 2874 0
 7710 0e84 012B     		cmp	r3, #1
 7711 0e86 07DD     		ble	.L571
 7712 0e88 0524     		movs	r4, #5
 7713              	.L475:
 7714              	.LVL707:
 7715              	.LBB982:
 7716              	.LBB983:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7717              		.loc 1 283 0 discriminator 4
 7718 0e8a F201     		lsls	r2, r6, #7
 7719 0e8c 944B     		ldr	r3, .L604
 7720 0e8e 9B18     		adds	r3, r3, r2
 7721 0e90 1861     		str	r0, [r3, #16]
 7722 0e92 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 7723              		.loc 1 284 0 discriminator 4
 7724 0e94 DC71     		strb	r4, [r3, #7]
 7725 0e96 C4E7     		b	.L474
 7726              	.LVL708:
 7727              	.L571:
 7728              	.LBE983:
 7729              	.LBE982:
2874:Src/usb_pd_protocol.c **** 						get_time().val +
 7730              		.loc 1 2874 0
 7731 0e98 1F24     		movs	r4, #31
 7732 0e9a F6E7     		b	.L475
 7733              	.L570:
2886:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 7734              		.loc 1 2886 0
 7735 0e9c 914B     		ldr	r3, .L604+4
ARM GAS  /tmp/ccWvVg6G.s 			page 202


 7736 0e9e 0122     		movs	r2, #1
 7737 0ea0 1A60     		str	r2, [r3]
2888:Src/usb_pd_protocol.c **** 						PD_T_SRC_RECOVER_MAX +
 7738              		.loc 1 2888 0
 7739 0ea2 02A8     		add	r0, sp, #8
 7740 0ea4 FFF7FEFF 		bl	get_time
 7741              	.LVL709:
2887:Src/usb_pd_protocol.c **** 						get_time().val +
 7742              		.loc 1 2887 0
 7743 0ea8 9348     		ldr	r0, .L604+24
 7744 0eaa 0021     		movs	r1, #0
 7745 0eac 029B     		ldr	r3, [sp, #8]
 7746 0eae 039C     		ldr	r4, [sp, #12]
 7747 0eb0 C018     		adds	r0, r0, r3
 7748 0eb2 6141     		adcs	r1, r1, r4
 7749              	.LVL710:
 7750              	.LBB984:
 7751              	.LBB985:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7752              		.loc 1 283 0
 7753 0eb4 F201     		lsls	r2, r6, #7
 7754 0eb6 8A4B     		ldr	r3, .L604
 7755 0eb8 9B18     		adds	r3, r3, r2
 7756 0eba 1861     		str	r0, [r3, #16]
 7757 0ebc 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 7758              		.loc 1 284 0
 7759 0ebe 0222     		movs	r2, #2
 7760 0ec0 DA71     		strb	r2, [r3, #7]
 7761 0ec2 B7E7     		b	.L476
 7762              	.LVL711:
 7763              	.L378:
 7764              	.LBE985:
 7765              	.LBE984:
2908:Src/usb_pd_protocol.c **** 		}
2909:Src/usb_pd_protocol.c **** 
2910:Src/usb_pd_protocol.c **** 		/*
2911:Src/usb_pd_protocol.c **** 			* Don't need to set timeout because VBUS changing
2912:Src/usb_pd_protocol.c **** 			* will trigger an interrupt and wake us up.
2913:Src/usb_pd_protocol.c **** 			*/
2914:Src/usb_pd_protocol.c **** #endif
2915:Src/usb_pd_protocol.c **** 		break;
2916:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_DISCOVERY:
2917:Src/usb_pd_protocol.c **** 		/* Wait for source cap expired only if we are enabled */
2918:Src/usb_pd_protocol.c **** 		if ((pd[port].last_state != pd[port].task_state)
 7766              		.loc 1 2918 0
 7767 0ec4 F101     		lsls	r1, r6, #7
 7768 0ec6 864A     		ldr	r2, .L604
 7769 0ec8 5218     		adds	r2, r2, r1
 7770 0eca 5279     		ldrb	r2, [r2, #5]
 7771 0ecc 9342     		cmp	r3, r2
 7772 0ece 19D0     		beq	.L477
2919:Src/usb_pd_protocol.c **** 			&& pd_comm_is_enabled(port)) {
 7773              		.loc 1 2919 0
 7774 0ed0 3000     		movs	r0, r6
 7775 0ed2 FFF7FEFF 		bl	pd_comm_is_enabled
 7776              	.LVL712:
ARM GAS  /tmp/ccWvVg6G.s 			page 203


 7777 0ed6 0028     		cmp	r0, #0
 7778 0ed8 14D0     		beq	.L477
2920:Src/usb_pd_protocol.c **** 			/*
2921:Src/usb_pd_protocol.c **** 				* If VBUS has never been low, and we timeout
2922:Src/usb_pd_protocol.c **** 				* waiting for source cap, try a soft reset
2923:Src/usb_pd_protocol.c **** 				* first, in case we were already in a stable
2924:Src/usb_pd_protocol.c **** 				* contract before this boot.
2925:Src/usb_pd_protocol.c **** 				*/
2926:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_VBUS_NEVER_LOW)
 7779              		.loc 1 2926 0
 7780 0eda F201     		lsls	r2, r6, #7
 7781 0edc 804B     		ldr	r3, .L604
 7782 0ede 9B18     		adds	r3, r3, r2
 7783 0ee0 9B68     		ldr	r3, [r3, #8]
 7784 0ee2 1A06     		lsls	r2, r3, #24
 7785 0ee4 2FD4     		bmi	.L572
2927:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2928:Src/usb_pd_protocol.c **** 						get_time().val +
2929:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
2930:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET);
2931:Src/usb_pd_protocol.c **** 			/*
2932:Src/usb_pd_protocol.c **** 				* If we haven't passed hard reset counter,
2933:Src/usb_pd_protocol.c **** 				* start SinkWaitCapTimer, otherwise start
2934:Src/usb_pd_protocol.c **** 				* NoResponseTimer.
2935:Src/usb_pd_protocol.c **** 				*/
2936:Src/usb_pd_protocol.c **** 			else if (hard_reset_count < PD_HARD_RESET_COUNT)
 7786              		.loc 1 2936 0
 7787 0ee6 834A     		ldr	r2, .L604+20
 7788 0ee8 1268     		ldr	r2, [r2]
 7789 0eea 012A     		cmp	r2, #1
 7790 0eec 3CDD     		ble	.L573
2937:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2938:Src/usb_pd_protocol.c **** 						get_time().val +
2939:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
2940:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
2941:Src/usb_pd_protocol.c **** 			else if (pd[port].flags &
 7791              		.loc 1 2941 0
 7792 0eee DB05     		lsls	r3, r3, #23
 7793 0ef0 4BD4     		bmi	.L574
 7794              	.L479:
2942:Src/usb_pd_protocol.c **** 					PD_FLAGS_PREVIOUS_PD_CONN)
2943:Src/usb_pd_protocol.c **** 				/* ErrorRecovery */
2944:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2945:Src/usb_pd_protocol.c **** 						get_time().val +
2946:Src/usb_pd_protocol.c **** 						PD_T_NO_RESPONSE,
2947:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2948:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
2949:Src/usb_pd_protocol.c **** 			/*
2950:Src/usb_pd_protocol.c **** 				* If we didn't come from disconnected, must
2951:Src/usb_pd_protocol.c **** 				* have come from some path that did not set
2952:Src/usb_pd_protocol.c **** 				* typec current limit. So, set to 0 so that
2953:Src/usb_pd_protocol.c **** 				* we guarantee this is revised below.
2954:Src/usb_pd_protocol.c **** 				*/
2955:Src/usb_pd_protocol.c **** 			if (pd[port].last_state !=
 7795              		.loc 1 2955 0
 7796 0ef2 F201     		lsls	r2, r6, #7
 7797 0ef4 7A4B     		ldr	r3, .L604
ARM GAS  /tmp/ccWvVg6G.s 			page 204


 7798 0ef6 9B18     		adds	r3, r3, r2
 7799 0ef8 5B79     		ldrb	r3, [r3, #5]
 7800 0efa 032B     		cmp	r3, #3
 7801 0efc 02D0     		beq	.L477
2956:Src/usb_pd_protocol.c **** 				PD_STATE_SNK_DISCONNECTED_DEBOUNCE)
2957:Src/usb_pd_protocol.c **** 				typec_curr = 0;
 7802              		.loc 1 2957 0
 7803 0efe 7F4B     		ldr	r3, .L604+28
 7804 0f00 0022     		movs	r2, #0
 7805 0f02 1A60     		str	r2, [r3]
 7806              	.L477:
2958:Src/usb_pd_protocol.c **** #endif
2959:Src/usb_pd_protocol.c **** 		}
2960:Src/usb_pd_protocol.c **** 
2961:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
2962:Src/usb_pd_protocol.c **** 		timeout = PD_T_SINK_ADJ - PD_T_DEBOUNCE;
 7807              		.loc 1 2962 0
 7808 0f04 784B     		ldr	r3, .L604+8
 7809 0f06 7E4A     		ldr	r2, .L604+32
 7810 0f08 1A60     		str	r2, [r3]
 7811              	.LVL713:
 7812              	.LBB986:
 7813              	.LBB987:
  56:Inc/tcpm.h    **** }
 7814              		.loc 2 56 0
 7815 0f0a A368     		ldr	r3, [r4, #8]
 7816 0f0c 7D4D     		ldr	r5, .L604+36
 7817 0f0e 7E4C     		ldr	r4, .L604+40
 7818 0f10 2A00     		movs	r2, r5
 7819 0f12 2100     		movs	r1, r4
 7820 0f14 3000     		movs	r0, r6
 7821 0f16 9847     		blx	r3
 7822              	.LVL714:
 7823              	.LBE987:
 7824              	.LBE986:
2963:Src/usb_pd_protocol.c **** 
2964:Src/usb_pd_protocol.c **** 		/* Check if CC pull-up has changed */
2965:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
2966:Src/usb_pd_protocol.c **** 		if (typec_curr != get_typec_current_limit(
2967:Src/usb_pd_protocol.c **** 					pd[port].polarity, cc1, cc2)) {
 7825              		.loc 1 2967 0
 7826 0f18 F201     		lsls	r2, r6, #7
 7827 0f1a 714B     		ldr	r3, .L604
 7828 0f1c 9B18     		adds	r3, r3, r2
 7829 0f1e D878     		ldrb	r0, [r3, #3]
2966:Src/usb_pd_protocol.c **** 					pd[port].polarity, cc1, cc2)) {
 7830              		.loc 1 2966 0
 7831 0f20 2A68     		ldr	r2, [r5]
 7832 0f22 2168     		ldr	r1, [r4]
 7833 0f24 FFF7FEFF 		bl	get_typec_current_limit
 7834              	.LVL715:
 7835 0f28 744B     		ldr	r3, .L604+28
 7836 0f2a 1B68     		ldr	r3, [r3]
 7837 0f2c 9842     		cmp	r0, r3
 7838 0f2e 41D0     		beq	.L481
2968:Src/usb_pd_protocol.c **** 			/* debounce signal by requiring two reads */
2969:Src/usb_pd_protocol.c **** 			if (typec_curr_change) {
ARM GAS  /tmp/ccWvVg6G.s 			page 205


 7839              		.loc 1 2969 0
 7840 0f30 764B     		ldr	r3, .L604+44
 7841 0f32 1B68     		ldr	r3, [r3]
 7842 0f34 002B     		cmp	r3, #0
 7843 0f36 39D0     		beq	.L482
2970:Src/usb_pd_protocol.c **** 				/* set new input current limit */
2971:Src/usb_pd_protocol.c **** 				typec_curr = get_typec_current_limit(
 7844              		.loc 1 2971 0
 7845 0f38 704A     		ldr	r2, .L604+28
 7846 0f3a 1060     		str	r0, [r2]
 7847              	.L483:
2972:Src/usb_pd_protocol.c **** 					pd[port].polarity, cc1, cc2);
2973:Src/usb_pd_protocol.c **** 				//typec_set_input_current_limit(
2974:Src/usb_pd_protocol.c **** 				//	port, typec_curr, TYPE_C_VOLTAGE);
2975:Src/usb_pd_protocol.c **** 			} else {
2976:Src/usb_pd_protocol.c **** 				/* delay for debounce */
2977:Src/usb_pd_protocol.c **** 				timeout = PD_T_DEBOUNCE;
2978:Src/usb_pd_protocol.c **** 			}
2979:Src/usb_pd_protocol.c **** 			typec_curr_change = !typec_curr_change;
 7848              		.loc 1 2979 0
 7849 0f3c 5A42     		rsbs	r2, r3, #0
 7850 0f3e 5341     		adcs	r3, r3, r2
 7851 0f40 724A     		ldr	r2, .L604+44
 7852 0f42 1360     		str	r3, [r2]
 7853 0f44 62E1     		b	.L372
 7854              	.L572:
2928:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
 7855              		.loc 1 2928 0
 7856 0f46 02A8     		add	r0, sp, #8
 7857 0f48 FFF7FEFF 		bl	get_time
 7858              	.LVL716:
2927:Src/usb_pd_protocol.c **** 						get_time().val +
 7859              		.loc 1 2927 0
 7860 0f4c 7048     		ldr	r0, .L604+48
 7861 0f4e 0021     		movs	r1, #0
 7862 0f50 029A     		ldr	r2, [sp, #8]
 7863 0f52 039B     		ldr	r3, [sp, #12]
 7864 0f54 8018     		adds	r0, r0, r2
 7865 0f56 5941     		adcs	r1, r1, r3
 7866              	.LVL717:
 7867              	.LBB988:
 7868              	.LBB989:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7869              		.loc 1 283 0
 7870 0f58 F201     		lsls	r2, r6, #7
 7871 0f5a 614B     		ldr	r3, .L604
 7872 0f5c 9B18     		adds	r3, r3, r2
 7873 0f5e 1861     		str	r0, [r3, #16]
 7874 0f60 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 7875              		.loc 1 284 0
 7876 0f62 1E22     		movs	r2, #30
 7877 0f64 DA71     		strb	r2, [r3, #7]
 7878 0f66 C4E7     		b	.L479
 7879              	.LVL718:
 7880              	.L573:
 7881              	.LBE989:
ARM GAS  /tmp/ccWvVg6G.s 			page 206


 7882              	.LBE988:
2938:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
 7883              		.loc 1 2938 0
 7884 0f68 02A8     		add	r0, sp, #8
 7885 0f6a FFF7FEFF 		bl	get_time
 7886              	.LVL719:
2937:Src/usb_pd_protocol.c **** 						get_time().val +
 7887              		.loc 1 2937 0
 7888 0f6e 6848     		ldr	r0, .L604+48
 7889 0f70 0021     		movs	r1, #0
 7890 0f72 029A     		ldr	r2, [sp, #8]
 7891 0f74 039B     		ldr	r3, [sp, #12]
 7892 0f76 8018     		adds	r0, r0, r2
 7893 0f78 5941     		adcs	r1, r1, r3
 7894              	.LVL720:
 7895              	.LBB990:
 7896              	.LBB991:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7897              		.loc 1 283 0
 7898 0f7a F201     		lsls	r2, r6, #7
 7899 0f7c 584B     		ldr	r3, .L604
 7900 0f7e 9B18     		adds	r3, r3, r2
 7901 0f80 1861     		str	r0, [r3, #16]
 7902 0f82 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 7903              		.loc 1 284 0
 7904 0f84 1F22     		movs	r2, #31
 7905 0f86 DA71     		strb	r2, [r3, #7]
 7906 0f88 B3E7     		b	.L479
 7907              	.LVL721:
 7908              	.L574:
 7909              	.LBE991:
 7910              	.LBE990:
2945:Src/usb_pd_protocol.c **** 						PD_T_NO_RESPONSE,
 7911              		.loc 1 2945 0
 7912 0f8a 02A8     		add	r0, sp, #8
 7913 0f8c FFF7FEFF 		bl	get_time
 7914              	.LVL722:
2944:Src/usb_pd_protocol.c **** 						get_time().val +
 7915              		.loc 1 2944 0
 7916 0f90 6048     		ldr	r0, .L604+52
 7917 0f92 0021     		movs	r1, #0
 7918 0f94 029A     		ldr	r2, [sp, #8]
 7919 0f96 039B     		ldr	r3, [sp, #12]
 7920 0f98 8018     		adds	r0, r0, r2
 7921 0f9a 5941     		adcs	r1, r1, r3
 7922              	.LVL723:
 7923              	.LBB992:
 7924              	.LBB993:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7925              		.loc 1 283 0
 7926 0f9c F201     		lsls	r2, r6, #7
 7927 0f9e 504B     		ldr	r3, .L604
 7928 0fa0 9B18     		adds	r3, r3, r2
 7929 0fa2 1861     		str	r0, [r3, #16]
 7930 0fa4 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccWvVg6G.s 			page 207


 7931              		.loc 1 284 0
 7932 0fa6 0222     		movs	r2, #2
 7933 0fa8 DA71     		strb	r2, [r3, #7]
 7934 0faa A2E7     		b	.L479
 7935              	.LVL724:
 7936              	.L482:
 7937              	.LBE993:
 7938              	.LBE992:
2977:Src/usb_pd_protocol.c **** 			}
 7939              		.loc 1 2977 0
 7940 0fac 4E4A     		ldr	r2, .L604+8
 7941 0fae 5A49     		ldr	r1, .L604+56
 7942 0fb0 1160     		str	r1, [r2]
 7943 0fb2 C3E7     		b	.L483
 7944              	.L481:
2980:Src/usb_pd_protocol.c **** 		} else {
2981:Src/usb_pd_protocol.c **** 			typec_curr_change = 0;
 7945              		.loc 1 2981 0
 7946 0fb4 554B     		ldr	r3, .L604+44
 7947 0fb6 0022     		movs	r2, #0
 7948 0fb8 1A60     		str	r2, [r3]
 7949 0fba 27E1     		b	.L372
 7950              	.L379:
2982:Src/usb_pd_protocol.c **** 		}
2983:Src/usb_pd_protocol.c **** #endif
2984:Src/usb_pd_protocol.c **** 		break;
2985:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_REQUESTED:
2986:Src/usb_pd_protocol.c **** 		/* Wait for ACCEPT or REJECT */
2987:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 7951              		.loc 1 2987 0
 7952 0fbc F101     		lsls	r1, r6, #7
 7953 0fbe 484A     		ldr	r2, .L604
 7954 0fc0 5218     		adds	r2, r2, r1
 7955 0fc2 5279     		ldrb	r2, [r2, #5]
 7956 0fc4 9342     		cmp	r3, r2
 7957 0fc6 00D1     		bne	.LCB8086
 7958 0fc8 20E1     		b	.L372	@long jump
 7959              	.LCB8086:
2988:Src/usb_pd_protocol.c **** 			hard_reset_count = 0;
 7960              		.loc 1 2988 0
 7961 0fca 4A4B     		ldr	r3, .L604+20
 7962 0fcc 0022     		movs	r2, #0
 7963 0fce 1A60     		str	r2, [r3]
2989:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2990:Src/usb_pd_protocol.c **** 						get_time().val +
 7964              		.loc 1 2990 0
 7965 0fd0 02A8     		add	r0, sp, #8
 7966 0fd2 FFF7FEFF 		bl	get_time
 7967              	.LVL725:
2989:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 7968              		.loc 1 2989 0
 7969 0fd6 5148     		ldr	r0, .L604+60
 7970 0fd8 0021     		movs	r1, #0
 7971 0fda 029B     		ldr	r3, [sp, #8]
 7972 0fdc 039C     		ldr	r4, [sp, #12]
 7973 0fde C018     		adds	r0, r0, r3
 7974 0fe0 6141     		adcs	r1, r1, r4
ARM GAS  /tmp/ccWvVg6G.s 			page 208


 7975              	.LVL726:
 7976              	.LBB994:
 7977              	.LBB995:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7978              		.loc 1 283 0
 7979 0fe2 F201     		lsls	r2, r6, #7
 7980 0fe4 3E4B     		ldr	r3, .L604
 7981 0fe6 9B18     		adds	r3, r3, r2
 7982 0fe8 1861     		str	r0, [r3, #16]
 7983 0fea 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 7984              		.loc 1 284 0
 7985 0fec 1F22     		movs	r2, #31
 7986 0fee DA71     		strb	r2, [r3, #7]
 7987 0ff0 0CE1     		b	.L372
 7988              	.LVL727:
 7989              	.L380:
 7990              	.LBE995:
 7991              	.LBE994:
2991:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2992:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
2993:Src/usb_pd_protocol.c **** 		}
2994:Src/usb_pd_protocol.c **** 		break;
2995:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_TRANSITION:
2996:Src/usb_pd_protocol.c **** 		/* Wait for PS_RDY */
2997:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 7992              		.loc 1 2997 0
 7993 0ff2 F101     		lsls	r1, r6, #7
 7994 0ff4 3A4A     		ldr	r2, .L604
 7995 0ff6 5218     		adds	r2, r2, r1
 7996 0ff8 5279     		ldrb	r2, [r2, #5]
 7997 0ffa 9342     		cmp	r3, r2
 7998 0ffc 00D1     		bne	.LCB8124
 7999 0ffe 05E1     		b	.L372	@long jump
 8000              	.LCB8124:
2998:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2999:Src/usb_pd_protocol.c **** 						get_time().val +
 8001              		.loc 1 2999 0
 8002 1000 02A8     		add	r0, sp, #8
 8003 1002 FFF7FEFF 		bl	get_time
 8004              	.LVL728:
2998:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8005              		.loc 1 2998 0
 8006 1006 4648     		ldr	r0, .L604+64
 8007 1008 0021     		movs	r1, #0
 8008 100a 029B     		ldr	r3, [sp, #8]
 8009 100c 039C     		ldr	r4, [sp, #12]
 8010 100e C018     		adds	r0, r0, r3
 8011 1010 6141     		adcs	r1, r1, r4
 8012              	.LVL729:
 8013              	.LBB996:
 8014              	.LBB997:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8015              		.loc 1 283 0
 8016 1012 F201     		lsls	r2, r6, #7
 8017 1014 324B     		ldr	r3, .L604
 8018 1016 9B18     		adds	r3, r3, r2
ARM GAS  /tmp/ccWvVg6G.s 			page 209


 8019 1018 1861     		str	r0, [r3, #16]
 8020 101a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8021              		.loc 1 284 0
 8022 101c 1F22     		movs	r2, #31
 8023 101e DA71     		strb	r2, [r3, #7]
 8024 1020 F4E0     		b	.L372
 8025              	.LVL730:
 8026              	.L381:
 8027              	.LBE997:
 8028              	.LBE996:
3000:Src/usb_pd_protocol.c **** 						PD_T_PS_TRANSITION,
3001:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
3002:Src/usb_pd_protocol.c **** 		break;
3003:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_READY:
3004:Src/usb_pd_protocol.c **** 		timeout = 20*MSEC;
 8029              		.loc 1 3004 0
 8030 1022 314B     		ldr	r3, .L604+8
 8031 1024 3F4A     		ldr	r2, .L604+68
 8032 1026 1A60     		str	r2, [r3]
3005:Src/usb_pd_protocol.c **** 
3006:Src/usb_pd_protocol.c **** 		/*
3007:Src/usb_pd_protocol.c **** 			* Don't send any PD traffic if we woke up due to
3008:Src/usb_pd_protocol.c **** 			* incoming packet or if VDO response pending to avoid
3009:Src/usb_pd_protocol.c **** 			* collisions.
3010:Src/usb_pd_protocol.c **** 			*/
3011:Src/usb_pd_protocol.c **** 		if (incoming_packet ||
 8033              		.loc 1 3011 0
 8034 1028 3F4B     		ldr	r3, .L604+72
 8035 102a 1B68     		ldr	r3, [r3]
 8036 102c 002B     		cmp	r3, #0
 8037 102e 00D0     		beq	.LCB8160
 8038 1030 ECE0     		b	.L372	@long jump
 8039              	.LCB8160:
3012:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 8040              		.loc 1 3012 0 discriminator 1
 8041 1032 F201     		lsls	r2, r6, #7
 8042 1034 2A4B     		ldr	r3, .L604
 8043 1036 9B18     		adds	r3, r3, r2
 8044 1038 4833     		adds	r3, r3, #72
 8045 103a 1B78     		ldrb	r3, [r3]
 8046 103c 5BB2     		sxtb	r3, r3
3011:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 8047              		.loc 1 3011 0 discriminator 1
 8048 103e 022B     		cmp	r3, #2
 8049 1040 00D1     		bne	.LCB8168
 8050 1042 E3E0     		b	.L372	@long jump
 8051              	.LCB8168:
3013:Src/usb_pd_protocol.c **** 			break;
3014:Src/usb_pd_protocol.c **** 
3015:Src/usb_pd_protocol.c **** 		/* Check for new power to request */
3016:Src/usb_pd_protocol.c **** 		if (pd[port].new_power_request) {
 8052              		.loc 1 3016 0
 8053 1044 264B     		ldr	r3, .L604
 8054 1046 9B18     		adds	r3, r3, r2
 8055 1048 9B6B     		ldr	r3, [r3, #56]
 8056 104a 002B     		cmp	r3, #0
ARM GAS  /tmp/ccWvVg6G.s 			page 210


 8057 104c 11D1     		bne	.L575
3017:Src/usb_pd_protocol.c **** 			if (pd_send_request_msg(port, 0) != EC_SUCCESS)
3018:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SOFT_RESET);
3019:Src/usb_pd_protocol.c **** 			break;
3020:Src/usb_pd_protocol.c **** 		}
3021:Src/usb_pd_protocol.c **** 
3022:Src/usb_pd_protocol.c **** 		/* Check power role policy, which may trigger a swap */
3023:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_PR_ROLE) {
 8058              		.loc 1 3023 0
 8059 104e F201     		lsls	r2, r6, #7
 8060 1050 234B     		ldr	r3, .L604
 8061 1052 9B18     		adds	r3, r3, r2
 8062 1054 9A68     		ldr	r2, [r3, #8]
 8063 1056 9305     		lsls	r3, r2, #22
 8064 1058 17D4     		bmi	.L576
3024:Src/usb_pd_protocol.c **** 			pd_check_pr_role(port, PD_ROLE_SINK,
3025:Src/usb_pd_protocol.c **** 						pd[port].flags);
3026:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_PR_ROLE;
3027:Src/usb_pd_protocol.c **** 			break;
3028:Src/usb_pd_protocol.c **** 		}
3029:Src/usb_pd_protocol.c **** 
3030:Src/usb_pd_protocol.c **** 		/* Check data role policy, which may trigger a swap */
3031:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_DR_ROLE) {
 8065              		.loc 1 3031 0
 8066 105a 5305     		lsls	r3, r2, #21
 8067 105c 21D4     		bmi	.L577
3032:Src/usb_pd_protocol.c **** 			pd_check_dr_role(port, pd[port].data_role,
3033:Src/usb_pd_protocol.c **** 						pd[port].flags);
3034:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_DR_ROLE;
3035:Src/usb_pd_protocol.c **** 			break;
3036:Src/usb_pd_protocol.c **** 		}
3037:Src/usb_pd_protocol.c **** 
3038:Src/usb_pd_protocol.c **** 		/* If DFP, send discovery SVDMs */
3039:Src/usb_pd_protocol.c **** 		if (pd[port].data_role == PD_ROLE_DFP &&
 8068              		.loc 1 3039 0
 8069 105e F101     		lsls	r1, r6, #7
 8070 1060 1F4B     		ldr	r3, .L604
 8071 1062 5B18     		adds	r3, r3, r1
 8072 1064 5B78     		ldrb	r3, [r3, #1]
 8073 1066 012B     		cmp	r3, #1
 8074 1068 27D0     		beq	.L578
 8075              	.L487:
3040:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
3041:Src/usb_pd_protocol.c **** 			pd_send_vdm(port, USB_SID_PD,
3042:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
3043:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_IDENTITY;
3044:Src/usb_pd_protocol.c **** 			break;
3045:Src/usb_pd_protocol.c **** 		}
3046:Src/usb_pd_protocol.c **** 
3047:Src/usb_pd_protocol.c **** 		/* Sent all messages, don't need to wake very often */
3048:Src/usb_pd_protocol.c **** 		timeout = 200*MSEC;
 8076              		.loc 1 3048 0
 8077 106a 1F4B     		ldr	r3, .L604+8
 8078 106c 2F4A     		ldr	r2, .L604+76
 8079 106e 1A60     		str	r2, [r3]
3049:Src/usb_pd_protocol.c **** 		break;
 8080              		.loc 1 3049 0
ARM GAS  /tmp/ccWvVg6G.s 			page 211


 8081 1070 CCE0     		b	.L372
 8082              	.L575:
3017:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SOFT_RESET);
 8083              		.loc 1 3017 0
 8084 1072 0021     		movs	r1, #0
 8085 1074 3000     		movs	r0, r6
 8086 1076 FFF7FEFF 		bl	pd_send_request_msg
 8087              	.LVL731:
 8088 107a 0028     		cmp	r0, #0
 8089 107c 00D1     		bne	.LCB8205
 8090 107e C5E0     		b	.L372	@long jump
 8091              	.LCB8205:
3018:Src/usb_pd_protocol.c **** 			break;
 8092              		.loc 1 3018 0
 8093 1080 1E21     		movs	r1, #30
 8094 1082 3000     		movs	r0, r6
 8095 1084 FFF7FEFF 		bl	set_state
 8096              	.LVL732:
 8097 1088 C0E0     		b	.L372
 8098              	.L576:
3024:Src/usb_pd_protocol.c **** 						pd[port].flags);
 8099              		.loc 1 3024 0
 8100 108a 0021     		movs	r1, #0
 8101 108c 3000     		movs	r0, r6
 8102 108e FFF7FEFF 		bl	pd_check_pr_role
 8103              	.LVL733:
3026:Src/usb_pd_protocol.c **** 			break;
 8104              		.loc 1 3026 0
 8105 1092 F201     		lsls	r2, r6, #7
 8106 1094 124B     		ldr	r3, .L604
 8107 1096 9B18     		adds	r3, r3, r2
 8108 1098 254A     		ldr	r2, .L604+80
 8109 109a 9968     		ldr	r1, [r3, #8]
 8110 109c 0A40     		ands	r2, r1
 8111 109e 9A60     		str	r2, [r3, #8]
3027:Src/usb_pd_protocol.c **** 		}
 8112              		.loc 1 3027 0
 8113 10a0 B4E0     		b	.L372
 8114              	.L577:
3032:Src/usb_pd_protocol.c **** 						pd[port].flags);
 8115              		.loc 1 3032 0
 8116 10a2 F301     		lsls	r3, r6, #7
 8117 10a4 0E4C     		ldr	r4, .L604
 8118 10a6 E418     		adds	r4, r4, r3
 8119 10a8 6178     		ldrb	r1, [r4, #1]
 8120 10aa 3000     		movs	r0, r6
 8121 10ac FFF7FEFF 		bl	pd_check_dr_role
 8122              	.LVL734:
3034:Src/usb_pd_protocol.c **** 			break;
 8123              		.loc 1 3034 0
 8124 10b0 204B     		ldr	r3, .L604+84
 8125 10b2 A268     		ldr	r2, [r4, #8]
 8126 10b4 1340     		ands	r3, r2
 8127 10b6 A360     		str	r3, [r4, #8]
3035:Src/usb_pd_protocol.c **** 		}
 8128              		.loc 1 3035 0
 8129 10b8 A8E0     		b	.L372
ARM GAS  /tmp/ccWvVg6G.s 			page 212


 8130              	.L578:
3039:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
 8131              		.loc 1 3039 0 discriminator 1
 8132 10ba 1307     		lsls	r3, r2, #28
 8133 10bc D5D5     		bpl	.L487
3041:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
 8134              		.loc 1 3041 0
 8135 10be FF21     		movs	r1, #255
 8136 10c0 0023     		movs	r3, #0
 8137 10c2 0093     		str	r3, [sp]
 8138 10c4 0122     		movs	r2, #1
 8139 10c6 0902     		lsls	r1, r1, #8
 8140 10c8 3000     		movs	r0, r6
 8141 10ca FFF7FEFF 		bl	pd_send_vdm
 8142              	.LVL735:
3043:Src/usb_pd_protocol.c **** 			break;
 8143              		.loc 1 3043 0
 8144 10ce F201     		lsls	r2, r6, #7
 8145 10d0 034B     		ldr	r3, .L604
 8146 10d2 9B18     		adds	r3, r3, r2
 8147 10d4 0822     		movs	r2, #8
 8148 10d6 9968     		ldr	r1, [r3, #8]
 8149 10d8 9143     		bics	r1, r2
 8150 10da 9960     		str	r1, [r3, #8]
3044:Src/usb_pd_protocol.c **** 		}
 8151              		.loc 1 3044 0
 8152 10dc 96E0     		b	.L372
 8153              	.L605:
 8154 10de C046     		.align	2
 8155              	.L604:
 8156 10e0 00000000 		.word	pd
 8157 10e4 00000000 		.word	.LANCHOR14
 8158 10e8 00000000 		.word	.LANCHOR5
 8159 10ec 10270000 		.word	10000
 8160 10f0 10EB0900 		.word	650000
 8161 10f4 00000000 		.word	.LANCHOR10
 8162 10f8 78741300 		.word	1275000
 8163 10fc 00000000 		.word	.LANCHOR13
 8164 1100 409C0000 		.word	40000
 8165 1104 00000000 		.word	.LANCHOR6
 8166 1108 00000000 		.word	.LANCHOR7
 8167 110c 00000000 		.word	.LANCHOR15
 8168 1110 C0270900 		.word	600000
 8169 1114 60EC5300 		.word	5500000
 8170 1118 983A0000 		.word	15000
 8171 111c A0860100 		.word	100000
 8172 1120 20A10700 		.word	500000
 8173 1124 204E0000 		.word	20000
 8174 1128 00000000 		.word	.LANCHOR2
 8175 112c 400D0300 		.word	200000
 8176 1130 FFFDFFFF 		.word	-513
 8177 1134 FFFBFFFF 		.word	-1025
 8178              	.L382:
3050:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_INIT:
3051:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 8179              		.loc 1 3051 0
 8180 1138 F101     		lsls	r1, r6, #7
ARM GAS  /tmp/ccWvVg6G.s 			page 213


 8181 113a BE4A     		ldr	r2, .L606
 8182 113c 5218     		adds	r2, r2, r1
 8183 113e 5279     		ldrb	r2, [r2, #5]
 8184 1140 9342     		cmp	r3, r2
 8185 1142 63D0     		beq	.L372
3052:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_PR_SWAP);
 8186              		.loc 1 3052 0
 8187 1144 0A21     		movs	r1, #10
 8188 1146 3000     		movs	r0, r6
 8189 1148 FFF7FEFF 		bl	send_control
 8190              	.LVL736:
3053:Src/usb_pd_protocol.c **** 			if (res < 0) {
 8191              		.loc 1 3053 0
 8192 114c 0028     		cmp	r0, #0
 8193 114e 39DA     		bge	.L488
3054:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
 8194              		.loc 1 3054 0
 8195 1150 B94B     		ldr	r3, .L606+4
 8196 1152 BA4A     		ldr	r2, .L606+8
 8197 1154 1A60     		str	r2, [r3]
3055:Src/usb_pd_protocol.c **** 				/*
3056:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
3057:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
3058:Src/usb_pd_protocol.c **** 					* failure.
3059:Src/usb_pd_protocol.c **** 					*/
3060:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
 8198              		.loc 1 3060 0
 8199 1156 431C     		adds	r3, r0, #1
 8200 1158 28D0     		beq	.L579
 8201 115a 0822     		movs	r2, #8
 8202              	.L489:
 8203              	.LVL737:
 8204              	.LBB998:
 8205              	.LBB999:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8206              		.loc 1 346 0 discriminator 4
 8207 115c F101     		lsls	r1, r6, #7
 8208 115e B54B     		ldr	r3, .L606
 8209 1160 5B18     		adds	r3, r3, r1
 8210 1162 1C79     		ldrb	r4, [r3, #4]
 8211              	.LVL738:
 8212              	.LBB1000:
 8213              	.LBB1001:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8214              		.loc 1 283 0 discriminator 4
 8215 1164 0020     		movs	r0, #0
 8216 1166 0021     		movs	r1, #0
 8217 1168 1861     		str	r0, [r3, #16]
 8218 116a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8219              		.loc 1 284 0 discriminator 4
 8220 116c 0021     		movs	r1, #0
 8221 116e D971     		strb	r1, [r3, #7]
 8222              	.LVL739:
 8223              	.LBE1001:
 8224              	.LBE1000:
 352:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccWvVg6G.s 			page 214


 8225              		.loc 1 352 0 discriminator 4
 8226 1170 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 8227              		.loc 1 354 0 discriminator 4
 8228 1172 A242     		cmp	r2, r4
 8229 1174 4AD0     		beq	.L372
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8230              		.loc 1 365 0
 8231 1176 022C     		cmp	r4, #2
 8232 1178 1AD0     		beq	.L580
 8233              	.L490:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 8234              		.loc 1 366 0
 8235 117a 0E2C     		cmp	r4, #14
 8236 117c 1BD0     		beq	.L581
 8237              	.L491:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8238              		.loc 1 371 0
 8239 117e 0E2A     		cmp	r2, #14
 8240 1180 01D0     		beq	.L492
 8241 1182 022A     		cmp	r2, #2
 8242 1184 42D1     		bne	.L372
 8243              	.L492:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8244              		.loc 1 374 0
 8245 1186 0022     		movs	r2, #0
 8246              	.LVL740:
 8247 1188 0021     		movs	r1, #0
 8248 118a 3000     		movs	r0, r6
 8249 118c FFF7FEFF 		bl	pd_set_input_current_limit
 8250              	.LVL741:
 391:Src/usb_pd_protocol.c **** 			/*
 8251              		.loc 1 391 0
 8252 1190 F301     		lsls	r3, r6, #7
 8253 1192 A84A     		ldr	r2, .L606
 8254 1194 9B5C     		ldrb	r3, [r3, r2]
 8255 1196 012B     		cmp	r3, #1
 8256 1198 10D0     		beq	.L582
 8257              	.L493:
 8258              	.LVL742:
 8259              	.LBB1002:
 8260              	.LBB1003:
  92:Inc/tcpm.h    **** }
 8261              		.loc 2 92 0
 8262 119a 3201     		lsls	r2, r6, #4
 8263 119c A84B     		ldr	r3, .L606+12
 8264 119e 9B18     		adds	r3, r3, r2
 8265 11a0 9B68     		ldr	r3, [r3, #8]
 8266 11a2 5B6A     		ldr	r3, [r3, #36]
 8267 11a4 0021     		movs	r1, #0
 8268 11a6 3000     		movs	r0, r6
 8269 11a8 9847     		blx	r3
 8270              	.LVL743:
 8271 11aa 2FE0     		b	.L372
 8272              	.LVL744:
 8273              	.L579:
 8274              	.LBE1003:
ARM GAS  /tmp/ccWvVg6G.s 			page 215


 8275              	.LBE1002:
 8276              	.LBE999:
 8277              	.LBE998:
 8278              		.loc 1 3060 0
 8279 11ac 1E22     		movs	r2, #30
 8280 11ae D5E7     		b	.L489
 8281              	.LVL745:
 8282              	.L580:
 8283              	.LBB1005:
 8284              	.LBB1004:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8285              		.loc 1 365 0
 8286 11b0 0E2A     		cmp	r2, #14
 8287 11b2 E2D1     		bne	.L490
 8288 11b4 2AE0     		b	.L372
 8289              	.L581:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 8290              		.loc 1 367 0
 8291 11b6 022A     		cmp	r2, #2
 8292 11b8 E1D1     		bne	.L491
 8293 11ba 27E0     		b	.L372
 8294              	.LVL746:
 8295              	.L582:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8296              		.loc 1 396 0
 8297 11bc 3000     		movs	r0, r6
 8298 11be FFF7FEFF 		bl	pd_power_supply_reset
 8299              	.LVL747:
 8300 11c2 EAE7     		b	.L493
 8301              	.LVL748:
 8302              	.L488:
 8303              	.LBE1004:
 8304              	.LBE1005:
3061:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
3062:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_READY);
3063:Src/usb_pd_protocol.c **** 				break;
3064:Src/usb_pd_protocol.c **** 			}
3065:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
3066:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
3067:Src/usb_pd_protocol.c **** 						get_time().val +
 8305              		.loc 1 3067 0
 8306 11c4 02A8     		add	r0, sp, #8
 8307 11c6 FFF7FEFF 		bl	get_time
 8308              	.LVL749:
3066:Src/usb_pd_protocol.c **** 						get_time().val +
 8309              		.loc 1 3066 0
 8310 11ca 9E48     		ldr	r0, .L606+16
 8311 11cc 0021     		movs	r1, #0
 8312 11ce 029B     		ldr	r3, [sp, #8]
 8313 11d0 039C     		ldr	r4, [sp, #12]
 8314 11d2 C018     		adds	r0, r0, r3
 8315 11d4 6141     		adcs	r1, r1, r4
 8316              	.LVL750:
 8317              	.LBB1006:
 8318              	.LBB1007:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8319              		.loc 1 283 0
ARM GAS  /tmp/ccWvVg6G.s 			page 216


 8320 11d6 F201     		lsls	r2, r6, #7
 8321 11d8 964B     		ldr	r3, .L606
 8322 11da 9B18     		adds	r3, r3, r2
 8323 11dc 1861     		str	r0, [r3, #16]
 8324 11de 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8325              		.loc 1 284 0
 8326 11e0 0822     		movs	r2, #8
 8327 11e2 DA71     		strb	r2, [r3, #7]
 8328 11e4 12E0     		b	.L372
 8329              	.LVL751:
 8330              	.L383:
 8331              	.LBE1007:
 8332              	.LBE1006:
3068:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
3069:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_READY);
3070:Src/usb_pd_protocol.c **** 		}
3071:Src/usb_pd_protocol.c **** 		break;
3072:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_SNK_DISABLE:
3073:Src/usb_pd_protocol.c **** 		/* Stop drawing power */
3074:Src/usb_pd_protocol.c **** 		pd_set_input_current_limit(port, 0, 0);
 8333              		.loc 1 3074 0
 8334 11e6 0022     		movs	r2, #0
 8335 11e8 0021     		movs	r1, #0
 8336 11ea 3000     		movs	r0, r6
 8337 11ec FFF7FEFF 		bl	pd_set_input_current_limit
 8338              	.LVL752:
 8339              	.LBB1008:
 8340              	.LBB1009:
 8341              	.LBB1010:
 8342              	.LBB1011:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8343              		.loc 1 283 0
 8344 11f0 F201     		lsls	r2, r6, #7
 8345 11f2 904B     		ldr	r3, .L606
 8346 11f4 9B18     		adds	r3, r3, r2
 8347 11f6 0020     		movs	r0, #0
 8348 11f8 0021     		movs	r1, #0
 8349 11fa 1861     		str	r0, [r3, #16]
 8350 11fc 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8351              		.loc 1 284 0
 8352 11fe 0022     		movs	r2, #0
 8353 1200 DA71     		strb	r2, [r3, #7]
 8354              	.LVL753:
 8355              	.LBE1011:
 8356              	.LBE1010:
 352:Src/usb_pd_protocol.c **** 
 8357              		.loc 1 352 0
 8358 1202 0B32     		adds	r2, r2, #11
 8359 1204 1A71     		strb	r2, [r3, #4]
 8360              	.LVL754:
 8361              	.LBE1009:
 8362              	.LBE1008:
3075:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
3076:Src/usb_pd_protocol.c **** 		//typec_set_input_current_limit(port, 0, 0);
3077:Src/usb_pd_protocol.c **** 		//charge_manager_set_ceil(port,
ARM GAS  /tmp/ccWvVg6G.s 			page 217


3078:Src/usb_pd_protocol.c **** 		//			CEIL_REQUESTOR_PD,
3079:Src/usb_pd_protocol.c **** 		//			CHARGE_CEIL_NONE);
3080:Src/usb_pd_protocol.c **** #endif
3081:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_SWAP_SRC_DISABLE);
3082:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC;
 8363              		.loc 1 3082 0
 8364 1206 8C4B     		ldr	r3, .L606+4
 8365 1208 8C4A     		ldr	r2, .L606+8
 8366 120a 1A60     		str	r2, [r3]
 8367              	.L372:
3083:Src/usb_pd_protocol.c **** 		break;
3084:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_SRC_DISABLE:
3085:Src/usb_pd_protocol.c **** 		/* Wait for PS_RDY */
3086:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
3087:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
3088:Src/usb_pd_protocol.c **** 						get_time().val +
3089:Src/usb_pd_protocol.c **** 						PD_T_PS_SOURCE_OFF,
3090:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
3091:Src/usb_pd_protocol.c **** 		break;
3092:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_STANDBY:
3093:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3094:Src/usb_pd_protocol.c **** 			/* Switch to Rp and enable power supply */
3095:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
3096:Src/usb_pd_protocol.c **** 			if (pd_set_power_supply_ready(port)) {
3097:Src/usb_pd_protocol.c **** 				/* Restore Rd */
3098:Src/usb_pd_protocol.c **** 				tcpm_set_cc(port, TYPEC_CC_RD);
3099:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
3100:Src/usb_pd_protocol.c **** 				set_state(port,
3101:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
3102:Src/usb_pd_protocol.c **** 				break;
3103:Src/usb_pd_protocol.c **** 			}
3104:Src/usb_pd_protocol.c **** 			/* Wait for power supply to turn on */
3105:Src/usb_pd_protocol.c **** 			set_state_timeout(
3106:Src/usb_pd_protocol.c **** 				port,
3107:Src/usb_pd_protocol.c **** 				get_time().val +
3108:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
3109:Src/usb_pd_protocol.c **** 				PD_STATE_SNK_SWAP_COMPLETE);
3110:Src/usb_pd_protocol.c **** 		}
3111:Src/usb_pd_protocol.c **** 		break;
3112:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_COMPLETE:
3113:Src/usb_pd_protocol.c **** 		/* Send PS_RDY and change to source role */
3114:Src/usb_pd_protocol.c **** 		res = send_control(port, PD_CTRL_PS_RDY);
3115:Src/usb_pd_protocol.c **** 		if (res < 0) {
3116:Src/usb_pd_protocol.c **** 			/* Restore Rd */
3117:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
3118:Src/usb_pd_protocol.c **** 			pd_power_supply_reset(port);
3119:Src/usb_pd_protocol.c **** 			timeout = 10 * MSEC;
3120:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
3121:Src/usb_pd_protocol.c **** 			break;
3122:Src/usb_pd_protocol.c **** 		}
3123:Src/usb_pd_protocol.c **** 
3124:Src/usb_pd_protocol.c **** 		/* Don't send GET_SINK_CAP on swap */
3125:Src/usb_pd_protocol.c **** 		snk_cap_count = PD_SNK_CAP_RETRIES+1;
3126:Src/usb_pd_protocol.c **** 		caps_count = 0;
3127:Src/usb_pd_protocol.c **** 		pd[port].msg_id = 0;
3128:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
3129:Src/usb_pd_protocol.c **** 		pd_update_roles(port);
ARM GAS  /tmp/ccWvVg6G.s 			page 218


3130:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCOVERY);
3131:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC;
3132:Src/usb_pd_protocol.c **** 		break;
3133:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
3134:Src/usb_pd_protocol.c **** 	case PD_STATE_VCONN_SWAP_SEND:
3135:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3136:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_VCONN_SWAP);
3137:Src/usb_pd_protocol.c **** 			if (res < 0) {
3138:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
3139:Src/usb_pd_protocol.c **** 				/*
3140:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
3141:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
3142:Src/usb_pd_protocol.c **** 					* failure.
3143:Src/usb_pd_protocol.c **** 					*/
3144:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
3145:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
3146:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
3147:Src/usb_pd_protocol.c **** 				break;
3148:Src/usb_pd_protocol.c **** 			}
3149:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
3150:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
3151:Src/usb_pd_protocol.c **** 						get_time().val +
3152:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
3153:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
3154:Src/usb_pd_protocol.c **** 		}
3155:Src/usb_pd_protocol.c **** 		break;
3156:Src/usb_pd_protocol.c **** 	case PD_STATE_VCONN_SWAP_INIT:
3157:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3158:Src/usb_pd_protocol.c **** 			if (!(pd[port].flags & PD_FLAGS_VCONN_ON)) {
3159:Src/usb_pd_protocol.c **** 				/* Turn VCONN on and wait for it */
3160:Src/usb_pd_protocol.c **** 				tcpm_set_vconn(port, 1);
3161:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3162:Src/usb_pd_protocol.c **** 					get_time().val + PD_VCONN_SWAP_DELAY,
3163:Src/usb_pd_protocol.c **** 					PD_STATE_VCONN_SWAP_READY);
3164:Src/usb_pd_protocol.c **** 			} else {
3165:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3166:Src/usb_pd_protocol.c **** 					get_time().val + PD_T_VCONN_SOURCE_ON,
3167:Src/usb_pd_protocol.c **** 					READY_RETURN_STATE(port));
3168:Src/usb_pd_protocol.c **** 			}
3169:Src/usb_pd_protocol.c **** 		}
3170:Src/usb_pd_protocol.c **** 		break;
3171:Src/usb_pd_protocol.c **** 	case PD_STATE_VCONN_SWAP_READY:
3172:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3173:Src/usb_pd_protocol.c **** 			if (!(pd[port].flags & PD_FLAGS_VCONN_ON)) {
3174:Src/usb_pd_protocol.c **** 				/* VCONN is now on, send PS_RDY */
3175:Src/usb_pd_protocol.c **** 				pd[port].flags |= PD_FLAGS_VCONN_ON;
3176:Src/usb_pd_protocol.c **** 				res = send_control(port,
3177:Src/usb_pd_protocol.c **** 							PD_CTRL_PS_RDY);
3178:Src/usb_pd_protocol.c **** 				if (res == -1) {
3179:Src/usb_pd_protocol.c **** 					timeout = 10*MSEC;
3180:Src/usb_pd_protocol.c **** 					/*
3181:Src/usb_pd_protocol.c **** 						* If failed to get goodCRC,
3182:Src/usb_pd_protocol.c **** 						* send soft reset
3183:Src/usb_pd_protocol.c **** 						*/
3184:Src/usb_pd_protocol.c **** 					set_state(port,
3185:Src/usb_pd_protocol.c **** 							PD_STATE_SOFT_RESET);
3186:Src/usb_pd_protocol.c **** 					break;
ARM GAS  /tmp/ccWvVg6G.s 			page 219


3187:Src/usb_pd_protocol.c **** 				}
3188:Src/usb_pd_protocol.c **** 				set_state(port,
3189:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
3190:Src/usb_pd_protocol.c **** 			} else {
3191:Src/usb_pd_protocol.c **** 				/* Turn VCONN off and wait for it */
3192:Src/usb_pd_protocol.c **** 				tcpm_set_vconn(port, 0);
3193:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_VCONN_ON;
3194:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3195:Src/usb_pd_protocol.c **** 					get_time().val + PD_VCONN_SWAP_DELAY,
3196:Src/usb_pd_protocol.c **** 					READY_RETURN_STATE(port));
3197:Src/usb_pd_protocol.c **** 			}
3198:Src/usb_pd_protocol.c **** 		}
3199:Src/usb_pd_protocol.c **** 		break;
3200:Src/usb_pd_protocol.c **** #endif /* CONFIG_USBC_VCONN_SWAP */
3201:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
3202:Src/usb_pd_protocol.c **** 	case PD_STATE_SOFT_RESET:
3203:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3204:Src/usb_pd_protocol.c **** 			/* Message ID of soft reset is always 0 */
3205:Src/usb_pd_protocol.c **** 			pd[port].msg_id = 0;
3206:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_SOFT_RESET);
3207:Src/usb_pd_protocol.c **** 
3208:Src/usb_pd_protocol.c **** 			/* if soft reset failed, try hard reset. */
3209:Src/usb_pd_protocol.c **** 			if (res < 0) {
3210:Src/usb_pd_protocol.c **** 				set_state(port,
3211:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
3212:Src/usb_pd_protocol.c **** 				timeout = 5*MSEC;
3213:Src/usb_pd_protocol.c **** 				break;
3214:Src/usb_pd_protocol.c **** 			}
3215:Src/usb_pd_protocol.c **** 
3216:Src/usb_pd_protocol.c **** 			set_state_timeout(
3217:Src/usb_pd_protocol.c **** 				port,
3218:Src/usb_pd_protocol.c **** 				get_time().val + PD_T_SENDER_RESPONSE,
3219:Src/usb_pd_protocol.c **** 				PD_STATE_HARD_RESET_SEND);
3220:Src/usb_pd_protocol.c **** 		}
3221:Src/usb_pd_protocol.c **** 		break;
3222:Src/usb_pd_protocol.c **** 	case PD_STATE_HARD_RESET_SEND:
3223:Src/usb_pd_protocol.c **** 		hard_reset_count++;
3224:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
3225:Src/usb_pd_protocol.c **** 			hard_reset_sent = 0;
3226:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
3227:Src/usb_pd_protocol.c **** 		if (pd[port].last_state == PD_STATE_SNK_DISCOVERY ||
3228:Src/usb_pd_protocol.c **** 			(pd[port].last_state == PD_STATE_SOFT_RESET &&
3229:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_VBUS_NEVER_LOW))) {
3230:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
3231:Src/usb_pd_protocol.c **** 			/*
3232:Src/usb_pd_protocol.c **** 				* If discovery timed out, assume that we
3233:Src/usb_pd_protocol.c **** 				* have a dedicated charger attached. This
3234:Src/usb_pd_protocol.c **** 				* may not be a correct assumption according
3235:Src/usb_pd_protocol.c **** 				* to the specification, but it generally
3236:Src/usb_pd_protocol.c **** 				* works in practice and the harmful
3237:Src/usb_pd_protocol.c **** 				* effects of a wrong assumption here
3238:Src/usb_pd_protocol.c **** 				* are minimal.
3239:Src/usb_pd_protocol.c **** 				*/
3240:Src/usb_pd_protocol.c **** 			//charge_manager_update_dualrole(port,
3241:Src/usb_pd_protocol.c **** 			//				    CAP_DEDICATED);
3242:Src/usb_pd_protocol.c **** 		}
3243:Src/usb_pd_protocol.c **** #endif
ARM GAS  /tmp/ccWvVg6G.s 			page 220


3244:Src/usb_pd_protocol.c **** 
3245:Src/usb_pd_protocol.c **** 		/* try sending hard reset until it succeeds */
3246:Src/usb_pd_protocol.c **** 		if (!hard_reset_sent) {
3247:Src/usb_pd_protocol.c **** 			if (pd_transmit(port, TCPC_TX_HARD_RESET,
3248:Src/usb_pd_protocol.c **** 					0, NULL) < 0) {
3249:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
3250:Src/usb_pd_protocol.c **** 				break;
3251:Src/usb_pd_protocol.c **** 			}
3252:Src/usb_pd_protocol.c **** 
3253:Src/usb_pd_protocol.c **** 			/* successfully sent hard reset */
3254:Src/usb_pd_protocol.c **** 			hard_reset_sent = 1;
3255:Src/usb_pd_protocol.c **** 			/*
3256:Src/usb_pd_protocol.c **** 				* If we are source, delay before cutting power
3257:Src/usb_pd_protocol.c **** 				* to allow sink time to get hard reset.
3258:Src/usb_pd_protocol.c **** 				*/
3259:Src/usb_pd_protocol.c **** 			if (pd[port].power_role == PD_ROLE_SOURCE) {
3260:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3261:Src/usb_pd_protocol.c **** 					get_time().val + PD_T_PS_HARD_RESET,
3262:Src/usb_pd_protocol.c **** 					PD_STATE_HARD_RESET_EXECUTE);
3263:Src/usb_pd_protocol.c **** 			} else {
3264:Src/usb_pd_protocol.c **** 				set_state(port,
3265:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_EXECUTE);
3266:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC;
3267:Src/usb_pd_protocol.c **** 			}
3268:Src/usb_pd_protocol.c **** 		}
3269:Src/usb_pd_protocol.c **** 		break;
3270:Src/usb_pd_protocol.c **** 	case PD_STATE_HARD_RESET_EXECUTE:
3271:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
3272:Src/usb_pd_protocol.c **** 		/*
3273:Src/usb_pd_protocol.c **** 			* If hard reset while in the last stages of power
3274:Src/usb_pd_protocol.c **** 			* swap, then we need to restore our CC resistor.
3275:Src/usb_pd_protocol.c **** 			*/
3276:Src/usb_pd_protocol.c **** 		if (pd[port].last_state == PD_STATE_SNK_SWAP_STANDBY)
3277:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
3278:Src/usb_pd_protocol.c **** #endif
3279:Src/usb_pd_protocol.c **** 
3280:Src/usb_pd_protocol.c **** 		/* reset our own state machine */
3281:Src/usb_pd_protocol.c **** 		pd_execute_hard_reset(port);
3282:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC;
3283:Src/usb_pd_protocol.c **** 		break;
3284:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
3285:Src/usb_pd_protocol.c **** 	case PD_STATE_BIST_RX:
3286:Src/usb_pd_protocol.c **** 		send_bist_cmd(port);
3287:Src/usb_pd_protocol.c **** 		/* Delay at least enough for partner to finish BIST */
3288:Src/usb_pd_protocol.c **** 		timeout = PD_T_BIST_RECEIVE + 20*MSEC;
3289:Src/usb_pd_protocol.c **** 		/* Set to appropriate port disconnected state */
3290:Src/usb_pd_protocol.c **** 		set_state(port, DUAL_ROLE_IF_ELSE(port,
3291:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_DISCONNECTED,
3292:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_DISCONNECTED));
3293:Src/usb_pd_protocol.c **** 		break;
3294:Src/usb_pd_protocol.c **** 	case PD_STATE_BIST_TX:
3295:Src/usb_pd_protocol.c **** 		pd_transmit(port, TCPC_TX_BIST_MODE_2, 0, NULL);
3296:Src/usb_pd_protocol.c **** 		/* Delay at least enough to finish sending BIST */
3297:Src/usb_pd_protocol.c **** 		timeout = PD_T_BIST_TRANSMIT + 20*MSEC;
3298:Src/usb_pd_protocol.c **** 		/* Set to appropriate port disconnected state */
3299:Src/usb_pd_protocol.c **** 		set_state(port, DUAL_ROLE_IF_ELSE(port,
3300:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_DISCONNECTED,
ARM GAS  /tmp/ccWvVg6G.s 			page 221


3301:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_DISCONNECTED));
3302:Src/usb_pd_protocol.c **** 		break;
3303:Src/usb_pd_protocol.c **** #endif
3304:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
3305:Src/usb_pd_protocol.c **** 	case PD_STATE_DRP_AUTO_TOGGLE:
3306:Src/usb_pd_protocol.c **** 	{
3307:Src/usb_pd_protocol.c **** 		enum pd_states next_state;
3308:Src/usb_pd_protocol.c **** 
3309:Src/usb_pd_protocol.c **** 		assert(auto_toggle_supported);
3310:Src/usb_pd_protocol.c **** 
3311:Src/usb_pd_protocol.c **** 		/* Check for connection */
3312:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
3313:Src/usb_pd_protocol.c **** 
3314:Src/usb_pd_protocol.c **** 		/* Set to appropriate port state */
3315:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_OPEN &&
3316:Src/usb_pd_protocol.c **** 			cc2 == TYPEC_CC_VOLT_OPEN)
3317:Src/usb_pd_protocol.c **** 			/* nothing connected, keep toggling*/
3318:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_DRP_AUTO_TOGGLE;
3319:Src/usb_pd_protocol.c **** 		else if ((cc_is_rp(cc1) || cc_is_rp(cc2)) &&
3320:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SOURCE)
3321:Src/usb_pd_protocol.c **** 			/* SNK allowed unless ForceSRC */
3322:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_SNK_DISCONNECTED;
3323:Src/usb_pd_protocol.c **** 		else if (((cc1 == TYPEC_CC_VOLT_RD ||
3324:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RD) ||
3325:Src/usb_pd_protocol.c **** 				(cc1 == TYPEC_CC_VOLT_RA &&
3326:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RA)) &&
3327:Src/usb_pd_protocol.c **** 				(drp_state != PD_DRP_TOGGLE_OFF &&
3328:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SINK))
3329:Src/usb_pd_protocol.c **** 			/* SRC allowed unless ForceSNK or Toggle Off */
3330:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_SRC_DISCONNECTED;
3331:Src/usb_pd_protocol.c **** 		else
3332:Src/usb_pd_protocol.c **** 			/* Anything else, keep toggling */
3333:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_DRP_AUTO_TOGGLE;
3334:Src/usb_pd_protocol.c **** 
3335:Src/usb_pd_protocol.c **** 		if (next_state != PD_STATE_DRP_AUTO_TOGGLE) {
3336:Src/usb_pd_protocol.c **** 			tcpm_set_drp_toggle(port, 0);
3337:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC_LOW_POWER
3338:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d Exit Low Power Mode", port);
3339:Src/usb_pd_protocol.c **** #endif
3340:Src/usb_pd_protocol.c **** 		}
3341:Src/usb_pd_protocol.c **** 
3342:Src/usb_pd_protocol.c **** 		if (next_state == PD_STATE_SNK_DISCONNECTED) {
3343:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
3344:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
3345:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC;
3346:Src/usb_pd_protocol.c **** 		} else if (next_state == PD_STATE_SRC_DISCONNECTED) {
3347:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
3348:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SOURCE;
3349:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC;
3350:Src/usb_pd_protocol.c **** 		} else {
3351:Src/usb_pd_protocol.c **** 			tcpm_set_drp_toggle(port, 1);
3352:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_TCPC_DRP_TOGGLE;
3353:Src/usb_pd_protocol.c **** 			timeout = -1;
3354:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC_LOW_POWER
3355:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d Low Power Mode", port);
3356:Src/usb_pd_protocol.c **** #endif
3357:Src/usb_pd_protocol.c **** 		}
ARM GAS  /tmp/ccWvVg6G.s 			page 222


3358:Src/usb_pd_protocol.c **** 		set_state(port, next_state);
3359:Src/usb_pd_protocol.c **** 
3360:Src/usb_pd_protocol.c **** 		break;
3361:Src/usb_pd_protocol.c **** 	}
3362:Src/usb_pd_protocol.c **** #endif
3363:Src/usb_pd_protocol.c **** 	default:
3364:Src/usb_pd_protocol.c **** 		break;
3365:Src/usb_pd_protocol.c **** 	}
3366:Src/usb_pd_protocol.c **** 
3367:Src/usb_pd_protocol.c **** 	pd[port].last_state = this_state;
 8368              		.loc 1 3367 0
 8369 120c F301     		lsls	r3, r6, #7
 8370 120e 894C     		ldr	r4, .L606
 8371 1210 E418     		adds	r4, r4, r3
 8372 1212 8D4B     		ldr	r3, .L606+20
 8373 1214 1B78     		ldrb	r3, [r3]
 8374 1216 6371     		strb	r3, [r4, #5]
3368:Src/usb_pd_protocol.c **** 
3369:Src/usb_pd_protocol.c **** 	/*
3370:Src/usb_pd_protocol.c **** 		* Check for state timeout, and if not check if need to adjust
3371:Src/usb_pd_protocol.c **** 		* timeout value to wake up on the next state timeout.
3372:Src/usb_pd_protocol.c **** 		*/
3373:Src/usb_pd_protocol.c **** 	now = get_time();
 8375              		.loc 1 3373 0
 8376 1218 02A8     		add	r0, sp, #8
 8377 121a FFF7FEFF 		bl	get_time
 8378              	.LVL755:
 8379 121e 8B4B     		ldr	r3, .L606+24
 8380 1220 0299     		ldr	r1, [sp, #8]
 8381 1222 039A     		ldr	r2, [sp, #12]
 8382 1224 1960     		str	r1, [r3]
 8383 1226 5A60     		str	r2, [r3, #4]
3374:Src/usb_pd_protocol.c **** 	if (pd[port].timeout) {
 8384              		.loc 1 3374 0
 8385 1228 2269     		ldr	r2, [r4, #16]
 8386 122a 6369     		ldr	r3, [r4, #20]
 8387 122c 1100     		movs	r1, r2
 8388 122e 1943     		orrs	r1, r3
 8389 1230 15D0     		beq	.L505
3375:Src/usb_pd_protocol.c **** 		if (now.val >= pd[port].timeout) {
 8390              		.loc 1 3375 0
 8391 1232 8649     		ldr	r1, .L606+24
 8392 1234 0868     		ldr	r0, [r1]
 8393 1236 4968     		ldr	r1, [r1, #4]
 8394 1238 8B42     		cmp	r3, r1
 8395 123a 00D8     		bhi	.LCB8532
 8396 123c AAE1     		b	.L583	@long jump
 8397              	.LCB8532:
 8398              	.L507:
3376:Src/usb_pd_protocol.c **** 			set_state(port, pd[port].timeout_state);
3377:Src/usb_pd_protocol.c **** 			/* On a state timeout, run next state soon */
3378:Src/usb_pd_protocol.c **** 			timeout = timeout < 10*MSEC ? timeout : 10*MSEC;
3379:Src/usb_pd_protocol.c **** 		} else if (pd[port].timeout - now.val < timeout) {
 8399              		.loc 1 3379 0
 8400 123e 1400     		movs	r4, r2
 8401 1240 1D00     		movs	r5, r3
 8402 1242 241A     		subs	r4, r4, r0
ARM GAS  /tmp/ccWvVg6G.s 			page 223


 8403 1244 8D41     		sbcs	r5, r5, r1
 8404 1246 7C4F     		ldr	r7, .L606+4
 8405 1248 3F68     		ldr	r7, [r7]
 8406 124a BC46     		mov	ip, r7
 8407 124c FF17     		asrs	r7, r7, #31
 8408 124e AF42     		cmp	r7, r5
 8409 1250 02D8     		bhi	.L535
 8410 1252 04D1     		bne	.L505
 8411 1254 A445     		cmp	ip, r4
 8412 1256 02D9     		bls	.L505
 8413              	.L535:
3380:Src/usb_pd_protocol.c **** 			timeout = pd[port].timeout - now.val;
 8414              		.loc 1 3380 0
 8415 1258 121A     		subs	r2, r2, r0
 8416 125a 774B     		ldr	r3, .L606+4
 8417 125c 1A60     		str	r2, [r3]
 8418              	.L505:
3381:Src/usb_pd_protocol.c **** 		}
3382:Src/usb_pd_protocol.c **** 	}
3383:Src/usb_pd_protocol.c **** 
3384:Src/usb_pd_protocol.c **** 	/* Check for disconnection if we're connected */
3385:Src/usb_pd_protocol.c **** 	if (!pd_is_connected(port))
 8419              		.loc 1 3385 0
 8420 125e 3000     		movs	r0, r6
 8421 1260 FFF7FEFF 		bl	pd_is_connected
 8422              	.LVL756:
 8423 1264 0028     		cmp	r0, #0
 8424 1266 27D0     		beq	.L368
3386:Src/usb_pd_protocol.c **** 		return;
3387:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
3388:Src/usb_pd_protocol.c **** 	if (pd_is_power_swapping(port))
 8425              		.loc 1 3388 0
 8426 1268 3000     		movs	r0, r6
 8427 126a FFF7FEFF 		bl	pd_is_power_swapping
 8428              	.LVL757:
 8429 126e 0028     		cmp	r0, #0
 8430 1270 22D1     		bne	.L368
3389:Src/usb_pd_protocol.c **** 		return;
3390:Src/usb_pd_protocol.c **** #endif
3391:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SOURCE) {
 8431              		.loc 1 3391 0
 8432 1272 F301     		lsls	r3, r6, #7
 8433 1274 6F4A     		ldr	r2, .L606
 8434 1276 9B5C     		ldrb	r3, [r3, r2]
 8435 1278 012B     		cmp	r3, #1
 8436 127a 17D1     		bne	.L517
 8437              	.LVL758:
 8438              	.LBB1012:
 8439              	.LBB1013:
  56:Inc/tcpm.h    **** }
 8440              		.loc 2 56 0
 8441 127c 3201     		lsls	r2, r6, #4
 8442 127e 704B     		ldr	r3, .L606+12
 8443 1280 9B18     		adds	r3, r3, r2
 8444 1282 9B68     		ldr	r3, [r3, #8]
 8445 1284 9B68     		ldr	r3, [r3, #8]
 8446 1286 724A     		ldr	r2, .L606+28
ARM GAS  /tmp/ccWvVg6G.s 			page 224


 8447 1288 7249     		ldr	r1, .L606+32
 8448 128a 3000     		movs	r0, r6
 8449 128c 9847     		blx	r3
 8450              	.LVL759:
 8451              	.LBE1013:
 8452              	.LBE1012:
3392:Src/usb_pd_protocol.c **** 		/* Source: detect disconnect by monitoring CC */
3393:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
3394:Src/usb_pd_protocol.c **** 		if (pd[port].polarity)
 8453              		.loc 1 3394 0
 8454 128e F201     		lsls	r2, r6, #7
 8455 1290 684B     		ldr	r3, .L606
 8456 1292 9B18     		adds	r3, r3, r2
 8457 1294 DB78     		ldrb	r3, [r3, #3]
 8458 1296 002B     		cmp	r3, #0
 8459 1298 03D0     		beq	.L518
3395:Src/usb_pd_protocol.c **** 			cc1 = cc2;
 8460              		.loc 1 3395 0
 8461 129a 6D4B     		ldr	r3, .L606+28
 8462 129c 1A68     		ldr	r2, [r3]
 8463 129e 6D4B     		ldr	r3, .L606+32
 8464 12a0 1A60     		str	r2, [r3]
 8465              	.L518:
3396:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_OPEN) {
 8466              		.loc 1 3396 0
 8467 12a2 6C4B     		ldr	r3, .L606+32
 8468 12a4 1B68     		ldr	r3, [r3]
 8469 12a6 002B     		cmp	r3, #0
 8470 12a8 00D1     		bne	.LCB8603
 8471 12aa B3E1     		b	.L584	@long jump
 8472              	.LCB8603:
 8473              	.L517:
3397:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
3398:Src/usb_pd_protocol.c **** 			/* Debouncing */
3399:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC;
3400:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
3401:Src/usb_pd_protocol.c **** 			/*
3402:Src/usb_pd_protocol.c **** 				* If Try.SRC is configured, then ATTACHED_SRC
3403:Src/usb_pd_protocol.c **** 				* needs to transition to TryWait.SNK. Change
3404:Src/usb_pd_protocol.c **** 				* power role to SNK and start state timer.
3405:Src/usb_pd_protocol.c **** 				*/
3406:Src/usb_pd_protocol.c **** 			if (pd_try_src_enable) {
3407:Src/usb_pd_protocol.c **** 				/* Swap roles to sink */
3408:Src/usb_pd_protocol.c **** 				pd[port].power_role = PD_ROLE_SINK;
3409:Src/usb_pd_protocol.c **** 				tcpm_set_cc(port, TYPEC_CC_RD);
3410:Src/usb_pd_protocol.c **** 				/* Set timer for TryWait.SNK state */
3411:Src/usb_pd_protocol.c **** 				pd[port].try_src_marker = get_time().val
3412:Src/usb_pd_protocol.c **** 					+ PD_T_TRY_WAIT;
3413:Src/usb_pd_protocol.c **** 				/* Advance to TryWait.SNK state */
3414:Src/usb_pd_protocol.c **** 				set_state(port,
3415:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
3416:Src/usb_pd_protocol.c **** 				/* Mark state as TryWait.SNK */
3417:Src/usb_pd_protocol.c **** 				pd[port].flags |= PD_FLAGS_TRY_SRC;
3418:Src/usb_pd_protocol.c **** 			}
3419:Src/usb_pd_protocol.c **** #endif
3420:Src/usb_pd_protocol.c **** 		}
3421:Src/usb_pd_protocol.c **** 	}
ARM GAS  /tmp/ccWvVg6G.s 			page 225


3422:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
3423:Src/usb_pd_protocol.c **** 	/*
3424:Src/usb_pd_protocol.c **** 		* Sink disconnect if VBUS is low and we are not recovering
3425:Src/usb_pd_protocol.c **** 		* a hard reset.
3426:Src/usb_pd_protocol.c **** 		*/
3427:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SINK &&
 8474              		.loc 1 3427 0
 8475 12ac F301     		lsls	r3, r6, #7
 8476 12ae 614A     		ldr	r2, .L606
 8477 12b0 9B5C     		ldrb	r3, [r3, r2]
 8478 12b2 002B     		cmp	r3, #0
 8479 12b4 00D1     		bne	.LCB8609
 8480 12b6 D7E1     		b	.L585	@long jump
 8481              	.LCB8609:
 8482              	.L368:
3428:Src/usb_pd_protocol.c **** 		!pd_is_vbus_present(port) &&
3429:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_HARD_RESET_RECOVER &&
3430:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_HARD_RESET_EXECUTE) {
3431:Src/usb_pd_protocol.c **** 		/* Sink: detect disconnect by monitoring VBUS */
3432:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_DISCONNECTED);
3433:Src/usb_pd_protocol.c **** 		/* set timeout small to reconnect fast */
3434:Src/usb_pd_protocol.c **** 		timeout = 5*MSEC;
3435:Src/usb_pd_protocol.c **** 	}
3436:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
3437:Src/usb_pd_protocol.c **** }
 8483              		.loc 1 3437 0
 8484 12b8 05B0     		add	sp, sp, #20
 8485              		@ sp needed
 8486              	.LVL760:
 8487 12ba F0BD     		pop	{r4, r5, r6, r7, pc}
 8488              	.LVL761:
 8489              	.L384:
3086:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8490              		.loc 1 3086 0
 8491 12bc F101     		lsls	r1, r6, #7
 8492 12be 5D4A     		ldr	r2, .L606
 8493 12c0 5218     		adds	r2, r2, r1
 8494 12c2 5279     		ldrb	r2, [r2, #5]
 8495 12c4 9342     		cmp	r3, r2
 8496 12c6 A1D0     		beq	.L372
3088:Src/usb_pd_protocol.c **** 						PD_T_PS_SOURCE_OFF,
 8497              		.loc 1 3088 0
 8498 12c8 02A8     		add	r0, sp, #8
 8499 12ca FFF7FEFF 		bl	get_time
 8500              	.LVL762:
3087:Src/usb_pd_protocol.c **** 						get_time().val +
 8501              		.loc 1 3087 0
 8502 12ce 6248     		ldr	r0, .L606+36
 8503 12d0 0021     		movs	r1, #0
 8504 12d2 029B     		ldr	r3, [sp, #8]
 8505 12d4 039C     		ldr	r4, [sp, #12]
 8506 12d6 C018     		adds	r0, r0, r3
 8507 12d8 6141     		adcs	r1, r1, r4
 8508              	.LVL763:
 8509              	.LBB1014:
 8510              	.LBB1015:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
ARM GAS  /tmp/ccWvVg6G.s 			page 226


 8511              		.loc 1 283 0
 8512 12da F201     		lsls	r2, r6, #7
 8513 12dc 554B     		ldr	r3, .L606
 8514 12de 9B18     		adds	r3, r3, r2
 8515 12e0 1861     		str	r0, [r3, #16]
 8516 12e2 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8517              		.loc 1 284 0
 8518 12e4 1F22     		movs	r2, #31
 8519 12e6 DA71     		strb	r2, [r3, #7]
 8520 12e8 90E7     		b	.L372
 8521              	.LVL764:
 8522              	.L385:
 8523              	.LBE1015:
 8524              	.LBE1014:
3093:Src/usb_pd_protocol.c **** 			/* Switch to Rp and enable power supply */
 8525              		.loc 1 3093 0
 8526 12ea F101     		lsls	r1, r6, #7
 8527 12ec 514A     		ldr	r2, .L606
 8528 12ee 5218     		adds	r2, r2, r1
 8529 12f0 5279     		ldrb	r2, [r2, #5]
 8530 12f2 9342     		cmp	r3, r2
 8531 12f4 00D1     		bne	.LCB8666
 8532 12f6 89E7     		b	.L372	@long jump
 8533              	.LCB8666:
 8534              	.LVL765:
 8535              	.LBB1016:
 8536              	.LBB1017:
  71:Inc/tcpm.h    **** }
 8537              		.loc 2 71 0
 8538 12f8 0121     		movs	r1, #1
 8539 12fa 3000     		movs	r0, r6
 8540 12fc 6369     		ldr	r3, [r4, #20]
 8541 12fe 9847     		blx	r3
 8542              	.LVL766:
 8543              	.LBE1017:
 8544              	.LBE1016:
3096:Src/usb_pd_protocol.c **** 				/* Restore Rd */
 8545              		.loc 1 3096 0
 8546 1300 3000     		movs	r0, r6
 8547 1302 FFF7FEFF 		bl	pd_set_power_supply_ready
 8548              	.LVL767:
 8549 1306 0028     		cmp	r0, #0
 8550 1308 2FD0     		beq	.L494
 8551              	.LVL768:
 8552              	.LBB1018:
 8553              	.LBB1019:
  71:Inc/tcpm.h    **** }
 8554              		.loc 2 71 0
 8555 130a 6369     		ldr	r3, [r4, #20]
 8556 130c 0221     		movs	r1, #2
 8557 130e 3000     		movs	r0, r6
 8558 1310 9847     		blx	r3
 8559              	.LVL769:
 8560              	.LBE1019:
 8561              	.LBE1018:
3099:Src/usb_pd_protocol.c **** 				set_state(port,
ARM GAS  /tmp/ccWvVg6G.s 			page 227


 8562              		.loc 1 3099 0
 8563 1312 494B     		ldr	r3, .L606+4
 8564 1314 494A     		ldr	r2, .L606+8
 8565 1316 1A60     		str	r2, [r3]
 8566              	.LVL770:
 8567              	.LBB1020:
 8568              	.LBB1021:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8569              		.loc 1 346 0
 8570 1318 F201     		lsls	r2, r6, #7
 8571 131a 464B     		ldr	r3, .L606
 8572 131c 9B18     		adds	r3, r3, r2
 8573 131e 1A79     		ldrb	r2, [r3, #4]
 8574              	.LVL771:
 8575              	.LBB1022:
 8576              	.LBB1023:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8577              		.loc 1 283 0
 8578 1320 0020     		movs	r0, #0
 8579 1322 0021     		movs	r1, #0
 8580 1324 1861     		str	r0, [r3, #16]
 8581 1326 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8582              		.loc 1 284 0
 8583 1328 0021     		movs	r1, #0
 8584 132a D971     		strb	r1, [r3, #7]
 8585              	.LVL772:
 8586              	.LBE1023:
 8587              	.LBE1022:
 352:Src/usb_pd_protocol.c **** 
 8588              		.loc 1 352 0
 8589 132c 0231     		adds	r1, r1, #2
 8590 132e 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 8591              		.loc 1 354 0
 8592 1330 022A     		cmp	r2, #2
 8593 1332 00D1     		bne	.LCB8729
 8594 1334 6AE7     		b	.L372	@long jump
 8595              	.LCB8729:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 8596              		.loc 1 366 0
 8597 1336 0E2A     		cmp	r2, #14
 8598 1338 00D1     		bne	.LCB8731
 8599 133a 67E7     		b	.L372	@long jump
 8600              	.LCB8731:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8601              		.loc 1 374 0
 8602 133c 0022     		movs	r2, #0
 8603              	.LVL773:
 8604 133e 0021     		movs	r1, #0
 8605 1340 3000     		movs	r0, r6
 8606 1342 FFF7FEFF 		bl	pd_set_input_current_limit
 8607              	.LVL774:
 391:Src/usb_pd_protocol.c **** 			/*
 8608              		.loc 1 391 0
 8609 1346 F301     		lsls	r3, r6, #7
 8610 1348 3A4A     		ldr	r2, .L606
ARM GAS  /tmp/ccWvVg6G.s 			page 228


 8611 134a 9B5C     		ldrb	r3, [r3, r2]
 8612 134c 012B     		cmp	r3, #1
 8613 134e 08D0     		beq	.L586
 8614              	.L495:
 8615              	.LVL775:
 8616              	.LBB1024:
 8617              	.LBB1025:
  92:Inc/tcpm.h    **** }
 8618              		.loc 2 92 0
 8619 1350 3201     		lsls	r2, r6, #4
 8620 1352 3B4B     		ldr	r3, .L606+12
 8621 1354 9B18     		adds	r3, r3, r2
 8622 1356 9B68     		ldr	r3, [r3, #8]
 8623 1358 5B6A     		ldr	r3, [r3, #36]
 8624 135a 0021     		movs	r1, #0
 8625 135c 3000     		movs	r0, r6
 8626 135e 9847     		blx	r3
 8627              	.LVL776:
 8628 1360 54E7     		b	.L372
 8629              	.LVL777:
 8630              	.L586:
 8631              	.LBE1025:
 8632              	.LBE1024:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8633              		.loc 1 396 0
 8634 1362 3000     		movs	r0, r6
 8635 1364 FFF7FEFF 		bl	pd_power_supply_reset
 8636              	.LVL778:
 8637 1368 F2E7     		b	.L495
 8638              	.LVL779:
 8639              	.L494:
 8640              	.LBE1021:
 8641              	.LBE1020:
3107:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
 8642              		.loc 1 3107 0
 8643 136a 02A8     		add	r0, sp, #8
 8644 136c FFF7FEFF 		bl	get_time
 8645              	.LVL780:
3105:Src/usb_pd_protocol.c **** 				port,
 8646              		.loc 1 3105 0
 8647 1370 3248     		ldr	r0, .L606+8
 8648 1372 0021     		movs	r1, #0
 8649 1374 029B     		ldr	r3, [sp, #8]
 8650 1376 039C     		ldr	r4, [sp, #12]
 8651 1378 C018     		adds	r0, r0, r3
 8652 137a 6141     		adcs	r1, r1, r4
 8653              	.LVL781:
 8654              	.LBB1026:
 8655              	.LBB1027:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8656              		.loc 1 283 0
 8657 137c F201     		lsls	r2, r6, #7
 8658 137e 2D4B     		ldr	r3, .L606
 8659 1380 9B18     		adds	r3, r3, r2
 8660 1382 1861     		str	r0, [r3, #16]
 8661 1384 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccWvVg6G.s 			page 229


 8662              		.loc 1 284 0
 8663 1386 0D22     		movs	r2, #13
 8664 1388 DA71     		strb	r2, [r3, #7]
 8665 138a 3FE7     		b	.L372
 8666              	.LVL782:
 8667              	.L386:
 8668              	.LBE1027:
 8669              	.LBE1026:
3114:Src/usb_pd_protocol.c **** 		if (res < 0) {
 8670              		.loc 1 3114 0
 8671 138c 0621     		movs	r1, #6
 8672 138e 3000     		movs	r0, r6
 8673 1390 FFF7FEFF 		bl	send_control
 8674              	.LVL783:
3115:Src/usb_pd_protocol.c **** 			/* Restore Rd */
 8675              		.loc 1 3115 0
 8676 1394 0028     		cmp	r0, #0
 8677 1396 32DA     		bge	.L496
 8678              	.LVL784:
 8679              	.LBB1028:
 8680              	.LBB1029:
  71:Inc/tcpm.h    **** }
 8681              		.loc 2 71 0
 8682 1398 6369     		ldr	r3, [r4, #20]
 8683 139a 0221     		movs	r1, #2
 8684 139c 3000     		movs	r0, r6
 8685 139e 9847     		blx	r3
 8686              	.LVL785:
 8687              	.LBE1029:
 8688              	.LBE1028:
3118:Src/usb_pd_protocol.c **** 			timeout = 10 * MSEC;
 8689              		.loc 1 3118 0
 8690 13a0 3000     		movs	r0, r6
 8691 13a2 FFF7FEFF 		bl	pd_power_supply_reset
 8692              	.LVL786:
3119:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
 8693              		.loc 1 3119 0
 8694 13a6 244B     		ldr	r3, .L606+4
 8695 13a8 244A     		ldr	r2, .L606+8
 8696 13aa 1A60     		str	r2, [r3]
 8697              	.LVL787:
 8698              	.LBB1030:
 8699              	.LBB1031:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8700              		.loc 1 346 0
 8701 13ac F201     		lsls	r2, r6, #7
 8702 13ae 214B     		ldr	r3, .L606
 8703 13b0 9B18     		adds	r3, r3, r2
 8704 13b2 1A79     		ldrb	r2, [r3, #4]
 8705              	.LVL788:
 8706              	.LBB1032:
 8707              	.LBB1033:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8708              		.loc 1 283 0
 8709 13b4 0020     		movs	r0, #0
 8710 13b6 0021     		movs	r1, #0
 8711 13b8 1861     		str	r0, [r3, #16]
ARM GAS  /tmp/ccWvVg6G.s 			page 230


 8712 13ba 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8713              		.loc 1 284 0
 8714 13bc 0021     		movs	r1, #0
 8715 13be D971     		strb	r1, [r3, #7]
 8716              	.LVL789:
 8717              	.LBE1033:
 8718              	.LBE1032:
 352:Src/usb_pd_protocol.c **** 
 8719              		.loc 1 352 0
 8720 13c0 0231     		adds	r1, r1, #2
 8721 13c2 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 8722              		.loc 1 354 0
 8723 13c4 022A     		cmp	r2, #2
 8724 13c6 00D1     		bne	.LCB8862
 8725 13c8 20E7     		b	.L372	@long jump
 8726              	.LCB8862:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 8727              		.loc 1 366 0
 8728 13ca 0E2A     		cmp	r2, #14
 8729 13cc 00D1     		bne	.LCB8864
 8730 13ce 1DE7     		b	.L372	@long jump
 8731              	.LCB8864:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8732              		.loc 1 374 0
 8733 13d0 0022     		movs	r2, #0
 8734              	.LVL790:
 8735 13d2 0021     		movs	r1, #0
 8736 13d4 3000     		movs	r0, r6
 8737 13d6 FFF7FEFF 		bl	pd_set_input_current_limit
 8738              	.LVL791:
 391:Src/usb_pd_protocol.c **** 			/*
 8739              		.loc 1 391 0
 8740 13da F301     		lsls	r3, r6, #7
 8741 13dc 154A     		ldr	r2, .L606
 8742 13de 9B5C     		ldrb	r3, [r3, r2]
 8743 13e0 012B     		cmp	r3, #1
 8744 13e2 08D0     		beq	.L587
 8745              	.L497:
 8746              	.LVL792:
 8747              	.LBB1034:
 8748              	.LBB1035:
  92:Inc/tcpm.h    **** }
 8749              		.loc 2 92 0
 8750 13e4 3201     		lsls	r2, r6, #4
 8751 13e6 164B     		ldr	r3, .L606+12
 8752 13e8 9B18     		adds	r3, r3, r2
 8753 13ea 9B68     		ldr	r3, [r3, #8]
 8754 13ec 5B6A     		ldr	r3, [r3, #36]
 8755 13ee 0021     		movs	r1, #0
 8756 13f0 3000     		movs	r0, r6
 8757 13f2 9847     		blx	r3
 8758              	.LVL793:
 8759 13f4 0AE7     		b	.L372
 8760              	.LVL794:
 8761              	.L587:
ARM GAS  /tmp/ccWvVg6G.s 			page 231


 8762              	.LBE1035:
 8763              	.LBE1034:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8764              		.loc 1 396 0
 8765 13f6 3000     		movs	r0, r6
 8766 13f8 FFF7FEFF 		bl	pd_power_supply_reset
 8767              	.LVL795:
 8768 13fc F2E7     		b	.L497
 8769              	.LVL796:
 8770              	.L496:
 8771              	.LBE1031:
 8772              	.LBE1030:
3125:Src/usb_pd_protocol.c **** 		caps_count = 0;
 8773              		.loc 1 3125 0
 8774 13fe 174B     		ldr	r3, .L606+40
 8775 1400 0422     		movs	r2, #4
 8776 1402 1A60     		str	r2, [r3]
3126:Src/usb_pd_protocol.c **** 		pd[port].msg_id = 0;
 8777              		.loc 1 3126 0
 8778 1404 0025     		movs	r5, #0
 8779 1406 164B     		ldr	r3, .L606+44
 8780 1408 1D60     		str	r5, [r3]
3127:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
 8781              		.loc 1 3127 0
 8782 140a 0A4B     		ldr	r3, .L606
 8783 140c F201     		lsls	r2, r6, #7
 8784 140e 9C18     		adds	r4, r3, r2
 8785 1410 A570     		strb	r5, [r4, #2]
3128:Src/usb_pd_protocol.c **** 		pd_update_roles(port);
 8786              		.loc 1 3128 0
 8787 1412 0121     		movs	r1, #1
 8788 1414 D154     		strb	r1, [r2, r3]
3129:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCOVERY);
 8789              		.loc 1 3129 0
 8790 1416 3000     		movs	r0, r6
 8791 1418 FFF7FEFF 		bl	pd_update_roles
 8792              	.LVL797:
 8793              	.LBB1036:
 8794              	.LBB1037:
 8795              	.LBB1038:
 8796              	.LBB1039:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8797              		.loc 1 283 0
 8798 141c 0022     		movs	r2, #0
 8799 141e 0023     		movs	r3, #0
 8800 1420 2261     		str	r2, [r4, #16]
 8801 1422 6361     		str	r3, [r4, #20]
 284:Src/usb_pd_protocol.c **** }
 8802              		.loc 1 284 0
 8803 1424 E571     		strb	r5, [r4, #7]
 8804              	.LVL798:
 8805              	.LBE1039:
 8806              	.LBE1038:
 352:Src/usb_pd_protocol.c **** 
 8807              		.loc 1 352 0
 8808 1426 1223     		movs	r3, #18
 8809 1428 2371     		strb	r3, [r4, #4]
ARM GAS  /tmp/ccWvVg6G.s 			page 232


 8810              	.LVL799:
 8811              	.LBE1037:
 8812              	.LBE1036:
3131:Src/usb_pd_protocol.c **** 		break;
 8813              		.loc 1 3131 0
 8814 142a 034B     		ldr	r3, .L606+4
 8815 142c 034A     		ldr	r2, .L606+8
 8816 142e 1A60     		str	r2, [r3]
3132:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 8817              		.loc 1 3132 0
 8818 1430 ECE6     		b	.L372
 8819              	.L607:
 8820 1432 C046     		.align	2
 8821              	.L606:
 8822 1434 00000000 		.word	pd
 8823 1438 00000000 		.word	.LANCHOR5
 8824 143c 10270000 		.word	10000
 8825 1440 00000000 		.word	tcpc_config
 8826 1444 A0860100 		.word	100000
 8827 1448 00000000 		.word	.LANCHOR1
 8828 144c 00000000 		.word	.LANCHOR17
 8829 1450 00000000 		.word	.LANCHOR6
 8830 1454 00000000 		.word	.LANCHOR7
 8831 1458 C0090E00 		.word	920000
 8832 145c 00000000 		.word	.LANCHOR12
 8833 1460 00000000 		.word	.LANCHOR11
 8834              	.L403:
3203:Src/usb_pd_protocol.c **** 			/* Message ID of soft reset is always 0 */
 8835              		.loc 1 3203 0
 8836 1464 F101     		lsls	r1, r6, #7
 8837 1466 9D4A     		ldr	r2, .L608
 8838 1468 5218     		adds	r2, r2, r1
 8839 146a 5279     		ldrb	r2, [r2, #5]
 8840 146c 9342     		cmp	r3, r2
 8841 146e 00D1     		bne	.LCB8986
 8842 1470 CCE6     		b	.L372	@long jump
 8843              	.LCB8986:
3205:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_SOFT_RESET);
 8844              		.loc 1 3205 0
 8845 1472 9A4B     		ldr	r3, .L608
 8846 1474 5B18     		adds	r3, r3, r1
 8847 1476 0022     		movs	r2, #0
 8848 1478 9A70     		strb	r2, [r3, #2]
3206:Src/usb_pd_protocol.c **** 
 8849              		.loc 1 3206 0
 8850 147a 0D21     		movs	r1, #13
 8851 147c 3000     		movs	r0, r6
 8852 147e FFF7FEFF 		bl	send_control
 8853              	.LVL800:
3209:Src/usb_pd_protocol.c **** 				set_state(port,
 8854              		.loc 1 3209 0
 8855 1482 0028     		cmp	r0, #0
 8856 1484 10DB     		blt	.L588
3218:Src/usb_pd_protocol.c **** 				PD_STATE_HARD_RESET_SEND);
 8857              		.loc 1 3218 0
 8858 1486 02A8     		add	r0, sp, #8
 8859 1488 FFF7FEFF 		bl	get_time
ARM GAS  /tmp/ccWvVg6G.s 			page 233


 8860              	.LVL801:
3216:Src/usb_pd_protocol.c **** 				port,
 8861              		.loc 1 3216 0
 8862 148c 9448     		ldr	r0, .L608+4
 8863 148e 0021     		movs	r1, #0
 8864 1490 029B     		ldr	r3, [sp, #8]
 8865 1492 039C     		ldr	r4, [sp, #12]
 8866 1494 C018     		adds	r0, r0, r3
 8867 1496 6141     		adcs	r1, r1, r4
 8868              	.LVL802:
 8869              	.LBB1040:
 8870              	.LBB1041:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8871              		.loc 1 283 0
 8872 1498 F201     		lsls	r2, r6, #7
 8873 149a 904B     		ldr	r3, .L608
 8874 149c 9B18     		adds	r3, r3, r2
 8875 149e 1861     		str	r0, [r3, #16]
 8876 14a0 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8877              		.loc 1 284 0
 8878 14a2 1F22     		movs	r2, #31
 8879 14a4 DA71     		strb	r2, [r3, #7]
 8880 14a6 B1E6     		b	.L372
 8881              	.LVL803:
 8882              	.L588:
 8883              	.LBE1041:
 8884              	.LBE1040:
 8885              	.LBB1042:
 8886              	.LBB1043:
 8887              	.LBB1044:
 8888              	.LBB1045:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8889              		.loc 1 283 0
 8890 14a8 F201     		lsls	r2, r6, #7
 8891 14aa 8C4B     		ldr	r3, .L608
 8892 14ac 9B18     		adds	r3, r3, r2
 8893 14ae 0020     		movs	r0, #0
 8894 14b0 0021     		movs	r1, #0
 8895 14b2 1861     		str	r0, [r3, #16]
 8896 14b4 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8897              		.loc 1 284 0
 8898 14b6 0022     		movs	r2, #0
 8899 14b8 DA71     		strb	r2, [r3, #7]
 8900              	.LVL804:
 8901              	.LBE1045:
 8902              	.LBE1044:
 352:Src/usb_pd_protocol.c **** 
 8903              		.loc 1 352 0
 8904 14ba 1F32     		adds	r2, r2, #31
 8905 14bc 1A71     		strb	r2, [r3, #4]
 8906              	.LVL805:
 8907              	.LBE1043:
 8908              	.LBE1042:
3212:Src/usb_pd_protocol.c **** 				break;
 8909              		.loc 1 3212 0
ARM GAS  /tmp/ccWvVg6G.s 			page 234


 8910 14be 894B     		ldr	r3, .L608+8
 8911 14c0 894A     		ldr	r2, .L608+12
 8912 14c2 1A60     		str	r2, [r3]
3213:Src/usb_pd_protocol.c **** 			}
 8913              		.loc 1 3213 0
 8914 14c4 A2E6     		b	.L372
 8915              	.L404:
3223:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 8916              		.loc 1 3223 0
 8917 14c6 8949     		ldr	r1, .L608+16
 8918 14c8 0A68     		ldr	r2, [r1]
 8919 14ca 0132     		adds	r2, r2, #1
 8920 14cc 0A60     		str	r2, [r1]
3224:Src/usb_pd_protocol.c **** 			hard_reset_sent = 0;
 8921              		.loc 1 3224 0
 8922 14ce F101     		lsls	r1, r6, #7
 8923 14d0 824A     		ldr	r2, .L608
 8924 14d2 5218     		adds	r2, r2, r1
 8925 14d4 5279     		ldrb	r2, [r2, #5]
 8926 14d6 9342     		cmp	r3, r2
 8927 14d8 02D0     		beq	.L499
3225:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8928              		.loc 1 3225 0
 8929 14da 854B     		ldr	r3, .L608+20
 8930 14dc 0021     		movs	r1, #0
 8931 14de 1960     		str	r1, [r3]
 8932              	.L499:
3227:Src/usb_pd_protocol.c **** 			(pd[port].last_state == PD_STATE_SOFT_RESET &&
 8933              		.loc 1 3227 0
 8934 14e0 052A     		cmp	r2, #5
 8935 14e2 07D0     		beq	.L500
3227:Src/usb_pd_protocol.c **** 			(pd[port].last_state == PD_STATE_SOFT_RESET &&
 8936              		.loc 1 3227 0 is_stmt 0 discriminator 1
 8937 14e4 1E2A     		cmp	r2, #30
 8938 14e6 0CD1     		bne	.L501
3229:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
 8939              		.loc 1 3229 0 is_stmt 1
 8940 14e8 F201     		lsls	r2, r6, #7
 8941 14ea 7C4B     		ldr	r3, .L608
 8942 14ec 9B18     		adds	r3, r3, r2
 8943 14ee 9B68     		ldr	r3, [r3, #8]
3228:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_VBUS_NEVER_LOW))) {
 8944              		.loc 1 3228 0
 8945 14f0 1B06     		lsls	r3, r3, #24
 8946 14f2 06D5     		bpl	.L501
 8947              	.L500:
3230:Src/usb_pd_protocol.c **** 			/*
 8948              		.loc 1 3230 0
 8949 14f4 F201     		lsls	r2, r6, #7
 8950 14f6 794B     		ldr	r3, .L608
 8951 14f8 9B18     		adds	r3, r3, r2
 8952 14fa 8022     		movs	r2, #128
 8953 14fc 9968     		ldr	r1, [r3, #8]
 8954 14fe 9143     		bics	r1, r2
 8955 1500 9960     		str	r1, [r3, #8]
 8956              	.L501:
3246:Src/usb_pd_protocol.c **** 			if (pd_transmit(port, TCPC_TX_HARD_RESET,
ARM GAS  /tmp/ccWvVg6G.s 			page 235


 8957              		.loc 1 3246 0
 8958 1502 7B4B     		ldr	r3, .L608+20
 8959 1504 1B68     		ldr	r3, [r3]
 8960 1506 002B     		cmp	r3, #0
 8961 1508 00D0     		beq	.LCB9108
 8962 150a 7FE6     		b	.L372	@long jump
 8963              	.LCB9108:
3247:Src/usb_pd_protocol.c **** 					0, NULL) < 0) {
 8964              		.loc 1 3247 0
 8965 150c 0022     		movs	r2, #0
 8966 150e 0521     		movs	r1, #5
 8967 1510 3000     		movs	r0, r6
 8968 1512 FFF7FEFF 		bl	pd_transmit
 8969              	.LVL806:
 8970 1516 0028     		cmp	r0, #0
 8971 1518 16DB     		blt	.L589
3254:Src/usb_pd_protocol.c **** 			/*
 8972              		.loc 1 3254 0
 8973 151a 754B     		ldr	r3, .L608+20
 8974 151c 0122     		movs	r2, #1
 8975 151e 1A60     		str	r2, [r3]
3259:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
 8976              		.loc 1 3259 0
 8977 1520 F301     		lsls	r3, r6, #7
 8978 1522 6E4A     		ldr	r2, .L608
 8979 1524 9B5C     		ldrb	r3, [r3, r2]
 8980 1526 012B     		cmp	r3, #1
 8981 1528 12D0     		beq	.L590
 8982              	.LVL807:
 8983              	.LBB1046:
 8984              	.LBB1047:
 8985              	.LBB1048:
 8986              	.LBB1049:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8987              		.loc 1 283 0
 8988 152a F201     		lsls	r2, r6, #7
 8989 152c 6B4B     		ldr	r3, .L608
 8990 152e 9B18     		adds	r3, r3, r2
 8991 1530 0020     		movs	r0, #0
 8992 1532 0021     		movs	r1, #0
 8993 1534 1861     		str	r0, [r3, #16]
 8994 1536 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 8995              		.loc 1 284 0
 8996 1538 0022     		movs	r2, #0
 8997 153a DA71     		strb	r2, [r3, #7]
 8998              	.LVL808:
 8999              	.LBE1049:
 9000              	.LBE1048:
 352:Src/usb_pd_protocol.c **** 
 9001              		.loc 1 352 0
 9002 153c 2032     		adds	r2, r2, #32
 9003 153e 1A71     		strb	r2, [r3, #4]
 9004              	.LVL809:
 9005              	.LBE1047:
 9006              	.LBE1046:
3266:Src/usb_pd_protocol.c **** 			}
ARM GAS  /tmp/ccWvVg6G.s 			page 236


 9007              		.loc 1 3266 0
 9008 1540 684B     		ldr	r3, .L608+8
 9009 1542 6C4A     		ldr	r2, .L608+24
 9010 1544 1A60     		str	r2, [r3]
 9011 1546 61E6     		b	.L372
 9012              	.L589:
3249:Src/usb_pd_protocol.c **** 				break;
 9013              		.loc 1 3249 0
 9014 1548 664B     		ldr	r3, .L608+8
 9015 154a 6A4A     		ldr	r2, .L608+24
 9016 154c 1A60     		str	r2, [r3]
3250:Src/usb_pd_protocol.c **** 			}
 9017              		.loc 1 3250 0
 9018 154e 5DE6     		b	.L372
 9019              	.L590:
3261:Src/usb_pd_protocol.c **** 					PD_STATE_HARD_RESET_EXECUTE);
 9020              		.loc 1 3261 0
 9021 1550 02A8     		add	r0, sp, #8
 9022 1552 FFF7FEFF 		bl	get_time
 9023              	.LVL810:
3260:Src/usb_pd_protocol.c **** 					get_time().val + PD_T_PS_HARD_RESET,
 9024              		.loc 1 3260 0
 9025 1556 6848     		ldr	r0, .L608+28
 9026 1558 0021     		movs	r1, #0
 9027 155a 029B     		ldr	r3, [sp, #8]
 9028 155c 039C     		ldr	r4, [sp, #12]
 9029 155e C018     		adds	r0, r0, r3
 9030 1560 6141     		adcs	r1, r1, r4
 9031              	.LVL811:
 9032              	.LBB1050:
 9033              	.LBB1051:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9034              		.loc 1 283 0
 9035 1562 F201     		lsls	r2, r6, #7
 9036 1564 5D4B     		ldr	r3, .L608
 9037 1566 9B18     		adds	r3, r3, r2
 9038 1568 1861     		str	r0, [r3, #16]
 9039 156a 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 9040              		.loc 1 284 0
 9041 156c 2022     		movs	r2, #32
 9042 156e DA71     		strb	r2, [r3, #7]
 9043 1570 4CE6     		b	.L372
 9044              	.LVL812:
 9045              	.L405:
 9046              	.LBE1051:
 9047              	.LBE1050:
3276:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
 9048              		.loc 1 3276 0
 9049 1572 F201     		lsls	r2, r6, #7
 9050 1574 594B     		ldr	r3, .L608
 9051 1576 9B18     		adds	r3, r3, r2
 9052 1578 5B79     		ldrb	r3, [r3, #5]
 9053 157a 0C2B     		cmp	r3, #12
 9054 157c 03D1     		bne	.L504
 9055              	.LVL813:
 9056              	.LBB1052:
ARM GAS  /tmp/ccWvVg6G.s 			page 237


 9057              	.LBB1053:
  71:Inc/tcpm.h    **** }
 9058              		.loc 2 71 0
 9059 157e 6369     		ldr	r3, [r4, #20]
 9060 1580 0221     		movs	r1, #2
 9061 1582 3000     		movs	r0, r6
 9062 1584 9847     		blx	r3
 9063              	.LVL814:
 9064              	.L504:
 9065              	.LBE1053:
 9066              	.LBE1052:
3281:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC;
 9067              		.loc 1 3281 0
 9068 1586 3000     		movs	r0, r6
 9069 1588 FFF7FEFF 		bl	pd_execute_hard_reset
 9070              	.LVL815:
3282:Src/usb_pd_protocol.c **** 		break;
 9071              		.loc 1 3282 0
 9072 158c 554B     		ldr	r3, .L608+8
 9073 158e 594A     		ldr	r2, .L608+24
 9074 1590 1A60     		str	r2, [r3]
3283:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 9075              		.loc 1 3283 0
 9076 1592 3BE6     		b	.L372
 9077              	.L583:
3375:Src/usb_pd_protocol.c **** 			set_state(port, pd[port].timeout_state);
 9078              		.loc 1 3375 0
 9079 1594 8B42     		cmp	r3, r1
 9080 1596 02D1     		bne	.L534
 9081 1598 8242     		cmp	r2, r0
 9082 159a 00D9     		bls	.LCB9233
 9083 159c 4FE6     		b	.L507	@long jump
 9084              	.LCB9233:
 9085              	.L534:
3376:Src/usb_pd_protocol.c **** 			/* On a state timeout, run next state soon */
 9086              		.loc 1 3376 0
 9087 159e F201     		lsls	r2, r6, #7
 9088 15a0 4E4B     		ldr	r3, .L608
 9089 15a2 9B18     		adds	r3, r3, r2
 9090 15a4 DA79     		ldrb	r2, [r3, #7]
 9091              	.LVL816:
 9092              	.LBB1054:
 9093              	.LBB1055:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 9094              		.loc 1 346 0
 9095 15a6 1C79     		ldrb	r4, [r3, #4]
 9096              	.LVL817:
 9097              	.LBB1056:
 9098              	.LBB1057:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9099              		.loc 1 283 0
 9100 15a8 0020     		movs	r0, #0
 9101 15aa 0021     		movs	r1, #0
 9102 15ac 1861     		str	r0, [r3, #16]
 9103 15ae 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 9104              		.loc 1 284 0
ARM GAS  /tmp/ccWvVg6G.s 			page 238


 9105 15b0 0021     		movs	r1, #0
 9106 15b2 D971     		strb	r1, [r3, #7]
 9107              	.LVL818:
 9108              	.LBE1057:
 9109              	.LBE1056:
 352:Src/usb_pd_protocol.c **** 
 9110              		.loc 1 352 0
 9111 15b4 1A71     		strb	r2, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 9112              		.loc 1 354 0
 9113 15b6 A242     		cmp	r2, r4
 9114 15b8 19D0     		beq	.L509
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 9115              		.loc 1 365 0
 9116 15ba 022C     		cmp	r4, #2
 9117 15bc 20D0     		beq	.L591
 9118              	.L510:
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 9119              		.loc 1 366 0
 9120 15be 0E2C     		cmp	r4, #14
 9121 15c0 21D0     		beq	.L592
 9122              	.L511:
 371:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 9123              		.loc 1 371 0
 9124 15c2 0E2A     		cmp	r2, #14
 9125 15c4 01D0     		beq	.L512
 9126 15c6 022A     		cmp	r2, #2
 9127 15c8 11D1     		bne	.L509
 9128              	.L512:
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 9129              		.loc 1 374 0
 9130 15ca 0022     		movs	r2, #0
 9131              	.LVL819:
 9132 15cc 0021     		movs	r1, #0
 9133 15ce 3000     		movs	r0, r6
 9134 15d0 FFF7FEFF 		bl	pd_set_input_current_limit
 9135              	.LVL820:
 391:Src/usb_pd_protocol.c **** 			/*
 9136              		.loc 1 391 0
 9137 15d4 F301     		lsls	r3, r6, #7
 9138 15d6 414A     		ldr	r2, .L608
 9139 15d8 9B5C     		ldrb	r3, [r3, r2]
 9140 15da 012B     		cmp	r3, #1
 9141 15dc 16D0     		beq	.L593
 9142              	.L513:
 9143              	.LVL821:
 9144              	.LBB1058:
 9145              	.LBB1059:
  92:Inc/tcpm.h    **** }
 9146              		.loc 2 92 0
 9147 15de 3201     		lsls	r2, r6, #4
 9148 15e0 464B     		ldr	r3, .L608+32
 9149 15e2 9B18     		adds	r3, r3, r2
 9150 15e4 9B68     		ldr	r3, [r3, #8]
 9151 15e6 5B6A     		ldr	r3, [r3, #36]
 9152 15e8 0021     		movs	r1, #0
 9153 15ea 3000     		movs	r0, r6
ARM GAS  /tmp/ccWvVg6G.s 			page 239


 9154 15ec 9847     		blx	r3
 9155              	.LVL822:
 9156              	.L509:
 9157              	.LBE1059:
 9158              	.LBE1058:
 9159              	.LBE1055:
 9160              	.LBE1054:
3378:Src/usb_pd_protocol.c **** 		} else if (pd[port].timeout - now.val < timeout) {
 9161              		.loc 1 3378 0
 9162 15ee 3D4B     		ldr	r3, .L608+8
 9163 15f0 1B68     		ldr	r3, [r3]
 9164 15f2 404A     		ldr	r2, .L608+24
 9165 15f4 9342     		cmp	r3, r2
 9166 15f6 00DD     		ble	.L514
 9167 15f8 1300     		movs	r3, r2
 9168              	.L514:
 9169 15fa 3A4A     		ldr	r2, .L608+8
 9170 15fc 1360     		str	r3, [r2]
 9171 15fe 2EE6     		b	.L505
 9172              	.LVL823:
 9173              	.L591:
 9174              	.LBB1061:
 9175              	.LBB1060:
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 9176              		.loc 1 365 0
 9177 1600 0E2A     		cmp	r2, #14
 9178 1602 DCD1     		bne	.L510
 9179 1604 F3E7     		b	.L509
 9180              	.L592:
 367:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 9181              		.loc 1 367 0
 9182 1606 022A     		cmp	r2, #2
 9183 1608 DBD1     		bne	.L511
 9184 160a F0E7     		b	.L509
 9185              	.LVL824:
 9186              	.L593:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 9187              		.loc 1 396 0
 9188 160c 3000     		movs	r0, r6
 9189 160e FFF7FEFF 		bl	pd_power_supply_reset
 9190              	.LVL825:
 9191 1612 E4E7     		b	.L513
 9192              	.LVL826:
 9193              	.L584:
 9194              	.LBE1060:
 9195              	.LBE1061:
 9196              	.LBB1062:
 9197              	.LBB1063:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 9198              		.loc 1 346 0
 9199 1614 F201     		lsls	r2, r6, #7
 9200 1616 314B     		ldr	r3, .L608
 9201 1618 9B18     		adds	r3, r3, r2
 9202 161a 1A79     		ldrb	r2, [r3, #4]
 9203              	.LVL827:
 9204              	.LBB1064:
 9205              	.LBB1065:
ARM GAS  /tmp/ccWvVg6G.s 			page 240


 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9206              		.loc 1 283 0
 9207 161c 0020     		movs	r0, #0
 9208 161e 0021     		movs	r1, #0
 9209 1620 1861     		str	r0, [r3, #16]
 9210 1622 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 9211              		.loc 1 284 0
 9212 1624 0021     		movs	r1, #0
 9213 1626 D971     		strb	r1, [r3, #7]
 9214              	.LVL828:
 9215              	.LBE1065:
 9216              	.LBE1064:
 352:Src/usb_pd_protocol.c **** 
 9217              		.loc 1 352 0
 9218 1628 0E31     		adds	r1, r1, #14
 9219 162a 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 9220              		.loc 1 354 0
 9221 162c 0E2A     		cmp	r2, #14
 9222 162e 13D0     		beq	.L519
 365:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 9223              		.loc 1 365 0
 9224 1630 022A     		cmp	r2, #2
 9225 1632 11D0     		beq	.L519
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 9226              		.loc 1 374 0
 9227 1634 0022     		movs	r2, #0
 9228              	.LVL829:
 9229 1636 0021     		movs	r1, #0
 9230 1638 3000     		movs	r0, r6
 9231 163a FFF7FEFF 		bl	pd_set_input_current_limit
 9232              	.LVL830:
 391:Src/usb_pd_protocol.c **** 			/*
 9233              		.loc 1 391 0
 9234 163e F301     		lsls	r3, r6, #7
 9235 1640 264A     		ldr	r2, .L608
 9236 1642 9B5C     		ldrb	r3, [r3, r2]
 9237 1644 012B     		cmp	r3, #1
 9238 1646 0BD0     		beq	.L594
 9239              	.L520:
 9240              	.LVL831:
 9241              	.LBB1066:
 9242              	.LBB1067:
  92:Inc/tcpm.h    **** }
 9243              		.loc 2 92 0
 9244 1648 3201     		lsls	r2, r6, #4
 9245 164a 2C4B     		ldr	r3, .L608+32
 9246 164c 9B18     		adds	r3, r3, r2
 9247 164e 9B68     		ldr	r3, [r3, #8]
 9248 1650 5B6A     		ldr	r3, [r3, #36]
 9249 1652 0021     		movs	r1, #0
 9250 1654 3000     		movs	r0, r6
 9251 1656 9847     		blx	r3
 9252              	.LVL832:
 9253              	.L519:
 9254              	.LBE1067:
ARM GAS  /tmp/ccWvVg6G.s 			page 241


 9255              	.LBE1066:
 9256              	.LBE1063:
 9257              	.LBE1062:
3399:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 9258              		.loc 1 3399 0
 9259 1658 224B     		ldr	r3, .L608+8
 9260 165a 264A     		ldr	r2, .L608+24
 9261 165c 1A60     		str	r2, [r3]
 9262 165e 25E6     		b	.L517
 9263              	.LVL833:
 9264              	.L594:
 9265              	.LBB1069:
 9266              	.LBB1068:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 9267              		.loc 1 396 0
 9268 1660 3000     		movs	r0, r6
 9269 1662 FFF7FEFF 		bl	pd_power_supply_reset
 9270              	.LVL834:
 9271 1666 EFE7     		b	.L520
 9272              	.LVL835:
 9273              	.L585:
 9274              	.LBE1068:
 9275              	.LBE1069:
 9276              	.LBB1070:
 9277              	.LBB1071:
 339:Src/usb_pd_protocol.c **** #endif
 9278              		.loc 1 339 0
 9279 1668 3000     		movs	r0, r6
 9280 166a FFF7FEFF 		bl	pd_snk_is_vbus_provided
 9281              	.LVL836:
 9282              	.LBE1071:
 9283              	.LBE1070:
3427:Src/usb_pd_protocol.c **** 		!pd_is_vbus_present(port) &&
 9284              		.loc 1 3427 0
 9285 166e 0028     		cmp	r0, #0
 9286 1670 00D0     		beq	.LCB9466
 9287 1672 21E6     		b	.L368	@long jump
 9288              	.LCB9466:
3429:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_HARD_RESET_EXECUTE) {
 9289              		.loc 1 3429 0
 9290 1674 F201     		lsls	r2, r6, #7
 9291 1676 194B     		ldr	r3, .L608
 9292 1678 9B18     		adds	r3, r3, r2
 9293 167a 1B79     		ldrb	r3, [r3, #4]
3428:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_HARD_RESET_RECOVER &&
 9294              		.loc 1 3428 0
 9295 167c 042B     		cmp	r3, #4
 9296 167e 00D1     		bne	.LCB9472
 9297 1680 1AE6     		b	.L368	@long jump
 9298              	.LCB9472:
3429:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_HARD_RESET_EXECUTE) {
 9299              		.loc 1 3429 0
 9300 1682 202B     		cmp	r3, #32
 9301 1684 00D1     		bne	.LCB9474
 9302 1686 17E6     		b	.L368	@long jump
 9303              	.LCB9474:
 9304              	.LVL837:
ARM GAS  /tmp/ccWvVg6G.s 			page 242


 9305              	.LBB1072:
 9306              	.LBB1073:
 346:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 9307              		.loc 1 346 0
 9308 1688 144B     		ldr	r3, .L608
 9309 168a 9B18     		adds	r3, r3, r2
 9310 168c 1A79     		ldrb	r2, [r3, #4]
 9311              	.LVL838:
 9312              	.LBB1074:
 9313              	.LBB1075:
 283:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9314              		.loc 1 283 0
 9315 168e 0020     		movs	r0, #0
 9316 1690 0021     		movs	r1, #0
 9317 1692 1861     		str	r0, [r3, #16]
 9318 1694 5961     		str	r1, [r3, #20]
 284:Src/usb_pd_protocol.c **** }
 9319              		.loc 1 284 0
 9320 1696 0021     		movs	r1, #0
 9321 1698 D971     		strb	r1, [r3, #7]
 9322              	.LVL839:
 9323              	.LBE1075:
 9324              	.LBE1074:
 352:Src/usb_pd_protocol.c **** 
 9325              		.loc 1 352 0
 9326 169a 0231     		adds	r1, r1, #2
 9327 169c 1971     		strb	r1, [r3, #4]
 354:Src/usb_pd_protocol.c **** 		return;
 9328              		.loc 1 354 0
 9329 169e 022A     		cmp	r2, #2
 9330 16a0 13D0     		beq	.L521
 366:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 9331              		.loc 1 366 0
 9332 16a2 0E2A     		cmp	r2, #14
 9333 16a4 11D0     		beq	.L521
 374:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 9334              		.loc 1 374 0
 9335 16a6 0022     		movs	r2, #0
 9336              	.LVL840:
 9337 16a8 0021     		movs	r1, #0
 9338 16aa 3000     		movs	r0, r6
 9339 16ac FFF7FEFF 		bl	pd_set_input_current_limit
 9340              	.LVL841:
 391:Src/usb_pd_protocol.c **** 			/*
 9341              		.loc 1 391 0
 9342 16b0 F301     		lsls	r3, r6, #7
 9343 16b2 0A4A     		ldr	r2, .L608
 9344 16b4 9B5C     		ldrb	r3, [r3, r2]
 9345 16b6 012B     		cmp	r3, #1
 9346 16b8 0BD0     		beq	.L595
 9347              	.L522:
 9348              	.LVL842:
 9349              	.LBB1076:
 9350              	.LBB1077:
  92:Inc/tcpm.h    **** }
 9351              		.loc 2 92 0
 9352 16ba 3201     		lsls	r2, r6, #4
ARM GAS  /tmp/ccWvVg6G.s 			page 243


 9353 16bc 0F4B     		ldr	r3, .L608+32
 9354 16be 9B18     		adds	r3, r3, r2
 9355 16c0 9B68     		ldr	r3, [r3, #8]
 9356 16c2 5B6A     		ldr	r3, [r3, #36]
 9357 16c4 0021     		movs	r1, #0
 9358 16c6 3000     		movs	r0, r6
 9359 16c8 9847     		blx	r3
 9360              	.LVL843:
 9361              	.L521:
 9362              	.LBE1077:
 9363              	.LBE1076:
 9364              	.LBE1073:
 9365              	.LBE1072:
3434:Src/usb_pd_protocol.c **** 	}
 9366              		.loc 1 3434 0
 9367 16ca 064B     		ldr	r3, .L608+8
 9368 16cc 064A     		ldr	r2, .L608+12
 9369 16ce 1A60     		str	r2, [r3]
 9370 16d0 F2E5     		b	.L368
 9371              	.LVL844:
 9372              	.L595:
 9373              	.LBB1079:
 9374              	.LBB1078:
 396:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 9375              		.loc 1 396 0
 9376 16d2 3000     		movs	r0, r6
 9377 16d4 FFF7FEFF 		bl	pd_power_supply_reset
 9378              	.LVL845:
 9379 16d8 EFE7     		b	.L522
 9380              	.L609:
 9381 16da C046     		.align	2
 9382              	.L608:
 9383 16dc 00000000 		.word	pd
 9384 16e0 A0860100 		.word	100000
 9385 16e4 00000000 		.word	.LANCHOR5
 9386 16e8 88130000 		.word	5000
 9387 16ec 00000000 		.word	.LANCHOR10
 9388 16f0 00000000 		.word	.LANCHOR16
 9389 16f4 10270000 		.word	10000
 9390 16f8 A8610000 		.word	25000
 9391 16fc 00000000 		.word	tcpc_config
 9392              	.LBE1078:
 9393              	.LBE1079:
 9394              		.cfi_endproc
 9395              	.LFE67:
 9397              		.global	drp_state
 9398              		.section	.bss.caps_count,"aw",%nobits
 9399              		.align	2
 9400              		.set	.LANCHOR11,. + 0
 9403              	caps_count:
 9404 0000 00000000 		.space	4
 9405              		.section	.bss.cc1,"aw",%nobits
 9406              		.align	2
 9407              		.set	.LANCHOR7,. + 0
 9410              	cc1:
 9411 0000 00000000 		.space	4
 9412              		.section	.bss.cc2,"aw",%nobits
ARM GAS  /tmp/ccWvVg6G.s 			page 244


 9413              		.align	2
 9414              		.set	.LANCHOR6,. + 0
 9417              	cc2:
 9418 0000 00000000 		.space	4
 9419              		.section	.bss.hard_reset_count,"aw",%nobits
 9420              		.align	2
 9421              		.set	.LANCHOR10,. + 0
 9424              	hard_reset_count:
 9425 0000 00000000 		.space	4
 9426              		.section	.bss.hard_reset_sent,"aw",%nobits
 9427              		.align	2
 9428              		.set	.LANCHOR16,. + 0
 9431              	hard_reset_sent:
 9432 0000 00000000 		.space	4
 9433              		.section	.bss.head,"aw",%nobits
 9434              		.align	2
 9435              		.set	.LANCHOR3,. + 0
 9438              	head:
 9439 0000 00000000 		.space	4
 9440              		.section	.bss.incoming_packet,"aw",%nobits
 9441              		.align	2
 9442              		.set	.LANCHOR2,. + 0
 9445              	incoming_packet:
 9446 0000 00000000 		.space	4
 9447              		.section	.bss.new_cc_state,"aw",%nobits
 9448              		.set	.LANCHOR9,. + 0
 9451              	new_cc_state:
 9452 0000 00       		.space	1
 9453              		.section	.bss.now,"aw",%nobits
 9454              		.align	3
 9455              		.set	.LANCHOR17,. + 0
 9458              	now:
 9459 0000 00000000 		.space	8
 9459      00000000 
 9460              		.section	.bss.payload,"aw",%nobits
 9461              		.align	2
 9462              		.set	.LANCHOR4,. + 0
 9465              	payload:
 9466 0000 00000000 		.space	28
 9466      00000000 
 9466      00000000 
 9466      00000000 
 9466      00000000 
 9467              		.section	.bss.pd,"aw",%nobits
 9468              		.align	3
 9471              	pd:
 9472 0000 00000000 		.space	128
 9472      00000000 
 9472      00000000 
 9472      00000000 
 9472      00000000 
 9473              		.section	.bss.snk_cap_count,"aw",%nobits
 9474              		.align	2
 9475              		.set	.LANCHOR12,. + 0
 9478              	snk_cap_count:
 9479 0000 00000000 		.space	4
 9480              		.section	.bss.snk_hard_reset_vbus_off,"aw",%nobits
ARM GAS  /tmp/ccWvVg6G.s 			page 245


 9481              		.align	2
 9482              		.set	.LANCHOR14,. + 0
 9485              	snk_hard_reset_vbus_off:
 9486 0000 00000000 		.space	4
 9487              		.section	.bss.this_state,"aw",%nobits
 9488              		.set	.LANCHOR1,. + 0
 9491              	this_state:
 9492 0000 00       		.space	1
 9493              		.section	.bss.typec_curr,"aw",%nobits
 9494              		.align	2
 9495              		.set	.LANCHOR13,. + 0
 9498              	typec_curr:
 9499 0000 00000000 		.space	4
 9500              		.section	.bss.typec_curr_change,"aw",%nobits
 9501              		.align	2
 9502              		.set	.LANCHOR15,. + 0
 9505              	typec_curr_change:
 9506 0000 00000000 		.space	4
 9507              		.section	.data.drp_state,"aw",%progbits
 9508              		.set	.LANCHOR0,. + 0
 9511              	drp_state:
 9512 0000 02       		.byte	2
 9513              		.section	.data.next_role_swap,"aw",%progbits
 9514              		.align	3
 9515              		.set	.LANCHOR8,. + 0
 9518              	next_role_swap:
 9519 0000 409C0000 		.word	40000
 9520 0004 00000000 		.word	0
 9521              		.section	.data.timeout,"aw",%progbits
 9522              		.align	2
 9523              		.set	.LANCHOR5,. + 0
 9526              	timeout:
 9527 0000 10270000 		.word	10000
 9528              		.weak	board_tcpc_post_init
 9529              		.weak	board_set_tcpc_power_mode
 9530              		.text
 9531              	.Letext0:
 9532              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 9533              		.file 4 "/usr/arm-none-eabi/include/sys/_stdint.h"
 9534              		.file 5 "Inc/usb_pd_tcpm.h"
 9535              		.file 6 "Inc/FUSB302.h"
 9536              		.file 7 "Inc/tcpm_driver.h"
 9537              		.file 8 "Inc/usb_pd_driver.h"
 9538              		.file 9 "Inc/usb_pd.h"
 9539              		.file 10 "<built-in>"
ARM GAS  /tmp/ccWvVg6G.s 			page 246


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_pd_protocol.c
     /tmp/ccWvVg6G.s:16     .text.inc_id:0000000000000000 $t
     /tmp/ccWvVg6G.s:22     .text.inc_id:0000000000000000 inc_id
     /tmp/ccWvVg6G.s:47     .text.inc_id:0000000000000014 $d
     /tmp/ccWvVg6G.s:9471   .bss.pd:0000000000000000 pd
     /tmp/ccWvVg6G.s:52     .text.pd_update_roles:0000000000000000 $t
     /tmp/ccWvVg6G.s:58     .text.pd_update_roles:0000000000000000 pd_update_roles
     /tmp/ccWvVg6G.s:96     .text.pd_update_roles:000000000000001c $d
     /tmp/ccWvVg6G.s:102    .text.pd_update_pdo_flags:0000000000000000 $t
     /tmp/ccWvVg6G.s:108    .text.pd_update_pdo_flags:0000000000000000 pd_update_pdo_flags
     /tmp/ccWvVg6G.s:223    .text.pd_update_pdo_flags:0000000000000094 $d
     /tmp/ccWvVg6G.s:230    .text.vdm_get_ready_timeout:0000000000000000 $t
     /tmp/ccWvVg6G.s:236    .text.vdm_get_ready_timeout:0000000000000000 vdm_get_ready_timeout
     /tmp/ccWvVg6G.s:300    .text.vdm_get_ready_timeout:0000000000000038 $d
     /tmp/ccWvVg6G.s:309    .text.pd_is_power_swapping:0000000000000000 $t
     /tmp/ccWvVg6G.s:315    .text.pd_is_power_swapping:0000000000000000 pd_is_power_swapping
     /tmp/ccWvVg6G.s:367    .text.pd_is_power_swapping:0000000000000034 $d
     /tmp/ccWvVg6G.s:372    .text.get_typec_current_limit:0000000000000000 $t
     /tmp/ccWvVg6G.s:378    .text.get_typec_current_limit:0000000000000000 get_typec_current_limit
     /tmp/ccWvVg6G.s:453    .text.get_typec_current_limit:0000000000000034 $d
     /tmp/ccWvVg6G.s:459    .text.set_state:0000000000000000 $t
     /tmp/ccWvVg6G.s:465    .text.set_state:0000000000000000 set_state
     /tmp/ccWvVg6G.s:576    .text.set_state:0000000000000068 $d
     /tmp/ccWvVg6G.s:582    .text.queue_vdm:0000000000000000 $t
     /tmp/ccWvVg6G.s:588    .text.queue_vdm:0000000000000000 queue_vdm
     /tmp/ccWvVg6G.s:638    .text.queue_vdm:000000000000002c $d
     /tmp/ccWvVg6G.s:643    .text.handle_vdm_request:0000000000000000 $t
     /tmp/ccWvVg6G.s:649    .text.handle_vdm_request:0000000000000000 handle_vdm_request
     /tmp/ccWvVg6G.s:769    .text.handle_vdm_request:0000000000000094 $d
     /tmp/ccWvVg6G.s:775    .text.pd_set_data_role:0000000000000000 $t
     /tmp/ccWvVg6G.s:781    .text.pd_set_data_role:0000000000000000 pd_set_data_role
     /tmp/ccWvVg6G.s:813    .text.pd_set_data_role:0000000000000018 $d
     /tmp/ccWvVg6G.s:818    .text.pd_dr_swap:0000000000000000 $t
     /tmp/ccWvVg6G.s:824    .text.pd_dr_swap:0000000000000000 pd_dr_swap
     /tmp/ccWvVg6G.s:856    .text.pd_dr_swap:000000000000001c $d
     /tmp/ccWvVg6G.s:861    .text.pd_restart_tcpc:0000000000000000 $t
     /tmp/ccWvVg6G.s:867    .text.pd_restart_tcpc:0000000000000000 pd_restart_tcpc
     /tmp/ccWvVg6G.s:922    .text.pd_restart_tcpc:0000000000000030 $d
     /tmp/ccWvVg6G.s:929    .text.execute_soft_reset:0000000000000000 $t
     /tmp/ccWvVg6G.s:935    .text.execute_soft_reset:0000000000000000 execute_soft_reset
     /tmp/ccWvVg6G.s:1068   .text.execute_soft_reset:0000000000000080 $d
     /tmp/ccWvVg6G.s:1076   .text.pd_comm_is_enabled:0000000000000000 $t
     /tmp/ccWvVg6G.s:1083   .text.pd_comm_is_enabled:0000000000000000 pd_comm_is_enabled
     /tmp/ccWvVg6G.s:1100   .text.pd_transmit:0000000000000000 $t
     /tmp/ccWvVg6G.s:1106   .text.pd_transmit:0000000000000000 pd_transmit
     /tmp/ccWvVg6G.s:1181   .text.pd_transmit:0000000000000048 $d
     /tmp/ccWvVg6G.s:1187   .text.send_sink_cap:0000000000000000 $t
     /tmp/ccWvVg6G.s:1193   .text.send_sink_cap:0000000000000000 send_sink_cap
     /tmp/ccWvVg6G.s:1241   .text.send_sink_cap:0000000000000038 $d
     /tmp/ccWvVg6G.s:1248   .text.send_source_cap:0000000000000000 $t
     /tmp/ccWvVg6G.s:1254   .text.send_source_cap:0000000000000000 send_source_cap
     /tmp/ccWvVg6G.s:1332   .text.send_source_cap:000000000000005c $d
     /tmp/ccWvVg6G.s:1339   .text.send_request:0000000000000000 $t
     /tmp/ccWvVg6G.s:1345   .text.send_request:0000000000000000 send_request
     /tmp/ccWvVg6G.s:1397   .text.send_request:0000000000000038 $d
     /tmp/ccWvVg6G.s:1402   .text.pd_send_request_msg:0000000000000000 $t
ARM GAS  /tmp/ccWvVg6G.s 			page 247


     /tmp/ccWvVg6G.s:1408   .text.pd_send_request_msg:0000000000000000 pd_send_request_msg
     /tmp/ccWvVg6G.s:1530   .text.pd_send_request_msg:0000000000000078 $d
     /tmp/ccWvVg6G.s:1535   .text.send_control:0000000000000000 $t
     /tmp/ccWvVg6G.s:1541   .text.send_control:0000000000000000 send_control
     /tmp/ccWvVg6G.s:1586   .text.send_control:0000000000000030 $d
     /tmp/ccWvVg6G.s:1591   .text.handle_ctrl_request:0000000000000000 $t
     /tmp/ccWvVg6G.s:1597   .text.handle_ctrl_request:0000000000000000 handle_ctrl_request
     /tmp/ccWvVg6G.s:1629   .rodata.handle_ctrl_request:0000000000000000 $d
     /tmp/ccWvVg6G.s:2386   .text.handle_ctrl_request:0000000000000320 $d
     /tmp/ccWvVg6G.s:2393   .text.handle_ctrl_request:0000000000000330 $t
     /tmp/ccWvVg6G.s:2582   .text.handle_ctrl_request:0000000000000414 $d
     /tmp/ccWvVg6G.s:2590   .text.handle_data_request:0000000000000000 $t
     /tmp/ccWvVg6G.s:2596   .text.handle_data_request:0000000000000000 handle_data_request
     /tmp/ccWvVg6G.s:2627   .rodata.handle_data_request:0000000000000000 $d
     /tmp/ccWvVg6G.s:3015   .text.handle_data_request:00000000000001c8 $d
     /tmp/ccWvVg6G.s:3022   .text.pd_is_connected:0000000000000000 $t
     /tmp/ccWvVg6G.s:3029   .text.pd_is_connected:0000000000000000 pd_is_connected
     /tmp/ccWvVg6G.s:3080   .text.pd_is_connected:0000000000000038 $d
     /tmp/ccWvVg6G.s:3085   .text.pd_vdm_send_state_machine:0000000000000000 $t
     /tmp/ccWvVg6G.s:3091   .text.pd_vdm_send_state_machine:0000000000000000 pd_vdm_send_state_machine
     /tmp/ccWvVg6G.s:3329   .text.pd_vdm_send_state_machine:0000000000000140 $d
     /tmp/ccWvVg6G.s:3334   .text.handle_request:0000000000000000 $t
     /tmp/ccWvVg6G.s:3340   .text.handle_request:0000000000000000 handle_request
     /tmp/ccWvVg6G.s:3426   .text.handle_request:000000000000004c $d
     /tmp/ccWvVg6G.s:3431   .text.pd_ts_dts_plugged:0000000000000000 $t
     /tmp/ccWvVg6G.s:3438   .text.pd_ts_dts_plugged:0000000000000000 pd_ts_dts_plugged
     /tmp/ccWvVg6G.s:3461   .text.pd_ts_dts_plugged:0000000000000010 $d
     /tmp/ccWvVg6G.s:3466   .text.pd_vbus_low:0000000000000000 $t
     /tmp/ccWvVg6G.s:3473   .text.pd_vbus_low:0000000000000000 pd_vbus_low
     /tmp/ccWvVg6G.s:3496   .text.pd_vbus_low:0000000000000010 $d
     /tmp/ccWvVg6G.s:3501   .text.pd_transmit_complete:0000000000000000 $t
     /tmp/ccWvVg6G.s:3508   .text.pd_transmit_complete:0000000000000000 pd_transmit_complete
     /tmp/ccWvVg6G.s:3553   .text.pd_transmit_complete:0000000000000024 $d
     /tmp/ccWvVg6G.s:3558   .text.pd_execute_hard_reset:0000000000000000 $t
     /tmp/ccWvVg6G.s:3565   .text.pd_execute_hard_reset:0000000000000000 pd_execute_hard_reset
     /tmp/ccWvVg6G.s:3703   .text.pd_execute_hard_reset:0000000000000094 $d
     /tmp/ccWvVg6G.s:3712   .text.pd_soft_reset:0000000000000000 $t
     /tmp/ccWvVg6G.s:3719   .text.pd_soft_reset:0000000000000000 pd_soft_reset
     /tmp/ccWvVg6G.s:3783   .text.pd_soft_reset:0000000000000030 $d
     /tmp/ccWvVg6G.s:3790   .text.pd_request_power_swap:0000000000000000 $t
     /tmp/ccWvVg6G.s:3797   .text.pd_request_power_swap:0000000000000000 pd_request_power_swap
     /tmp/ccWvVg6G.s:3878   .text.pd_request_power_swap:0000000000000040 $d
     /tmp/ccWvVg6G.s:3883   .text.pd_request_data_swap:0000000000000000 $t
     /tmp/ccWvVg6G.s:3890   .text.pd_request_data_swap:0000000000000000 pd_request_data_swap
     /tmp/ccWvVg6G.s:3965   .text.pd_request_data_swap:0000000000000048 $d
     /tmp/ccWvVg6G.s:3970   .text.pd_send_vdm:0000000000000000 $t
     /tmp/ccWvVg6G.s:3977   .text.pd_send_vdm:0000000000000000 pd_send_vdm
     /tmp/ccWvVg6G.s:4048   .text.pd_send_vdm:000000000000004c $d
     /tmp/ccWvVg6G.s:4053   .text.pd_dev_store_rw_hash:0000000000000000 $t
     /tmp/ccWvVg6G.s:4060   .text.pd_dev_store_rw_hash:0000000000000000 pd_dev_store_rw_hash
     /tmp/ccWvVg6G.s:4077   .text.pd_get_dual_role:0000000000000000 $t
     /tmp/ccWvVg6G.s:4084   .text.pd_get_dual_role:0000000000000000 pd_get_dual_role
     /tmp/ccWvVg6G.s:4100   .text.pd_get_dual_role:0000000000000008 $d
     /tmp/ccWvVg6G.s:4105   .text.pd_set_dual_role:0000000000000000 $t
     /tmp/ccWvVg6G.s:4112   .text.pd_set_dual_role:0000000000000000 pd_set_dual_role
     /tmp/ccWvVg6G.s:4142   .text.pd_set_dual_role:0000000000000010 $d
     /tmp/ccWvVg6G.s:4147   .text.pd_update_dual_role_config:0000000000000000 $t
ARM GAS  /tmp/ccWvVg6G.s 			page 248


     /tmp/ccWvVg6G.s:4154   .text.pd_update_dual_role_config:0000000000000000 pd_update_dual_role_config
     /tmp/ccWvVg6G.s:4416   .text.pd_update_dual_role_config:000000000000010c $d
     /tmp/ccWvVg6G.s:4425   .text.pd_get_role:0000000000000000 $t
     /tmp/ccWvVg6G.s:4432   .text.pd_get_role:0000000000000000 pd_get_role
     /tmp/ccWvVg6G.s:4451   .text.pd_get_role:0000000000000008 $d
     /tmp/ccWvVg6G.s:4456   .text.pd_get_polarity:0000000000000000 $t
     /tmp/ccWvVg6G.s:4463   .text.pd_get_polarity:0000000000000000 pd_get_polarity
     /tmp/ccWvVg6G.s:4483   .text.pd_get_polarity:000000000000000c $d
     /tmp/ccWvVg6G.s:4488   .text.pd_get_partner_data_swap_capable:0000000000000000 $t
     /tmp/ccWvVg6G.s:4495   .text.pd_get_partner_data_swap_capable:0000000000000000 pd_get_partner_data_swap_capable
     /tmp/ccWvVg6G.s:4517   .text.pd_get_partner_data_swap_capable:0000000000000010 $d
     /tmp/ccWvVg6G.s:4522   .text.pd_ping_enable:0000000000000000 $t
     /tmp/ccWvVg6G.s:4529   .text.pd_ping_enable:0000000000000000 pd_ping_enable
     /tmp/ccWvVg6G.s:4568   .text.pd_ping_enable:0000000000000024 $d
     /tmp/ccWvVg6G.s:4573   .text.pd_set_new_power_request:0000000000000000 $t
     /tmp/ccWvVg6G.s:4580   .text.pd_set_new_power_request:0000000000000000 pd_set_new_power_request
     /tmp/ccWvVg6G.s:4601   .text.pd_set_new_power_request:000000000000000c $d
     /tmp/ccWvVg6G.s:4606   .text.pd_init:0000000000000000 $t
     /tmp/ccWvVg6G.s:4613   .text.pd_init:0000000000000000 pd_init
     /tmp/ccWvVg6G.s:4868   .text.pd_init:0000000000000104 $d
     /tmp/ccWvVg6G.s:4878   .text.pd_run_state_machine:0000000000000000 $t
     /tmp/ccWvVg6G.s:4885   .text.pd_run_state_machine:0000000000000000 pd_run_state_machine
     /tmp/ccWvVg6G.s:4967   .rodata.pd_run_state_machine:0000000000000000 $d
     /tmp/ccWvVg6G.s:5499   .text.pd_run_state_machine:00000000000002d0 $d
     /tmp/ccWvVg6G.s:5524   .text.pd_run_state_machine:0000000000000320 $t
     /tmp/ccWvVg6G.s:6204   .text.pd_run_state_machine:0000000000000694 $d
     /tmp/ccWvVg6G.s:6223   .text.pd_run_state_machine:00000000000006cc $t
     /tmp/ccWvVg6G.s:6852   .text.pd_run_state_machine:0000000000000a24 $d
     /tmp/ccWvVg6G.s:6870   .text.pd_run_state_machine:0000000000000a58 $t
     /tmp/ccWvVg6G.s:7572   .text.pd_run_state_machine:0000000000000db0 $d
     /tmp/ccWvVg6G.s:7591   .text.pd_run_state_machine:0000000000000df4 $t
     /tmp/ccWvVg6G.s:8156   .text.pd_run_state_machine:00000000000010e0 $d
     /tmp/ccWvVg6G.s:8180   .text.pd_run_state_machine:0000000000001138 $t
     /tmp/ccWvVg6G.s:8822   .text.pd_run_state_machine:0000000000001434 $d
     /tmp/ccWvVg6G.s:8836   .text.pd_run_state_machine:0000000000001464 $t
     /tmp/ccWvVg6G.s:9383   .text.pd_run_state_machine:00000000000016dc $d
     /tmp/ccWvVg6G.s:9511   .data.drp_state:0000000000000000 drp_state
     /tmp/ccWvVg6G.s:9399   .bss.caps_count:0000000000000000 $d
     /tmp/ccWvVg6G.s:9403   .bss.caps_count:0000000000000000 caps_count
     /tmp/ccWvVg6G.s:9406   .bss.cc1:0000000000000000 $d
     /tmp/ccWvVg6G.s:9410   .bss.cc1:0000000000000000 cc1
     /tmp/ccWvVg6G.s:9413   .bss.cc2:0000000000000000 $d
     /tmp/ccWvVg6G.s:9417   .bss.cc2:0000000000000000 cc2
     /tmp/ccWvVg6G.s:9420   .bss.hard_reset_count:0000000000000000 $d
     /tmp/ccWvVg6G.s:9424   .bss.hard_reset_count:0000000000000000 hard_reset_count
     /tmp/ccWvVg6G.s:9427   .bss.hard_reset_sent:0000000000000000 $d
     /tmp/ccWvVg6G.s:9431   .bss.hard_reset_sent:0000000000000000 hard_reset_sent
     /tmp/ccWvVg6G.s:9434   .bss.head:0000000000000000 $d
     /tmp/ccWvVg6G.s:9438   .bss.head:0000000000000000 head
     /tmp/ccWvVg6G.s:9441   .bss.incoming_packet:0000000000000000 $d
     /tmp/ccWvVg6G.s:9445   .bss.incoming_packet:0000000000000000 incoming_packet
     /tmp/ccWvVg6G.s:9451   .bss.new_cc_state:0000000000000000 new_cc_state
     /tmp/ccWvVg6G.s:9452   .bss.new_cc_state:0000000000000000 $d
     /tmp/ccWvVg6G.s:9454   .bss.now:0000000000000000 $d
     /tmp/ccWvVg6G.s:9458   .bss.now:0000000000000000 now
     /tmp/ccWvVg6G.s:9461   .bss.payload:0000000000000000 $d
     /tmp/ccWvVg6G.s:9465   .bss.payload:0000000000000000 payload
ARM GAS  /tmp/ccWvVg6G.s 			page 249


     /tmp/ccWvVg6G.s:9468   .bss.pd:0000000000000000 $d
     /tmp/ccWvVg6G.s:9474   .bss.snk_cap_count:0000000000000000 $d
     /tmp/ccWvVg6G.s:9478   .bss.snk_cap_count:0000000000000000 snk_cap_count
     /tmp/ccWvVg6G.s:9481   .bss.snk_hard_reset_vbus_off:0000000000000000 $d
     /tmp/ccWvVg6G.s:9485   .bss.snk_hard_reset_vbus_off:0000000000000000 snk_hard_reset_vbus_off
     /tmp/ccWvVg6G.s:9491   .bss.this_state:0000000000000000 this_state
     /tmp/ccWvVg6G.s:9492   .bss.this_state:0000000000000000 $d
     /tmp/ccWvVg6G.s:9494   .bss.typec_curr:0000000000000000 $d
     /tmp/ccWvVg6G.s:9498   .bss.typec_curr:0000000000000000 typec_curr
     /tmp/ccWvVg6G.s:9501   .bss.typec_curr_change:0000000000000000 $d
     /tmp/ccWvVg6G.s:9505   .bss.typec_curr_change:0000000000000000 typec_curr_change
     /tmp/ccWvVg6G.s:9514   .data.next_role_swap:0000000000000000 $d
     /tmp/ccWvVg6G.s:9518   .data.next_role_swap:0000000000000000 next_role_swap
     /tmp/ccWvVg6G.s:9522   .data.timeout:0000000000000000 $d
     /tmp/ccWvVg6G.s:9526   .data.timeout:0000000000000000 timeout

UNDEFINED SYMBOLS
tcpc_config
pd_set_input_current_limit
pd_power_supply_reset
memcpy
pd_svdm
get_time
pd_custom_vdm
pd_execute_data_swap
board_set_tcpc_power_mode
board_tcpc_post_init
pd_snk_pdo_cnt
pd_snk_pdo
pd_src_pdo_cnt
pd_src_pdo
pd_build_request
pd_check_power_swap
pd_check_data_swap
pd_process_source_cap
pd_process_source_cap_callback
pd_check_requested_voltage
pd_task_set_event
pd_board_checks
pd_set_power_supply_ready
pd_transition_voltage
pd_check_pr_role
pd_check_dr_role
pd_snk_is_vbus_provided
