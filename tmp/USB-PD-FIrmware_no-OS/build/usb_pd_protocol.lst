ARM GAS  /tmp/ccoQIC4J.s 			page 1


   1              		.cpu cortex-m0
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"usb_pd_protocol.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.inc_id,"ax",%progbits
  16              		.align	1
  17              		.arch armv6s-m
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	inc_id:
  24              	.LVL0:
  25              	.LFB25:
  26              		.file 1 "Src/usb_pd_protocol.c"
   1:Src/usb_pd_protocol.c **** /* Copyright (c) 2014 The Chromium OS Authors. All rights reserved.
   2:Src/usb_pd_protocol.c ****  * Use of this source code is governed by a BSD-style license that can be
   3:Src/usb_pd_protocol.c ****  * found in the LICENSE file.
   4:Src/usb_pd_protocol.c ****  */
   5:Src/usb_pd_protocol.c **** 
   6:Src/usb_pd_protocol.c **** #include <stddef.h>
   7:Src/usb_pd_protocol.c **** #include <string.h>
   8:Src/usb_pd_protocol.c **** #include "usb_pd.h"
   9:Src/usb_pd_protocol.c **** #include "usb_pd_tcpm.h"
  10:Src/usb_pd_protocol.c **** #include "tcpm.h"
  11:Src/usb_pd_protocol.c **** #include "usb_pd_driver.h"
  12:Src/usb_pd_protocol.c **** 
  13:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
  14:Src/usb_pd_protocol.c **** #define CPRINTF(format, args...) cprintf(CC_USBPD, format, ## args)
  15:Src/usb_pd_protocol.c **** #define CPRINTS(format, args...) cprints(CC_USBPD, format, ## args)
  16:Src/usb_pd_protocol.c **** 
  17:Src/usb_pd_protocol.c **** BUILD_ASSERT(CONFIG_USB_PD_PORT_COUNT <= EC_USB_PD_MAX_PORTS);
  18:Src/usb_pd_protocol.c **** 
  19:Src/usb_pd_protocol.c **** /*
  20:Src/usb_pd_protocol.c ****  * Debug log level - higher number == more log
  21:Src/usb_pd_protocol.c ****  *   Level 0: Log state transitions
  22:Src/usb_pd_protocol.c ****  *   Level 1: Level 0, plus state name
  23:Src/usb_pd_protocol.c ****  *   Level 2: Level 1, plus packet info
  24:Src/usb_pd_protocol.c ****  *   Level 3: Level 2, plus ping packet and packet dump on error
  25:Src/usb_pd_protocol.c ****  *
  26:Src/usb_pd_protocol.c ****  * Note that higher log level causes timing changes and thus may affect
  27:Src/usb_pd_protocol.c ****  * performance.
  28:Src/usb_pd_protocol.c ****  *
  29:Src/usb_pd_protocol.c ****  * Can be limited to constant debug_level by CONFIG_USB_PD_DEBUG_LEVEL
  30:Src/usb_pd_protocol.c ****  */
  31:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DEBUG_LEVEL
  32:Src/usb_pd_protocol.c **** static const int debug_level = CONFIG_USB_PD_DEBUG_LEVEL;
ARM GAS  /tmp/ccoQIC4J.s 			page 2


  33:Src/usb_pd_protocol.c **** #else
  34:Src/usb_pd_protocol.c **** static int debug_level;
  35:Src/usb_pd_protocol.c **** #endif
  36:Src/usb_pd_protocol.c **** 
  37:Src/usb_pd_protocol.c **** /*
  38:Src/usb_pd_protocol.c ****  * PD communication enabled flag. When false, PD state machine still
  39:Src/usb_pd_protocol.c ****  * detects source/sink connection and disconnection, and will still
  40:Src/usb_pd_protocol.c ****  * provide VBUS, but never sends any PD communication.
  41:Src/usb_pd_protocol.c ****  */
  42:Src/usb_pd_protocol.c **** static uint8_t pd_comm_enabled[CONFIG_USB_PD_PORT_COUNT];
  43:Src/usb_pd_protocol.c **** #else /* CONFIG_COMMON_RUNTIME */
  44:Src/usb_pd_protocol.c **** #define CPRINTF(format, args...)
  45:Src/usb_pd_protocol.c **** #define CPRINTS(format, args...)
  46:Src/usb_pd_protocol.c **** static const int debug_level;
  47:Src/usb_pd_protocol.c **** #endif
  48:Src/usb_pd_protocol.c **** 
  49:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
  50:Src/usb_pd_protocol.c **** #define DUAL_ROLE_IF_ELSE(port, sink_clause, src_clause) \
  51:Src/usb_pd_protocol.c **** 	(pd[port].power_role == PD_ROLE_SINK ? (sink_clause) : (src_clause))
  52:Src/usb_pd_protocol.c **** #else
  53:Src/usb_pd_protocol.c **** #define DUAL_ROLE_IF_ELSE(port, sink_clause, src_clause) (src_clause)
  54:Src/usb_pd_protocol.c **** #endif
  55:Src/usb_pd_protocol.c **** 
  56:Src/usb_pd_protocol.c **** #define READY_RETURN_STATE(port) DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_READY, \
  57:Src/usb_pd_protocol.c **** 							 PD_STATE_SRC_READY)
  58:Src/usb_pd_protocol.c **** 
  59:Src/usb_pd_protocol.c **** /* Type C supply voltage (mV) */
  60:Src/usb_pd_protocol.c **** #define TYPE_C_VOLTAGE	5000 /* mV */
  61:Src/usb_pd_protocol.c **** 
  62:Src/usb_pd_protocol.c **** /* PD counter definitions */
  63:Src/usb_pd_protocol.c **** #define PD_MESSAGE_ID_COUNT 7
  64:Src/usb_pd_protocol.c **** #define PD_HARD_RESET_COUNT 2
  65:Src/usb_pd_protocol.c **** #define PD_CAPS_COUNT 50
  66:Src/usb_pd_protocol.c **** #define PD_SNK_CAP_RETRIES 3
  67:Src/usb_pd_protocol.c **** 
  68:Src/usb_pd_protocol.c **** enum vdm_states {
  69:Src/usb_pd_protocol.c **** 	VDM_STATE_ERR_BUSY = -3,
  70:Src/usb_pd_protocol.c **** 	VDM_STATE_ERR_SEND = -2,
  71:Src/usb_pd_protocol.c **** 	VDM_STATE_ERR_TMOUT = -1,
  72:Src/usb_pd_protocol.c **** 	VDM_STATE_DONE = 0,
  73:Src/usb_pd_protocol.c **** 	/* Anything >0 represents an active state */
  74:Src/usb_pd_protocol.c **** 	VDM_STATE_READY = 1,
  75:Src/usb_pd_protocol.c **** 	VDM_STATE_BUSY = 2,
  76:Src/usb_pd_protocol.c **** 	VDM_STATE_WAIT_RSP_BUSY = 3,
  77:Src/usb_pd_protocol.c **** };
  78:Src/usb_pd_protocol.c **** 
  79:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
  80:Src/usb_pd_protocol.c **** /* Port dual-role state */
  81:Src/usb_pd_protocol.c **** enum pd_dual_role_states drp_state = CONFIG_USB_PD_INITIAL_DRP_STATE;
  82:Src/usb_pd_protocol.c **** 
  83:Src/usb_pd_protocol.c **** /* Enable variable for Try.SRC states */
  84:Src/usb_pd_protocol.c **** static uint8_t pd_try_src_enable;
  85:Src/usb_pd_protocol.c **** #endif
  86:Src/usb_pd_protocol.c **** 
  87:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
  88:Src/usb_pd_protocol.c **** /*
  89:Src/usb_pd_protocol.c ****  * The spec. revision is used to index into this array.
ARM GAS  /tmp/ccoQIC4J.s 			page 3


  90:Src/usb_pd_protocol.c ****  *  Rev 0 (PD 1.0) - return PD_CTRL_REJECT
  91:Src/usb_pd_protocol.c ****  *  Rev 1 (PD 2.0) - return PD_CTRL_REJECT
  92:Src/usb_pd_protocol.c ****  *  Rev 2 (PD 3.0) - return PD_CTRL_NOT_SUPPORTED
  93:Src/usb_pd_protocol.c ****  */
  94:Src/usb_pd_protocol.c **** static const uint8_t refuse[] = {
  95:Src/usb_pd_protocol.c **** 	PD_CTRL_REJECT, PD_CTRL_REJECT, PD_CTRL_NOT_SUPPORTED};
  96:Src/usb_pd_protocol.c **** #define REFUSE(r) refuse[r]
  97:Src/usb_pd_protocol.c **** #else
  98:Src/usb_pd_protocol.c **** #define REFUSE(r) PD_CTRL_REJECT
  99:Src/usb_pd_protocol.c **** #endif
 100:Src/usb_pd_protocol.c **** 
 101:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 102:Src/usb_pd_protocol.c **** /*
 103:Src/usb_pd_protocol.c ****  * The spec. revision is used to index into this array.
 104:Src/usb_pd_protocol.c ****  *  Rev 0 (VDO 1.0) - return VDM_VER10
 105:Src/usb_pd_protocol.c ****  *  Rev 1 (VDO 1.0) - return VDM_VER10
 106:Src/usb_pd_protocol.c ****  *  Rev 2 (VDO 2.0) - return VDM_VER20
 107:Src/usb_pd_protocol.c ****  */
 108:Src/usb_pd_protocol.c **** static const uint8_t vdo_ver[] = {
 109:Src/usb_pd_protocol.c **** 	VDM_VER10, VDM_VER10, VDM_VER20};
 110:Src/usb_pd_protocol.c **** #define VDO_VER(v) vdo_ver[v]
 111:Src/usb_pd_protocol.c **** #else
 112:Src/usb_pd_protocol.c **** #define VDO_VER(v) VDM_VER10
 113:Src/usb_pd_protocol.c **** #endif
 114:Src/usb_pd_protocol.c **** 
 115:Src/usb_pd_protocol.c **** // variables that used to be pd_task, but had to be promoted 
 116:Src/usb_pd_protocol.c **** // so both pd_init and pd_run_state_machine can see them
 117:Src/usb_pd_protocol.c **** static int head;
 118:Src/usb_pd_protocol.c **** static int port = TASK_ID_TO_PD_PORT(task_get_current());
 119:Src/usb_pd_protocol.c **** static uint32_t payload[7];
 120:Src/usb_pd_protocol.c **** static int timeout = 10*MSEC_US;
 121:Src/usb_pd_protocol.c **** static int cc1, cc2;
 122:Src/usb_pd_protocol.c **** static int res, incoming_packet = 0;
 123:Src/usb_pd_protocol.c **** static int hard_reset_count = 0;
 124:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 125:Src/usb_pd_protocol.c **** static uint64_t next_role_swap = PD_T_DRP_SNK;
 126:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_VBUS_DETECT_NONE
 127:Src/usb_pd_protocol.c **** static int snk_hard_reset_vbus_off = 0;
 128:Src/usb_pd_protocol.c **** #endif
 129:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 130:Src/usb_pd_protocol.c **** static const int auto_toggle_supported = tcpm_auto_toggle_supported(port);
 131:Src/usb_pd_protocol.c **** #endif
 132:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
 133:Src/usb_pd_protocol.c **** static typec_current_t typec_curr = 0, typec_curr_change = 0;
 134:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
 135:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 136:Src/usb_pd_protocol.c **** static enum pd_states this_state;
 137:Src/usb_pd_protocol.c **** static enum pd_cc_states new_cc_state;
 138:Src/usb_pd_protocol.c **** static timestamp_t now;
 139:Src/usb_pd_protocol.c **** static int caps_count = 0, hard_reset_sent = 0;
 140:Src/usb_pd_protocol.c **** static int snk_cap_count = 0;
 141:Src/usb_pd_protocol.c **** static int evt;
 142:Src/usb_pd_protocol.c **** 
 143:Src/usb_pd_protocol.c **** static struct pd_protocol {
 144:Src/usb_pd_protocol.c **** 	/* current port power role (SOURCE or SINK) */
 145:Src/usb_pd_protocol.c **** 	uint8_t power_role;
 146:Src/usb_pd_protocol.c **** 	/* current port data role (DFP or UFP) */
ARM GAS  /tmp/ccoQIC4J.s 			page 4


 147:Src/usb_pd_protocol.c **** 	uint8_t data_role;
 148:Src/usb_pd_protocol.c **** 	/* 3-bit rolling message ID counter */
 149:Src/usb_pd_protocol.c **** 	uint8_t msg_id;
 150:Src/usb_pd_protocol.c **** 	/* Port polarity : 0 => CC1 is CC line, 1 => CC2 is CC line */
 151:Src/usb_pd_protocol.c **** 	uint8_t polarity;
 152:Src/usb_pd_protocol.c **** 	/* PD state for port */
 153:Src/usb_pd_protocol.c **** 	enum pd_states task_state;
 154:Src/usb_pd_protocol.c **** 	/* PD state when we run state handler the last time */
 155:Src/usb_pd_protocol.c **** 	enum pd_states last_state;
 156:Src/usb_pd_protocol.c **** 	/* bool: request state change to SUSPENDED */
 157:Src/usb_pd_protocol.c **** 	uint8_t req_suspend_state;
 158:Src/usb_pd_protocol.c **** 	/* The state to go to after timeout */
 159:Src/usb_pd_protocol.c **** 	enum pd_states timeout_state;
 160:Src/usb_pd_protocol.c **** 	/* port flags, see PD_FLAGS_* */
 161:Src/usb_pd_protocol.c **** 	uint32_t flags;
 162:Src/usb_pd_protocol.c **** 	/* Timeout for the current state. Set to 0 for no timeout. */
 163:Src/usb_pd_protocol.c **** 	uint64_t timeout;
 164:Src/usb_pd_protocol.c **** 	/* Time for source recovery after hard reset */
 165:Src/usb_pd_protocol.c **** 	uint64_t src_recover;
 166:Src/usb_pd_protocol.c **** 	/* Time for CC debounce end */
 167:Src/usb_pd_protocol.c **** 	uint64_t cc_debounce;
 168:Src/usb_pd_protocol.c **** 	/* The cc state */
 169:Src/usb_pd_protocol.c **** 	enum pd_cc_states cc_state;
 170:Src/usb_pd_protocol.c **** 	/* status of last transmit */
 171:Src/usb_pd_protocol.c **** 	uint8_t tx_status;
 172:Src/usb_pd_protocol.c **** 
 173:Src/usb_pd_protocol.c **** 	/* last requested voltage PDO index */
 174:Src/usb_pd_protocol.c **** 	int requested_idx;
 175:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 176:Src/usb_pd_protocol.c **** 	/* Current limit / voltage based on the last request message */
 177:Src/usb_pd_protocol.c **** 	uint32_t curr_limit;
 178:Src/usb_pd_protocol.c **** 	uint32_t supply_voltage;
 179:Src/usb_pd_protocol.c **** 	/* Signal charging update that affects the port */
 180:Src/usb_pd_protocol.c **** 	int new_power_request;
 181:Src/usb_pd_protocol.c **** 	/* Store previously requested voltage request */
 182:Src/usb_pd_protocol.c **** 	int prev_request_mv;
 183:Src/usb_pd_protocol.c **** 	/* Time for Try.SRC states */
 184:Src/usb_pd_protocol.c **** 	uint64_t try_src_marker;
 185:Src/usb_pd_protocol.c **** #endif
 186:Src/usb_pd_protocol.c **** 
 187:Src/usb_pd_protocol.c **** 	/* PD state for Vendor Defined Messages */
 188:Src/usb_pd_protocol.c **** 	enum vdm_states vdm_state;
 189:Src/usb_pd_protocol.c **** 	/* Timeout for the current vdm state.  Set to 0 for no timeout. */
 190:Src/usb_pd_protocol.c **** 	timestamp_t vdm_timeout;
 191:Src/usb_pd_protocol.c **** 	/* next Vendor Defined Message to send */
 192:Src/usb_pd_protocol.c **** 	uint32_t vdo_data[VDO_MAX_SIZE];
 193:Src/usb_pd_protocol.c **** 	uint8_t vdo_count;
 194:Src/usb_pd_protocol.c **** 	/* VDO to retry if UFP responder replied busy. */
 195:Src/usb_pd_protocol.c **** 	uint32_t vdo_retry;
 196:Src/usb_pd_protocol.c **** 
 197:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
 198:Src/usb_pd_protocol.c **** 	/* Attached ChromeOS device id, RW hash, and current RO / RW image */
 199:Src/usb_pd_protocol.c **** 	uint16_t dev_id;
 200:Src/usb_pd_protocol.c **** 	uint32_t dev_rw_hash[PD_RW_HASH_SIZE/4];
 201:Src/usb_pd_protocol.c **** 	enum ec_current_image current_image;
 202:Src/usb_pd_protocol.c **** #endif
 203:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
ARM GAS  /tmp/ccoQIC4J.s 			page 5


 204:Src/usb_pd_protocol.c **** 	/* PD Collision avoidance buffer */
 205:Src/usb_pd_protocol.c **** 	uint16_t ca_buffered;
 206:Src/usb_pd_protocol.c **** 	uint16_t ca_header;
 207:Src/usb_pd_protocol.c **** 	uint32_t ca_buffer[PDO_MAX_OBJECTS];
 208:Src/usb_pd_protocol.c **** 	enum tcpm_transmit_type ca_type;
 209:Src/usb_pd_protocol.c **** 	/* protocol revision */
 210:Src/usb_pd_protocol.c **** 	uint8_t rev;
 211:Src/usb_pd_protocol.c **** #endif
 212:Src/usb_pd_protocol.c **** } pd[CONFIG_USB_PD_PORT_COUNT];
 213:Src/usb_pd_protocol.c **** 
 214:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 215:Src/usb_pd_protocol.c **** static const char * const pd_state_names[] = {
 216:Src/usb_pd_protocol.c **** 	"DISABLED", "SUSPENDED",
 217:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 218:Src/usb_pd_protocol.c **** 	"SNK_DISCONNECTED", "SNK_DISCONNECTED_DEBOUNCE",
 219:Src/usb_pd_protocol.c **** 	"SNK_HARD_RESET_RECOVER",
 220:Src/usb_pd_protocol.c **** 	"SNK_DISCOVERY", "SNK_REQUESTED", "SNK_TRANSITION", "SNK_READY",
 221:Src/usb_pd_protocol.c **** 	"SNK_SWAP_INIT", "SNK_SWAP_SNK_DISABLE",
 222:Src/usb_pd_protocol.c **** 	"SNK_SWAP_SRC_DISABLE", "SNK_SWAP_STANDBY", "SNK_SWAP_COMPLETE",
 223:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 224:Src/usb_pd_protocol.c **** 	"SRC_DISCONNECTED", "SRC_DISCONNECTED_DEBOUNCE",
 225:Src/usb_pd_protocol.c **** 	"SRC_HARD_RESET_RECOVER", "SRC_STARTUP",
 226:Src/usb_pd_protocol.c **** 	"SRC_DISCOVERY", "SRC_NEGOCIATE", "SRC_ACCEPTED", "SRC_POWERED",
 227:Src/usb_pd_protocol.c **** 	"SRC_TRANSITION", "SRC_READY", "SRC_GET_SNK_CAP", "DR_SWAP",
 228:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 229:Src/usb_pd_protocol.c **** 	"SRC_SWAP_INIT", "SRC_SWAP_SNK_DISABLE", "SRC_SWAP_SRC_DISABLE",
 230:Src/usb_pd_protocol.c **** 	"SRC_SWAP_STANDBY",
 231:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 232:Src/usb_pd_protocol.c **** 	"VCONN_SWAP_SEND", "VCONN_SWAP_INIT", "VCONN_SWAP_READY",
 233:Src/usb_pd_protocol.c **** #endif /* CONFIG_USBC_VCONN_SWAP */
 234:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 235:Src/usb_pd_protocol.c **** 	"SOFT_RESET", "HARD_RESET_SEND", "HARD_RESET_EXECUTE", "BIST_RX",
 236:Src/usb_pd_protocol.c **** 	"BIST_TX",
 237:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 238:Src/usb_pd_protocol.c **** 	"DRP_AUTO_TOGGLE",
 239:Src/usb_pd_protocol.c **** #endif
 240:Src/usb_pd_protocol.c **** };
 241:Src/usb_pd_protocol.c **** BUILD_ASSERT(ARRAY_SIZE(pd_state_names) == PD_STATE_COUNT);
 242:Src/usb_pd_protocol.c **** #endif
 243:Src/usb_pd_protocol.c **** 
 244:Src/usb_pd_protocol.c **** /*
 245:Src/usb_pd_protocol.c ****  * 4 entry rw_hash table of type-C devices that AP has firmware updates for.
 246:Src/usb_pd_protocol.c ****  */
 247:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 248:Src/usb_pd_protocol.c **** #define RW_HASH_ENTRIES 4
 249:Src/usb_pd_protocol.c **** static struct ec_params_usb_pd_rw_hash_entry rw_hash_table[RW_HASH_ENTRIES];
 250:Src/usb_pd_protocol.c **** #endif
 251:Src/usb_pd_protocol.c **** 
 252:Src/usb_pd_protocol.c **** int pd_comm_is_enabled(int port)
 253:Src/usb_pd_protocol.c **** {
 254:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 255:Src/usb_pd_protocol.c **** 	return pd_comm_enabled[port];
 256:Src/usb_pd_protocol.c **** #else
 257:Src/usb_pd_protocol.c **** 	return 1;
 258:Src/usb_pd_protocol.c **** #endif
 259:Src/usb_pd_protocol.c **** }
 260:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 6


 261:Src/usb_pd_protocol.c **** static inline void set_state_timeout(int port,
 262:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 263:Src/usb_pd_protocol.c **** 				     enum pd_states timeout_state)
 264:Src/usb_pd_protocol.c **** {
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout = timeout;
 266:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 267:Src/usb_pd_protocol.c **** }
 268:Src/usb_pd_protocol.c **** 
 269:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 270:Src/usb_pd_protocol.c **** int pd_get_rev(int port)
 271:Src/usb_pd_protocol.c **** {
 272:Src/usb_pd_protocol.c **** 	return pd[port].rev;
 273:Src/usb_pd_protocol.c **** }
 274:Src/usb_pd_protocol.c **** 
 275:Src/usb_pd_protocol.c **** int pd_get_vdo_ver(int port)
 276:Src/usb_pd_protocol.c **** {
 277:Src/usb_pd_protocol.c **** 	return vdo_ver[pd[port].rev];
 278:Src/usb_pd_protocol.c **** }
 279:Src/usb_pd_protocol.c **** #endif
 280:Src/usb_pd_protocol.c **** 
 281:Src/usb_pd_protocol.c **** /* Return flag for pd state is connected */
 282:Src/usb_pd_protocol.c **** int pd_is_connected(int port)
 283:Src/usb_pd_protocol.c **** {
 284:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_DISABLED)
 285:Src/usb_pd_protocol.c **** 		return 0;
 286:Src/usb_pd_protocol.c **** 
 287:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 288:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_DRP_AUTO_TOGGLE)
 289:Src/usb_pd_protocol.c **** 		return 0;
 290:Src/usb_pd_protocol.c **** #endif
 291:Src/usb_pd_protocol.c **** 
 292:Src/usb_pd_protocol.c **** 	return DUAL_ROLE_IF_ELSE(port,
 293:Src/usb_pd_protocol.c **** 		/* sink */
 294:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_DISCONNECTED &&
 295:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_DISCONNECTED_DEBOUNCE,
 296:Src/usb_pd_protocol.c **** 		/* source */
 297:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SRC_DISCONNECTED &&
 298:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SRC_DISCONNECTED_DEBOUNCE);
 299:Src/usb_pd_protocol.c **** }
 300:Src/usb_pd_protocol.c **** 
 301:Src/usb_pd_protocol.c **** /*
 302:Src/usb_pd_protocol.c ****  * Return true if partner port is a DTS or TS capable of entering debug
 303:Src/usb_pd_protocol.c ****  * mode (eg. is presenting Rp/Rp or Rd/Rd).
 304:Src/usb_pd_protocol.c ****  */
 305:Src/usb_pd_protocol.c **** int pd_ts_dts_plugged(int port)
 306:Src/usb_pd_protocol.c **** {
 307:Src/usb_pd_protocol.c **** 	return pd[port].flags & PD_FLAGS_TS_DTS_PARTNER;
 308:Src/usb_pd_protocol.c **** }
 309:Src/usb_pd_protocol.c **** 
 310:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 311:Src/usb_pd_protocol.c **** void pd_vbus_low(int port)
 312:Src/usb_pd_protocol.c **** {
 313:Src/usb_pd_protocol.c **** 	pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
 314:Src/usb_pd_protocol.c **** }
 315:Src/usb_pd_protocol.c **** 
 316:Src/usb_pd_protocol.c **** static inline int pd_is_vbus_present(int port)
 317:Src/usb_pd_protocol.c **** {
ARM GAS  /tmp/ccoQIC4J.s 			page 7


 318:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_TCPC
 319:Src/usb_pd_protocol.c **** 	return tcpm_get_vbus_level(port);
 320:Src/usb_pd_protocol.c **** #else
 321:Src/usb_pd_protocol.c **** 	return pd_snk_is_vbus_provided(port);
 322:Src/usb_pd_protocol.c **** #endif
 323:Src/usb_pd_protocol.c **** }
 324:Src/usb_pd_protocol.c **** #endif
 325:Src/usb_pd_protocol.c **** 
 326:Src/usb_pd_protocol.c **** static inline void set_state(int port, enum pd_states next_state)
 327:Src/usb_pd_protocol.c **** {
 328:Src/usb_pd_protocol.c **** 	enum pd_states last_state = pd[port].task_state;
 329:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 330:Src/usb_pd_protocol.c **** 	int i;
 331:Src/usb_pd_protocol.c **** #endif
 332:Src/usb_pd_protocol.c **** 
 333:Src/usb_pd_protocol.c **** 	set_state_timeout(port, 0, 0);
 334:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 335:Src/usb_pd_protocol.c **** 
 336:Src/usb_pd_protocol.c **** 	if (last_state == next_state)
 337:Src/usb_pd_protocol.c **** 		return;
 338:Src/usb_pd_protocol.c **** 
 339:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 340:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 341:Src/usb_pd_protocol.c **** 	/* Clear flag to allow DRP auto toggle when possible */
 342:Src/usb_pd_protocol.c **** 	if (last_state != PD_STATE_DRP_AUTO_TOGGLE)
 343:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_TCPC_DRP_TOGGLE;
 344:Src/usb_pd_protocol.c **** #endif
 345:Src/usb_pd_protocol.c **** 
 346:Src/usb_pd_protocol.c **** 	/* Ignore dual-role toggling between sink and source */
 347:Src/usb_pd_protocol.c **** 	if ((last_state == PD_STATE_SNK_DISCONNECTED &&
 348:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 349:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 350:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 351:Src/usb_pd_protocol.c **** 		return;
 352:Src/usb_pd_protocol.c **** 
 353:Src/usb_pd_protocol.c **** 	if (next_state == PD_STATE_SRC_DISCONNECTED ||
 354:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 355:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 356:Src/usb_pd_protocol.c **** 		pd_set_input_current_limit(port, 0, 0);
 357:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 358:Src/usb_pd_protocol.c **** 		//typec_set_input_current_limit(port, 0, 0);
 359:Src/usb_pd_protocol.c **** 		//charge_manager_set_ceil(port,
 360:Src/usb_pd_protocol.c **** 		//			CEIL_REQUESTOR_PD,
 361:Src/usb_pd_protocol.c **** 		//			CHARGE_CEIL_NONE);
 362:Src/usb_pd_protocol.c **** #endif
 363:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN
 364:Src/usb_pd_protocol.c **** 		tcpm_set_vconn(port, 0);
 365:Src/usb_pd_protocol.c **** #endif
 366:Src/usb_pd_protocol.c **** #else /* CONFIG_USB_PD_DUAL_ROLE */
 367:Src/usb_pd_protocol.c **** 	if (next_state == PD_STATE_SRC_DISCONNECTED) {
 368:Src/usb_pd_protocol.c **** #endif
 369:Src/usb_pd_protocol.c **** 		/*
 370:Src/usb_pd_protocol.c **** 		 * If we are source, make sure VBUS is off and
 371:Src/usb_pd_protocol.c **** 		 * if PD REV3.0, restore RP.
 372:Src/usb_pd_protocol.c **** 		 */
 373:Src/usb_pd_protocol.c **** 		if (pd[port].power_role == PD_ROLE_SOURCE) {
 374:Src/usb_pd_protocol.c **** 			/*
ARM GAS  /tmp/ccoQIC4J.s 			page 8


 375:Src/usb_pd_protocol.c **** 			 * Rp is restored by pd_power_supply_reset if
 376:Src/usb_pd_protocol.c **** 			 * CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT is defined.
 377:Src/usb_pd_protocol.c **** 			 */
 378:Src/usb_pd_protocol.c **** 			pd_power_supply_reset(port);
 379:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 380:Src/usb_pd_protocol.c **** 		defined(CONFIG_USB_PD_REV30)
 381:Src/usb_pd_protocol.c **** 			/* Restore Rp */
 382:Src/usb_pd_protocol.c **** 			tcpm_select_rp_value(port, CONFIG_USB_PD_PULLUP);
 383:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
 384:Src/usb_pd_protocol.c **** #endif
 385:Src/usb_pd_protocol.c **** 		}
 386:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 387:Src/usb_pd_protocol.c **** 		/* Adjust rev to highest level*/
 388:Src/usb_pd_protocol.c **** 		pd[port].rev = PD_REV30;
 389:Src/usb_pd_protocol.c **** #endif
 390:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
 391:Src/usb_pd_protocol.c **** 		pd[port].dev_id = 0;
 392:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_RESET_ON_DISCONNECT_MASK;
 393:Src/usb_pd_protocol.c **** #endif
 394:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 395:Src/usb_pd_protocol.c **** 		//charge_manager_update_dualrole(port, CAP_UNKNOWN);
 396:Src/usb_pd_protocol.c **** #endif
 397:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 398:Src/usb_pd_protocol.c **** 		pd_dfp_exit_mode(port, 0, 0);
 399:Src/usb_pd_protocol.c **** #endif
 400:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
 401:Src/usb_pd_protocol.c **** 		usb_mux_set(port, TYPEC_MUX_NONE, USB_SWITCH_DISCONNECT,
 402:Src/usb_pd_protocol.c **** 			    pd[port].polarity);
 403:Src/usb_pd_protocol.c **** #endif
 404:Src/usb_pd_protocol.c **** 		/* Disable TCPC RX */
 405:Src/usb_pd_protocol.c **** 		tcpm_set_rx_enable(port, 0);
 406:Src/usb_pd_protocol.c **** 	}
 407:Src/usb_pd_protocol.c **** 
 408:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 409:Src/usb_pd_protocol.c **** 	/* If a PD device is attached then disable deep sleep */
 410:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++) {
 411:Src/usb_pd_protocol.c **** 		if (pd[i].flags & PD_FLAGS_PREVIOUS_PD_CONN)
 412:Src/usb_pd_protocol.c **** 			break;
 413:Src/usb_pd_protocol.c **** 	}
 414:Src/usb_pd_protocol.c **** 	if (i == CONFIG_USB_PD_PORT_COUNT)
 415:Src/usb_pd_protocol.c **** 		enable_sleep(SLEEP_MASK_USB_PD);
 416:Src/usb_pd_protocol.c **** 	else
 417:Src/usb_pd_protocol.c **** 		disable_sleep(SLEEP_MASK_USB_PD);
 418:Src/usb_pd_protocol.c **** #endif
 419:Src/usb_pd_protocol.c **** 
 420:Src/usb_pd_protocol.c **** 	if (debug_level >= 1)
 421:Src/usb_pd_protocol.c **** 		CPRINTF("C%d st%d %s\n", port, next_state,
 422:Src/usb_pd_protocol.c **** 					 pd_state_names[next_state]);
 423:Src/usb_pd_protocol.c **** 	else
 424:Src/usb_pd_protocol.c **** 		CPRINTF("C%d st%d\n", port, next_state);
 425:Src/usb_pd_protocol.c **** }
 426:Src/usb_pd_protocol.c **** 
 427:Src/usb_pd_protocol.c **** /* increment message ID counter */
 428:Src/usb_pd_protocol.c **** static void inc_id(int port)
 429:Src/usb_pd_protocol.c **** {
  27              		.loc 1 429 1 view -0
  28              		.cfi_startproc
ARM GAS  /tmp/ccoQIC4J.s 			page 9


  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
 430:Src/usb_pd_protocol.c **** 	pd[port].msg_id = (pd[port].msg_id + 1) & PD_MESSAGE_ID_COUNT;
  32              		.loc 1 430 2 view .LVU1
  33              		.loc 1 430 29 is_stmt 0 view .LVU2
  34 0000 C301     		lsls	r3, r0, #7
  35 0002 0448     		ldr	r0, .L2
  36              	.LVL1:
  37              		.loc 1 430 29 view .LVU3
  38 0004 C018     		adds	r0, r0, r3
  39 0006 8378     		ldrb	r3, [r0, #2]
  40              		.loc 1 430 37 view .LVU4
  41 0008 0133     		adds	r3, r3, #1
  42              		.loc 1 430 42 view .LVU5
  43 000a 0722     		movs	r2, #7
  44 000c 1340     		ands	r3, r2
  45              		.loc 1 430 18 view .LVU6
  46 000e 8370     		strb	r3, [r0, #2]
 431:Src/usb_pd_protocol.c **** }
  47              		.loc 1 431 1 view .LVU7
  48              		@ sp needed
  49 0010 7047     		bx	lr
  50              	.L3:
  51 0012 C046     		.align	2
  52              	.L2:
  53 0014 00000000 		.word	pd
  54              		.cfi_endproc
  55              	.LFE25:
  57              		.section	.text.pd_update_roles,"ax",%progbits
  58              		.align	1
  59              		.syntax unified
  60              		.code	16
  61              		.thumb_func
  62              		.fpu softvfp
  64              	pd_update_roles:
  65              	.LVL2:
  66              	.LFB28:
 432:Src/usb_pd_protocol.c **** 
 433:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 434:Src/usb_pd_protocol.c **** static void sink_can_xmit(int port, int rp)
 435:Src/usb_pd_protocol.c **** {
 436:Src/usb_pd_protocol.c **** 	tcpm_select_rp_value(port, rp);
 437:Src/usb_pd_protocol.c **** 	tcpm_set_cc(port, TYPEC_CC_RP);
 438:Src/usb_pd_protocol.c **** }
 439:Src/usb_pd_protocol.c **** 
 440:Src/usb_pd_protocol.c **** static inline void pd_ca_reset(int port)
 441:Src/usb_pd_protocol.c **** {
 442:Src/usb_pd_protocol.c **** 	pd[port].ca_buffered = 0;
 443:Src/usb_pd_protocol.c **** }
 444:Src/usb_pd_protocol.c **** #endif
 445:Src/usb_pd_protocol.c **** 
 446:Src/usb_pd_protocol.c **** void pd_transmit_complete(int port, int status)
 447:Src/usb_pd_protocol.c **** {
 448:Src/usb_pd_protocol.c **** 	if (status == TCPC_TX_COMPLETE_SUCCESS)
 449:Src/usb_pd_protocol.c **** 		inc_id(port);
 450:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 10


 451:Src/usb_pd_protocol.c **** 	pd[port].tx_status = status;
 452:Src/usb_pd_protocol.c **** 	//task_set_event(PD_PORT_TO_TASK_ID(port), PD_EVENT_TX, 0);
 453:Src/usb_pd_protocol.c **** 	pd_task_set_event(PD_EVENT_TX, 0);
 454:Src/usb_pd_protocol.c **** }
 455:Src/usb_pd_protocol.c **** 
 456:Src/usb_pd_protocol.c **** static int pd_transmit(int port, enum tcpm_transmit_type type,
 457:Src/usb_pd_protocol.c **** 		       uint16_t header, const uint32_t *data)
 458:Src/usb_pd_protocol.c **** {
 459:Src/usb_pd_protocol.c **** 	int evt;
 460:Src/usb_pd_protocol.c **** 
 461:Src/usb_pd_protocol.c **** 	/* If comms are disabled, do not transmit, return error */
 462:Src/usb_pd_protocol.c **** 	if (!pd_comm_is_enabled(port))
 463:Src/usb_pd_protocol.c **** 		return -1;
 464:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 465:Src/usb_pd_protocol.c **** 	/* Source-coordinated collision avoidance */
 466:Src/usb_pd_protocol.c **** 	/*
 467:Src/usb_pd_protocol.c **** 	 * In order to avoid message collisions due to asynchronous Messaging
 468:Src/usb_pd_protocol.c **** 	 * sent from the Sink, the Source sets Rp to SinkTxOk to indicate to
 469:Src/usb_pd_protocol.c **** 	 * the Sink that it is ok to initiate an AMS. When the Source wishes
 470:Src/usb_pd_protocol.c **** 	 * to initiate an AMS it sets Rp to SinkTxNG. When the Sink detects
 471:Src/usb_pd_protocol.c **** 	 * that Rp is set to SinkTxOk it May initiate an AMS. When the Sink
 472:Src/usb_pd_protocol.c **** 	 * detects that Rp is set to SinkTxNG it Shall Not initiate an AMS
 473:Src/usb_pd_protocol.c **** 	 * and Shall only send Messages that are part of an AMS the Source has
 474:Src/usb_pd_protocol.c **** 	 * initiated. Note that this restriction applies to SOP* AMS’s i.e.
 475:Src/usb_pd_protocol.c **** 	 * for both Port to Port and Port to Cable Plug communications.
 476:Src/usb_pd_protocol.c **** 	 *
 477:Src/usb_pd_protocol.c **** 	 * This starts after an Explicit Contract is in place
 478:Src/usb_pd_protocol.c **** 	 * PD R3 V1.1 Section 2.5.2.
 479:Src/usb_pd_protocol.c **** 	 *
 480:Src/usb_pd_protocol.c **** 	 * Note: a Sink can still send Hard Reset signaling at any time.
 481:Src/usb_pd_protocol.c **** 	 */
 482:Src/usb_pd_protocol.c **** 	if ((pd[port].rev == PD_REV30) &&
 483:Src/usb_pd_protocol.c **** 		(pd[port].flags & PD_FLAGS_EXPLICIT_CONTRACT)) {
 484:Src/usb_pd_protocol.c **** 		if (pd[port].power_role == PD_ROLE_SOURCE) {
 485:Src/usb_pd_protocol.c **** 			/*
 486:Src/usb_pd_protocol.c **** 			 * Inform Sink that it can't transmit. If a sink
 487:Src/usb_pd_protocol.c **** 			 * transmition is in progress and a collsion occurs,
 488:Src/usb_pd_protocol.c **** 			 * a reset is generated. This should be rare because
 489:Src/usb_pd_protocol.c **** 			 * all extended messages are chunked. This effectively
 490:Src/usb_pd_protocol.c **** 			 * defaults to PD REV 2.0 collision avoidance.
 491:Src/usb_pd_protocol.c **** 			 */
 492:Src/usb_pd_protocol.c **** 			sink_can_xmit(port, SINK_TX_NG);
 493:Src/usb_pd_protocol.c **** 		} else if (type != TCPC_TX_HARD_RESET) {
 494:Src/usb_pd_protocol.c **** 			int cc1;
 495:Src/usb_pd_protocol.c **** 			int cc2;
 496:Src/usb_pd_protocol.c **** 
 497:Src/usb_pd_protocol.c **** 			tcpm_get_cc(port, &cc1, &cc2);
 498:Src/usb_pd_protocol.c **** 			if (cc1 == TYPEC_CC_VOLT_SNK_1_5 ||
 499:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_SNK_1_5) {
 500:Src/usb_pd_protocol.c **** 				/* Sink can't transmit now. */
 501:Src/usb_pd_protocol.c **** 				/* Check if message is already buffered. */
 502:Src/usb_pd_protocol.c **** 				if (pd[port].ca_buffered)
 503:Src/usb_pd_protocol.c **** 					return -1;
 504:Src/usb_pd_protocol.c **** 
 505:Src/usb_pd_protocol.c **** 				/* Buffer message and send later. */
 506:Src/usb_pd_protocol.c **** 				pd[port].ca_type = type;
 507:Src/usb_pd_protocol.c **** 				pd[port].ca_header = header;
ARM GAS  /tmp/ccoQIC4J.s 			page 11


 508:Src/usb_pd_protocol.c **** 				memcpy(pd[port].ca_buffer,
 509:Src/usb_pd_protocol.c **** 					data, sizeof(uint32_t) *
 510:Src/usb_pd_protocol.c **** 					PD_HEADER_CNT(header));
 511:Src/usb_pd_protocol.c **** 				pd[port].ca_buffered = 1;
 512:Src/usb_pd_protocol.c **** 				return 1;
 513:Src/usb_pd_protocol.c **** 			}
 514:Src/usb_pd_protocol.c **** 		}
 515:Src/usb_pd_protocol.c **** 	}
 516:Src/usb_pd_protocol.c **** #endif
 517:Src/usb_pd_protocol.c **** 	tcpm_transmit(port, type, header, data);
 518:Src/usb_pd_protocol.c **** 
 519:Src/usb_pd_protocol.c **** 	/* Wait until TX is complete */
 520:Src/usb_pd_protocol.c **** 	// Would wait, except that we're making tcpm_transmit blocking
 521:Src/usb_pd_protocol.c **** 	//evt = task_wait_event_mask(PD_EVENT_TX, PD_T_TCPC_TX_TIMEOUT);
 522:Src/usb_pd_protocol.c **** 
 523:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 524:Src/usb_pd_protocol.c **** 	/*
 525:Src/usb_pd_protocol.c **** 	 * If the source just completed a transmit, tell
 526:Src/usb_pd_protocol.c **** 	 * the sink it can transmit if it wants to.
 527:Src/usb_pd_protocol.c **** 	 */
 528:Src/usb_pd_protocol.c **** 	if ((pd[port].rev == PD_REV30) &&
 529:Src/usb_pd_protocol.c **** 			(pd[port].power_role == PD_ROLE_SOURCE) &&
 530:Src/usb_pd_protocol.c **** 			(pd[port].flags & PD_FLAGS_EXPLICIT_CONTRACT)) {
 531:Src/usb_pd_protocol.c **** 		sink_can_xmit(port, SINK_TX_OK);
 532:Src/usb_pd_protocol.c **** 	}
 533:Src/usb_pd_protocol.c **** #endif
 534:Src/usb_pd_protocol.c **** 
 535:Src/usb_pd_protocol.c **** 	// removing task-based stuff from the library
 536:Src/usb_pd_protocol.c **** 	//if (evt & TASK_EVENT_TIMER)
 537:Src/usb_pd_protocol.c ****     //		return -1;
 538:Src/usb_pd_protocol.c **** 
 539:Src/usb_pd_protocol.c **** 	/* TODO: give different error condition for failed vs discarded */
 540:Src/usb_pd_protocol.c **** 	return pd[port].tx_status == TCPC_TX_COMPLETE_SUCCESS ? 1 : -1;
 541:Src/usb_pd_protocol.c **** }
 542:Src/usb_pd_protocol.c **** 
 543:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 544:Src/usb_pd_protocol.c **** static void pd_ca_send_pending(int port)
 545:Src/usb_pd_protocol.c **** {
 546:Src/usb_pd_protocol.c **** 	int cc1;
 547:Src/usb_pd_protocol.c **** 	int cc2;
 548:Src/usb_pd_protocol.c **** 
 549:Src/usb_pd_protocol.c **** 	/* Check if a message has been buffered. */
 550:Src/usb_pd_protocol.c **** 	if (!pd[port].ca_buffered)
 551:Src/usb_pd_protocol.c **** 		return;
 552:Src/usb_pd_protocol.c **** 
 553:Src/usb_pd_protocol.c **** 	tcpm_get_cc(port, &cc1, &cc2);
 554:Src/usb_pd_protocol.c **** 	if ((cc1 != TYPEC_CC_VOLT_SNK_1_5) &&
 555:Src/usb_pd_protocol.c **** 			(cc2 != TYPEC_CC_VOLT_SNK_1_5))
 556:Src/usb_pd_protocol.c **** 		if (pd_transmit(port, pd[port].ca_type,
 557:Src/usb_pd_protocol.c **** 				pd[port].ca_header,
 558:Src/usb_pd_protocol.c **** 				pd[port].ca_buffer) < 0)
 559:Src/usb_pd_protocol.c **** 			return;
 560:Src/usb_pd_protocol.c **** 
 561:Src/usb_pd_protocol.c **** 	/* Message was sent, so free up the buffer. */
 562:Src/usb_pd_protocol.c **** 	pd[port].ca_buffered = 0;
 563:Src/usb_pd_protocol.c **** }
 564:Src/usb_pd_protocol.c **** #endif
ARM GAS  /tmp/ccoQIC4J.s 			page 12


 565:Src/usb_pd_protocol.c **** 
 566:Src/usb_pd_protocol.c **** static void pd_update_roles(int port)
 567:Src/usb_pd_protocol.c **** {
  67              		.loc 1 567 1 is_stmt 1 view -0
  68              		.cfi_startproc
  69              		@ args = 0, pretend = 0, frame = 0
  70              		@ frame_needed = 0, uses_anonymous_args = 0
  71              		.loc 1 567 1 is_stmt 0 view .LVU9
  72 0000 10B5     		push	{r4, lr}
  73              	.LCFI0:
  74              		.cfi_def_cfa_offset 8
  75              		.cfi_offset 4, -8
  76              		.cfi_offset 14, -4
 568:Src/usb_pd_protocol.c **** 	/* Notify TCPC of role update */
 569:Src/usb_pd_protocol.c **** 	tcpm_set_msg_header(port, pd[port].power_role, pd[port].data_role);
  77              		.loc 1 569 2 is_stmt 1 view .LVU10
  78              		.loc 1 569 36 is_stmt 0 view .LVU11
  79 0002 064B     		ldr	r3, .L5
  80 0004 C201     		lsls	r2, r0, #7
  81 0006 D15C     		ldrb	r1, [r2, r3]
  82              		.loc 1 569 57 view .LVU12
  83 0008 9B18     		adds	r3, r3, r2
  84 000a 5A78     		ldrb	r2, [r3, #1]
  85              	.LVL3:
  86              	.LBB146:
  87              	.LBI146:
  88              		.file 2 "Inc/tcpm.h"
   1:Inc/tcpm.h    **** /* Copyright 2015 The Chromium OS Authors. All rights reserved.
   2:Inc/tcpm.h    ****  * Use of this source code is governed by a BSD-style license that can be
   3:Inc/tcpm.h    ****  * found in the LICENSE file.
   4:Inc/tcpm.h    ****  */
   5:Inc/tcpm.h    **** 
   6:Inc/tcpm.h    **** /* USB Power delivery port management - common header for TCPM drivers */
   7:Inc/tcpm.h    **** 
   8:Inc/tcpm.h    **** #ifndef __CROS_EC_USB_PD_TCPM_TCPM_H
   9:Inc/tcpm.h    **** #define __CROS_EC_USB_PD_TCPM_TCPM_H
  10:Inc/tcpm.h    **** 
  11:Inc/tcpm.h    **** #ifdef __cplusplus
  12:Inc/tcpm.h    **** extern "C" {
  13:Inc/tcpm.h    **** #endif
  14:Inc/tcpm.h    **** 
  15:Inc/tcpm.h    **** #include "tcpm_driver.h"
  16:Inc/tcpm.h    **** #include "usb_pd_tcpm.h"
  17:Inc/tcpm.h    **** 
  18:Inc/tcpm.h    **** #if defined(CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE) && \
  19:Inc/tcpm.h    **** 	!defined(CONFIG_USB_PD_DUAL_ROLE)
  20:Inc/tcpm.h    **** #error "DRP auto toggle requires board to have DRP support"
  21:Inc/tcpm.h    **** #error "Please upgrade your board configuration"
  22:Inc/tcpm.h    **** #endif
  23:Inc/tcpm.h    **** 
  24:Inc/tcpm.h    **** #ifndef CONFIG_USB_PD_TCPC
  25:Inc/tcpm.h    **** extern const struct tcpc_config_t tcpc_config[];
  26:Inc/tcpm.h    **** 
  27:Inc/tcpm.h    **** /* I2C wrapper functions - get I2C port / slave addr from config struct. */
  28:Inc/tcpm.h    **** int tcpc_write(int port, int reg, int val);
  29:Inc/tcpm.h    **** int tcpc_write16(int port, int reg, int val);
  30:Inc/tcpm.h    **** int tcpc_read(int port, int reg, int *val);
ARM GAS  /tmp/ccoQIC4J.s 			page 13


  31:Inc/tcpm.h    **** int tcpc_read16(int port, int reg, int *val);
  32:Inc/tcpm.h    **** int tcpc_xfer(int port,
  33:Inc/tcpm.h    **** 		const uint8_t *out, int out_size,
  34:Inc/tcpm.h    **** 		uint8_t *in, int in_size,
  35:Inc/tcpm.h    **** 		int flags);
  36:Inc/tcpm.h    **** 
  37:Inc/tcpm.h    **** /* TCPM driver wrapper function */
  38:Inc/tcpm.h    **** static inline int tcpm_init(int port)
  39:Inc/tcpm.h    **** {
  40:Inc/tcpm.h    **** 	int rv;
  41:Inc/tcpm.h    **** 
  42:Inc/tcpm.h    **** 	rv = tcpc_config[port].drv->init(port);
  43:Inc/tcpm.h    **** 	if (rv)
  44:Inc/tcpm.h    **** 		return rv;
  45:Inc/tcpm.h    **** 
  46:Inc/tcpm.h    **** 	/* Board specific post TCPC init */
  47:Inc/tcpm.h    **** 	if (board_tcpc_post_init)
  48:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
  49:Inc/tcpm.h    **** 
  50:Inc/tcpm.h    **** 	return rv;
  51:Inc/tcpm.h    **** }
  52:Inc/tcpm.h    **** 
  53:Inc/tcpm.h    **** static inline int tcpm_release(int port)
  54:Inc/tcpm.h    **** {
  55:Inc/tcpm.h    **** 	return tcpc_config[port].drv->release(port);
  56:Inc/tcpm.h    **** }
  57:Inc/tcpm.h    **** 
  58:Inc/tcpm.h    **** static inline int tcpm_get_cc(int port, int *cc1, int *cc2)
  59:Inc/tcpm.h    **** {
  60:Inc/tcpm.h    **** 	return tcpc_config[port].drv->get_cc(port, cc1, cc2);
  61:Inc/tcpm.h    **** }
  62:Inc/tcpm.h    **** 
  63:Inc/tcpm.h    **** static inline int tcpm_get_vbus_level(int port)
  64:Inc/tcpm.h    **** {
  65:Inc/tcpm.h    **** 	return tcpc_config[port].drv->get_vbus_level(port);
  66:Inc/tcpm.h    **** }
  67:Inc/tcpm.h    **** 
  68:Inc/tcpm.h    **** static inline int tcpm_select_rp_value(int port, int rp)
  69:Inc/tcpm.h    **** {
  70:Inc/tcpm.h    **** 	return tcpc_config[port].drv->select_rp_value(port, rp);
  71:Inc/tcpm.h    **** }
  72:Inc/tcpm.h    **** 
  73:Inc/tcpm.h    **** static inline int tcpm_set_cc(int port, int pull)
  74:Inc/tcpm.h    **** {
  75:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_cc(port, pull);
  76:Inc/tcpm.h    **** }
  77:Inc/tcpm.h    **** 
  78:Inc/tcpm.h    **** static inline int tcpm_set_polarity(int port, int polarity)
  79:Inc/tcpm.h    **** {
  80:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_polarity(port, polarity);
  81:Inc/tcpm.h    **** }
  82:Inc/tcpm.h    **** 
  83:Inc/tcpm.h    **** static inline int tcpm_set_vconn(int port, int enable)
  84:Inc/tcpm.h    **** {
  85:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_vconn(port, enable);
  86:Inc/tcpm.h    **** }
  87:Inc/tcpm.h    **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 14


  88:Inc/tcpm.h    **** static inline int tcpm_set_msg_header(int port, int power_role, int data_role)
  89              		.loc 2 88 19 is_stmt 1 view .LVU13
  90              	.LBB147:
  89:Inc/tcpm.h    **** {
  90:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_msg_header(port, power_role,
  91              		.loc 2 90 2 view .LVU14
  92              		.loc 2 90 26 is_stmt 0 view .LVU15
  93 000c 0401     		lsls	r4, r0, #4
  94 000e 044B     		ldr	r3, .L5+4
  95 0010 1B19     		adds	r3, r3, r4
  96 0012 9B68     		ldr	r3, [r3, #8]
  97              		.loc 2 90 30 view .LVU16
  98 0014 1B6A     		ldr	r3, [r3, #32]
  99              		.loc 2 90 9 view .LVU17
 100 0016 9847     		blx	r3
 101              	.LVL4:
 102              		.loc 2 90 9 view .LVU18
 103              	.LBE147:
 104              	.LBE146:
 570:Src/usb_pd_protocol.c **** }
 105              		.loc 1 570 1 view .LVU19
 106              		@ sp needed
 107 0018 10BD     		pop	{r4, pc}
 108              	.L6:
 109 001a C046     		.align	2
 110              	.L5:
 111 001c 00000000 		.word	pd
 112 0020 00000000 		.word	tcpc_config
 113              		.cfi_endproc
 114              	.LFE28:
 116              		.section	.text.pd_update_pdo_flags,"ax",%progbits
 117              		.align	1
 118              		.syntax unified
 119              		.code	16
 120              		.thumb_func
 121              		.fpu softvfp
 123              	pd_update_pdo_flags:
 124              	.LVL5:
 125              	.LFB39:
 571:Src/usb_pd_protocol.c **** 
 572:Src/usb_pd_protocol.c **** static int send_control(int port, int type)
 573:Src/usb_pd_protocol.c **** {
 574:Src/usb_pd_protocol.c **** 	int bit_len;
 575:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(type, pd[port].power_role,
 576:Src/usb_pd_protocol.c **** 				pd[port].data_role, pd[port].msg_id, 0,
 577:Src/usb_pd_protocol.c **** 				pd_get_rev(port), 0);
 578:Src/usb_pd_protocol.c **** 
 579:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, NULL);
 580:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 581:Src/usb_pd_protocol.c **** 		CPRINTF("CTRL[%d]>%d\n", type, bit_len);
 582:Src/usb_pd_protocol.c **** 
 583:Src/usb_pd_protocol.c **** 	return bit_len;
 584:Src/usb_pd_protocol.c **** }
 585:Src/usb_pd_protocol.c **** 
 586:Src/usb_pd_protocol.c **** static int send_source_cap(int port)
 587:Src/usb_pd_protocol.c **** {
 588:Src/usb_pd_protocol.c **** 	int bit_len;
ARM GAS  /tmp/ccoQIC4J.s 			page 15


 589:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_DYNAMIC_SRC_CAP) || \
 590:Src/usb_pd_protocol.c **** 		defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT)
 591:Src/usb_pd_protocol.c **** 	const uint32_t *src_pdo;
 592:Src/usb_pd_protocol.c **** 	const int src_pdo_cnt = charge_manager_get_source_pdo(&src_pdo, port);
 593:Src/usb_pd_protocol.c **** #else
 594:Src/usb_pd_protocol.c **** 	const uint32_t *src_pdo = pd_src_pdo;
 595:Src/usb_pd_protocol.c **** 	const int src_pdo_cnt = pd_src_pdo_cnt;
 596:Src/usb_pd_protocol.c **** #endif
 597:Src/usb_pd_protocol.c **** 	uint16_t header;
 598:Src/usb_pd_protocol.c **** 
 599:Src/usb_pd_protocol.c **** 	if (src_pdo_cnt == 0)
 600:Src/usb_pd_protocol.c **** 		/* No source capabilities defined, sink only */
 601:Src/usb_pd_protocol.c **** 		header = PD_HEADER(PD_CTRL_REJECT, pd[port].power_role,
 602:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 0,
 603:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 604:Src/usb_pd_protocol.c **** 	else
 605:Src/usb_pd_protocol.c **** 		header = PD_HEADER(PD_DATA_SOURCE_CAP, pd[port].power_role,
 606:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 607:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 608:Src/usb_pd_protocol.c **** 
 609:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, src_pdo);
 610:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 611:Src/usb_pd_protocol.c **** 		CPRINTF("srcCAP>%d\n", bit_len);
 612:Src/usb_pd_protocol.c **** 
 613:Src/usb_pd_protocol.c **** 	return bit_len;
 614:Src/usb_pd_protocol.c **** }
 615:Src/usb_pd_protocol.c **** 
 616:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 617:Src/usb_pd_protocol.c **** static int send_battery_cap(int port, uint32_t *payload)
 618:Src/usb_pd_protocol.c **** {
 619:Src/usb_pd_protocol.c **** 	int bit_len;
 620:Src/usb_pd_protocol.c **** 	uint16_t msg[6] = {0, 0, 0, 0, 0, 0};
 621:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_EXT_BATTERY_CAP,
 622:Src/usb_pd_protocol.c **** 				    pd[port].power_role,
 623:Src/usb_pd_protocol.c **** 				    pd[port].data_role,
 624:Src/usb_pd_protocol.c **** 				    pd[port].msg_id,
 625:Src/usb_pd_protocol.c **** 				    3, /* Number of Data Objects */
 626:Src/usb_pd_protocol.c **** 				    pd[port].rev,
 627:Src/usb_pd_protocol.c **** 				    1  /* This is an exteded message */
 628:Src/usb_pd_protocol.c **** 				   );
 629:Src/usb_pd_protocol.c **** 
 630:Src/usb_pd_protocol.c **** 	/* Set extended header */
 631:Src/usb_pd_protocol.c **** 	msg[0] = PD_EXT_HEADER(0, /* Chunk Number */
 632:Src/usb_pd_protocol.c **** 			       0, /* Request Chunk */
 633:Src/usb_pd_protocol.c **** 			       9  /* Data Size in bytes */
 634:Src/usb_pd_protocol.c **** 			      );
 635:Src/usb_pd_protocol.c **** 	/* Set VID */
 636:Src/usb_pd_protocol.c **** 	msg[1] = USB_VID_GOOGLE;
 637:Src/usb_pd_protocol.c **** 
 638:Src/usb_pd_protocol.c **** 	/* Set PID */
 639:Src/usb_pd_protocol.c **** 	msg[2] = CONFIG_USB_PID;
 640:Src/usb_pd_protocol.c **** 
 641:Src/usb_pd_protocol.c **** 	if (battery_is_present()) {
 642:Src/usb_pd_protocol.c **** 		/*
 643:Src/usb_pd_protocol.c **** 		 * We only have one fixed battery,
 644:Src/usb_pd_protocol.c **** 		 * so make sure batt cap ref is 0.
 645:Src/usb_pd_protocol.c **** 		 */
ARM GAS  /tmp/ccoQIC4J.s 			page 16


 646:Src/usb_pd_protocol.c **** 		if (BATT_CAP_REF(payload[0]) != 0) {
 647:Src/usb_pd_protocol.c **** 			/* Invalid battery reference */
 648:Src/usb_pd_protocol.c **** 			msg[5] = 1;
 649:Src/usb_pd_protocol.c **** 		} else {
 650:Src/usb_pd_protocol.c **** 			uint32_t v;
 651:Src/usb_pd_protocol.c **** 			uint32_t c;
 652:Src/usb_pd_protocol.c **** 
 653:Src/usb_pd_protocol.c **** 			/*
 654:Src/usb_pd_protocol.c **** 			 * The Battery Design Capacity field shall return the
 655:Src/usb_pd_protocol.c **** 			 * Battery’s design capacity in tenths of Wh. If the
 656:Src/usb_pd_protocol.c **** 			 * Battery is Hot Swappable and is not present, the
 657:Src/usb_pd_protocol.c **** 			 * Battery Design Capacity field shall be set to 0. If
 658:Src/usb_pd_protocol.c **** 			 * the Battery is unable to report its Design Capacity,
 659:Src/usb_pd_protocol.c **** 			 * it shall return 0xFFFF
 660:Src/usb_pd_protocol.c **** 			 */
 661:Src/usb_pd_protocol.c **** 			msg[3] = 0xffff;
 662:Src/usb_pd_protocol.c **** 
 663:Src/usb_pd_protocol.c **** 			/*
 664:Src/usb_pd_protocol.c **** 			 * The Battery Last Full Charge Capacity field shall
 665:Src/usb_pd_protocol.c **** 			 * return the Battery’s last full charge capacity in
 666:Src/usb_pd_protocol.c **** 			 * tenths of Wh. If the Battery is Hot Swappable and
 667:Src/usb_pd_protocol.c **** 			 * is not present, the Battery Last Full Charge Capacity
 668:Src/usb_pd_protocol.c **** 			 * field shall be set to 0. If the Battery is unable to
 669:Src/usb_pd_protocol.c **** 			 * report its Design Capacity, the Battery Last Full
 670:Src/usb_pd_protocol.c **** 			 * Charge Capacity field shall be set to 0xFFFF.
 671:Src/usb_pd_protocol.c **** 			 */
 672:Src/usb_pd_protocol.c **** 			msg[4] = 0xffff;
 673:Src/usb_pd_protocol.c **** 
 674:Src/usb_pd_protocol.c **** 			if (battery_design_voltage(&v) == 0) {
 675:Src/usb_pd_protocol.c **** 				if (battery_design_capacity(&c) == 0) {
 676:Src/usb_pd_protocol.c **** 					/*
 677:Src/usb_pd_protocol.c **** 					 * Wh = (c * v) / 1000000
 678:Src/usb_pd_protocol.c **** 					 * 10th of a Wh = Wh * 10
 679:Src/usb_pd_protocol.c **** 					 */
 680:Src/usb_pd_protocol.c **** 					msg[3] = DIV_ROUND_NEAREST((c * v),
 681:Src/usb_pd_protocol.c **** 								100000);
 682:Src/usb_pd_protocol.c **** 				}
 683:Src/usb_pd_protocol.c **** 
 684:Src/usb_pd_protocol.c **** 				if (battery_full_charge_capacity(&c) == 0) {
 685:Src/usb_pd_protocol.c **** 					/*
 686:Src/usb_pd_protocol.c **** 					 * Wh = (c * v) / 1000000
 687:Src/usb_pd_protocol.c **** 					 * 10th of a Wh = Wh * 10
 688:Src/usb_pd_protocol.c **** 					 */
 689:Src/usb_pd_protocol.c **** 					msg[4] = DIV_ROUND_NEAREST((c * v),
 690:Src/usb_pd_protocol.c **** 								100000);
 691:Src/usb_pd_protocol.c **** 				}
 692:Src/usb_pd_protocol.c **** 			}
 693:Src/usb_pd_protocol.c **** 		}
 694:Src/usb_pd_protocol.c **** 	}
 695:Src/usb_pd_protocol.c **** 
 696:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, (uint32_t *)msg);
 697:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 698:Src/usb_pd_protocol.c **** 		CPRINTF("batCap>%d\n", bit_len);
 699:Src/usb_pd_protocol.c **** 	return bit_len;
 700:Src/usb_pd_protocol.c **** }
 701:Src/usb_pd_protocol.c **** 
 702:Src/usb_pd_protocol.c **** static int send_battery_status(int port,  uint32_t *payload)
ARM GAS  /tmp/ccoQIC4J.s 			page 17


 703:Src/usb_pd_protocol.c **** {
 704:Src/usb_pd_protocol.c **** 	int bit_len;
 705:Src/usb_pd_protocol.c **** 	uint32_t msg = 0;
 706:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_BATTERY_STATUS,
 707:Src/usb_pd_protocol.c **** 				    pd[port].power_role,
 708:Src/usb_pd_protocol.c **** 				    pd[port].data_role,
 709:Src/usb_pd_protocol.c **** 				    pd[port].msg_id,
 710:Src/usb_pd_protocol.c **** 				    1, /* Number of Data Objects */
 711:Src/usb_pd_protocol.c **** 				    pd[port].rev,
 712:Src/usb_pd_protocol.c **** 				    0 /* This is NOT an extended message */
 713:Src/usb_pd_protocol.c **** 				  );
 714:Src/usb_pd_protocol.c **** 
 715:Src/usb_pd_protocol.c **** 	if (battery_is_present()) {
 716:Src/usb_pd_protocol.c **** 		/*
 717:Src/usb_pd_protocol.c **** 		 * We only have one fixed battery,
 718:Src/usb_pd_protocol.c **** 		 * so make sure batt cap ref is 0.
 719:Src/usb_pd_protocol.c **** 		 */
 720:Src/usb_pd_protocol.c **** 		if (BATT_CAP_REF(payload[0]) != 0) {
 721:Src/usb_pd_protocol.c **** 			/* Invalid battery reference */
 722:Src/usb_pd_protocol.c **** 			msg |= BSDO_INVALID;
 723:Src/usb_pd_protocol.c **** 		} else {
 724:Src/usb_pd_protocol.c **** 			uint32_t v;
 725:Src/usb_pd_protocol.c **** 			uint32_t c;
 726:Src/usb_pd_protocol.c **** 
 727:Src/usb_pd_protocol.c **** 			if (battery_design_voltage(&v) != 0 ||
 728:Src/usb_pd_protocol.c **** 					battery_remaining_capacity(&c) != 0) {
 729:Src/usb_pd_protocol.c **** 				msg |= BSDO_CAP(BSDO_CAP_UNKNOWN);
 730:Src/usb_pd_protocol.c **** 			} else {
 731:Src/usb_pd_protocol.c **** 				/*
 732:Src/usb_pd_protocol.c **** 				 * Wh = (c * v) / 1000000
 733:Src/usb_pd_protocol.c **** 				 * 10th of a Wh = Wh * 10
 734:Src/usb_pd_protocol.c **** 				 */
 735:Src/usb_pd_protocol.c **** 				msg |= BSDO_CAP(DIV_ROUND_NEAREST((c * v),
 736:Src/usb_pd_protocol.c **** 								100000));
 737:Src/usb_pd_protocol.c **** 			}
 738:Src/usb_pd_protocol.c **** 
 739:Src/usb_pd_protocol.c **** 			/* Battery is present */
 740:Src/usb_pd_protocol.c **** 			msg |= BSDO_PRESENT;
 741:Src/usb_pd_protocol.c **** 
 742:Src/usb_pd_protocol.c **** 			/*
 743:Src/usb_pd_protocol.c **** 			 * For drivers that are not smart battery compliant,
 744:Src/usb_pd_protocol.c **** 			 * battery_status() returns EC_ERROR_UNIMPLEMENTED and
 745:Src/usb_pd_protocol.c **** 			 * the battery is assumed to be idle.
 746:Src/usb_pd_protocol.c **** 			 */
 747:Src/usb_pd_protocol.c **** 			if (battery_status(&c) != 0) {
 748:Src/usb_pd_protocol.c **** 				msg |= BSDO_IDLE; /* assume idle */
 749:Src/usb_pd_protocol.c **** 			} else {
 750:Src/usb_pd_protocol.c **** 				if (c & STATUS_FULLY_CHARGED)
 751:Src/usb_pd_protocol.c **** 					/* Fully charged */
 752:Src/usb_pd_protocol.c **** 					msg |= BSDO_IDLE;
 753:Src/usb_pd_protocol.c **** 				else if (c & STATUS_DISCHARGING)
 754:Src/usb_pd_protocol.c **** 					/* Discharging */
 755:Src/usb_pd_protocol.c **** 					msg |= BSDO_DISCHARGING;
 756:Src/usb_pd_protocol.c **** 				/* else battery is charging.*/
 757:Src/usb_pd_protocol.c **** 			}
 758:Src/usb_pd_protocol.c **** 		}
 759:Src/usb_pd_protocol.c **** 	} else {
ARM GAS  /tmp/ccoQIC4J.s 			page 18


 760:Src/usb_pd_protocol.c **** 		msg = BSDO_CAP(BSDO_CAP_UNKNOWN);
 761:Src/usb_pd_protocol.c **** 	}
 762:Src/usb_pd_protocol.c **** 
 763:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, &msg);
 764:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 765:Src/usb_pd_protocol.c **** 		CPRINTF("batStat>%d\n", bit_len);
 766:Src/usb_pd_protocol.c **** 
 767:Src/usb_pd_protocol.c **** 	return bit_len;
 768:Src/usb_pd_protocol.c **** }
 769:Src/usb_pd_protocol.c **** #endif
 770:Src/usb_pd_protocol.c **** 
 771:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 772:Src/usb_pd_protocol.c **** static void send_sink_cap(int port)
 773:Src/usb_pd_protocol.c **** {
 774:Src/usb_pd_protocol.c **** 	int bit_len;
 775:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_SINK_CAP, pd[port].power_role,
 776:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, pd_snk_pdo_cnt,
 777:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 778:Src/usb_pd_protocol.c **** 
 779:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, pd_snk_pdo);
 780:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 781:Src/usb_pd_protocol.c **** 		CPRINTF("snkCAP>%d\n", bit_len);
 782:Src/usb_pd_protocol.c **** }
 783:Src/usb_pd_protocol.c **** 
 784:Src/usb_pd_protocol.c **** static int send_request(int port, uint32_t rdo)
 785:Src/usb_pd_protocol.c **** {
 786:Src/usb_pd_protocol.c **** 	int bit_len;
 787:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_REQUEST, pd[port].power_role,
 788:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 789:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 790:Src/usb_pd_protocol.c **** 
 791:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, &rdo);
 792:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 793:Src/usb_pd_protocol.c **** 		CPRINTF("REQ%d>\n", bit_len);
 794:Src/usb_pd_protocol.c **** 
 795:Src/usb_pd_protocol.c **** 	return bit_len;
 796:Src/usb_pd_protocol.c **** }
 797:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
 798:Src/usb_pd_protocol.c **** static int pd_get_saved_active(int port)
 799:Src/usb_pd_protocol.c **** {
 800:Src/usb_pd_protocol.c **** 	uint8_t val;
 801:Src/usb_pd_protocol.c **** 
 802:Src/usb_pd_protocol.c **** 	if (system_get_bbram(port ? SYSTEM_BBRAM_IDX_PD1 :
 803:Src/usb_pd_protocol.c **** 				    SYSTEM_BBRAM_IDX_PD0, &val)) {
 804:Src/usb_pd_protocol.c **** 		CPRINTS("PD NVRAM FAIL");
 805:Src/usb_pd_protocol.c **** 		return 0;
 806:Src/usb_pd_protocol.c **** 	}
 807:Src/usb_pd_protocol.c **** 	return !!val;
 808:Src/usb_pd_protocol.c **** }
 809:Src/usb_pd_protocol.c **** 
 810:Src/usb_pd_protocol.c **** static void pd_set_saved_active(int port, int val)
 811:Src/usb_pd_protocol.c **** {
 812:Src/usb_pd_protocol.c **** 	if (system_set_bbram(port ? SYSTEM_BBRAM_IDX_PD1 :
 813:Src/usb_pd_protocol.c **** 				    SYSTEM_BBRAM_IDX_PD0, val))
 814:Src/usb_pd_protocol.c **** 		CPRINTS("PD NVRAM FAIL");
 815:Src/usb_pd_protocol.c **** }
 816:Src/usb_pd_protocol.c **** #endif // CONFIG_BBRAM
ARM GAS  /tmp/ccoQIC4J.s 			page 19


 817:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 818:Src/usb_pd_protocol.c **** 
 819:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 820:Src/usb_pd_protocol.c **** static int send_bist_cmd(int port)
 821:Src/usb_pd_protocol.c **** {
 822:Src/usb_pd_protocol.c **** 	/* currently only support sending bist carrier 2 */
 823:Src/usb_pd_protocol.c **** 	uint32_t bdo = BDO(BDO_MODE_CARRIER2, 0);
 824:Src/usb_pd_protocol.c **** 	int bit_len;
 825:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_BIST, pd[port].power_role,
 826:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 827:Src/usb_pd_protocol.c **** 			pd_get_rev(port), 0);
 828:Src/usb_pd_protocol.c **** 
 829:Src/usb_pd_protocol.c **** 	bit_len = pd_transmit(port, TCPC_TX_SOP, header, &bdo);
 830:Src/usb_pd_protocol.c **** 	CPRINTF("BIST>%d\n", bit_len);
 831:Src/usb_pd_protocol.c **** 
 832:Src/usb_pd_protocol.c **** 	return bit_len;
 833:Src/usb_pd_protocol.c **** }
 834:Src/usb_pd_protocol.c **** #endif
 835:Src/usb_pd_protocol.c **** 
 836:Src/usb_pd_protocol.c **** static void queue_vdm(int port, uint32_t *header, const uint32_t *data,
 837:Src/usb_pd_protocol.c **** 			     int data_cnt)
 838:Src/usb_pd_protocol.c **** {
 839:Src/usb_pd_protocol.c **** 	pd[port].vdo_count = data_cnt + 1;
 840:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 841:Src/usb_pd_protocol.c **** 	memcpy(&pd[port].vdo_data[1], data, sizeof(uint32_t) * data_cnt);
 842:Src/usb_pd_protocol.c **** 	/* Set ready, pd task will actually send */
 843:Src/usb_pd_protocol.c **** 	pd[port].vdm_state = VDM_STATE_READY;
 844:Src/usb_pd_protocol.c **** }
 845:Src/usb_pd_protocol.c **** 
 846:Src/usb_pd_protocol.c **** static void handle_vdm_request(int port, int cnt, uint32_t *payload)
 847:Src/usb_pd_protocol.c **** {
 848:Src/usb_pd_protocol.c **** 	int rlen = 0;
 849:Src/usb_pd_protocol.c **** 	uint32_t *rdata;
 850:Src/usb_pd_protocol.c **** 
 851:Src/usb_pd_protocol.c **** 	if (pd[port].vdm_state == VDM_STATE_BUSY) {
 852:Src/usb_pd_protocol.c **** 		/* If UFP responded busy retry after timeout */
 853:Src/usb_pd_protocol.c **** 		if (PD_VDO_CMDT(payload[0]) == CMDT_RSP_BUSY) {
 854:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 855:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 856:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_WAIT_RSP_BUSY;
 857:Src/usb_pd_protocol.c **** 			pd[port].vdo_retry = (payload[0] & ~VDO_CMDT_MASK) |
 858:Src/usb_pd_protocol.c **** 				CMDT_INIT;
 859:Src/usb_pd_protocol.c **** 			return;
 860:Src/usb_pd_protocol.c **** 		} else {
 861:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_DONE;
 862:Src/usb_pd_protocol.c **** 		}
 863:Src/usb_pd_protocol.c **** 	}
 864:Src/usb_pd_protocol.c **** 
 865:Src/usb_pd_protocol.c **** 	if (PD_VDO_SVDM(payload[0]))
 866:Src/usb_pd_protocol.c **** 		rlen = pd_svdm(port, cnt, payload, &rdata);
 867:Src/usb_pd_protocol.c **** 	else
 868:Src/usb_pd_protocol.c **** 		rlen = pd_custom_vdm(port, cnt, payload, &rdata);
 869:Src/usb_pd_protocol.c **** 
 870:Src/usb_pd_protocol.c **** 	if (rlen > 0) {
 871:Src/usb_pd_protocol.c **** 		queue_vdm(port, rdata, &rdata[1], rlen - 1);
 872:Src/usb_pd_protocol.c **** 		return;
 873:Src/usb_pd_protocol.c **** 	}
ARM GAS  /tmp/ccoQIC4J.s 			page 20


 874:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 875:Src/usb_pd_protocol.c **** 		CPRINTF("Unhandled VDM VID %04x CMD %04x\n",
 876:Src/usb_pd_protocol.c **** 			PD_VDO_VID(payload[0]), payload[0] & 0xFFFF);
 877:Src/usb_pd_protocol.c **** }
 878:Src/usb_pd_protocol.c **** 
 879:Src/usb_pd_protocol.c **** void pd_execute_hard_reset(int port)
 880:Src/usb_pd_protocol.c **** {
 881:Src/usb_pd_protocol.c **** 	if (pd[port].last_state == PD_STATE_HARD_RESET_SEND)
 882:Src/usb_pd_protocol.c **** 		CPRINTF("C%d HARD RST TX\n", port);
 883:Src/usb_pd_protocol.c **** 	else
 884:Src/usb_pd_protocol.c **** 		CPRINTF("C%d HARD RST RX\n", port);
 885:Src/usb_pd_protocol.c **** 
 886:Src/usb_pd_protocol.c **** 	pd[port].msg_id = 0;
 887:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 888:Src/usb_pd_protocol.c **** 	pd_dfp_exit_mode(port, 0, 0);
 889:Src/usb_pd_protocol.c **** #endif
 890:Src/usb_pd_protocol.c **** 
 891:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 892:Src/usb_pd_protocol.c **** 	pd[port].rev = PD_REV30;
 893:Src/usb_pd_protocol.c **** 	pd_ca_reset(port);
 894:Src/usb_pd_protocol.c **** #endif
 895:Src/usb_pd_protocol.c **** 	/*
 896:Src/usb_pd_protocol.c **** 	 * Fake set last state to hard reset to make sure that the next
 897:Src/usb_pd_protocol.c **** 	 * state to run knows that we just did a hard reset.
 898:Src/usb_pd_protocol.c **** 	 */
 899:Src/usb_pd_protocol.c **** 	pd[port].last_state = PD_STATE_HARD_RESET_EXECUTE;
 900:Src/usb_pd_protocol.c **** 
 901:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 902:Src/usb_pd_protocol.c **** 	/*
 903:Src/usb_pd_protocol.c **** 	 * If we are swapping to a source and have changed to Rp, restore back
 904:Src/usb_pd_protocol.c **** 	 * to Rd and turn off vbus to match our power_role.
 905:Src/usb_pd_protocol.c **** 	 */
 906:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SNK_SWAP_STANDBY ||
 907:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE) {
 908:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RD);
 909:Src/usb_pd_protocol.c **** 		pd_power_supply_reset(port);
 910:Src/usb_pd_protocol.c **** 	}
 911:Src/usb_pd_protocol.c **** 
 912:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SINK) {
 913:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 914:Src/usb_pd_protocol.c **** 		pd_set_input_current_limit(port, 0, 0);
 915:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 916:Src/usb_pd_protocol.c **** 		//charge_manager_set_ceil(port,
 917:Src/usb_pd_protocol.c **** 		//			CEIL_REQUESTOR_PD,
 918:Src/usb_pd_protocol.c **** 		//			CHARGE_CEIL_NONE);
 919:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
 920:Src/usb_pd_protocol.c **** 
 921:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_HARD_RESET_RECOVER);
 922:Src/usb_pd_protocol.c **** 		return;
 923:Src/usb_pd_protocol.c **** 	}
 924:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
 925:Src/usb_pd_protocol.c **** 
 926:Src/usb_pd_protocol.c **** 	/* We are a source, cut power */
 927:Src/usb_pd_protocol.c **** 	pd_power_supply_reset(port);
 928:Src/usb_pd_protocol.c **** 	pd[port].src_recover = get_time().val + PD_T_SRC_RECOVER;
 929:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 930:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 21


 931:Src/usb_pd_protocol.c **** 
 932:Src/usb_pd_protocol.c **** static void execute_soft_reset(int port)
 933:Src/usb_pd_protocol.c **** {
 934:Src/usb_pd_protocol.c **** 	pd[port].msg_id = 0;
 935:Src/usb_pd_protocol.c **** 	set_state(port, DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_DISCOVERY,
 936:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 937:Src/usb_pd_protocol.c **** 	CPRINTF("C%d Soft Rst\n", port);
 938:Src/usb_pd_protocol.c **** }
 939:Src/usb_pd_protocol.c **** 
 940:Src/usb_pd_protocol.c **** void pd_soft_reset(void)
 941:Src/usb_pd_protocol.c **** {
 942:Src/usb_pd_protocol.c **** 	int i;
 943:Src/usb_pd_protocol.c **** 
 944:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; ++i)
 945:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 946:Src/usb_pd_protocol.c **** 			set_state(i, PD_STATE_SOFT_RESET);
 947:Src/usb_pd_protocol.c **** 			// getting rid of task stuff
 948:Src/usb_pd_protocol.c **** 			//task_wake(PD_PORT_TO_TASK_ID(i));
 949:Src/usb_pd_protocol.c **** 		}
 950:Src/usb_pd_protocol.c **** }
 951:Src/usb_pd_protocol.c **** 
 952:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 953:Src/usb_pd_protocol.c **** /*
 954:Src/usb_pd_protocol.c ****  * Request desired charge voltage from source.
 955:Src/usb_pd_protocol.c ****  * Returns EC_SUCCESS on success or non-zero on failure.
 956:Src/usb_pd_protocol.c ****  */
 957:Src/usb_pd_protocol.c **** static int pd_send_request_msg(int port, int always_send_request)
 958:Src/usb_pd_protocol.c **** {
 959:Src/usb_pd_protocol.c **** 	uint32_t rdo, curr_limit, supply_voltage;
 960:Src/usb_pd_protocol.c **** 	int res;
 961:Src/usb_pd_protocol.c **** 
 962:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 963:Src/usb_pd_protocol.c **** 	//int charging = (charge_manager_get_active_charge_port() == port);
 964:Src/usb_pd_protocol.c **** 	const int charging = 1;
 965:Src/usb_pd_protocol.c **** #else
 966:Src/usb_pd_protocol.c **** 	const int charging = 1;
 967:Src/usb_pd_protocol.c **** #endif
 968:Src/usb_pd_protocol.c **** 
 969:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHECK_MAX_REQUEST_ALLOWED
 970:Src/usb_pd_protocol.c **** 	int max_request_allowed = pd_is_max_request_allowed();
 971:Src/usb_pd_protocol.c **** #else
 972:Src/usb_pd_protocol.c **** 	const int max_request_allowed = 1;
 973:Src/usb_pd_protocol.c **** #endif
 974:Src/usb_pd_protocol.c **** 
 975:Src/usb_pd_protocol.c **** 	/* Clear new power request */
 976:Src/usb_pd_protocol.c **** 	pd[port].new_power_request = 0;
 977:Src/usb_pd_protocol.c **** 
 978:Src/usb_pd_protocol.c **** 	/* Build and send request RDO */
 979:Src/usb_pd_protocol.c **** 	/*
 980:Src/usb_pd_protocol.c **** 	 * If this port is not actively charging or we are not allowed to
 981:Src/usb_pd_protocol.c **** 	 * request the max voltage, then select vSafe5V
 982:Src/usb_pd_protocol.c **** 	 */
 983:Src/usb_pd_protocol.c **** 	res = pd_build_request(port, &rdo, &curr_limit, &supply_voltage,
 984:Src/usb_pd_protocol.c **** 			       charging && max_request_allowed ?
 985:Src/usb_pd_protocol.c **** 					PD_REQUEST_MAX : PD_REQUEST_VSAFE5V);
 986:Src/usb_pd_protocol.c **** 
 987:Src/usb_pd_protocol.c **** 	if (res != EC_SUCCESS)
ARM GAS  /tmp/ccoQIC4J.s 			page 22


 988:Src/usb_pd_protocol.c **** 		/*
 989:Src/usb_pd_protocol.c **** 		 * If fail to choose voltage, do nothing, let source re-send
 990:Src/usb_pd_protocol.c **** 		 * source cap
 991:Src/usb_pd_protocol.c **** 		 */
 992:Src/usb_pd_protocol.c **** 		return -1;
 993:Src/usb_pd_protocol.c **** 
 994:Src/usb_pd_protocol.c **** 	if (!always_send_request) {
 995:Src/usb_pd_protocol.c **** 		/* Don't re-request the same voltage */
 996:Src/usb_pd_protocol.c **** 		if (pd[port].prev_request_mv == supply_voltage)
 997:Src/usb_pd_protocol.c **** 			return EC_SUCCESS;
 998:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 999:Src/usb_pd_protocol.c **** 		/* Limit current to PD_MIN_MA during transition */
1000:Src/usb_pd_protocol.c **** 		//else
1001:Src/usb_pd_protocol.c **** 		//	charge_manager_force_ceil(port, PD_MIN_MA);
1002:Src/usb_pd_protocol.c **** #endif
1003:Src/usb_pd_protocol.c **** 	}
1004:Src/usb_pd_protocol.c **** 
1005:Src/usb_pd_protocol.c **** 	CPRINTF("Req C%d [%d] %dmV %dmA", port, RDO_POS(rdo),
1006:Src/usb_pd_protocol.c **** 		supply_voltage, curr_limit);
1007:Src/usb_pd_protocol.c **** 	if (rdo & RDO_CAP_MISMATCH)
1008:Src/usb_pd_protocol.c **** 		CPRINTF(" Mismatch");
1009:Src/usb_pd_protocol.c **** 	CPRINTF("\n");
1010:Src/usb_pd_protocol.c **** 
1011:Src/usb_pd_protocol.c **** 	pd[port].curr_limit = curr_limit;
1012:Src/usb_pd_protocol.c **** 	pd[port].supply_voltage = supply_voltage;
1013:Src/usb_pd_protocol.c **** 	pd[port].prev_request_mv = supply_voltage;
1014:Src/usb_pd_protocol.c **** 	res = send_request(port, rdo);
1015:Src/usb_pd_protocol.c **** 	if (res < 0)
1016:Src/usb_pd_protocol.c **** 		return res;
1017:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SNK_REQUESTED);
1018:Src/usb_pd_protocol.c **** 	return EC_SUCCESS;
1019:Src/usb_pd_protocol.c **** }
1020:Src/usb_pd_protocol.c **** #endif
1021:Src/usb_pd_protocol.c **** 
1022:Src/usb_pd_protocol.c **** static void pd_update_pdo_flags(int port, uint32_t pdo)
1023:Src/usb_pd_protocol.c **** {
 126              		.loc 1 1023 1 is_stmt 1 view -0
 127              		.cfi_startproc
 128              		@ args = 0, pretend = 0, frame = 0
 129              		@ frame_needed = 0, uses_anonymous_args = 0
 130              		.loc 1 1023 1 is_stmt 0 view .LVU21
 131 0000 10B5     		push	{r4, lr}
 132              	.LCFI1:
 133              		.cfi_def_cfa_offset 8
 134              		.cfi_offset 4, -8
 135              		.cfi_offset 14, -4
1024:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
1025:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
1026:Src/usb_pd_protocol.c **** 	int charge_whitelisted =
1027:Src/usb_pd_protocol.c **** 		(pd[port].power_role == PD_ROLE_SINK &&
1028:Src/usb_pd_protocol.c **** 		 pd_charge_from_device(pd_get_identity_vid(port),
1029:Src/usb_pd_protocol.c **** 				       pd_get_identity_pid(port)));
1030:Src/usb_pd_protocol.c **** #else
1031:Src/usb_pd_protocol.c **** 	const int charge_whitelisted = 0;
 136              		.loc 1 1031 2 is_stmt 1 view .LVU22
 137              	.LVL6:
1032:Src/usb_pd_protocol.c **** #endif
ARM GAS  /tmp/ccoQIC4J.s 			page 23


1033:Src/usb_pd_protocol.c **** #endif
1034:Src/usb_pd_protocol.c **** 
1035:Src/usb_pd_protocol.c **** 	/* can only parse PDO flags if type is fixed */
1036:Src/usb_pd_protocol.c **** 	if ((pdo & PDO_TYPE_MASK) != PDO_TYPE_FIXED)
 138              		.loc 1 1036 2 view .LVU23
 139              		.loc 1 1036 11 is_stmt 0 view .LVU24
 140 0002 8B0F     		lsrs	r3, r1, #30
 141              		.loc 1 1036 5 view .LVU25
 142 0004 25D1     		bne	.L7
1037:Src/usb_pd_protocol.c **** 		return;
1038:Src/usb_pd_protocol.c **** 
1039:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1040:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_DUAL_ROLE)
 143              		.loc 1 1040 2 is_stmt 1 view .LVU26
 144              		.loc 1 1040 5 is_stmt 0 view .LVU27
 145 0006 8B00     		lsls	r3, r1, #2
 146 0008 24D5     		bpl	.L9
1041:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_DR_POWER;
 147              		.loc 1 1041 3 is_stmt 1 view .LVU28
 148              		.loc 1 1041 18 is_stmt 0 view .LVU29
 149 000a C201     		lsls	r2, r0, #7
 150 000c 214B     		ldr	r3, .L16
 151 000e 9B18     		adds	r3, r3, r2
 152 0010 0222     		movs	r2, #2
 153 0012 9C68     		ldr	r4, [r3, #8]
 154 0014 2243     		orrs	r2, r4
 155 0016 9A60     		str	r2, [r3, #8]
 156              	.L10:
1042:Src/usb_pd_protocol.c **** 	else
1043:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_DR_POWER;
1044:Src/usb_pd_protocol.c **** 
1045:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_EXTERNAL)
 157              		.loc 1 1045 2 is_stmt 1 view .LVU30
 158              		.loc 1 1045 5 is_stmt 0 view .LVU31
 159 0018 0B01     		lsls	r3, r1, #4
 160 001a 23D5     		bpl	.L11
1046:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_EXTPOWER;
 161              		.loc 1 1046 3 is_stmt 1 view .LVU32
 162              		.loc 1 1046 18 is_stmt 0 view .LVU33
 163 001c C201     		lsls	r2, r0, #7
 164 001e 1D4B     		ldr	r3, .L16
 165 0020 9B18     		adds	r3, r3, r2
 166 0022 8022     		movs	r2, #128
 167 0024 1201     		lsls	r2, r2, #4
 168 0026 9C68     		ldr	r4, [r3, #8]
 169 0028 2243     		orrs	r2, r4
 170 002a 9A60     		str	r2, [r3, #8]
 171              	.L12:
1047:Src/usb_pd_protocol.c **** 	else
1048:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_EXTPOWER;
1049:Src/usb_pd_protocol.c **** 
1050:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_COMM_CAP)
 172              		.loc 1 1050 2 is_stmt 1 view .LVU34
 173              		.loc 1 1050 5 is_stmt 0 view .LVU35
 174 002c 4B01     		lsls	r3, r1, #5
 175 002e 21D5     		bpl	.L13
1051:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_USB_COMM;
ARM GAS  /tmp/ccoQIC4J.s 			page 24


 176              		.loc 1 1051 3 is_stmt 1 view .LVU36
 177              		.loc 1 1051 18 is_stmt 0 view .LVU37
 178 0030 C201     		lsls	r2, r0, #7
 179 0032 184B     		ldr	r3, .L16
 180 0034 9B18     		adds	r3, r3, r2
 181 0036 8022     		movs	r2, #128
 182 0038 D201     		lsls	r2, r2, #7
 183 003a 9C68     		ldr	r4, [r3, #8]
 184 003c 2243     		orrs	r2, r4
 185 003e 9A60     		str	r2, [r3, #8]
 186              	.L14:
1052:Src/usb_pd_protocol.c **** 	else
1053:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_USB_COMM;
1054:Src/usb_pd_protocol.c **** #endif
1055:Src/usb_pd_protocol.c **** 
1056:Src/usb_pd_protocol.c **** 	if (pdo & PDO_FIXED_DATA_SWAP)
 187              		.loc 1 1056 2 is_stmt 1 view .LVU38
 188              		.loc 1 1056 5 is_stmt 0 view .LVU39
 189 0040 8B01     		lsls	r3, r1, #6
 190 0042 1FD5     		bpl	.L15
1057:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PARTNER_DR_DATA;
 191              		.loc 1 1057 3 is_stmt 1 view .LVU40
 192              		.loc 1 1057 18 is_stmt 0 view .LVU41
 193 0044 C001     		lsls	r0, r0, #7
 194              	.LVL7:
 195              		.loc 1 1057 18 view .LVU42
 196 0046 134B     		ldr	r3, .L16
 197 0048 1818     		adds	r0, r3, r0
 198 004a 0423     		movs	r3, #4
 199 004c 8268     		ldr	r2, [r0, #8]
 200 004e 1343     		orrs	r3, r2
 201 0050 8360     		str	r3, [r0, #8]
 202              	.L7:
1058:Src/usb_pd_protocol.c **** 	else
1059:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PARTNER_DR_DATA;
1060:Src/usb_pd_protocol.c **** 
1061:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
1062:Src/usb_pd_protocol.c **** 	/*
1063:Src/usb_pd_protocol.c **** 	 * Treat device as a dedicated charger (meaning we should charge
1064:Src/usb_pd_protocol.c **** 	 * from it) if it does not support power swap, or if it is externally
1065:Src/usb_pd_protocol.c **** 	 * powered, or if we are a sink and the device identity matches a
1066:Src/usb_pd_protocol.c **** 	 * charging white-list.
1067:Src/usb_pd_protocol.c **** 	 */
1068:Src/usb_pd_protocol.c **** 	/*
1069:Src/usb_pd_protocol.c **** 	if (!(pd[port].flags & PD_FLAGS_PARTNER_DR_POWER) ||
1070:Src/usb_pd_protocol.c **** 	    (pd[port].flags & PD_FLAGS_PARTNER_EXTPOWER) ||
1071:Src/usb_pd_protocol.c **** 	    charge_whitelisted)
1072:Src/usb_pd_protocol.c **** 		charge_manager_update_dualrole(port, CAP_DEDICATED);
1073:Src/usb_pd_protocol.c **** 	else
1074:Src/usb_pd_protocol.c **** 		charge_manager_update_dualrole(port, CAP_DUALROLE);
1075:Src/usb_pd_protocol.c **** 	*/
1076:Src/usb_pd_protocol.c **** #endif
1077:Src/usb_pd_protocol.c **** }
 203              		.loc 1 1077 1 view .LVU43
 204              		@ sp needed
 205 0052 10BD     		pop	{r4, pc}
 206              	.LVL8:
ARM GAS  /tmp/ccoQIC4J.s 			page 25


 207              	.L9:
1043:Src/usb_pd_protocol.c **** 
 208              		.loc 1 1043 3 is_stmt 1 view .LVU44
1043:Src/usb_pd_protocol.c **** 
 209              		.loc 1 1043 18 is_stmt 0 view .LVU45
 210 0054 C201     		lsls	r2, r0, #7
 211 0056 0F4B     		ldr	r3, .L16
 212 0058 9B18     		adds	r3, r3, r2
 213 005a 0222     		movs	r2, #2
 214 005c 9C68     		ldr	r4, [r3, #8]
 215 005e 9443     		bics	r4, r2
 216 0060 9C60     		str	r4, [r3, #8]
 217 0062 D9E7     		b	.L10
 218              	.L11:
1048:Src/usb_pd_protocol.c **** 
 219              		.loc 1 1048 3 is_stmt 1 view .LVU46
1048:Src/usb_pd_protocol.c **** 
 220              		.loc 1 1048 18 is_stmt 0 view .LVU47
 221 0064 C201     		lsls	r2, r0, #7
 222 0066 0B4B     		ldr	r3, .L16
 223 0068 9B18     		adds	r3, r3, r2
 224 006a 0B4A     		ldr	r2, .L16+4
 225 006c 9C68     		ldr	r4, [r3, #8]
 226 006e 2240     		ands	r2, r4
 227 0070 9A60     		str	r2, [r3, #8]
 228 0072 DBE7     		b	.L12
 229              	.L13:
1053:Src/usb_pd_protocol.c **** #endif
 230              		.loc 1 1053 3 is_stmt 1 view .LVU48
1053:Src/usb_pd_protocol.c **** #endif
 231              		.loc 1 1053 18 is_stmt 0 view .LVU49
 232 0074 C201     		lsls	r2, r0, #7
 233 0076 074B     		ldr	r3, .L16
 234 0078 9B18     		adds	r3, r3, r2
 235 007a 084A     		ldr	r2, .L16+8
 236 007c 9C68     		ldr	r4, [r3, #8]
 237 007e 2240     		ands	r2, r4
 238 0080 9A60     		str	r2, [r3, #8]
 239 0082 DDE7     		b	.L14
 240              	.L15:
1059:Src/usb_pd_protocol.c **** 
 241              		.loc 1 1059 3 is_stmt 1 view .LVU50
1059:Src/usb_pd_protocol.c **** 
 242              		.loc 1 1059 18 is_stmt 0 view .LVU51
 243 0084 C001     		lsls	r0, r0, #7
 244              	.LVL9:
1059:Src/usb_pd_protocol.c **** 
 245              		.loc 1 1059 18 view .LVU52
 246 0086 034B     		ldr	r3, .L16
 247 0088 1818     		adds	r0, r3, r0
 248 008a 0423     		movs	r3, #4
 249 008c 8268     		ldr	r2, [r0, #8]
 250 008e 9A43     		bics	r2, r3
 251 0090 8260     		str	r2, [r0, #8]
 252 0092 DEE7     		b	.L7
 253              	.L17:
 254              		.align	2
ARM GAS  /tmp/ccoQIC4J.s 			page 26


 255              	.L16:
 256 0094 00000000 		.word	pd
 257 0098 FFF7FFFF 		.word	-2049
 258 009c FFBFFFFF 		.word	-16385
 259              		.cfi_endproc
 260              	.LFE39:
 262              		.section	.text.vdm_get_ready_timeout,"ax",%progbits
 263              		.align	1
 264              		.syntax unified
 265              		.code	16
 266              		.thumb_func
 267              		.fpu softvfp
 269              	vdm_get_ready_timeout:
 270              	.LVL10:
 271              	.LFB49:
1078:Src/usb_pd_protocol.c **** 
1079:Src/usb_pd_protocol.c **** static void handle_data_request(int port, uint16_t head,
1080:Src/usb_pd_protocol.c **** 		uint32_t *payload)
1081:Src/usb_pd_protocol.c **** {
1082:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
1083:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
1084:Src/usb_pd_protocol.c **** 
1085:Src/usb_pd_protocol.c **** 	switch (type) {
1086:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1087:Src/usb_pd_protocol.c **** 	case PD_DATA_SOURCE_CAP:
1088:Src/usb_pd_protocol.c **** 		if ((pd[port].task_state == PD_STATE_SNK_DISCOVERY)
1089:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_TRANSITION)
1090:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_NONE
1091:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state ==
1092:Src/usb_pd_protocol.c **** 			    PD_STATE_SNK_HARD_RESET_RECOVER)
1093:Src/usb_pd_protocol.c **** #endif
1094:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_READY)) {
1095:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1096:Src/usb_pd_protocol.c **** 			/*
1097:Src/usb_pd_protocol.c **** 			 * Only adjust sink rev if source rev is higher.
1098:Src/usb_pd_protocol.c **** 			 */
1099:Src/usb_pd_protocol.c **** 			if (PD_HEADER_REV(head) < pd[port].rev)
1100:Src/usb_pd_protocol.c **** 				pd[port].rev = PD_HEADER_REV(head);
1101:Src/usb_pd_protocol.c **** #endif
1102:Src/usb_pd_protocol.c **** 			/* Port partner is now known to be PD capable */
1103:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_PREVIOUS_PD_CONN;
1104:Src/usb_pd_protocol.c **** 
1105:Src/usb_pd_protocol.c **** 			/* src cap 0 should be fixed PDO */
1106:Src/usb_pd_protocol.c **** 			pd_update_pdo_flags(port, payload[0]);
1107:Src/usb_pd_protocol.c **** 
1108:Src/usb_pd_protocol.c **** 			pd_process_source_cap(port, cnt, payload);
1109:Src/usb_pd_protocol.c **** 			pd_process_source_cap_callback(port, cnt, payload);
1110:Src/usb_pd_protocol.c **** 
1111:Src/usb_pd_protocol.c **** 			/* Source will resend source cap on failure */
1112:Src/usb_pd_protocol.c **** 			pd_send_request_msg(port, 1);
1113:Src/usb_pd_protocol.c **** 		}
1114:Src/usb_pd_protocol.c **** 		break;
1115:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
1116:Src/usb_pd_protocol.c **** 	case PD_DATA_REQUEST:
1117:Src/usb_pd_protocol.c **** 		if ((pd[port].power_role == PD_ROLE_SOURCE) && (cnt == 1)) {
1118:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1119:Src/usb_pd_protocol.c **** 			/*
ARM GAS  /tmp/ccoQIC4J.s 			page 27


1120:Src/usb_pd_protocol.c **** 			 * Adjust the rev level to what the sink supports. If
1121:Src/usb_pd_protocol.c **** 			 * they're equal, no harm done.
1122:Src/usb_pd_protocol.c **** 			 */
1123:Src/usb_pd_protocol.c **** 			pd[port].rev = PD_HEADER_REV(head);
1124:Src/usb_pd_protocol.c **** #endif
1125:Src/usb_pd_protocol.c **** 			if (!pd_check_requested_voltage(payload[0], port)) {
1126:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
1127:Src/usb_pd_protocol.c **** 					/*
1128:Src/usb_pd_protocol.c **** 					 * if we fail to send accept, do
1129:Src/usb_pd_protocol.c **** 					 * nothing and let sink timeout and
1130:Src/usb_pd_protocol.c **** 					 * send hard reset
1131:Src/usb_pd_protocol.c **** 					 */
1132:Src/usb_pd_protocol.c **** 					return;
1133:Src/usb_pd_protocol.c **** 
1134:Src/usb_pd_protocol.c **** 				/* explicit contract is now in place */
1135:Src/usb_pd_protocol.c **** 				pd[port].flags |= PD_FLAGS_EXPLICIT_CONTRACT;
1136:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1137:Src/usb_pd_protocol.c **** 				/*
1138:Src/usb_pd_protocol.c **** 				 * Start Source-coordinated collision
1139:Src/usb_pd_protocol.c **** 				 * avoidance
1140:Src/usb_pd_protocol.c **** 				 */
1141:Src/usb_pd_protocol.c **** 				if (pd[port].rev == PD_REV30 &&
1142:Src/usb_pd_protocol.c **** 					pd[port].power_role == PD_ROLE_SOURCE)
1143:Src/usb_pd_protocol.c **** 					sink_can_xmit(port, SINK_TX_OK);
1144:Src/usb_pd_protocol.c **** #endif
1145:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1146:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1147:Src/usb_pd_protocol.c **** 				pd_set_saved_active(port, 1);
1148:Src/usb_pd_protocol.c **** #endif
1149:Src/usb_pd_protocol.c **** #endif
1150:Src/usb_pd_protocol.c **** 				pd[port].requested_idx = RDO_POS(payload[0]);
1151:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_ACCEPTED);
1152:Src/usb_pd_protocol.c **** 				return;
1153:Src/usb_pd_protocol.c **** 			}
1154:Src/usb_pd_protocol.c **** 		}
1155:Src/usb_pd_protocol.c **** 		/* the message was incorrect or cannot be satisfied */
1156:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_REJECT);
1157:Src/usb_pd_protocol.c **** 		/* keep last contract in place (whether implicit or explicit) */
1158:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_READY);
1159:Src/usb_pd_protocol.c **** 		break;
1160:Src/usb_pd_protocol.c **** 	case PD_DATA_BIST:
1161:Src/usb_pd_protocol.c **** 		/* If not in READY state, then don't start BIST */
1162:Src/usb_pd_protocol.c **** 		if (DUAL_ROLE_IF_ELSE(port,
1163:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
1164:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SRC_READY)) {
1165:Src/usb_pd_protocol.c **** 			/* currently only support sending bist carrier mode 2 */
1166:Src/usb_pd_protocol.c **** 			if ((payload[0] >> 28) == 5) {
1167:Src/usb_pd_protocol.c **** 				/* bist data object mode is 2 */
1168:Src/usb_pd_protocol.c **** 				pd_transmit(port, TCPC_TX_BIST_MODE_2, 0,
1169:Src/usb_pd_protocol.c **** 					    NULL);
1170:Src/usb_pd_protocol.c **** 				/* Set to appropriate port disconnected state */
1171:Src/usb_pd_protocol.c **** 				set_state(port, DUAL_ROLE_IF_ELSE(port,
1172:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
1173:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED));
1174:Src/usb_pd_protocol.c **** 			}
1175:Src/usb_pd_protocol.c **** 		}
1176:Src/usb_pd_protocol.c **** 		break;
ARM GAS  /tmp/ccoQIC4J.s 			page 28


1177:Src/usb_pd_protocol.c **** 	case PD_DATA_SINK_CAP:
1178:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_SNK_CAP_RECVD;
1179:Src/usb_pd_protocol.c **** 		/* snk cap 0 should be fixed PDO */
1180:Src/usb_pd_protocol.c **** 		pd_update_pdo_flags(port, payload[0]);
1181:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SRC_GET_SINK_CAP)
1182:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
1183:Src/usb_pd_protocol.c **** 		break;
1184:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1185:Src/usb_pd_protocol.c **** 	case PD_DATA_BATTERY_STATUS:
1186:Src/usb_pd_protocol.c **** 		break;
1187:Src/usb_pd_protocol.c **** #endif
1188:Src/usb_pd_protocol.c **** 	case PD_DATA_VENDOR_DEF:
1189:Src/usb_pd_protocol.c **** 		handle_vdm_request(port, cnt, payload);
1190:Src/usb_pd_protocol.c **** 		break;
1191:Src/usb_pd_protocol.c **** 	default:
1192:Src/usb_pd_protocol.c **** 		CPRINTF("Unhandled data message type %d\n", type);
1193:Src/usb_pd_protocol.c **** 	}
1194:Src/usb_pd_protocol.c **** }
1195:Src/usb_pd_protocol.c **** 
1196:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1197:Src/usb_pd_protocol.c **** void pd_request_power_swap(int port)
1198:Src/usb_pd_protocol.c **** {
1199:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SRC_READY)
1200:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_SWAP_INIT);
1201:Src/usb_pd_protocol.c **** 	else if (pd[port].task_state == PD_STATE_SNK_READY)
1202:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_SWAP_INIT);
1203:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1204:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1205:Src/usb_pd_protocol.c **** }
1206:Src/usb_pd_protocol.c **** 
1207:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1208:Src/usb_pd_protocol.c **** static void pd_request_vconn_swap(int port)
1209:Src/usb_pd_protocol.c **** {
1210:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SRC_READY ||
1211:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_READY)
1212:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_VCONN_SWAP_SEND);
1213:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1214:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1215:Src/usb_pd_protocol.c **** }
1216:Src/usb_pd_protocol.c **** 
1217:Src/usb_pd_protocol.c **** void pd_try_vconn_src(int port)
1218:Src/usb_pd_protocol.c **** {
1219:Src/usb_pd_protocol.c **** 	/*
1220:Src/usb_pd_protocol.c **** 	 * If we don't currently provide vconn, and we can supply it, send
1221:Src/usb_pd_protocol.c **** 	 * a vconn swap request.
1222:Src/usb_pd_protocol.c **** 	 */
1223:Src/usb_pd_protocol.c **** 	if (!(pd[port].flags & PD_FLAGS_VCONN_ON)) {
1224:Src/usb_pd_protocol.c **** 		if (pd_check_vconn_swap(port))
1225:Src/usb_pd_protocol.c **** 			pd_request_vconn_swap(port);
1226:Src/usb_pd_protocol.c **** 	}
1227:Src/usb_pd_protocol.c **** }
1228:Src/usb_pd_protocol.c **** #endif
1229:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
1230:Src/usb_pd_protocol.c **** 
1231:Src/usb_pd_protocol.c **** void pd_request_data_swap(int port)
1232:Src/usb_pd_protocol.c **** {
1233:Src/usb_pd_protocol.c **** 	if (DUAL_ROLE_IF_ELSE(port,
ARM GAS  /tmp/ccoQIC4J.s 			page 29


1234:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
1235:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SRC_READY))
1236:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_DR_SWAP);
1237:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1238:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1239:Src/usb_pd_protocol.c **** }
1240:Src/usb_pd_protocol.c **** 
1241:Src/usb_pd_protocol.c **** static void pd_set_data_role(int port, int role)
1242:Src/usb_pd_protocol.c **** {
1243:Src/usb_pd_protocol.c **** 	pd[port].data_role = role;
1244:Src/usb_pd_protocol.c **** 	pd_execute_data_swap(port, role);
1245:Src/usb_pd_protocol.c **** 
1246:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
1247:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX_DFP_ONLY
1248:Src/usb_pd_protocol.c **** 	/*
1249:Src/usb_pd_protocol.c **** 	 * Need to connect SS mux for if new data role is DFP.
1250:Src/usb_pd_protocol.c **** 	 * If new data role is UFP, then disconnect the SS mux.
1251:Src/usb_pd_protocol.c **** 	 */
1252:Src/usb_pd_protocol.c **** 	if (role == PD_ROLE_DFP)
1253:Src/usb_pd_protocol.c **** 		usb_mux_set(port, TYPEC_MUX_USB, USB_SWITCH_CONNECT,
1254:Src/usb_pd_protocol.c **** 			    pd[port].polarity);
1255:Src/usb_pd_protocol.c **** 	else
1256:Src/usb_pd_protocol.c **** 		usb_mux_set(port, TYPEC_MUX_NONE, USB_SWITCH_DISCONNECT,
1257:Src/usb_pd_protocol.c **** 			    pd[port].polarity);
1258:Src/usb_pd_protocol.c **** #else
1259:Src/usb_pd_protocol.c **** 	usb_mux_set(port, TYPEC_MUX_USB, USB_SWITCH_CONNECT,
1260:Src/usb_pd_protocol.c **** 		    pd[port].polarity);
1261:Src/usb_pd_protocol.c **** #endif
1262:Src/usb_pd_protocol.c **** #endif
1263:Src/usb_pd_protocol.c **** 	pd_update_roles(port);
1264:Src/usb_pd_protocol.c **** }
1265:Src/usb_pd_protocol.c **** 
1266:Src/usb_pd_protocol.c **** static void pd_dr_swap(int port)
1267:Src/usb_pd_protocol.c **** {
1268:Src/usb_pd_protocol.c **** 	pd_set_data_role(port, !pd[port].data_role);
1269:Src/usb_pd_protocol.c **** 	pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
1270:Src/usb_pd_protocol.c **** }
1271:Src/usb_pd_protocol.c **** 
1272:Src/usb_pd_protocol.c **** static void handle_ctrl_request(int port, uint16_t head,
1273:Src/usb_pd_protocol.c **** 		uint32_t *payload)
1274:Src/usb_pd_protocol.c **** {
1275:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
1276:Src/usb_pd_protocol.c **** 	int res;
1277:Src/usb_pd_protocol.c **** 
1278:Src/usb_pd_protocol.c **** 	switch (type) {
1279:Src/usb_pd_protocol.c **** 	case PD_CTRL_GOOD_CRC:
1280:Src/usb_pd_protocol.c **** 		/* should not get it */
1281:Src/usb_pd_protocol.c **** 		break;
1282:Src/usb_pd_protocol.c **** 	case PD_CTRL_PING:
1283:Src/usb_pd_protocol.c **** 		/* Nothing else to do */
1284:Src/usb_pd_protocol.c **** 		break;
1285:Src/usb_pd_protocol.c **** 	case PD_CTRL_GET_SOURCE_CAP:
1286:Src/usb_pd_protocol.c **** 		res = send_source_cap(port);
1287:Src/usb_pd_protocol.c **** 		if ((res >= 0) &&
1288:Src/usb_pd_protocol.c **** 		    (pd[port].task_state == PD_STATE_SRC_DISCOVERY))
1289:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_NEGOCIATE);
1290:Src/usb_pd_protocol.c **** 		break;
ARM GAS  /tmp/ccoQIC4J.s 			page 30


1291:Src/usb_pd_protocol.c **** 	case PD_CTRL_GET_SINK_CAP:
1292:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1293:Src/usb_pd_protocol.c **** 		send_sink_cap(port);
1294:Src/usb_pd_protocol.c **** #else
1295:Src/usb_pd_protocol.c **** 		send_control(port, REFUSE(pd[port].rev));
1296:Src/usb_pd_protocol.c **** #endif
1297:Src/usb_pd_protocol.c **** 		break;
1298:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1299:Src/usb_pd_protocol.c **** 	case PD_CTRL_GOTO_MIN:
1300:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_GIVE_BACK
1301:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SNK_READY) {
1302:Src/usb_pd_protocol.c **** 			/*
1303:Src/usb_pd_protocol.c **** 			 * Reduce power consumption now!
1304:Src/usb_pd_protocol.c **** 			 *
1305:Src/usb_pd_protocol.c **** 			 * The source will restore power to this sink
1306:Src/usb_pd_protocol.c **** 			 * by sending a new source cap message at a
1307:Src/usb_pd_protocol.c **** 			 * later time.
1308:Src/usb_pd_protocol.c **** 			 */
1309:Src/usb_pd_protocol.c **** 			pd_snk_give_back(port, &pd[port].curr_limit,
1310:Src/usb_pd_protocol.c **** 				&pd[port].supply_voltage);
1311:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_TRANSITION);
1312:Src/usb_pd_protocol.c **** 		}
1313:Src/usb_pd_protocol.c **** #endif
1314:Src/usb_pd_protocol.c **** 
1315:Src/usb_pd_protocol.c **** 		break;
1316:Src/usb_pd_protocol.c **** 	case PD_CTRL_PS_RDY:
1317:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SNK_SWAP_SRC_DISABLE) {
1318:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_STANDBY);
1319:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SRC_SWAP_STANDBY) {
1320:Src/usb_pd_protocol.c **** 			/* reset message ID and swap roles */
1321:Src/usb_pd_protocol.c **** 			pd[port].msg_id = 0;
1322:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
1323:Src/usb_pd_protocol.c **** 			pd_update_roles(port);
1324:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
1325:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1326:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_VCONN_SWAP_INIT) {
1327:Src/usb_pd_protocol.c **** 			/*
1328:Src/usb_pd_protocol.c **** 			 * If VCONN is on, then this PS_RDY tells us it's
1329:Src/usb_pd_protocol.c **** 			 * ok to turn VCONN off
1330:Src/usb_pd_protocol.c **** 			 */
1331:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_VCONN_ON)
1332:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_VCONN_SWAP_READY);
1333:Src/usb_pd_protocol.c **** #endif
1334:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_DISCOVERY) {
1335:Src/usb_pd_protocol.c **** 			/* Don't know what power source is ready. Reset. */
1336:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_HARD_RESET_SEND);
1337:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_SWAP_STANDBY) {
1338:Src/usb_pd_protocol.c **** 			/* Do nothing, assume this is a redundant PD_RDY */
1339:Src/usb_pd_protocol.c **** 		} else if (pd[port].power_role == PD_ROLE_SINK) {
1340:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
1341:Src/usb_pd_protocol.c **** 			pd_set_input_current_limit(port, pd[port].curr_limit,
1342:Src/usb_pd_protocol.c **** 						   pd[port].supply_voltage);
1343:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
1344:Src/usb_pd_protocol.c **** 			/* Set ceiling based on what's negotiated */
1345:Src/usb_pd_protocol.c **** 			//charge_manager_set_ceil(port,
1346:Src/usb_pd_protocol.c **** 			//			CEIL_REQUESTOR_PD,
1347:Src/usb_pd_protocol.c **** 			//			pd[port].curr_limit);
ARM GAS  /tmp/ccoQIC4J.s 			page 31


1348:Src/usb_pd_protocol.c **** #endif
1349:Src/usb_pd_protocol.c **** 		}
1350:Src/usb_pd_protocol.c **** 		break;
1351:Src/usb_pd_protocol.c **** #endif
1352:Src/usb_pd_protocol.c **** 	case PD_CTRL_REJECT:
1353:Src/usb_pd_protocol.c **** 	case PD_CTRL_WAIT:
1354:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_DR_SWAP)
1355:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
1356:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1357:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_VCONN_SWAP_SEND)
1358:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
1359:Src/usb_pd_protocol.c **** #endif
1360:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1361:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SRC_SWAP_INIT)
1362:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
1363:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SNK_SWAP_INIT)
1364:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
1365:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SNK_REQUESTED) {
1366:Src/usb_pd_protocol.c **** 			/*
1367:Src/usb_pd_protocol.c **** 			 * Explicit Contract in place
1368:Src/usb_pd_protocol.c **** 			 *
1369:Src/usb_pd_protocol.c **** 			 *  On reception of a WAIT message, transition to
1370:Src/usb_pd_protocol.c **** 			 *  PD_STATE_SNK_READY after PD_T_SINK_REQUEST ms to
1371:Src/usb_pd_protocol.c **** 			 *  send another reqest.
1372:Src/usb_pd_protocol.c **** 			 *
1373:Src/usb_pd_protocol.c **** 			 *  On reception of a REJECT messag, transition to
1374:Src/usb_pd_protocol.c **** 			 *  PD_STATE_SNK_READY but don't resend the request.
1375:Src/usb_pd_protocol.c **** 			 *
1376:Src/usb_pd_protocol.c **** 			 * NO Explicit Contract in place
1377:Src/usb_pd_protocol.c **** 			 *
1378:Src/usb_pd_protocol.c **** 			 *  On reception of a WAIT or REJECT message,
1379:Src/usb_pd_protocol.c **** 			 *  transition to PD_STATE_SNK_DISCOVERY
1380:Src/usb_pd_protocol.c **** 			 */
1381:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_EXPLICIT_CONTRACT) {
1382:Src/usb_pd_protocol.c **** 				/* We have an explicit contract */
1383:Src/usb_pd_protocol.c **** 				if (type == PD_CTRL_WAIT) {
1384:Src/usb_pd_protocol.c **** 					/*
1385:Src/usb_pd_protocol.c **** 					 * Trigger a new power request when
1386:Src/usb_pd_protocol.c **** 					 * we enter PD_STATE_SNK_READY
1387:Src/usb_pd_protocol.c **** 					 */
1388:Src/usb_pd_protocol.c **** 					pd[port].new_power_request = 1;
1389:Src/usb_pd_protocol.c **** 
1390:Src/usb_pd_protocol.c **** 					/*
1391:Src/usb_pd_protocol.c **** 					 * After the request is triggered,
1392:Src/usb_pd_protocol.c **** 					 * make sure the request is sent.
1393:Src/usb_pd_protocol.c **** 					 */
1394:Src/usb_pd_protocol.c **** 					pd[port].prev_request_mv = 0;
1395:Src/usb_pd_protocol.c **** 
1396:Src/usb_pd_protocol.c **** 					/*
1397:Src/usb_pd_protocol.c **** 					 * Transition to PD_STATE_SNK_READY
1398:Src/usb_pd_protocol.c **** 					 * after PD_T_SINK_REQUEST ms.
1399:Src/usb_pd_protocol.c **** 					 */
1400:Src/usb_pd_protocol.c **** 					set_state_timeout(port, get_time().val +
1401:Src/usb_pd_protocol.c **** 							PD_T_SINK_REQUEST,
1402:Src/usb_pd_protocol.c **** 							PD_STATE_SNK_READY);
1403:Src/usb_pd_protocol.c **** 				} else {
1404:Src/usb_pd_protocol.c **** 					/* The request was rejected */
ARM GAS  /tmp/ccoQIC4J.s 			page 32


1405:Src/usb_pd_protocol.c **** 					set_state(port, PD_STATE_SNK_READY);
1406:Src/usb_pd_protocol.c **** 				}
1407:Src/usb_pd_protocol.c **** 			} else {
1408:Src/usb_pd_protocol.c **** 				/* No explicit contract */
1409:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SNK_DISCOVERY);
1410:Src/usb_pd_protocol.c **** 			}
1411:Src/usb_pd_protocol.c **** 		}
1412:Src/usb_pd_protocol.c **** #endif
1413:Src/usb_pd_protocol.c **** 		break;
1414:Src/usb_pd_protocol.c **** 	case PD_CTRL_ACCEPT:
1415:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SOFT_RESET) {
1416:Src/usb_pd_protocol.c **** 			/*
1417:Src/usb_pd_protocol.c **** 			 * For the case that we sent soft reset in SNK_DISCOVERY
1418:Src/usb_pd_protocol.c **** 			 * on startup due to VBUS never low, clear the flag.
1419:Src/usb_pd_protocol.c **** 			 */
1420:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
1421:Src/usb_pd_protocol.c **** 			execute_soft_reset(port);
1422:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_DR_SWAP) {
1423:Src/usb_pd_protocol.c **** 			/* switch data role */
1424:Src/usb_pd_protocol.c **** 			pd_dr_swap(port);
1425:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
1426:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1427:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1428:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_VCONN_SWAP_SEND) {
1429:Src/usb_pd_protocol.c **** 			/* switch vconn */
1430:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_VCONN_SWAP_INIT);
1431:Src/usb_pd_protocol.c **** #endif
1432:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SRC_SWAP_INIT) {
1433:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
1434:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_EXPLICIT_CONTRACT;
1435:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_SWAP_SNK_DISABLE);
1436:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_SWAP_INIT) {
1437:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
1438:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_EXPLICIT_CONTRACT;
1439:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_SNK_DISABLE);
1440:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_REQUESTED) {
1441:Src/usb_pd_protocol.c **** 			/* explicit contract is now in place */
1442:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_EXPLICIT_CONTRACT;
1443:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1444:Src/usb_pd_protocol.c **** 			pd_set_saved_active(port, 1);
1445:Src/usb_pd_protocol.c **** #endif
1446:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_TRANSITION);
1447:Src/usb_pd_protocol.c **** #endif
1448:Src/usb_pd_protocol.c **** 		}
1449:Src/usb_pd_protocol.c **** 		break;
1450:Src/usb_pd_protocol.c **** 	case PD_CTRL_SOFT_RESET:
1451:Src/usb_pd_protocol.c **** 		execute_soft_reset(port);
1452:Src/usb_pd_protocol.c **** 		/* We are done, acknowledge with an Accept packet */
1453:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_ACCEPT);
1454:Src/usb_pd_protocol.c **** 		break;
1455:Src/usb_pd_protocol.c **** 	case PD_CTRL_PR_SWAP:
1456:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1457:Src/usb_pd_protocol.c **** 		if (pd_check_power_swap(port)) {
1458:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_ACCEPT);
1459:Src/usb_pd_protocol.c **** 			/*
1460:Src/usb_pd_protocol.c **** 			 * Clear flag for checking power role to avoid
1461:Src/usb_pd_protocol.c **** 			 * immediately requesting another swap.
ARM GAS  /tmp/ccoQIC4J.s 			page 33


1462:Src/usb_pd_protocol.c **** 			 */
1463:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_PR_ROLE;
1464:Src/usb_pd_protocol.c **** 			set_state(port,
1465:Src/usb_pd_protocol.c **** 				  DUAL_ROLE_IF_ELSE(port,
1466:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_SWAP_SNK_DISABLE,
1467:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_SWAP_SNK_DISABLE));
1468:Src/usb_pd_protocol.c **** 		} else {
1469:Src/usb_pd_protocol.c **** 			send_control(port, REFUSE(pd[port].rev));
1470:Src/usb_pd_protocol.c **** 		}
1471:Src/usb_pd_protocol.c **** #else
1472:Src/usb_pd_protocol.c **** 		send_control(port, REFUSE(pd[port].rev));
1473:Src/usb_pd_protocol.c **** #endif
1474:Src/usb_pd_protocol.c **** 		break;
1475:Src/usb_pd_protocol.c **** 	case PD_CTRL_DR_SWAP:
1476:Src/usb_pd_protocol.c **** 		if (pd_check_data_swap(port, pd[port].data_role)) {
1477:Src/usb_pd_protocol.c **** 			/*
1478:Src/usb_pd_protocol.c **** 			 * Accept switch and perform data swap. Clear
1479:Src/usb_pd_protocol.c **** 			 * flag for checking data role to avoid
1480:Src/usb_pd_protocol.c **** 			 * immediately requesting another swap.
1481:Src/usb_pd_protocol.c **** 			 */
1482:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_DR_ROLE;
1483:Src/usb_pd_protocol.c **** 			if (send_control(port, PD_CTRL_ACCEPT) >= 0)
1484:Src/usb_pd_protocol.c **** 				pd_dr_swap(port);
1485:Src/usb_pd_protocol.c **** 		} else {
1486:Src/usb_pd_protocol.c **** 			send_control(port, REFUSE(pd[port].rev));
1487:Src/usb_pd_protocol.c **** 
1488:Src/usb_pd_protocol.c **** 		}
1489:Src/usb_pd_protocol.c **** 		break;
1490:Src/usb_pd_protocol.c **** 	case PD_CTRL_VCONN_SWAP:
1491:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
1492:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SRC_READY ||
1493:Src/usb_pd_protocol.c **** 		    pd[port].task_state == PD_STATE_SNK_READY) {
1494:Src/usb_pd_protocol.c **** 			if (pd_check_vconn_swap(port)) {
1495:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) > 0)
1496:Src/usb_pd_protocol.c **** 					set_state(port,
1497:Src/usb_pd_protocol.c **** 						  PD_STATE_VCONN_SWAP_INIT);
1498:Src/usb_pd_protocol.c **** 			} else {
1499:Src/usb_pd_protocol.c **** 				send_control(port, REFUSE(pd[port].rev));
1500:Src/usb_pd_protocol.c **** 			}
1501:Src/usb_pd_protocol.c **** 		}
1502:Src/usb_pd_protocol.c **** #else
1503:Src/usb_pd_protocol.c **** 		send_control(port, REFUSE(pd[port].rev));
1504:Src/usb_pd_protocol.c **** #endif
1505:Src/usb_pd_protocol.c **** 		break;
1506:Src/usb_pd_protocol.c **** 	default:
1507:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1508:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_NOT_SUPPORTED);
1509:Src/usb_pd_protocol.c **** #endif
1510:Src/usb_pd_protocol.c **** 		CPRINTF("Unhandled ctrl message type %d\n", type);
1511:Src/usb_pd_protocol.c **** 	}
1512:Src/usb_pd_protocol.c **** }
1513:Src/usb_pd_protocol.c **** 
1514:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1515:Src/usb_pd_protocol.c **** static void handle_ext_request(int port, uint16_t head, uint32_t *payload)
1516:Src/usb_pd_protocol.c **** {
1517:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
1518:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 34


1519:Src/usb_pd_protocol.c **** 	switch (type) {
1520:Src/usb_pd_protocol.c **** 	case PD_EXT_GET_BATTERY_CAP:
1521:Src/usb_pd_protocol.c **** 		send_battery_cap(port, payload);
1522:Src/usb_pd_protocol.c **** 		break;
1523:Src/usb_pd_protocol.c **** 	case PD_EXT_GET_BATTERY_STATUS:
1524:Src/usb_pd_protocol.c **** 		send_battery_status(port, payload);
1525:Src/usb_pd_protocol.c **** 		break;
1526:Src/usb_pd_protocol.c **** 	case PD_EXT_BATTERY_CAP:
1527:Src/usb_pd_protocol.c **** 		break;
1528:Src/usb_pd_protocol.c **** 	default:
1529:Src/usb_pd_protocol.c **** 		send_control(port, PD_CTRL_NOT_SUPPORTED);
1530:Src/usb_pd_protocol.c **** 	}
1531:Src/usb_pd_protocol.c **** }
1532:Src/usb_pd_protocol.c **** #endif
1533:Src/usb_pd_protocol.c **** 
1534:Src/usb_pd_protocol.c **** static void handle_request(int port, uint16_t head,
1535:Src/usb_pd_protocol.c **** 		uint32_t *payload)
1536:Src/usb_pd_protocol.c **** {
1537:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
1538:Src/usb_pd_protocol.c **** 	int p;
1539:Src/usb_pd_protocol.c **** 
1540:Src/usb_pd_protocol.c **** 	/* dump received packet content (only dump ping at debug level 3) */
1541:Src/usb_pd_protocol.c **** 	if ((debug_level == 2 && PD_HEADER_TYPE(head) != PD_CTRL_PING) ||
1542:Src/usb_pd_protocol.c **** 	    debug_level >= 3) {
1543:Src/usb_pd_protocol.c **** 		CPRINTF("RECV %04x/%d ", head, cnt);
1544:Src/usb_pd_protocol.c **** 		for (p = 0; p < cnt; p++)
1545:Src/usb_pd_protocol.c **** 			CPRINTF("[%d]%08x ", p, payload[p]);
1546:Src/usb_pd_protocol.c **** 		CPRINTF("\n");
1547:Src/usb_pd_protocol.c **** 	}
1548:Src/usb_pd_protocol.c **** 
1549:Src/usb_pd_protocol.c **** 	/*
1550:Src/usb_pd_protocol.c **** 	 * If we are in disconnected state, we shouldn't get a request. Do
1551:Src/usb_pd_protocol.c **** 	 * a hard reset if we get one.
1552:Src/usb_pd_protocol.c **** 	 */
1553:Src/usb_pd_protocol.c **** 	if (!pd_is_connected(port))
1554:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_HARD_RESET_SEND);
1555:Src/usb_pd_protocol.c **** 
1556:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1557:Src/usb_pd_protocol.c **** 	/* Check if this is an extended chunked data message. */
1558:Src/usb_pd_protocol.c **** 	if (pd[port].rev == PD_REV30 && PD_HEADER_EXT(head)) {
1559:Src/usb_pd_protocol.c **** 		handle_ext_request(port, head, payload);
1560:Src/usb_pd_protocol.c **** 		return;
1561:Src/usb_pd_protocol.c **** 	}
1562:Src/usb_pd_protocol.c **** #endif
1563:Src/usb_pd_protocol.c **** 	if (cnt)
1564:Src/usb_pd_protocol.c **** 		handle_data_request(port, head, payload);
1565:Src/usb_pd_protocol.c **** 	else
1566:Src/usb_pd_protocol.c **** 		handle_ctrl_request(port, head, payload);
1567:Src/usb_pd_protocol.c **** }
1568:Src/usb_pd_protocol.c **** 
1569:Src/usb_pd_protocol.c **** void pd_send_vdm(int port, uint32_t vid, int cmd, const uint32_t *data,
1570:Src/usb_pd_protocol.c **** 		 int count)
1571:Src/usb_pd_protocol.c **** {
1572:Src/usb_pd_protocol.c **** 	if (count > VDO_MAX_SIZE - 1) {
1573:Src/usb_pd_protocol.c **** 		CPRINTF("VDM over max size\n");
1574:Src/usb_pd_protocol.c **** 		return;
1575:Src/usb_pd_protocol.c **** 	}
ARM GAS  /tmp/ccoQIC4J.s 			page 35


1576:Src/usb_pd_protocol.c **** 
1577:Src/usb_pd_protocol.c **** 	/* set VDM header with VID & CMD */
1578:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = VDO(vid, ((vid & USB_SID_PD) == USB_SID_PD) ?
1579:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
1580:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
1581:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] |= VDO_SVDM_VERS(vdo_ver[pd[port].rev]);
1582:Src/usb_pd_protocol.c **** #endif
1583:Src/usb_pd_protocol.c **** 	queue_vdm(port, pd[port].vdo_data, data, count);
1584:Src/usb_pd_protocol.c **** 
1585:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1586:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1587:Src/usb_pd_protocol.c **** }
1588:Src/usb_pd_protocol.c **** 
1589:Src/usb_pd_protocol.c **** static inline int pdo_busy(int port)
1590:Src/usb_pd_protocol.c **** {
1591:Src/usb_pd_protocol.c **** 	/*
1592:Src/usb_pd_protocol.c **** 	 * Note, main PDO state machine (pd_task) uses READY state exclusively
1593:Src/usb_pd_protocol.c **** 	 * to denote port partners have successfully negociated a contract.  All
1594:Src/usb_pd_protocol.c **** 	 * other protocol actions force state transitions.
1595:Src/usb_pd_protocol.c **** 	 */
1596:Src/usb_pd_protocol.c **** 	int rv = (pd[port].task_state != PD_STATE_SRC_READY);
1597:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1598:Src/usb_pd_protocol.c **** 	rv &= (pd[port].task_state != PD_STATE_SNK_READY);
1599:Src/usb_pd_protocol.c **** #endif
1600:Src/usb_pd_protocol.c **** 	return rv;
1601:Src/usb_pd_protocol.c **** }
1602:Src/usb_pd_protocol.c **** 
1603:Src/usb_pd_protocol.c **** static uint64_t vdm_get_ready_timeout(uint32_t vdm_hdr)
1604:Src/usb_pd_protocol.c **** {
 272              		.loc 1 1604 1 is_stmt 1 view -0
 273              		.cfi_startproc
 274              		@ args = 0, pretend = 0, frame = 0
 275              		@ frame_needed = 0, uses_anonymous_args = 0
 276              		@ link register save eliminated.
1605:Src/usb_pd_protocol.c **** 	uint64_t timeout;
 277              		.loc 1 1605 2 view .LVU54
1606:Src/usb_pd_protocol.c **** 	int cmd = PD_VDO_CMD(vdm_hdr);
 278              		.loc 1 1606 2 view .LVU55
 279              		.loc 1 1606 6 is_stmt 0 view .LVU56
 280 0000 1F23     		movs	r3, #31
 281 0002 0340     		ands	r3, r0
 282              	.LVL11:
1607:Src/usb_pd_protocol.c **** 
1608:Src/usb_pd_protocol.c **** 	/* its not a structured VDM command */
1609:Src/usb_pd_protocol.c **** 	if (!PD_VDO_SVDM(vdm_hdr))
 283              		.loc 1 1609 2 is_stmt 1 view .LVU57
 284              		.loc 1 1609 5 is_stmt 0 view .LVU58
 285 0004 0204     		lsls	r2, r0, #16
 286 0006 14D5     		bpl	.L21
1610:Src/usb_pd_protocol.c **** 		return 500*MSEC_US;
1611:Src/usb_pd_protocol.c **** 
1612:Src/usb_pd_protocol.c **** 	switch (PD_VDO_CMDT(vdm_hdr)) {
 287              		.loc 1 1612 2 is_stmt 1 view .LVU59
 288              		.loc 1 1612 10 is_stmt 0 view .LVU60
 289 0008 8009     		lsrs	r0, r0, #6
 290              	.LVL12:
 291              		.loc 1 1612 2 view .LVU61
ARM GAS  /tmp/ccoQIC4J.s 			page 36


 292 000a 8207     		lsls	r2, r0, #30
 293 000c 08D1     		bne	.L20
1613:Src/usb_pd_protocol.c **** 	case CMDT_INIT:
1614:Src/usb_pd_protocol.c **** 		if ((cmd == CMD_ENTER_MODE) || (cmd == CMD_EXIT_MODE))
 294              		.loc 1 1614 3 is_stmt 1 view .LVU62
 295              		.loc 1 1614 31 is_stmt 0 view .LVU63
 296 000e 043B     		subs	r3, r3, #4
 297              	.LVL13:
 298              		.loc 1 1614 6 view .LVU64
 299 0010 012B     		cmp	r3, #1
 300 0012 02D9     		bls	.L24
1615:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_WAIT_MODE_E;
1616:Src/usb_pd_protocol.c **** 		else
1617:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_SNDR_RSP;
 301              		.loc 1 1617 12 view .LVU65
 302 0014 0848     		ldr	r0, .L26
 303 0016 0021     		movs	r1, #0
 304 0018 0DE0     		b	.L18
 305              	.L24:
1615:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_WAIT_MODE_E;
 306              		.loc 1 1615 12 view .LVU66
 307 001a 0848     		ldr	r0, .L26+4
 308 001c 0021     		movs	r1, #0
 309 001e 0AE0     		b	.L18
 310              	.LVL14:
 311              	.L20:
1618:Src/usb_pd_protocol.c **** 		break;
1619:Src/usb_pd_protocol.c **** 	default:
1620:Src/usb_pd_protocol.c **** 		if ((cmd == CMD_ENTER_MODE) || (cmd == CMD_EXIT_MODE))
 312              		.loc 1 1620 3 is_stmt 1 view .LVU67
 313              		.loc 1 1620 31 is_stmt 0 view .LVU68
 314 0020 043B     		subs	r3, r3, #4
 315              	.LVL15:
 316              		.loc 1 1620 6 view .LVU69
 317 0022 012B     		cmp	r3, #1
 318 0024 02D9     		bls	.L25
1621:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_E_MODE;
1622:Src/usb_pd_protocol.c **** 		else
1623:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_RCVR_RSP;
 319              		.loc 1 1623 12 view .LVU70
 320 0026 0648     		ldr	r0, .L26+8
 321 0028 0021     		movs	r1, #0
 322 002a 04E0     		b	.L18
 323              	.L25:
1621:Src/usb_pd_protocol.c **** 			timeout = PD_T_VDM_E_MODE;
 324              		.loc 1 1621 12 view .LVU71
 325 002c 0548     		ldr	r0, .L26+12
 326 002e 0021     		movs	r1, #0
 327 0030 01E0     		b	.L18
 328              	.LVL16:
 329              	.L21:
1610:Src/usb_pd_protocol.c **** 
 330              		.loc 1 1610 10 view .LVU72
 331 0032 0548     		ldr	r0, .L26+16
 332              	.LVL17:
1610:Src/usb_pd_protocol.c **** 
 333              		.loc 1 1610 10 view .LVU73
ARM GAS  /tmp/ccoQIC4J.s 			page 37


 334 0034 0021     		movs	r1, #0
 335              	.LVL18:
 336              	.L18:
1624:Src/usb_pd_protocol.c **** 		break;
1625:Src/usb_pd_protocol.c **** 	}
1626:Src/usb_pd_protocol.c **** 	return timeout;
1627:Src/usb_pd_protocol.c **** }
 337              		.loc 1 1627 1 view .LVU74
 338              		@ sp needed
 339 0036 7047     		bx	lr
 340              	.L27:
 341              		.align	2
 342              	.L26:
 343 0038 30750000 		.word	30000
 344 003c A0860100 		.word	100000
 345 0040 983A0000 		.word	15000
 346 0044 A8610000 		.word	25000
 347 0048 20A10700 		.word	500000
 348              		.cfi_endproc
 349              	.LFE49:
 351              		.section	.text.pd_is_power_swapping,"ax",%progbits
 352              		.align	1
 353              		.syntax unified
 354              		.code	16
 355              		.thumb_func
 356              		.fpu softvfp
 358              	pd_is_power_swapping:
 359              	.LVL19:
 360              	.LFB56:
1628:Src/usb_pd_protocol.c **** 
1629:Src/usb_pd_protocol.c **** static void pd_vdm_send_state_machine(int port)
1630:Src/usb_pd_protocol.c **** {
1631:Src/usb_pd_protocol.c **** 	int res;
1632:Src/usb_pd_protocol.c **** 	uint16_t header;
1633:Src/usb_pd_protocol.c **** 
1634:Src/usb_pd_protocol.c **** 	switch (pd[port].vdm_state) {
1635:Src/usb_pd_protocol.c **** 	case VDM_STATE_READY:
1636:Src/usb_pd_protocol.c **** 		/* Only transmit VDM if connected. */
1637:Src/usb_pd_protocol.c **** 		if (!pd_is_connected(port)) {
1638:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_BUSY;
1639:Src/usb_pd_protocol.c **** 			break;
1640:Src/usb_pd_protocol.c **** 		}
1641:Src/usb_pd_protocol.c **** 
1642:Src/usb_pd_protocol.c **** 		/*
1643:Src/usb_pd_protocol.c **** 		 * if there's traffic or we're not in PDO ready state don't send
1644:Src/usb_pd_protocol.c **** 		 * a VDM.
1645:Src/usb_pd_protocol.c **** 		 */
1646:Src/usb_pd_protocol.c **** 		if (pdo_busy(port))
1647:Src/usb_pd_protocol.c **** 			break;
1648:Src/usb_pd_protocol.c **** 
1649:Src/usb_pd_protocol.c **** 		/* Prepare and send VDM */
1650:Src/usb_pd_protocol.c **** 		header = PD_HEADER(PD_DATA_VENDOR_DEF, pd[port].power_role,
1651:Src/usb_pd_protocol.c **** 				   pd[port].data_role, pd[port].msg_id,
1652:Src/usb_pd_protocol.c **** 				   (int)pd[port].vdo_count,
1653:Src/usb_pd_protocol.c **** 				   pd_get_rev(port), 0);
1654:Src/usb_pd_protocol.c **** 		res = pd_transmit(port, TCPC_TX_SOP, header,
1655:Src/usb_pd_protocol.c **** 				  pd[port].vdo_data);
ARM GAS  /tmp/ccoQIC4J.s 			page 38


1656:Src/usb_pd_protocol.c **** 		if (res < 0) {
1657:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_SEND;
1658:Src/usb_pd_protocol.c **** 		} else {
1659:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_BUSY;
1660:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
1661:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
1662:Src/usb_pd_protocol.c **** 		}
1663:Src/usb_pd_protocol.c **** 		break;
1664:Src/usb_pd_protocol.c **** 	case VDM_STATE_WAIT_RSP_BUSY:
1665:Src/usb_pd_protocol.c **** 		/* wait and then initiate request again */
1666:Src/usb_pd_protocol.c **** 		if (get_time().val > pd[port].vdm_timeout.val) {
1667:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
1668:Src/usb_pd_protocol.c **** 			pd[port].vdo_count = 1;
1669:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_READY;
1670:Src/usb_pd_protocol.c **** 		}
1671:Src/usb_pd_protocol.c **** 		break;
1672:Src/usb_pd_protocol.c **** 	case VDM_STATE_BUSY:
1673:Src/usb_pd_protocol.c **** 		/* Wait for VDM response or timeout */
1674:Src/usb_pd_protocol.c **** 		if (pd[port].vdm_timeout.val &&
1675:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
1676:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_TMOUT;
1677:Src/usb_pd_protocol.c **** 		}
1678:Src/usb_pd_protocol.c **** 		break;
1679:Src/usb_pd_protocol.c **** 	default:
1680:Src/usb_pd_protocol.c **** 		break;
1681:Src/usb_pd_protocol.c **** 	}
1682:Src/usb_pd_protocol.c **** }
1683:Src/usb_pd_protocol.c **** 
1684:Src/usb_pd_protocol.c **** #ifdef CONFIG_CMD_PD_DEV_DUMP_INFO
1685:Src/usb_pd_protocol.c **** static inline void pd_dev_dump_info(uint16_t dev_id, uint8_t *hash)
1686:Src/usb_pd_protocol.c **** {
1687:Src/usb_pd_protocol.c **** 	int j;
1688:Src/usb_pd_protocol.c **** 	ccprintf("DevId:%d.%d Hash:", HW_DEV_ID_MAJ(dev_id),
1689:Src/usb_pd_protocol.c **** 		 HW_DEV_ID_MIN(dev_id));
1690:Src/usb_pd_protocol.c **** 	for (j = 0; j < PD_RW_HASH_SIZE; j += 4) {
1691:Src/usb_pd_protocol.c **** 		ccprintf(" 0x%02x%02x%02x%02x", hash[j + 3], hash[j + 2],
1692:Src/usb_pd_protocol.c **** 			 hash[j + 1], hash[j]);
1693:Src/usb_pd_protocol.c **** 	}
1694:Src/usb_pd_protocol.c **** 	ccprintf("\n");
1695:Src/usb_pd_protocol.c **** }
1696:Src/usb_pd_protocol.c **** #endif /* CONFIG_CMD_PD_DEV_DUMP_INFO */
1697:Src/usb_pd_protocol.c **** 
1698:Src/usb_pd_protocol.c **** int pd_dev_store_rw_hash(int port, uint16_t dev_id, uint32_t *rw_hash,
1699:Src/usb_pd_protocol.c **** 			 uint32_t current_image)
1700:Src/usb_pd_protocol.c **** {
1701:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
1702:Src/usb_pd_protocol.c **** 	int i;
1703:Src/usb_pd_protocol.c **** #endif
1704:Src/usb_pd_protocol.c **** 
1705:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
1706:Src/usb_pd_protocol.c **** 	pd[port].dev_id = dev_id;
1707:Src/usb_pd_protocol.c **** 	memcpy(pd[port].dev_rw_hash, rw_hash, PD_RW_HASH_SIZE);
1708:Src/usb_pd_protocol.c **** #endif
1709:Src/usb_pd_protocol.c **** #ifdef CONFIG_CMD_PD_DEV_DUMP_INFO
1710:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
1711:Src/usb_pd_protocol.c **** 		pd_dev_dump_info(dev_id, (uint8_t *)rw_hash);
1712:Src/usb_pd_protocol.c **** #endif
ARM GAS  /tmp/ccoQIC4J.s 			page 39


1713:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_CHROMEOS
1714:Src/usb_pd_protocol.c **** 	pd[port].current_image = current_image;
1715:Src/usb_pd_protocol.c **** #endif
1716:Src/usb_pd_protocol.c **** 
1717:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
1718:Src/usb_pd_protocol.c **** 	/* Search table for matching device / hash */
1719:Src/usb_pd_protocol.c **** 	for (i = 0; i < RW_HASH_ENTRIES; i++)
1720:Src/usb_pd_protocol.c **** 		if (dev_id == rw_hash_table[i].dev_id)
1721:Src/usb_pd_protocol.c **** 			return !memcmp(rw_hash,
1722:Src/usb_pd_protocol.c **** 				       rw_hash_table[i].dev_rw_hash,
1723:Src/usb_pd_protocol.c **** 				       PD_RW_HASH_SIZE);
1724:Src/usb_pd_protocol.c **** #endif
1725:Src/usb_pd_protocol.c **** 	return 0;
1726:Src/usb_pd_protocol.c **** }
1727:Src/usb_pd_protocol.c **** 
1728:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1729:Src/usb_pd_protocol.c **** enum pd_dual_role_states pd_get_dual_role(void)
1730:Src/usb_pd_protocol.c **** {
1731:Src/usb_pd_protocol.c **** 	return drp_state;
1732:Src/usb_pd_protocol.c **** }
1733:Src/usb_pd_protocol.c **** 
1734:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TRY_SRC
1735:Src/usb_pd_protocol.c **** static void pd_update_try_source(void)
1736:Src/usb_pd_protocol.c **** {
1737:Src/usb_pd_protocol.c **** 	int i;
1738:Src/usb_pd_protocol.c **** 
1739:Src/usb_pd_protocol.c **** #ifndef CONFIG_CHARGER
1740:Src/usb_pd_protocol.c **** 	int batt_soc = board_get_battery_soc();
1741:Src/usb_pd_protocol.c **** #else
1742:Src/usb_pd_protocol.c **** 	int batt_soc = charge_get_percent();
1743:Src/usb_pd_protocol.c **** #endif
1744:Src/usb_pd_protocol.c **** 
1745:Src/usb_pd_protocol.c **** 	/*
1746:Src/usb_pd_protocol.c **** 	 * Enable try source when dual-role toggling AND battery is present
1747:Src/usb_pd_protocol.c **** 	 * and at some minimum percentage.
1748:Src/usb_pd_protocol.c **** 	 */
1749:Src/usb_pd_protocol.c **** 	pd_try_src_enable = drp_state == PD_DRP_TOGGLE_ON &&
1750:Src/usb_pd_protocol.c **** 			    batt_soc >= CONFIG_USB_PD_TRY_SRC_MIN_BATT_SOC;
1751:Src/usb_pd_protocol.c **** #if defined(CONFIG_BATTERY_PRESENT_CUSTOM) || \
1752:Src/usb_pd_protocol.c **** 	defined(CONFIG_BATTERY_PRESENT_GPIO)
1753:Src/usb_pd_protocol.c **** 	/*
1754:Src/usb_pd_protocol.c **** 	 * When battery is cutoff in ship mode it may not be reliable to
1755:Src/usb_pd_protocol.c **** 	 * check if battery is present with its state of charge.
1756:Src/usb_pd_protocol.c **** 	 * Also check if battery is initialized and ready to provide power.
1757:Src/usb_pd_protocol.c **** 	 */
1758:Src/usb_pd_protocol.c **** 	pd_try_src_enable &= (battery_is_present() == BP_YES);
1759:Src/usb_pd_protocol.c **** #endif
1760:Src/usb_pd_protocol.c **** 
1761:Src/usb_pd_protocol.c **** 	/*
1762:Src/usb_pd_protocol.c **** 	 * Clear this flag to cover case where a TrySrc
1763:Src/usb_pd_protocol.c **** 	 * mode went from enabled to disabled and trying_source
1764:Src/usb_pd_protocol.c **** 	 * was active at that time.
1765:Src/usb_pd_protocol.c **** 	 */
1766:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++)
1767:Src/usb_pd_protocol.c **** 		pd[i].flags &= ~PD_FLAGS_TRY_SRC;
1768:Src/usb_pd_protocol.c **** 
1769:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 40


1770:Src/usb_pd_protocol.c **** DECLARE_HOOK(HOOK_BATTERY_SOC_CHANGE, pd_update_try_source, HOOK_PRIO_DEFAULT);
1771:Src/usb_pd_protocol.c **** #endif
1772:Src/usb_pd_protocol.c **** 
1773:Src/usb_pd_protocol.c **** void pd_set_dual_role(enum pd_dual_role_states state)
1774:Src/usb_pd_protocol.c **** {
1775:Src/usb_pd_protocol.c **** 	int i;
1776:Src/usb_pd_protocol.c **** 	drp_state = state;
1777:Src/usb_pd_protocol.c **** 
1778:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TRY_SRC
1779:Src/usb_pd_protocol.c **** 	pd_update_try_source();
1780:Src/usb_pd_protocol.c **** #endif
1781:Src/usb_pd_protocol.c **** 
1782:Src/usb_pd_protocol.c **** 	/* Inform PD tasks of dual role change. */
1783:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++)
1784:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
1785:Src/usb_pd_protocol.c **** 		//task_set_event(PD_PORT_TO_TASK_ID(i),
1786:Src/usb_pd_protocol.c **** 		//	       PD_EVENT_UPDATE_DUAL_ROLE, 0);
1787:Src/usb_pd_protocol.c **** 		;
1788:Src/usb_pd_protocol.c **** }
1789:Src/usb_pd_protocol.c **** 
1790:Src/usb_pd_protocol.c **** void pd_update_dual_role_config(int port)
1791:Src/usb_pd_protocol.c **** {
1792:Src/usb_pd_protocol.c **** 	/*
1793:Src/usb_pd_protocol.c **** 	 * Change to sink if port is currently a source AND (new DRP
1794:Src/usb_pd_protocol.c **** 	 * state is force sink OR new DRP state is either toggle off
1795:Src/usb_pd_protocol.c **** 	 * or debug accessory toggle only and we are in the source
1796:Src/usb_pd_protocol.c **** 	 * disconnected state).
1797:Src/usb_pd_protocol.c **** 	 */
1798:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SOURCE &&
1799:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
1800:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
1801:Src/usb_pd_protocol.c **** 	      && pd[port].task_state == PD_STATE_SRC_DISCONNECTED))) {
1802:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SINK;
1803:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_DISCONNECTED);
1804:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RD);
1805:Src/usb_pd_protocol.c **** 		/* Make sure we're not sourcing VBUS. */
1806:Src/usb_pd_protocol.c **** 		pd_power_supply_reset(port);
1807:Src/usb_pd_protocol.c **** 	}
1808:Src/usb_pd_protocol.c **** 
1809:Src/usb_pd_protocol.c **** 	/*
1810:Src/usb_pd_protocol.c **** 	 * Change to source if port is currently a sink and the
1811:Src/usb_pd_protocol.c **** 	 * new DRP state is force source.
1812:Src/usb_pd_protocol.c **** 	 */
1813:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SINK &&
1814:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
1815:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
1816:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCONNECTED);
1817:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RP);
1818:Src/usb_pd_protocol.c **** 	}
1819:Src/usb_pd_protocol.c **** 
1820:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE) && \
1821:Src/usb_pd_protocol.c **** 	defined(CONFIG_USB_PD_TCPC_LOW_POWER)
1822:Src/usb_pd_protocol.c **** 	/* When switching drp mode, make sure tcpc is out of standby mode */
1823:Src/usb_pd_protocol.c **** 	tcpm_set_drp_toggle(port, 0);
1824:Src/usb_pd_protocol.c **** #endif
1825:Src/usb_pd_protocol.c **** }
1826:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 41


1827:Src/usb_pd_protocol.c **** int pd_get_role(int port)
1828:Src/usb_pd_protocol.c **** {
1829:Src/usb_pd_protocol.c **** 	return pd[port].power_role;
1830:Src/usb_pd_protocol.c **** }
1831:Src/usb_pd_protocol.c **** 
1832:Src/usb_pd_protocol.c **** static int pd_is_power_swapping(int port)
1833:Src/usb_pd_protocol.c **** {
 361              		.loc 1 1833 1 is_stmt 1 view -0
 362              		.cfi_startproc
 363              		@ args = 0, pretend = 0, frame = 0
 364              		@ frame_needed = 0, uses_anonymous_args = 0
 365              		@ link register save eliminated.
1834:Src/usb_pd_protocol.c **** 	/* return true if in the act of swapping power roles */
1835:Src/usb_pd_protocol.c **** 	return  pd[port].task_state == PD_STATE_SNK_SWAP_SNK_DISABLE ||
 366              		.loc 1 1835 2 view .LVU76
 367              		.loc 1 1835 18 is_stmt 0 view .LVU77
 368 0000 C301     		lsls	r3, r0, #7
 369 0002 0C48     		ldr	r0, .L35
 370              	.LVL20:
 371              		.loc 1 1835 18 view .LVU78
 372 0004 C018     		adds	r0, r0, r3
 373 0006 0279     		ldrb	r2, [r0, #4]
1836:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_SRC_DISABLE ||
1837:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_STANDBY ||
 374              		.loc 1 1837 52 view .LVU79
 375 0008 1300     		movs	r3, r2
 376 000a 0A3B     		subs	r3, r3, #10
 377 000c DBB2     		uxtb	r3, r3
1838:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE ||
1839:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_SNK_DISABLE ||
1840:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_SRC_DISABLE ||
 378              		.loc 1 1840 56 view .LVU80
 379 000e 032B     		cmp	r3, #3
 380 0010 09D9     		bls	.L30
1838:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE ||
 381              		.loc 1 1838 53 view .LVU81
 382 0012 1B2A     		cmp	r2, #27
 383 0014 09D0     		beq	.L31
1839:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_SRC_DISABLE ||
 384              		.loc 1 1839 56 view .LVU82
 385 0016 1C2A     		cmp	r2, #28
 386 0018 09D0     		beq	.L32
 387              		.loc 1 1840 56 discriminator 2 view .LVU83
 388 001a 1D2A     		cmp	r2, #29
 389 001c 01D0     		beq	.L34
 390              		.loc 1 1840 56 view .LVU84
 391 001e 0020     		movs	r0, #0
 392 0020 02E0     		b	.L28
 393              	.L34:
 394 0022 0120     		movs	r0, #1
 395 0024 00E0     		b	.L28
 396              	.L30:
 397 0026 0120     		movs	r0, #1
 398              	.L28:
1841:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_STANDBY;
1842:Src/usb_pd_protocol.c **** }
 399              		.loc 1 1842 1 view .LVU85
ARM GAS  /tmp/ccoQIC4J.s 			page 42


 400              		@ sp needed
 401 0028 7047     		bx	lr
 402              	.L31:
1840:Src/usb_pd_protocol.c **** 		pd[port].task_state == PD_STATE_SRC_SWAP_STANDBY;
 403              		.loc 1 1840 56 view .LVU86
 404 002a 0120     		movs	r0, #1
 405 002c FCE7     		b	.L28
 406              	.L32:
 407 002e 0120     		movs	r0, #1
 408 0030 FAE7     		b	.L28
 409              	.L36:
 410 0032 C046     		.align	2
 411              	.L35:
 412 0034 00000000 		.word	pd
 413              		.cfi_endproc
 414              	.LFE56:
 416              		.section	.text.get_typec_current_limit,"ax",%progbits
 417              		.align	1
 418              		.syntax unified
 419              		.code	16
 420              		.thumb_func
 421              		.fpu softvfp
 423              	get_typec_current_limit:
 424              	.LVL21:
 425              	.LFB63:
1843:Src/usb_pd_protocol.c **** 
1844:Src/usb_pd_protocol.c **** /*
1845:Src/usb_pd_protocol.c ****  * Provide Rp to ensure the partner port is in a known state (eg. not
1846:Src/usb_pd_protocol.c ****  * PD negotiated, not sourcing 20V).
1847:Src/usb_pd_protocol.c ****  */
1848:Src/usb_pd_protocol.c **** static void pd_partner_port_reset(int port)
1849:Src/usb_pd_protocol.c **** {
1850:Src/usb_pd_protocol.c **** 	uint64_t timeout;
1851:Src/usb_pd_protocol.c **** 
1852:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1853:Src/usb_pd_protocol.c **** 	/*
1854:Src/usb_pd_protocol.c **** 	 * Check our battery-backed previous port state. If PD comms were
1855:Src/usb_pd_protocol.c **** 	 * active, and we didn't just lose power, make sure we
1856:Src/usb_pd_protocol.c **** 	 * don't boot into RO with a pre-existing power contract.
1857:Src/usb_pd_protocol.c **** 	 */
1858:Src/usb_pd_protocol.c **** 	if (!pd_get_saved_active(port) ||
1859:Src/usb_pd_protocol.c **** 	   system_get_image_copy() != SYSTEM_IMAGE_RO ||
1860:Src/usb_pd_protocol.c **** 	   system_get_reset_flags() &
1861:Src/usb_pd_protocol.c **** 	   (RESET_FLAG_BROWNOUT | RESET_FLAG_POWER_ON))
1862:Src/usb_pd_protocol.c **** 		return;
1863:Src/usb_pd_protocol.c **** #endif // CONFIG_BBRAM
1864:Src/usb_pd_protocol.c **** 	/* Provide Rp for 100 msec. or until we no longer have VBUS. */
1865:Src/usb_pd_protocol.c **** 	tcpm_set_cc(port, TYPEC_CC_RP);
1866:Src/usb_pd_protocol.c **** 	timeout = get_time().val + 100 * MSEC_US;
1867:Src/usb_pd_protocol.c **** 
1868:Src/usb_pd_protocol.c **** 	while (get_time().val < timeout && pd_is_vbus_present(port))
1869:Src/usb_pd_protocol.c **** 		msleep(10);
1870:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
1871:Src/usb_pd_protocol.c **** 	pd_set_saved_active(port, 0);
1872:Src/usb_pd_protocol.c **** #endif
1873:Src/usb_pd_protocol.c **** }
1874:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
ARM GAS  /tmp/ccoQIC4J.s 			page 43


1875:Src/usb_pd_protocol.c **** 
1876:Src/usb_pd_protocol.c **** int pd_get_polarity(int port)
1877:Src/usb_pd_protocol.c **** {
1878:Src/usb_pd_protocol.c **** 	return pd[port].polarity;
1879:Src/usb_pd_protocol.c **** }
1880:Src/usb_pd_protocol.c **** 
1881:Src/usb_pd_protocol.c **** int pd_get_partner_data_swap_capable(int port)
1882:Src/usb_pd_protocol.c **** {
1883:Src/usb_pd_protocol.c **** 	/* return data swap capable status of port partner */
1884:Src/usb_pd_protocol.c **** 	return pd[port].flags & PD_FLAGS_PARTNER_DR_DATA;
1885:Src/usb_pd_protocol.c **** }
1886:Src/usb_pd_protocol.c **** 
1887:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
1888:Src/usb_pd_protocol.c **** void pd_comm_enable(int port, int enable)
1889:Src/usb_pd_protocol.c **** {
1890:Src/usb_pd_protocol.c **** 	/* We don't check port >= CONFIG_USB_PD_PORT_COUNT deliberately */
1891:Src/usb_pd_protocol.c **** 	pd_comm_enabled[port] = enable;
1892:Src/usb_pd_protocol.c **** 
1893:Src/usb_pd_protocol.c **** 	/* If type-C connection, then update the TCPC RX enable */
1894:Src/usb_pd_protocol.c **** 	if (pd_is_connected(port))
1895:Src/usb_pd_protocol.c **** 		tcpm_set_rx_enable(port, enable);
1896:Src/usb_pd_protocol.c **** 
1897:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
1898:Src/usb_pd_protocol.c **** 	/*
1899:Src/usb_pd_protocol.c **** 	 * If communications are enabled, start hard reset timer for
1900:Src/usb_pd_protocol.c **** 	 * any port in PD_SNK_DISCOVERY.
1901:Src/usb_pd_protocol.c **** 	 */
1902:Src/usb_pd_protocol.c **** 	if (enable && pd[port].task_state == PD_STATE_SNK_DISCOVERY)
1903:Src/usb_pd_protocol.c **** 		set_state_timeout(port,
1904:Src/usb_pd_protocol.c **** 				  get_time().val + PD_T_SINK_WAIT_CAP,
1905:Src/usb_pd_protocol.c **** 				  PD_STATE_HARD_RESET_SEND);
1906:Src/usb_pd_protocol.c **** #endif
1907:Src/usb_pd_protocol.c **** }
1908:Src/usb_pd_protocol.c **** #endif
1909:Src/usb_pd_protocol.c **** 
1910:Src/usb_pd_protocol.c **** void pd_ping_enable(int port, int enable)
1911:Src/usb_pd_protocol.c **** {
1912:Src/usb_pd_protocol.c **** 	if (enable)
1913:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PING_ENABLED;
1914:Src/usb_pd_protocol.c **** 	else
1915:Src/usb_pd_protocol.c **** 		pd[port].flags &= ~PD_FLAGS_PING_ENABLED;
1916:Src/usb_pd_protocol.c **** }
1917:Src/usb_pd_protocol.c **** 
1918:Src/usb_pd_protocol.c **** /**
1919:Src/usb_pd_protocol.c ****  * Returns whether the sink has detected a Rp resistor on the other side.
1920:Src/usb_pd_protocol.c ****  */
1921:Src/usb_pd_protocol.c **** static inline int cc_is_rp(int cc)
1922:Src/usb_pd_protocol.c **** {
1923:Src/usb_pd_protocol.c **** 	return (cc == TYPEC_CC_VOLT_SNK_DEF) || (cc == TYPEC_CC_VOLT_SNK_1_5) ||
1924:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
1925:Src/usb_pd_protocol.c **** }
1926:Src/usb_pd_protocol.c **** 
1927:Src/usb_pd_protocol.c **** /*
1928:Src/usb_pd_protocol.c ****  * CC values for regular sources and Debug sources (aka DTS)
1929:Src/usb_pd_protocol.c ****  *
1930:Src/usb_pd_protocol.c ****  * Source type  Mode of Operation   CC1    CC2
1931:Src/usb_pd_protocol.c ****  * ---------------------------------------------
ARM GAS  /tmp/ccoQIC4J.s 			page 44


1932:Src/usb_pd_protocol.c ****  * Regular      Default USB Power   RpUSB  Open
1933:Src/usb_pd_protocol.c ****  * Regular      USB-C @ 1.5 A       Rp1A5  Open
1934:Src/usb_pd_protocol.c ****  * Regular      USB-C @ 3 A         Rp3A0  Open
1935:Src/usb_pd_protocol.c ****  * DTS          Default USB Power   Rp3A0  Rp1A5
1936:Src/usb_pd_protocol.c ****  * DTS          USB-C @ 1.5 A       Rp1A5  RpUSB
1937:Src/usb_pd_protocol.c ****  * DTS          USB-C @ 3 A         Rp3A0  RpUSB
1938:Src/usb_pd_protocol.c **** */
1939:Src/usb_pd_protocol.c **** 
1940:Src/usb_pd_protocol.c **** /**
1941:Src/usb_pd_protocol.c ****  * Returns the polarity of a Sink.
1942:Src/usb_pd_protocol.c ****  */
1943:Src/usb_pd_protocol.c **** static inline int get_snk_polarity(int cc1, int cc2)
1944:Src/usb_pd_protocol.c **** {
1945:Src/usb_pd_protocol.c **** 	/* the following assumes:
1946:Src/usb_pd_protocol.c **** 	 * TYPEC_CC_VOLT_SNK_3_0 > TYPEC_CC_VOLT_SNK_1_5
1947:Src/usb_pd_protocol.c **** 	 * TYPEC_CC_VOLT_SNK_1_5 > TYPEC_CC_VOLT_SNK_DEF
1948:Src/usb_pd_protocol.c **** 	 * TYPEC_CC_VOLT_SNK_DEF > TYPEC_CC_VOLT_OPEN
1949:Src/usb_pd_protocol.c **** 	 */
1950:Src/usb_pd_protocol.c **** 	return (cc2 > cc1);
1951:Src/usb_pd_protocol.c **** }
1952:Src/usb_pd_protocol.c **** 
1953:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
1954:Src/usb_pd_protocol.c **** /**
1955:Src/usb_pd_protocol.c ****  * Returns type C current limit (mA) based upon cc_voltage (mV).
1956:Src/usb_pd_protocol.c ****  */
1957:Src/usb_pd_protocol.c **** static typec_current_t get_typec_current_limit(int polarity, int cc1, int cc2)
1958:Src/usb_pd_protocol.c **** {
 426              		.loc 1 1958 1 is_stmt 1 view -0
 427              		.cfi_startproc
 428              		@ args = 0, pretend = 0, frame = 0
 429              		@ frame_needed = 0, uses_anonymous_args = 0
 430              		@ link register save eliminated.
1959:Src/usb_pd_protocol.c **** 	typec_current_t charge;
 431              		.loc 1 1959 2 view .LVU88
1960:Src/usb_pd_protocol.c **** 	int cc = polarity ? cc2 : cc1;
 432              		.loc 1 1960 2 view .LVU89
 433              		.loc 1 1960 26 is_stmt 0 view .LVU90
 434 0000 0028     		cmp	r0, #0
 435 0002 0FD0     		beq	.L43
 436 0004 1300     		movs	r3, r2
 437              	.L38:
 438              	.LVL22:
1961:Src/usb_pd_protocol.c **** 	int cc_alt = polarity ? cc1 : cc2;
 439              		.loc 1 1961 2 is_stmt 1 discriminator 4 view .LVU91
 440              		.loc 1 1961 30 is_stmt 0 discriminator 4 view .LVU92
 441 0006 0028     		cmp	r0, #0
 442 0008 00D0     		beq	.L39
 443              		.loc 1 1961 30 view .LVU93
 444 000a 0A00     		movs	r2, r1
 445              	.LVL23:
 446              	.L39:
1962:Src/usb_pd_protocol.c **** 
1963:Src/usb_pd_protocol.c **** 	if (cc == TYPEC_CC_VOLT_SNK_3_0 && cc_alt != TYPEC_CC_VOLT_SNK_1_5)
 447              		.loc 1 1963 2 is_stmt 1 discriminator 4 view .LVU94
 448              		.loc 1 1963 5 is_stmt 0 discriminator 4 view .LVU95
 449 000c 072B     		cmp	r3, #7
 450 000e 0BD0     		beq	.L46
ARM GAS  /tmp/ccoQIC4J.s 			page 45


 451              	.L40:
1964:Src/usb_pd_protocol.c **** 		charge = 3000;
1965:Src/usb_pd_protocol.c **** 	else if (cc == TYPEC_CC_VOLT_SNK_1_5)
 452              		.loc 1 1965 7 is_stmt 1 view .LVU96
 453              		.loc 1 1965 10 is_stmt 0 view .LVU97
 454 0010 062B     		cmp	r3, #6
 455 0012 0DD0     		beq	.L47
1966:Src/usb_pd_protocol.c **** 		charge = 1500;
1967:Src/usb_pd_protocol.c **** 	else
1968:Src/usb_pd_protocol.c **** 		charge = 0;
 456              		.loc 1 1968 10 view .LVU98
 457 0014 0020     		movs	r0, #0
 458              	.LVL24:
 459              	.L41:
1969:Src/usb_pd_protocol.c **** 
1970:Src/usb_pd_protocol.c **** 	if (cc_is_rp(cc_alt))
 460              		.loc 1 1970 2 is_stmt 1 view .LVU99
 461              	.LBB148:
 462              	.LBI148:
1921:Src/usb_pd_protocol.c **** {
 463              		.loc 1 1921 19 view .LVU100
 464              	.LBB149:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 465              		.loc 1 1923 2 view .LVU101
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 466              		.loc 1 1923 72 is_stmt 0 view .LVU102
 467 0016 053A     		subs	r2, r2, #5
 468              	.LVL25:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 469              		.loc 1 1923 72 view .LVU103
 470              	.LBE149:
 471              	.LBE148:
 472              		.loc 1 1970 5 view .LVU104
 473 0018 022A     		cmp	r2, #2
 474 001a 02D8     		bhi	.L37
1971:Src/usb_pd_protocol.c **** 		charge |= TYPEC_CURRENT_DTS_MASK;
 475              		.loc 1 1971 3 is_stmt 1 view .LVU105
 476              		.loc 1 1971 10 is_stmt 0 view .LVU106
 477 001c 8023     		movs	r3, #128
 478              	.LVL26:
 479              		.loc 1 1971 10 view .LVU107
 480 001e 1B06     		lsls	r3, r3, #24
 481 0020 1843     		orrs	r0, r3
 482              	.LVL27:
1972:Src/usb_pd_protocol.c **** 
1973:Src/usb_pd_protocol.c **** 	return charge;
 483              		.loc 1 1973 2 is_stmt 1 view .LVU108
 484              	.L37:
1974:Src/usb_pd_protocol.c **** }
 485              		.loc 1 1974 1 is_stmt 0 view .LVU109
 486              		@ sp needed
 487 0022 7047     		bx	lr
 488              	.LVL28:
 489              	.L43:
1960:Src/usb_pd_protocol.c **** 	int cc_alt = polarity ? cc1 : cc2;
 490              		.loc 1 1960 26 view .LVU110
 491 0024 0B00     		movs	r3, r1
ARM GAS  /tmp/ccoQIC4J.s 			page 46


 492 0026 EEE7     		b	.L38
 493              	.LVL29:
 494              	.L46:
1963:Src/usb_pd_protocol.c **** 		charge = 3000;
 495              		.loc 1 1963 34 discriminator 1 view .LVU111
 496 0028 062A     		cmp	r2, #6
 497 002a F1D0     		beq	.L40
1964:Src/usb_pd_protocol.c **** 	else if (cc == TYPEC_CC_VOLT_SNK_1_5)
 498              		.loc 1 1964 10 view .LVU112
 499 002c 0148     		ldr	r0, .L48
 500              	.LVL30:
1964:Src/usb_pd_protocol.c **** 	else if (cc == TYPEC_CC_VOLT_SNK_1_5)
 501              		.loc 1 1964 10 view .LVU113
 502 002e F2E7     		b	.L41
 503              	.LVL31:
 504              	.L47:
1966:Src/usb_pd_protocol.c **** 	else
 505              		.loc 1 1966 10 view .LVU114
 506 0030 0148     		ldr	r0, .L48+4
 507              	.LVL32:
1966:Src/usb_pd_protocol.c **** 	else
 508              		.loc 1 1966 10 view .LVU115
 509 0032 F0E7     		b	.L41
 510              	.L49:
 511              		.align	2
 512              	.L48:
 513 0034 B80B0000 		.word	3000
 514 0038 DC050000 		.word	1500
 515              		.cfi_endproc
 516              	.LFE63:
 518              		.section	.text.set_state,"ax",%progbits
 519              		.align	1
 520              		.syntax unified
 521              		.code	16
 522              		.thumb_func
 523              		.fpu softvfp
 525              	set_state:
 526              	.LVL33:
 527              	.LFB24:
 327:Src/usb_pd_protocol.c **** 	enum pd_states last_state = pd[port].task_state;
 528              		.loc 1 327 1 is_stmt 1 view -0
 529              		.cfi_startproc
 530              		@ args = 0, pretend = 0, frame = 0
 531              		@ frame_needed = 0, uses_anonymous_args = 0
 327:Src/usb_pd_protocol.c **** 	enum pd_states last_state = pd[port].task_state;
 532              		.loc 1 327 1 is_stmt 0 view .LVU117
 533 0000 70B5     		push	{r4, r5, r6, lr}
 534              	.LCFI2:
 535              		.cfi_def_cfa_offset 16
 536              		.cfi_offset 4, -16
 537              		.cfi_offset 5, -12
 538              		.cfi_offset 6, -8
 539              		.cfi_offset 14, -4
 540 0002 0600     		movs	r6, r0
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 541              		.loc 1 328 2 is_stmt 1 view .LVU118
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
ARM GAS  /tmp/ccoQIC4J.s 			page 47


 542              		.loc 1 328 17 is_stmt 0 view .LVU119
 543 0004 C201     		lsls	r2, r0, #7
 544 0006 194B     		ldr	r3, .L59
 545 0008 9B18     		adds	r3, r3, r2
 546 000a 1A79     		ldrb	r2, [r3, #4]
 547              	.LVL34:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 548              		.loc 1 333 2 is_stmt 1 view .LVU120
 549              	.LBB154:
 550              	.LBI154:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 551              		.loc 1 261 20 view .LVU121
 552              	.LBB155:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 553              		.loc 1 265 2 view .LVU122
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 554              		.loc 1 265 19 is_stmt 0 view .LVU123
 555 000c 0024     		movs	r4, #0
 556 000e 0025     		movs	r5, #0
 557 0010 1C61     		str	r4, [r3, #16]
 558 0012 5D61     		str	r5, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 559              		.loc 1 266 2 is_stmt 1 view .LVU124
 266:Src/usb_pd_protocol.c **** }
 560              		.loc 1 266 25 is_stmt 0 view .LVU125
 561 0014 0020     		movs	r0, #0
 562              	.LVL35:
 266:Src/usb_pd_protocol.c **** }
 563              		.loc 1 266 25 view .LVU126
 564 0016 D871     		strb	r0, [r3, #7]
 565              	.LVL36:
 266:Src/usb_pd_protocol.c **** }
 566              		.loc 1 266 25 view .LVU127
 567              	.LBE155:
 568              	.LBE154:
 334:Src/usb_pd_protocol.c **** 
 569              		.loc 1 334 2 is_stmt 1 view .LVU128
 334:Src/usb_pd_protocol.c **** 
 570              		.loc 1 334 22 is_stmt 0 view .LVU129
 571 0018 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 572              		.loc 1 336 2 is_stmt 1 view .LVU130
 336:Src/usb_pd_protocol.c **** 		return;
 573              		.loc 1 336 5 is_stmt 0 view .LVU131
 574 001a 8A42     		cmp	r2, r1
 575 001c 07D0     		beq	.L50
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 576              		.loc 1 347 2 is_stmt 1 view .LVU132
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 577              		.loc 1 347 5 is_stmt 0 view .LVU133
 578 001e 022A     		cmp	r2, #2
 579 0020 06D0     		beq	.L56
 580              	.L52:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 581              		.loc 1 348 48 view .LVU134
 582 0022 0E2A     		cmp	r2, #14
 583 0024 07D0     		beq	.L57
ARM GAS  /tmp/ccoQIC4J.s 			page 48


 584              	.L53:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 585              		.loc 1 353 2 is_stmt 1 view .LVU135
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 586              		.loc 1 353 5 is_stmt 0 view .LVU136
 587 0026 0E29     		cmp	r1, #14
 588 0028 08D0     		beq	.L54
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 589              		.loc 1 353 46 discriminator 1 view .LVU137
 590 002a 0229     		cmp	r1, #2
 591 002c 06D0     		beq	.L54
 592              	.LVL37:
 593              	.L50:
 425:Src/usb_pd_protocol.c **** 
 594              		.loc 1 425 1 view .LVU138
 595              		@ sp needed
 596              	.LVL38:
 425:Src/usb_pd_protocol.c **** 
 597              		.loc 1 425 1 view .LVU139
 598 002e 70BD     		pop	{r4, r5, r6, pc}
 599              	.LVL39:
 600              	.L56:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 601              		.loc 1 347 47 discriminator 1 view .LVU140
 602 0030 0E29     		cmp	r1, #14
 603 0032 F6D1     		bne	.L52
 604 0034 FBE7     		b	.L50
 605              	.L57:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 606              		.loc 1 349 47 view .LVU141
 607 0036 0229     		cmp	r1, #2
 608 0038 F5D1     		bne	.L53
 609 003a F8E7     		b	.L50
 610              	.L54:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 611              		.loc 1 356 3 is_stmt 1 view .LVU142
 612 003c 0022     		movs	r2, #0
 613              	.LVL40:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 614              		.loc 1 356 3 is_stmt 0 view .LVU143
 615 003e 0021     		movs	r1, #0
 616              	.LVL41:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 617              		.loc 1 356 3 view .LVU144
 618 0040 3000     		movs	r0, r6
 619 0042 FFF7FEFF 		bl	pd_set_input_current_limit
 620              	.LVL42:
 373:Src/usb_pd_protocol.c **** 			/*
 621              		.loc 1 373 3 is_stmt 1 view .LVU145
 373:Src/usb_pd_protocol.c **** 			/*
 622              		.loc 1 373 15 is_stmt 0 view .LVU146
 623 0046 F301     		lsls	r3, r6, #7
 624 0048 084A     		ldr	r2, .L59
 625 004a 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 626              		.loc 1 373 6 view .LVU147
 627 004c 012B     		cmp	r3, #1
ARM GAS  /tmp/ccoQIC4J.s 			page 49


 628 004e 08D0     		beq	.L58
 629              	.L55:
 405:Src/usb_pd_protocol.c **** 	}
 630              		.loc 1 405 3 is_stmt 1 view .LVU148
 631              	.LVL43:
 632              	.LBB156:
 633              	.LBI156:
  91:Inc/tcpm.h    **** 						     data_role);
  92:Inc/tcpm.h    **** }
  93:Inc/tcpm.h    **** 
  94:Inc/tcpm.h    **** static inline int tcpm_set_rx_enable(int port, int enable)
 634              		.loc 2 94 19 view .LVU149
 635              	.LBB157:
  95:Inc/tcpm.h    **** {
  96:Inc/tcpm.h    **** 	return tcpc_config[port].drv->set_rx_enable(port, enable);
 636              		.loc 2 96 2 view .LVU150
 637              		.loc 2 96 26 is_stmt 0 view .LVU151
 638 0050 3201     		lsls	r2, r6, #4
 639 0052 074B     		ldr	r3, .L59+4
 640 0054 9B18     		adds	r3, r3, r2
 641 0056 9B68     		ldr	r3, [r3, #8]
 642              		.loc 2 96 30 view .LVU152
 643 0058 5B6A     		ldr	r3, [r3, #36]
 644              		.loc 2 96 9 view .LVU153
 645 005a 0021     		movs	r1, #0
 646 005c 3000     		movs	r0, r6
 647 005e 9847     		blx	r3
 648              	.LVL44:
 649 0060 E5E7     		b	.L50
 650              	.LVL45:
 651              	.L58:
 652              		.loc 2 96 9 view .LVU154
 653              	.LBE157:
 654              	.LBE156:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 655              		.loc 1 378 4 is_stmt 1 view .LVU155
 656 0062 3000     		movs	r0, r6
 657 0064 FFF7FEFF 		bl	pd_power_supply_reset
 658              	.LVL46:
 659 0068 F2E7     		b	.L55
 660              	.L60:
 661 006a C046     		.align	2
 662              	.L59:
 663 006c 00000000 		.word	pd
 664 0070 00000000 		.word	tcpc_config
 665              		.cfi_endproc
 666              	.LFE24:
 668              		.section	.text.queue_vdm,"ax",%progbits
 669              		.align	1
 670              		.syntax unified
 671              		.code	16
 672              		.thumb_func
 673              		.fpu softvfp
 675              	queue_vdm:
 676              	.LVL47:
 677              	.LFB33:
 838:Src/usb_pd_protocol.c **** 	pd[port].vdo_count = data_cnt + 1;
ARM GAS  /tmp/ccoQIC4J.s 			page 50


 678              		.loc 1 838 1 view -0
 679              		.cfi_startproc
 680              		@ args = 0, pretend = 0, frame = 0
 681              		@ frame_needed = 0, uses_anonymous_args = 0
 838:Src/usb_pd_protocol.c **** 	pd[port].vdo_count = data_cnt + 1;
 682              		.loc 1 838 1 is_stmt 0 view .LVU157
 683 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 684              	.LCFI3:
 685              		.cfi_def_cfa_offset 24
 686              		.cfi_offset 3, -24
 687              		.cfi_offset 4, -20
 688              		.cfi_offset 5, -16
 689              		.cfi_offset 6, -12
 690              		.cfi_offset 7, -8
 691              		.cfi_offset 14, -4
 692 0002 1500     		movs	r5, r2
 839:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 693              		.loc 1 839 2 is_stmt 1 view .LVU158
 839:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 694              		.loc 1 839 32 is_stmt 0 view .LVU159
 695 0004 5F1C     		adds	r7, r3, #1
 839:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 696              		.loc 1 839 21 view .LVU160
 697 0006 094A     		ldr	r2, .L62
 698              	.LVL48:
 839:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 699              		.loc 1 839 21 view .LVU161
 700 0008 C001     		lsls	r0, r0, #7
 701              	.LVL49:
 839:Src/usb_pd_protocol.c **** 	pd[port].vdo_data[0] = header[0];
 702              		.loc 1 839 21 view .LVU162
 703 000a 1418     		adds	r4, r2, r0
 704 000c 2600     		movs	r6, r4
 705 000e 7436     		adds	r6, r6, #116
 706 0010 3770     		strb	r7, [r6]
 840:Src/usb_pd_protocol.c **** 	memcpy(&pd[port].vdo_data[1], data, sizeof(uint32_t) * data_cnt);
 707              		.loc 1 840 2 is_stmt 1 view .LVU163
 840:Src/usb_pd_protocol.c **** 	memcpy(&pd[port].vdo_data[1], data, sizeof(uint32_t) * data_cnt);
 708              		.loc 1 840 31 is_stmt 0 view .LVU164
 709 0012 0968     		ldr	r1, [r1]
 710              	.LVL50:
 840:Src/usb_pd_protocol.c **** 	memcpy(&pd[port].vdo_data[1], data, sizeof(uint32_t) * data_cnt);
 711              		.loc 1 840 31 view .LVU165
 712 0014 A165     		str	r1, [r4, #88]
 841:Src/usb_pd_protocol.c **** 	/* Set ready, pd task will actually send */
 713              		.loc 1 841 2 is_stmt 1 view .LVU166
 841:Src/usb_pd_protocol.c **** 	/* Set ready, pd task will actually send */
 714              		.loc 1 841 9 is_stmt 0 view .LVU167
 715 0016 5C30     		adds	r0, r0, #92
 716 0018 8018     		adds	r0, r0, r2
 841:Src/usb_pd_protocol.c **** 	/* Set ready, pd task will actually send */
 717              		.loc 1 841 2 view .LVU168
 718 001a 9A00     		lsls	r2, r3, #2
 719 001c 2900     		movs	r1, r5
 720 001e FFF7FEFF 		bl	memcpy
 721              	.LVL51:
 843:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 51


 722              		.loc 1 843 2 is_stmt 1 view .LVU169
 843:Src/usb_pd_protocol.c **** }
 723              		.loc 1 843 21 is_stmt 0 view .LVU170
 724 0022 4834     		adds	r4, r4, #72
 725 0024 0123     		movs	r3, #1
 726 0026 2370     		strb	r3, [r4]
 844:Src/usb_pd_protocol.c **** 
 727              		.loc 1 844 1 view .LVU171
 728              		@ sp needed
 729              	.LVL52:
 730              	.LVL53:
 844:Src/usb_pd_protocol.c **** 
 731              		.loc 1 844 1 view .LVU172
 732 0028 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 733              	.L63:
 734 002a C046     		.align	2
 735              	.L62:
 736 002c 00000000 		.word	pd
 737              		.cfi_endproc
 738              	.LFE33:
 740              		.section	.text.handle_vdm_request,"ax",%progbits
 741              		.align	1
 742              		.syntax unified
 743              		.code	16
 744              		.thumb_func
 745              		.fpu softvfp
 747              	handle_vdm_request:
 748              	.LVL54:
 749              	.LFB34:
 847:Src/usb_pd_protocol.c **** 	int rlen = 0;
 750              		.loc 1 847 1 is_stmt 1 view -0
 751              		.cfi_startproc
 752              		@ args = 0, pretend = 0, frame = 16
 753              		@ frame_needed = 0, uses_anonymous_args = 0
 847:Src/usb_pd_protocol.c **** 	int rlen = 0;
 754              		.loc 1 847 1 is_stmt 0 view .LVU174
 755 0000 30B5     		push	{r4, r5, lr}
 756              	.LCFI4:
 757              		.cfi_def_cfa_offset 12
 758              		.cfi_offset 4, -12
 759              		.cfi_offset 5, -8
 760              		.cfi_offset 14, -4
 761 0002 85B0     		sub	sp, sp, #20
 762              	.LCFI5:
 763              		.cfi_def_cfa_offset 32
 764 0004 0400     		movs	r4, r0
 765 0006 1500     		movs	r5, r2
 848:Src/usb_pd_protocol.c **** 	uint32_t *rdata;
 766              		.loc 1 848 2 is_stmt 1 view .LVU175
 767              	.LVL55:
 849:Src/usb_pd_protocol.c **** 
 768              		.loc 1 849 2 view .LVU176
 851:Src/usb_pd_protocol.c **** 		/* If UFP responded busy retry after timeout */
 769              		.loc 1 851 2 view .LVU177
 851:Src/usb_pd_protocol.c **** 		/* If UFP responded busy retry after timeout */
 770              		.loc 1 851 14 is_stmt 0 view .LVU178
 771 0008 C201     		lsls	r2, r0, #7
ARM GAS  /tmp/ccoQIC4J.s 			page 52


 772              	.LVL56:
 851:Src/usb_pd_protocol.c **** 		/* If UFP responded busy retry after timeout */
 773              		.loc 1 851 14 view .LVU179
 774 000a 224B     		ldr	r3, .L75
 775 000c 9B18     		adds	r3, r3, r2
 776 000e 4833     		adds	r3, r3, #72
 777 0010 1B78     		ldrb	r3, [r3]
 778 0012 5BB2     		sxtb	r3, r3
 851:Src/usb_pd_protocol.c **** 		/* If UFP responded busy retry after timeout */
 779              		.loc 1 851 5 view .LVU180
 780 0014 022B     		cmp	r3, #2
 781 0016 0BD0     		beq	.L72
 782              	.L65:
 865:Src/usb_pd_protocol.c **** 		rlen = pd_svdm(port, cnt, payload, &rdata);
 783              		.loc 1 865 2 is_stmt 1 view .LVU181
 865:Src/usb_pd_protocol.c **** 		rlen = pd_svdm(port, cnt, payload, &rdata);
 784              		.loc 1 865 5 is_stmt 0 view .LVU182
 785 0018 2B68     		ldr	r3, [r5]
 786 001a 1B04     		lsls	r3, r3, #16
 787 001c 2CD5     		bpl	.L68
 866:Src/usb_pd_protocol.c **** 	else
 788              		.loc 1 866 3 is_stmt 1 view .LVU183
 866:Src/usb_pd_protocol.c **** 	else
 789              		.loc 1 866 10 is_stmt 0 view .LVU184
 790 001e 03AB     		add	r3, sp, #12
 791 0020 2A00     		movs	r2, r5
 792 0022 2000     		movs	r0, r4
 793              	.LVL57:
 866:Src/usb_pd_protocol.c **** 	else
 794              		.loc 1 866 10 view .LVU185
 795 0024 FFF7FEFF 		bl	pd_svdm
 796              	.LVL58:
 797              	.L69:
 870:Src/usb_pd_protocol.c **** 		queue_vdm(port, rdata, &rdata[1], rlen - 1);
 798              		.loc 1 870 2 is_stmt 1 view .LVU186
 870:Src/usb_pd_protocol.c **** 		queue_vdm(port, rdata, &rdata[1], rlen - 1);
 799              		.loc 1 870 5 is_stmt 0 view .LVU187
 800 0028 0028     		cmp	r0, #0
 801 002a 2BDC     		bgt	.L73
 802              	.LVL59:
 803              	.L64:
 877:Src/usb_pd_protocol.c **** 
 804              		.loc 1 877 1 view .LVU188
 805 002c 05B0     		add	sp, sp, #20
 806              		@ sp needed
 807              	.LVL60:
 877:Src/usb_pd_protocol.c **** 
 808              		.loc 1 877 1 view .LVU189
 809 002e 30BD     		pop	{r4, r5, pc}
 810              	.LVL61:
 811              	.L72:
 853:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 812              		.loc 1 853 3 is_stmt 1 view .LVU190
 853:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 813              		.loc 1 853 7 is_stmt 0 view .LVU191
 814 0030 2B68     		ldr	r3, [r5]
 815 0032 9A09     		lsrs	r2, r3, #6
ARM GAS  /tmp/ccoQIC4J.s 			page 53


 816 0034 0323     		movs	r3, #3
 817 0036 1340     		ands	r3, r2
 853:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 818              		.loc 1 853 6 view .LVU192
 819 0038 032B     		cmp	r3, #3
 820 003a 06D0     		beq	.L74
 861:Src/usb_pd_protocol.c **** 		}
 821              		.loc 1 861 4 is_stmt 1 view .LVU193
 861:Src/usb_pd_protocol.c **** 		}
 822              		.loc 1 861 23 is_stmt 0 view .LVU194
 823 003c C201     		lsls	r2, r0, #7
 824 003e 154B     		ldr	r3, .L75
 825 0040 9B18     		adds	r3, r3, r2
 826 0042 4833     		adds	r3, r3, #72
 827 0044 0022     		movs	r2, #0
 828 0046 1A70     		strb	r2, [r3]
 829 0048 E6E7     		b	.L65
 830              	.L74:
 854:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 831              		.loc 1 854 4 is_stmt 1 view .LVU195
 854:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 832              		.loc 1 854 31 is_stmt 0 view .LVU196
 833 004a 6846     		mov	r0, sp
 834              	.LVL62:
 854:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 835              		.loc 1 854 31 view .LVU197
 836 004c FFF7FEFF 		bl	get_time
 837              	.LVL63:
 854:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 838              		.loc 1 854 46 view .LVU198
 839 0050 114A     		ldr	r2, .L75+4
 840 0052 0023     		movs	r3, #0
 841 0054 0098     		ldr	r0, [sp]
 842 0056 0199     		ldr	r1, [sp, #4]
 843 0058 1218     		adds	r2, r2, r0
 844 005a 4B41     		adcs	r3, r3, r1
 854:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 845              		.loc 1 854 29 view .LVU199
 846 005c E401     		lsls	r4, r4, #7
 847              	.LVL64:
 854:Src/usb_pd_protocol.c **** 				PD_T_VDM_BUSY;
 848              		.loc 1 854 29 view .LVU200
 849 005e 0D49     		ldr	r1, .L75
 850 0060 0C19     		adds	r4, r1, r4
 851 0062 2265     		str	r2, [r4, #80]
 852 0064 6365     		str	r3, [r4, #84]
 856:Src/usb_pd_protocol.c **** 			pd[port].vdo_retry = (payload[0] & ~VDO_CMDT_MASK) |
 853              		.loc 1 856 4 is_stmt 1 view .LVU201
 856:Src/usb_pd_protocol.c **** 			pd[port].vdo_retry = (payload[0] & ~VDO_CMDT_MASK) |
 854              		.loc 1 856 23 is_stmt 0 view .LVU202
 855 0066 2300     		movs	r3, r4
 856 0068 4833     		adds	r3, r3, #72
 857 006a 0322     		movs	r2, #3
 858 006c 1A70     		strb	r2, [r3]
 857:Src/usb_pd_protocol.c **** 				CMDT_INIT;
 859              		.loc 1 857 4 is_stmt 1 view .LVU203
 857:Src/usb_pd_protocol.c **** 				CMDT_INIT;
ARM GAS  /tmp/ccoQIC4J.s 			page 54


 860              		.loc 1 857 33 is_stmt 0 view .LVU204
 861 006e 2B68     		ldr	r3, [r5]
 857:Src/usb_pd_protocol.c **** 				CMDT_INIT;
 862              		.loc 1 857 55 view .LVU205
 863 0070 BD32     		adds	r2, r2, #189
 864 0072 9343     		bics	r3, r2
 857:Src/usb_pd_protocol.c **** 				CMDT_INIT;
 865              		.loc 1 857 23 view .LVU206
 866 0074 A367     		str	r3, [r4, #120]
 859:Src/usb_pd_protocol.c **** 		} else {
 867              		.loc 1 859 4 is_stmt 1 view .LVU207
 868 0076 D9E7     		b	.L64
 869              	.LVL65:
 870              	.L68:
 868:Src/usb_pd_protocol.c **** 
 871              		.loc 1 868 3 view .LVU208
 868:Src/usb_pd_protocol.c **** 
 872              		.loc 1 868 10 is_stmt 0 view .LVU209
 873 0078 03AB     		add	r3, sp, #12
 874 007a 2A00     		movs	r2, r5
 875 007c 2000     		movs	r0, r4
 876              	.LVL66:
 868:Src/usb_pd_protocol.c **** 
 877              		.loc 1 868 10 view .LVU210
 878 007e FFF7FEFF 		bl	pd_custom_vdm
 879              	.LVL67:
 868:Src/usb_pd_protocol.c **** 
 880              		.loc 1 868 10 view .LVU211
 881 0082 D1E7     		b	.L69
 882              	.L73:
 871:Src/usb_pd_protocol.c **** 		return;
 883              		.loc 1 871 3 is_stmt 1 view .LVU212
 871:Src/usb_pd_protocol.c **** 		return;
 884              		.loc 1 871 26 is_stmt 0 view .LVU213
 885 0084 039B     		ldr	r3, [sp, #12]
 886 0086 1A1D     		adds	r2, r3, #4
 871:Src/usb_pd_protocol.c **** 		return;
 887              		.loc 1 871 3 view .LVU214
 888 0088 431E     		subs	r3, r0, #1
 889 008a 0399     		ldr	r1, [sp, #12]
 890 008c 2000     		movs	r0, r4
 891              	.LVL68:
 871:Src/usb_pd_protocol.c **** 		return;
 892              		.loc 1 871 3 view .LVU215
 893 008e FFF7FEFF 		bl	queue_vdm
 894              	.LVL69:
 872:Src/usb_pd_protocol.c **** 	}
 895              		.loc 1 872 3 is_stmt 1 view .LVU216
 896 0092 CBE7     		b	.L64
 897              	.L76:
 898              		.align	2
 899              	.L75:
 900 0094 00000000 		.word	pd
 901 0098 A0860100 		.word	100000
 902              		.cfi_endproc
 903              	.LFE34:
 905              		.section	.text.pd_set_data_role,"ax",%progbits
ARM GAS  /tmp/ccoQIC4J.s 			page 55


 906              		.align	1
 907              		.syntax unified
 908              		.code	16
 909              		.thumb_func
 910              		.fpu softvfp
 912              	pd_set_data_role:
 913              	.LVL70:
 914              	.LFB43:
1242:Src/usb_pd_protocol.c **** 	pd[port].data_role = role;
 915              		.loc 1 1242 1 view -0
 916              		.cfi_startproc
 917              		@ args = 0, pretend = 0, frame = 0
 918              		@ frame_needed = 0, uses_anonymous_args = 0
1242:Src/usb_pd_protocol.c **** 	pd[port].data_role = role;
 919              		.loc 1 1242 1 is_stmt 0 view .LVU218
 920 0000 10B5     		push	{r4, lr}
 921              	.LCFI6:
 922              		.cfi_def_cfa_offset 8
 923              		.cfi_offset 4, -8
 924              		.cfi_offset 14, -4
 925 0002 0400     		movs	r4, r0
1243:Src/usb_pd_protocol.c **** 	pd_execute_data_swap(port, role);
 926              		.loc 1 1243 2 is_stmt 1 view .LVU219
1243:Src/usb_pd_protocol.c **** 	pd_execute_data_swap(port, role);
 927              		.loc 1 1243 21 is_stmt 0 view .LVU220
 928 0004 C201     		lsls	r2, r0, #7
 929 0006 044B     		ldr	r3, .L78
 930 0008 9B18     		adds	r3, r3, r2
 931 000a 5970     		strb	r1, [r3, #1]
1244:Src/usb_pd_protocol.c **** 
 932              		.loc 1 1244 2 is_stmt 1 view .LVU221
 933 000c FFF7FEFF 		bl	pd_execute_data_swap
 934              	.LVL71:
1263:Src/usb_pd_protocol.c **** }
 935              		.loc 1 1263 2 view .LVU222
 936 0010 2000     		movs	r0, r4
 937 0012 FFF7FEFF 		bl	pd_update_roles
 938              	.LVL72:
1264:Src/usb_pd_protocol.c **** 
 939              		.loc 1 1264 1 is_stmt 0 view .LVU223
 940              		@ sp needed
 941              	.LVL73:
1264:Src/usb_pd_protocol.c **** 
 942              		.loc 1 1264 1 view .LVU224
 943 0016 10BD     		pop	{r4, pc}
 944              	.L79:
 945              		.align	2
 946              	.L78:
 947 0018 00000000 		.word	pd
 948              		.cfi_endproc
 949              	.LFE43:
 951              		.section	.text.pd_dr_swap,"ax",%progbits
 952              		.align	1
 953              		.syntax unified
 954              		.code	16
 955              		.thumb_func
 956              		.fpu softvfp
ARM GAS  /tmp/ccoQIC4J.s 			page 56


 958              	pd_dr_swap:
 959              	.LVL74:
 960              	.LFB44:
1267:Src/usb_pd_protocol.c **** 	pd_set_data_role(port, !pd[port].data_role);
 961              		.loc 1 1267 1 is_stmt 1 view -0
 962              		.cfi_startproc
 963              		@ args = 0, pretend = 0, frame = 0
 964              		@ frame_needed = 0, uses_anonymous_args = 0
1267:Src/usb_pd_protocol.c **** 	pd_set_data_role(port, !pd[port].data_role);
 965              		.loc 1 1267 1 is_stmt 0 view .LVU226
 966 0000 10B5     		push	{r4, lr}
 967              	.LCFI7:
 968              		.cfi_def_cfa_offset 8
 969              		.cfi_offset 4, -8
 970              		.cfi_offset 14, -4
1268:Src/usb_pd_protocol.c **** 	pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 971              		.loc 1 1268 2 is_stmt 1 view .LVU227
1268:Src/usb_pd_protocol.c **** 	pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 972              		.loc 1 1268 34 is_stmt 0 view .LVU228
 973 0002 C301     		lsls	r3, r0, #7
 974 0004 054C     		ldr	r4, .L81
 975 0006 E418     		adds	r4, r4, r3
 976 0008 6178     		ldrb	r1, [r4, #1]
1268:Src/usb_pd_protocol.c **** 	pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 977              		.loc 1 1268 2 view .LVU229
 978 000a 4B42     		rsbs	r3, r1, #0
 979 000c 5941     		adcs	r1, r1, r3
 980 000e FFF7FEFF 		bl	pd_set_data_role
 981              	.LVL75:
1269:Src/usb_pd_protocol.c **** }
 982              		.loc 1 1269 2 is_stmt 1 view .LVU230
1269:Src/usb_pd_protocol.c **** }
 983              		.loc 1 1269 17 is_stmt 0 view .LVU231
 984 0012 0823     		movs	r3, #8
 985 0014 A268     		ldr	r2, [r4, #8]
 986 0016 1343     		orrs	r3, r2
 987 0018 A360     		str	r3, [r4, #8]
1270:Src/usb_pd_protocol.c **** 
 988              		.loc 1 1270 1 view .LVU232
 989              		@ sp needed
 990 001a 10BD     		pop	{r4, pc}
 991              	.L82:
 992              		.align	2
 993              	.L81:
 994 001c 00000000 		.word	pd
 995              		.cfi_endproc
 996              	.LFE44:
 998              		.section	.text.pd_restart_tcpc,"ax",%progbits
 999              		.align	1
 1000              		.syntax unified
 1001              		.code	16
 1002              		.thumb_func
 1003              		.fpu softvfp
 1005              	pd_restart_tcpc:
 1006              	.LVL76:
 1007              	.LFB65:
1975:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 57


1976:Src/usb_pd_protocol.c **** /**
1977:Src/usb_pd_protocol.c ****  * Signal power request to indicate a charger update that affects the port.
1978:Src/usb_pd_protocol.c ****  */
1979:Src/usb_pd_protocol.c **** void pd_set_new_power_request(int port)
1980:Src/usb_pd_protocol.c **** {
1981:Src/usb_pd_protocol.c **** 	pd[port].new_power_request = 1;
1982:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
1983:Src/usb_pd_protocol.c **** 	//task_wake(PD_PORT_TO_TASK_ID(port));
1984:Src/usb_pd_protocol.c **** }
1985:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
1986:Src/usb_pd_protocol.c **** 
1987:Src/usb_pd_protocol.c **** #if defined(CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP) && defined(CONFIG_USBC_SS_MUX)
1988:Src/usb_pd_protocol.c **** /*
1989:Src/usb_pd_protocol.c ****  * Backwards compatible DFP does not support USB SS because it applies VBUS
1990:Src/usb_pd_protocol.c ****  * before debouncing CC and setting USB SS muxes, but SS detection will fail
1991:Src/usb_pd_protocol.c ****  * before we are done debouncing CC.
1992:Src/usb_pd_protocol.c ****  */
1993:Src/usb_pd_protocol.c **** #error "Backwards compatible DFP does not support USB"
1994:Src/usb_pd_protocol.c **** #endif
1995:Src/usb_pd_protocol.c **** 
1996:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
1997:Src/usb_pd_protocol.c **** 
1998:Src/usb_pd_protocol.c **** /* Initialize globals based on system state. */
1999:Src/usb_pd_protocol.c **** static void pd_init_tasks(void)
2000:Src/usb_pd_protocol.c **** {
2001:Src/usb_pd_protocol.c **** 	static int initialized;
2002:Src/usb_pd_protocol.c **** 	int enable = 1;
2003:Src/usb_pd_protocol.c **** 	int i;
2004:Src/usb_pd_protocol.c **** 
2005:Src/usb_pd_protocol.c **** 	/* Initialize globals once, for all PD tasks.  */
2006:Src/usb_pd_protocol.c **** 	if (initialized)
2007:Src/usb_pd_protocol.c **** 		return;
2008:Src/usb_pd_protocol.c **** 
2009:Src/usb_pd_protocol.c **** #if defined(HAS_TASK_CHIPSET) && defined(CONFIG_USB_PD_DUAL_ROLE)
2010:Src/usb_pd_protocol.c **** 	/* Set dual-role state based on chipset power state */
2011:Src/usb_pd_protocol.c **** 	if (chipset_in_state(CHIPSET_STATE_ANY_OFF))
2012:Src/usb_pd_protocol.c **** 		drp_state = PD_DRP_FORCE_SINK;
2013:Src/usb_pd_protocol.c **** 	else if (chipset_in_state(CHIPSET_STATE_SUSPEND))
2014:Src/usb_pd_protocol.c **** 		drp_state = PD_DRP_TOGGLE_OFF;
2015:Src/usb_pd_protocol.c **** 	else /* CHIPSET_STATE_ON */
2016:Src/usb_pd_protocol.c **** 		drp_state = PD_DRP_TOGGLE_ON;
2017:Src/usb_pd_protocol.c **** #endif
2018:Src/usb_pd_protocol.c **** 
2019:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_COMM_DISABLED)
2020:Src/usb_pd_protocol.c **** 	enable = 0;
2021:Src/usb_pd_protocol.c **** #elif defined(CONFIG_USB_PD_COMM_LOCKED)
2022:Src/usb_pd_protocol.c **** 	/* Disable PD communication at init if we're in RO and locked. */
2023:Src/usb_pd_protocol.c **** 	if (!system_is_in_rw() && system_is_locked())
2024:Src/usb_pd_protocol.c **** 		enable = 0;
2025:Src/usb_pd_protocol.c **** #endif
2026:Src/usb_pd_protocol.c **** 	for (i = 0; i < CONFIG_USB_PD_PORT_COUNT; i++)
2027:Src/usb_pd_protocol.c **** 		pd_comm_enabled[i] = enable;
2028:Src/usb_pd_protocol.c **** 	CPRINTS("PD comm %sabled", enable ? "en" : "dis");
2029:Src/usb_pd_protocol.c **** 
2030:Src/usb_pd_protocol.c **** 	initialized = 1;
2031:Src/usb_pd_protocol.c **** }
2032:Src/usb_pd_protocol.c **** #endif /* CONFIG_COMMON_RUNTIME */
ARM GAS  /tmp/ccoQIC4J.s 			page 58


2033:Src/usb_pd_protocol.c **** 
2034:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
2035:Src/usb_pd_protocol.c **** static int pd_restart_tcpc(int port)
2036:Src/usb_pd_protocol.c **** {
 1008              		.loc 1 2036 1 is_stmt 1 view -0
 1009              		.cfi_startproc
 1010              		@ args = 0, pretend = 0, frame = 0
 1011              		@ frame_needed = 0, uses_anonymous_args = 0
 1012              		.loc 1 2036 1 is_stmt 0 view .LVU234
 1013 0000 10B5     		push	{r4, lr}
 1014              	.LCFI8:
 1015              		.cfi_def_cfa_offset 8
 1016              		.cfi_offset 4, -8
 1017              		.cfi_offset 14, -4
 1018 0002 0400     		movs	r4, r0
2037:Src/usb_pd_protocol.c **** 	if (board_set_tcpc_power_mode) {
 1019              		.loc 1 2037 2 is_stmt 1 view .LVU235
 1020              		.loc 1 2037 5 is_stmt 0 view .LVU236
 1021 0004 0A4B     		ldr	r3, .L86
 1022 0006 002B     		cmp	r3, #0
 1023 0008 02D0     		beq	.L84
2038:Src/usb_pd_protocol.c **** 		/* force chip reset */
2039:Src/usb_pd_protocol.c **** 		board_set_tcpc_power_mode(port, 0);
 1024              		.loc 1 2039 3 is_stmt 1 view .LVU237
 1025 000a 0021     		movs	r1, #0
 1026 000c FFF7FEFF 		bl	board_set_tcpc_power_mode
 1027              	.LVL77:
 1028              	.L84:
2040:Src/usb_pd_protocol.c **** 	}
2041:Src/usb_pd_protocol.c **** 	return tcpm_init(port);
 1029              		.loc 1 2041 2 view .LVU238
 1030              	.LBB160:
 1031              	.LBI160:
  38:Inc/tcpm.h    **** {
 1032              		.loc 2 38 19 view .LVU239
 1033              	.LBB161:
  40:Inc/tcpm.h    **** 
 1034              		.loc 2 40 2 view .LVU240
  42:Inc/tcpm.h    **** 	if (rv)
 1035              		.loc 2 42 2 view .LVU241
  42:Inc/tcpm.h    **** 	if (rv)
 1036              		.loc 2 42 24 is_stmt 0 view .LVU242
 1037 0010 2201     		lsls	r2, r4, #4
 1038 0012 084B     		ldr	r3, .L86+4
 1039 0014 9B18     		adds	r3, r3, r2
 1040 0016 9B68     		ldr	r3, [r3, #8]
  42:Inc/tcpm.h    **** 	if (rv)
 1041              		.loc 2 42 28 view .LVU243
 1042 0018 1B68     		ldr	r3, [r3]
  42:Inc/tcpm.h    **** 	if (rv)
 1043              		.loc 2 42 7 view .LVU244
 1044 001a 2000     		movs	r0, r4
 1045 001c 9847     		blx	r3
 1046              	.LVL78:
  43:Inc/tcpm.h    **** 		return rv;
 1047              		.loc 2 43 2 is_stmt 1 view .LVU245
  43:Inc/tcpm.h    **** 		return rv;
ARM GAS  /tmp/ccoQIC4J.s 			page 59


 1048              		.loc 2 43 5 is_stmt 0 view .LVU246
 1049 001e 0028     		cmp	r0, #0
 1050 0020 05D1     		bne	.L83
  47:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
 1051              		.loc 2 47 2 is_stmt 1 view .LVU247
  47:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
 1052              		.loc 2 47 5 is_stmt 0 view .LVU248
 1053 0022 054B     		ldr	r3, .L86+8
 1054 0024 002B     		cmp	r3, #0
 1055 0026 02D0     		beq	.L83
  48:Inc/tcpm.h    **** 
 1056              		.loc 2 48 3 is_stmt 1 view .LVU249
  48:Inc/tcpm.h    **** 
 1057              		.loc 2 48 8 is_stmt 0 view .LVU250
 1058 0028 2000     		movs	r0, r4
 1059              	.LVL79:
  48:Inc/tcpm.h    **** 
 1060              		.loc 2 48 8 view .LVU251
 1061 002a FFF7FEFF 		bl	board_tcpc_post_init
 1062              	.LVL80:
 1063              	.L83:
  48:Inc/tcpm.h    **** 
 1064              		.loc 2 48 8 view .LVU252
 1065              	.LBE161:
 1066              	.LBE160:
2042:Src/usb_pd_protocol.c **** }
 1067              		.loc 1 2042 1 view .LVU253
 1068              		@ sp needed
 1069              	.LVL81:
 1070              		.loc 1 2042 1 view .LVU254
 1071 002e 10BD     		pop	{r4, pc}
 1072              	.L87:
 1073              		.align	2
 1074              	.L86:
 1075 0030 00000000 		.word	board_set_tcpc_power_mode
 1076 0034 00000000 		.word	tcpc_config
 1077 0038 00000000 		.word	board_tcpc_post_init
 1078              		.cfi_endproc
 1079              	.LFE65:
 1081              		.section	.text.execute_soft_reset,"ax",%progbits
 1082              		.align	1
 1083              		.syntax unified
 1084              		.code	16
 1085              		.thumb_func
 1086              		.fpu softvfp
 1088              	execute_soft_reset:
 1089              	.LVL82:
 1090              	.LFB36:
 933:Src/usb_pd_protocol.c **** 	pd[port].msg_id = 0;
 1091              		.loc 1 933 1 is_stmt 1 view -0
 1092              		.cfi_startproc
 1093              		@ args = 0, pretend = 0, frame = 0
 1094              		@ frame_needed = 0, uses_anonymous_args = 0
 933:Src/usb_pd_protocol.c **** 	pd[port].msg_id = 0;
 1095              		.loc 1 933 1 is_stmt 0 view .LVU256
 1096 0000 D0B5     		push	{r4, r6, r7, lr}
 1097              	.LCFI9:
ARM GAS  /tmp/ccoQIC4J.s 			page 60


 1098              		.cfi_def_cfa_offset 16
 1099              		.cfi_offset 4, -16
 1100              		.cfi_offset 6, -12
 1101              		.cfi_offset 7, -8
 1102              		.cfi_offset 14, -4
 1103 0002 0400     		movs	r4, r0
 934:Src/usb_pd_protocol.c **** 	set_state(port, DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_DISCOVERY,
 1104              		.loc 1 934 2 is_stmt 1 view .LVU257
 934:Src/usb_pd_protocol.c **** 	set_state(port, DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_DISCOVERY,
 1105              		.loc 1 934 18 is_stmt 0 view .LVU258
 1106 0004 1B4B     		ldr	r3, .L97
 1107 0006 C201     		lsls	r2, r0, #7
 1108 0008 9918     		adds	r1, r3, r2
 1109 000a 0020     		movs	r0, #0
 1110              	.LVL83:
 934:Src/usb_pd_protocol.c **** 	set_state(port, DUAL_ROLE_IF_ELSE(port, PD_STATE_SNK_DISCOVERY,
 1111              		.loc 1 934 18 view .LVU259
 1112 000c 8870     		strb	r0, [r1, #2]
 935:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 1113              		.loc 1 935 2 is_stmt 1 view .LVU260
 935:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 1114              		.loc 1 935 18 is_stmt 0 view .LVU261
 1115 000e D35C     		ldrb	r3, [r2, r3]
 935:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 1116              		.loc 1 935 2 view .LVU262
 1117 0010 002B     		cmp	r3, #0
 1118 0012 12D1     		bne	.L93
 1119 0014 0521     		movs	r1, #5
 1120              	.L89:
 1121              	.LVL84:
 1122              	.LBB168:
 1123              	.LBI168:
 326:Src/usb_pd_protocol.c **** {
 1124              		.loc 1 326 20 is_stmt 1 discriminator 4 view .LVU263
 1125              	.LBB169:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 1126              		.loc 1 328 2 discriminator 4 view .LVU264
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 1127              		.loc 1 328 17 is_stmt 0 discriminator 4 view .LVU265
 1128 0016 E201     		lsls	r2, r4, #7
 1129 0018 164B     		ldr	r3, .L97
 1130 001a 9B18     		adds	r3, r3, r2
 1131 001c 1A79     		ldrb	r2, [r3, #4]
 1132              	.LVL85:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 1133              		.loc 1 333 2 is_stmt 1 discriminator 4 view .LVU266
 1134              	.LBB170:
 1135              	.LBI170:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 1136              		.loc 1 261 20 discriminator 4 view .LVU267
 1137              	.LBB171:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1138              		.loc 1 265 2 discriminator 4 view .LVU268
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1139              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU269
 1140 001e 0026     		movs	r6, #0
 1141 0020 0027     		movs	r7, #0
ARM GAS  /tmp/ccoQIC4J.s 			page 61


 1142 0022 1E61     		str	r6, [r3, #16]
 1143 0024 5F61     		str	r7, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 1144              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU270
 266:Src/usb_pd_protocol.c **** }
 1145              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU271
 1146 0026 0020     		movs	r0, #0
 1147 0028 D871     		strb	r0, [r3, #7]
 1148              	.LVL86:
 266:Src/usb_pd_protocol.c **** }
 1149              		.loc 1 266 25 discriminator 4 view .LVU272
 1150              	.LBE171:
 1151              	.LBE170:
 334:Src/usb_pd_protocol.c **** 
 1152              		.loc 1 334 2 is_stmt 1 discriminator 4 view .LVU273
 334:Src/usb_pd_protocol.c **** 
 1153              		.loc 1 334 22 is_stmt 0 discriminator 4 view .LVU274
 1154 002a 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 1155              		.loc 1 336 2 is_stmt 1 discriminator 4 view .LVU275
 336:Src/usb_pd_protocol.c **** 		return;
 1156              		.loc 1 336 5 is_stmt 0 discriminator 4 view .LVU276
 1157 002c 9142     		cmp	r1, r2
 1158 002e 03D0     		beq	.L88
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 1159              		.loc 1 347 2 is_stmt 1 view .LVU277
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 1160              		.loc 1 348 48 is_stmt 0 view .LVU278
 1161 0030 0E2A     		cmp	r2, #14
 1162 0032 04D0     		beq	.L94
 1163              	.L91:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 1164              		.loc 1 353 2 is_stmt 1 view .LVU279
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 1165              		.loc 1 353 46 is_stmt 0 view .LVU280
 1166 0034 0229     		cmp	r1, #2
 1167 0036 05D0     		beq	.L95
 1168              	.LVL87:
 1169              	.L88:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 1170              		.loc 1 353 46 view .LVU281
 1171              	.LBE169:
 1172              	.LBE168:
 938:Src/usb_pd_protocol.c **** 
 1173              		.loc 1 938 1 view .LVU282
 1174              		@ sp needed
 1175              	.LVL88:
 938:Src/usb_pd_protocol.c **** 
 1176              		.loc 1 938 1 view .LVU283
 1177 0038 D0BD     		pop	{r4, r6, r7, pc}
 1178              	.LVL89:
 1179              	.L93:
 935:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCOVERY));
 1180              		.loc 1 935 2 view .LVU284
 1181 003a 1221     		movs	r1, #18
 1182 003c EBE7     		b	.L89
 1183              	.LVL90:
ARM GAS  /tmp/ccoQIC4J.s 			page 62


 1184              	.L94:
 1185              	.LBB176:
 1186              	.LBB174:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 1187              		.loc 1 349 47 view .LVU285
 1188 003e 0229     		cmp	r1, #2
 1189 0040 F8D1     		bne	.L91
 1190 0042 F9E7     		b	.L88
 1191              	.L95:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1192              		.loc 1 356 3 is_stmt 1 view .LVU286
 1193 0044 0022     		movs	r2, #0
 1194              	.LVL91:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1195              		.loc 1 356 3 is_stmt 0 view .LVU287
 1196 0046 0021     		movs	r1, #0
 1197              	.LVL92:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1198              		.loc 1 356 3 view .LVU288
 1199 0048 2000     		movs	r0, r4
 1200 004a FFF7FEFF 		bl	pd_set_input_current_limit
 1201              	.LVL93:
 373:Src/usb_pd_protocol.c **** 			/*
 1202              		.loc 1 373 3 is_stmt 1 view .LVU289
 373:Src/usb_pd_protocol.c **** 			/*
 1203              		.loc 1 373 15 is_stmt 0 view .LVU290
 1204 004e E301     		lsls	r3, r4, #7
 1205 0050 084A     		ldr	r2, .L97
 1206 0052 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 1207              		.loc 1 373 6 view .LVU291
 1208 0054 012B     		cmp	r3, #1
 1209 0056 08D0     		beq	.L96
 1210              	.L92:
 405:Src/usb_pd_protocol.c **** 	}
 1211              		.loc 1 405 3 is_stmt 1 view .LVU292
 1212              	.LVL94:
 1213              	.LBB172:
 1214              	.LBI172:
  94:Inc/tcpm.h    **** {
 1215              		.loc 2 94 19 view .LVU293
 1216              	.LBB173:
 1217              		.loc 2 96 2 view .LVU294
 1218              		.loc 2 96 26 is_stmt 0 view .LVU295
 1219 0058 2201     		lsls	r2, r4, #4
 1220 005a 074B     		ldr	r3, .L97+4
 1221 005c 9B18     		adds	r3, r3, r2
 1222 005e 9B68     		ldr	r3, [r3, #8]
 1223              		.loc 2 96 30 view .LVU296
 1224 0060 5B6A     		ldr	r3, [r3, #36]
 1225              		.loc 2 96 9 view .LVU297
 1226 0062 0021     		movs	r1, #0
 1227 0064 2000     		movs	r0, r4
 1228 0066 9847     		blx	r3
 1229              	.LVL95:
 1230              		.loc 2 96 9 view .LVU298
 1231              	.LBE173:
ARM GAS  /tmp/ccoQIC4J.s 			page 63


 1232              	.LBE172:
 1233              	.LBE174:
 1234              	.LBE176:
 937:Src/usb_pd_protocol.c **** }
 1235              		.loc 1 937 33 is_stmt 1 view .LVU299
 938:Src/usb_pd_protocol.c **** 
 1236              		.loc 1 938 1 is_stmt 0 view .LVU300
 1237 0068 E6E7     		b	.L88
 1238              	.LVL96:
 1239              	.L96:
 1240              	.LBB177:
 1241              	.LBB175:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 1242              		.loc 1 378 4 is_stmt 1 view .LVU301
 1243 006a 2000     		movs	r0, r4
 1244 006c FFF7FEFF 		bl	pd_power_supply_reset
 1245              	.LVL97:
 1246 0070 F2E7     		b	.L92
 1247              	.L98:
 1248 0072 C046     		.align	2
 1249              	.L97:
 1250 0074 00000000 		.word	pd
 1251 0078 00000000 		.word	tcpc_config
 1252              	.LBE175:
 1253              	.LBE177:
 1254              		.cfi_endproc
 1255              	.LFE36:
 1257              		.section	.text.pd_comm_is_enabled,"ax",%progbits
 1258              		.align	1
 1259              		.global	pd_comm_is_enabled
 1260              		.syntax unified
 1261              		.code	16
 1262              		.thumb_func
 1263              		.fpu softvfp
 1265              	pd_comm_is_enabled:
 1266              	.LVL98:
 1267              	.LFB18:
 253:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 1268              		.loc 1 253 1 view -0
 1269              		.cfi_startproc
 1270              		@ args = 0, pretend = 0, frame = 0
 1271              		@ frame_needed = 0, uses_anonymous_args = 0
 1272              		@ link register save eliminated.
 257:Src/usb_pd_protocol.c **** #endif
 1273              		.loc 1 257 2 view .LVU303
 259:Src/usb_pd_protocol.c **** 
 1274              		.loc 1 259 1 is_stmt 0 view .LVU304
 1275 0000 0120     		movs	r0, #1
 1276              	.LVL99:
 259:Src/usb_pd_protocol.c **** 
 1277              		.loc 1 259 1 view .LVU305
 1278              		@ sp needed
 1279 0002 7047     		bx	lr
 1280              		.cfi_endproc
 1281              	.LFE18:
 1283              		.section	.text.pd_transmit,"ax",%progbits
 1284              		.align	1
ARM GAS  /tmp/ccoQIC4J.s 			page 64


 1285              		.syntax unified
 1286              		.code	16
 1287              		.thumb_func
 1288              		.fpu softvfp
 1290              	pd_transmit:
 1291              	.LVL100:
 1292              	.LFB27:
 458:Src/usb_pd_protocol.c **** 	int evt;
 1293              		.loc 1 458 1 is_stmt 1 view -0
 1294              		.cfi_startproc
 1295              		@ args = 0, pretend = 0, frame = 8
 1296              		@ frame_needed = 0, uses_anonymous_args = 0
 458:Src/usb_pd_protocol.c **** 	int evt;
 1297              		.loc 1 458 1 is_stmt 0 view .LVU307
 1298 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1299              	.LCFI10:
 1300              		.cfi_def_cfa_offset 20
 1301              		.cfi_offset 4, -20
 1302              		.cfi_offset 5, -16
 1303              		.cfi_offset 6, -12
 1304              		.cfi_offset 7, -8
 1305              		.cfi_offset 14, -4
 1306 0002 83B0     		sub	sp, sp, #12
 1307              	.LCFI11:
 1308              		.cfi_def_cfa_offset 32
 1309 0004 0400     		movs	r4, r0
 1310 0006 0191     		str	r1, [sp, #4]
 1311 0008 1600     		movs	r6, r2
 1312 000a 1F00     		movs	r7, r3
 459:Src/usb_pd_protocol.c **** 
 1313              		.loc 1 459 2 is_stmt 1 view .LVU308
 462:Src/usb_pd_protocol.c **** 		return -1;
 1314              		.loc 1 462 2 view .LVU309
 462:Src/usb_pd_protocol.c **** 		return -1;
 1315              		.loc 1 462 7 is_stmt 0 view .LVU310
 1316 000c FFF7FEFF 		bl	pd_comm_is_enabled
 1317              	.LVL101:
 462:Src/usb_pd_protocol.c **** 		return -1;
 1318              		.loc 1 462 5 view .LVU311
 1319 0010 0028     		cmp	r0, #0
 1320 0012 12D0     		beq	.L102
 517:Src/usb_pd_protocol.c **** 
 1321              		.loc 1 517 2 is_stmt 1 view .LVU312
 1322              	.LVL102:
 1323              	.LBB178:
 1324              	.LBI178:
  97:Inc/tcpm.h    **** }
  98:Inc/tcpm.h    **** 
  99:Inc/tcpm.h    **** static inline int tcpm_get_message(int port, uint32_t *payload, int *head)
 100:Inc/tcpm.h    **** {
 101:Inc/tcpm.h    **** 	return tcpc_config[port].drv->get_message(port, payload, head);
 102:Inc/tcpm.h    **** }
 103:Inc/tcpm.h    **** 
 104:Inc/tcpm.h    **** static inline int tcpm_transmit(int port, enum tcpm_transmit_type type,
 1325              		.loc 2 104 19 view .LVU313
 1326              	.LBB179:
 105:Inc/tcpm.h    **** 		  uint16_t header, const uint32_t *data)
ARM GAS  /tmp/ccoQIC4J.s 			page 65


 106:Inc/tcpm.h    **** {
 107:Inc/tcpm.h    **** 	return tcpc_config[port].drv->transmit(port, type, header, data);
 1327              		.loc 2 107 2 view .LVU314
 1328              		.loc 2 107 26 is_stmt 0 view .LVU315
 1329 0014 2201     		lsls	r2, r4, #4
 1330 0016 0C4B     		ldr	r3, .L104
 1331 0018 9B18     		adds	r3, r3, r2
 1332 001a 9B68     		ldr	r3, [r3, #8]
 1333              		.loc 2 107 30 view .LVU316
 1334 001c DD6A     		ldr	r5, [r3, #44]
 1335              		.loc 2 107 9 view .LVU317
 1336 001e 3B00     		movs	r3, r7
 1337 0020 3200     		movs	r2, r6
 1338 0022 0199     		ldr	r1, [sp, #4]
 1339 0024 2000     		movs	r0, r4
 1340 0026 A847     		blx	r5
 1341              	.LVL103:
 1342              		.loc 2 107 9 view .LVU318
 1343              	.LBE179:
 1344              	.LBE178:
 540:Src/usb_pd_protocol.c **** }
 1345              		.loc 1 540 2 is_stmt 1 view .LVU319
 540:Src/usb_pd_protocol.c **** }
 1346              		.loc 1 540 17 is_stmt 0 view .LVU320
 1347 0028 E401     		lsls	r4, r4, #7
 1348              	.LVL104:
 540:Src/usb_pd_protocol.c **** }
 1349              		.loc 1 540 17 view .LVU321
 1350 002a 084B     		ldr	r3, .L104+4
 1351 002c 1C19     		adds	r4, r3, r4
 1352 002e 2934     		adds	r4, r4, #41
 1353 0030 2378     		ldrb	r3, [r4]
 540:Src/usb_pd_protocol.c **** }
 1354              		.loc 1 540 60 view .LVU322
 1355 0032 002B     		cmp	r3, #0
 1356 0034 05D1     		bne	.L103
 1357 0036 0120     		movs	r0, #1
 1358 0038 01E0     		b	.L100
 1359              	.LVL105:
 1360              	.L102:
 463:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 1361              		.loc 1 463 10 view .LVU323
 1362 003a 0120     		movs	r0, #1
 1363 003c 4042     		rsbs	r0, r0, #0
 1364              	.LVL106:
 1365              	.L100:
 541:Src/usb_pd_protocol.c **** 
 1366              		.loc 1 541 1 view .LVU324
 1367 003e 03B0     		add	sp, sp, #12
 1368              		@ sp needed
 1369              	.LVL107:
 541:Src/usb_pd_protocol.c **** 
 1370              		.loc 1 541 1 view .LVU325
 1371 0040 F0BD     		pop	{r4, r5, r6, r7, pc}
 1372              	.LVL108:
 1373              	.L103:
 540:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 66


 1374              		.loc 1 540 60 view .LVU326
 1375 0042 0120     		movs	r0, #1
 1376 0044 4042     		rsbs	r0, r0, #0
 1377 0046 FAE7     		b	.L100
 1378              	.L105:
 1379              		.align	2
 1380              	.L104:
 1381 0048 00000000 		.word	tcpc_config
 1382 004c 00000000 		.word	pd
 1383              		.cfi_endproc
 1384              	.LFE27:
 1386              		.section	.text.send_sink_cap,"ax",%progbits
 1387              		.align	1
 1388              		.syntax unified
 1389              		.code	16
 1390              		.thumb_func
 1391              		.fpu softvfp
 1393              	send_sink_cap:
 1394              	.LVL109:
 1395              	.LFB31:
 773:Src/usb_pd_protocol.c **** 	int bit_len;
 1396              		.loc 1 773 1 is_stmt 1 view -0
 1397              		.cfi_startproc
 1398              		@ args = 0, pretend = 0, frame = 0
 1399              		@ frame_needed = 0, uses_anonymous_args = 0
 773:Src/usb_pd_protocol.c **** 	int bit_len;
 1400              		.loc 1 773 1 is_stmt 0 view .LVU328
 1401 0000 70B5     		push	{r4, r5, r6, lr}
 1402              	.LCFI12:
 1403              		.cfi_def_cfa_offset 16
 1404              		.cfi_offset 4, -16
 1405              		.cfi_offset 5, -12
 1406              		.cfi_offset 6, -8
 1407              		.cfi_offset 14, -4
 774:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_SINK_CAP, pd[port].power_role,
 1408              		.loc 1 774 2 is_stmt 1 view .LVU329
 775:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, pd_snk_pdo_cnt,
 1409              		.loc 1 775 2 view .LVU330
 775:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, pd_snk_pdo_cnt,
 1410              		.loc 1 775 20 is_stmt 0 view .LVU331
 1411 0002 0D4B     		ldr	r3, .L107
 1412 0004 C401     		lsls	r4, r0, #7
 1413 0006 1919     		adds	r1, r3, r4
 1414 0008 4A78     		ldrb	r2, [r1, #1]
 1415 000a 5201     		lsls	r2, r2, #5
 1416 000c 4425     		movs	r5, #68
 1417 000e 2A43     		orrs	r2, r5
 1418 0010 E35C     		ldrb	r3, [r4, r3]
 1419 0012 1B02     		lsls	r3, r3, #8
 1420 0014 1A43     		orrs	r2, r3
 1421 0016 12B2     		sxth	r2, r2
 1422 0018 8B78     		ldrb	r3, [r1, #2]
 1423 001a 5B02     		lsls	r3, r3, #9
 1424 001c 1A43     		orrs	r2, r3
 1425 001e 12B2     		sxth	r2, r2
 1426 0020 064B     		ldr	r3, .L107+4
 1427 0022 1B68     		ldr	r3, [r3]
ARM GAS  /tmp/ccoQIC4J.s 			page 67


 1428 0024 1B03     		lsls	r3, r3, #12
 1429 0026 1A43     		orrs	r2, r3
 1430 0028 12B2     		sxth	r2, r2
 775:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, pd_snk_pdo_cnt,
 1431              		.loc 1 775 11 view .LVU332
 1432 002a 92B2     		uxth	r2, r2
 1433              	.LVL110:
 779:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1434              		.loc 1 779 2 is_stmt 1 view .LVU333
 779:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1435              		.loc 1 779 12 is_stmt 0 view .LVU334
 1436 002c 044B     		ldr	r3, .L107+8
 1437 002e 0021     		movs	r1, #0
 1438 0030 FFF7FEFF 		bl	pd_transmit
 1439              	.LVL111:
 780:Src/usb_pd_protocol.c **** 		CPRINTF("snkCAP>%d\n", bit_len);
 1440              		.loc 1 780 2 is_stmt 1 view .LVU335
 782:Src/usb_pd_protocol.c **** 
 1441              		.loc 1 782 1 is_stmt 0 view .LVU336
 1442              		@ sp needed
 1443 0034 70BD     		pop	{r4, r5, r6, pc}
 1444              	.L108:
 1445 0036 C046     		.align	2
 1446              	.L107:
 1447 0038 00000000 		.word	pd
 1448 003c 00000000 		.word	pd_snk_pdo_cnt
 1449 0040 00000000 		.word	pd_snk_pdo
 1450              		.cfi_endproc
 1451              	.LFE31:
 1453              		.section	.text.send_source_cap,"ax",%progbits
 1454              		.align	1
 1455              		.syntax unified
 1456              		.code	16
 1457              		.thumb_func
 1458              		.fpu softvfp
 1460              	send_source_cap:
 1461              	.LVL112:
 1462              	.LFB30:
 587:Src/usb_pd_protocol.c **** 	int bit_len;
 1463              		.loc 1 587 1 is_stmt 1 view -0
 1464              		.cfi_startproc
 1465              		@ args = 0, pretend = 0, frame = 0
 1466              		@ frame_needed = 0, uses_anonymous_args = 0
 587:Src/usb_pd_protocol.c **** 	int bit_len;
 1467              		.loc 1 587 1 is_stmt 0 view .LVU338
 1468 0000 70B5     		push	{r4, r5, r6, lr}
 1469              	.LCFI13:
 1470              		.cfi_def_cfa_offset 16
 1471              		.cfi_offset 4, -16
 1472              		.cfi_offset 5, -12
 1473              		.cfi_offset 6, -8
 1474              		.cfi_offset 14, -4
 588:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_DYNAMIC_SRC_CAP) || \
 1475              		.loc 1 588 2 is_stmt 1 view .LVU339
 594:Src/usb_pd_protocol.c **** 	const int src_pdo_cnt = pd_src_pdo_cnt;
 1476              		.loc 1 594 2 view .LVU340
 1477              	.LVL113:
ARM GAS  /tmp/ccoQIC4J.s 			page 68


 595:Src/usb_pd_protocol.c **** #endif
 1478              		.loc 1 595 2 view .LVU341
 595:Src/usb_pd_protocol.c **** #endif
 1479              		.loc 1 595 12 is_stmt 0 view .LVU342
 1480 0002 164B     		ldr	r3, .L112
 1481 0004 1968     		ldr	r1, [r3]
 1482              	.LVL114:
 597:Src/usb_pd_protocol.c **** 
 1483              		.loc 1 597 2 is_stmt 1 view .LVU343
 599:Src/usb_pd_protocol.c **** 		/* No source capabilities defined, sink only */
 1484              		.loc 1 599 2 view .LVU344
 599:Src/usb_pd_protocol.c **** 		/* No source capabilities defined, sink only */
 1485              		.loc 1 599 5 is_stmt 0 view .LVU345
 1486 0006 0029     		cmp	r1, #0
 1487 0008 14D1     		bne	.L110
 601:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 0,
 1488              		.loc 1 601 3 is_stmt 1 view .LVU346
 601:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 0,
 1489              		.loc 1 601 12 is_stmt 0 view .LVU347
 1490 000a 154B     		ldr	r3, .L112+4
 1491 000c C401     		lsls	r4, r0, #7
 1492 000e 1919     		adds	r1, r3, r4
 1493              	.LVL115:
 601:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 0,
 1494              		.loc 1 601 12 view .LVU348
 1495 0010 4A78     		ldrb	r2, [r1, #1]
 1496 0012 5201     		lsls	r2, r2, #5
 1497 0014 4425     		movs	r5, #68
 1498 0016 2A43     		orrs	r2, r5
 1499 0018 E35C     		ldrb	r3, [r4, r3]
 1500 001a 1B02     		lsls	r3, r3, #8
 1501 001c 1A43     		orrs	r2, r3
 1502 001e 12B2     		sxth	r2, r2
 1503 0020 8B78     		ldrb	r3, [r1, #2]
 1504 0022 5B02     		lsls	r3, r3, #9
 1505 0024 1A43     		orrs	r2, r3
 1506 0026 12B2     		sxth	r2, r2
 601:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 0,
 1507              		.loc 1 601 10 view .LVU349
 1508 0028 92B2     		uxth	r2, r2
 1509              	.LVL116:
 1510              	.L111:
 609:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1511              		.loc 1 609 2 is_stmt 1 view .LVU350
 609:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1512              		.loc 1 609 12 is_stmt 0 view .LVU351
 1513 002a 0E4B     		ldr	r3, .L112+8
 1514 002c 0021     		movs	r1, #0
 1515 002e FFF7FEFF 		bl	pd_transmit
 1516              	.LVL117:
 610:Src/usb_pd_protocol.c **** 		CPRINTF("srcCAP>%d\n", bit_len);
 1517              		.loc 1 610 2 is_stmt 1 view .LVU352
 613:Src/usb_pd_protocol.c **** }
 1518              		.loc 1 613 2 view .LVU353
 614:Src/usb_pd_protocol.c **** 
 1519              		.loc 1 614 1 is_stmt 0 view .LVU354
 1520              		@ sp needed
ARM GAS  /tmp/ccoQIC4J.s 			page 69


 1521 0032 70BD     		pop	{r4, r5, r6, pc}
 1522              	.LVL118:
 1523              	.L110:
 605:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 1524              		.loc 1 605 3 is_stmt 1 view .LVU355
 605:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 1525              		.loc 1 605 12 is_stmt 0 view .LVU356
 1526 0034 0A4D     		ldr	r5, .L112+4
 1527 0036 C601     		lsls	r6, r0, #7
 1528 0038 AC19     		adds	r4, r5, r6
 1529 003a 6378     		ldrb	r3, [r4, #1]
 1530 003c 5B01     		lsls	r3, r3, #5
 1531 003e 4122     		movs	r2, #65
 1532 0040 1343     		orrs	r3, r2
 1533 0042 725D     		ldrb	r2, [r6, r5]
 1534 0044 1202     		lsls	r2, r2, #8
 1535 0046 1343     		orrs	r3, r2
 1536 0048 1BB2     		sxth	r3, r3
 1537 004a A278     		ldrb	r2, [r4, #2]
 1538 004c 5202     		lsls	r2, r2, #9
 1539 004e 1A43     		orrs	r2, r3
 1540 0050 12B2     		sxth	r2, r2
 1541 0052 0903     		lsls	r1, r1, #12
 1542              	.LVL119:
 605:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 1543              		.loc 1 605 12 view .LVU357
 1544 0054 0A43     		orrs	r2, r1
 1545 0056 12B2     		sxth	r2, r2
 605:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 1546              		.loc 1 605 10 view .LVU358
 1547 0058 92B2     		uxth	r2, r2
 1548              	.LVL120:
 605:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, src_pdo_cnt,
 1549              		.loc 1 605 10 view .LVU359
 1550 005a E6E7     		b	.L111
 1551              	.L113:
 1552              		.align	2
 1553              	.L112:
 1554 005c 00000000 		.word	pd_src_pdo_cnt
 1555 0060 00000000 		.word	pd
 1556 0064 00000000 		.word	pd_src_pdo
 1557              		.cfi_endproc
 1558              	.LFE30:
 1560              		.section	.text.send_request,"ax",%progbits
 1561              		.align	1
 1562              		.syntax unified
 1563              		.code	16
 1564              		.thumb_func
 1565              		.fpu softvfp
 1567              	send_request:
 1568              	.LVL121:
 1569              	.LFB32:
 785:Src/usb_pd_protocol.c **** 	int bit_len;
 1570              		.loc 1 785 1 is_stmt 1 view -0
 1571              		.cfi_startproc
 1572              		@ args = 0, pretend = 0, frame = 8
 1573              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccoQIC4J.s 			page 70


 785:Src/usb_pd_protocol.c **** 	int bit_len;
 1574              		.loc 1 785 1 is_stmt 0 view .LVU361
 1575 0000 30B5     		push	{r4, r5, lr}
 1576              	.LCFI14:
 1577              		.cfi_def_cfa_offset 12
 1578              		.cfi_offset 4, -12
 1579              		.cfi_offset 5, -8
 1580              		.cfi_offset 14, -4
 1581 0002 83B0     		sub	sp, sp, #12
 1582              	.LCFI15:
 1583              		.cfi_def_cfa_offset 24
 1584 0004 0191     		str	r1, [sp, #4]
 786:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(PD_DATA_REQUEST, pd[port].power_role,
 1585              		.loc 1 786 2 is_stmt 1 view .LVU362
 787:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 1586              		.loc 1 787 2 view .LVU363
 787:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 1587              		.loc 1 787 20 is_stmt 0 view .LVU364
 1588 0006 0C4B     		ldr	r3, .L115
 1589 0008 C401     		lsls	r4, r0, #7
 1590 000a 1919     		adds	r1, r3, r4
 1591              	.LVL122:
 787:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 1592              		.loc 1 787 20 view .LVU365
 1593 000c 4A78     		ldrb	r2, [r1, #1]
 1594 000e 5201     		lsls	r2, r2, #5
 1595 0010 4225     		movs	r5, #66
 1596 0012 2A43     		orrs	r2, r5
 1597 0014 E35C     		ldrb	r3, [r4, r3]
 1598 0016 1B02     		lsls	r3, r3, #8
 1599 0018 1A43     		orrs	r2, r3
 1600 001a 12B2     		sxth	r2, r2
 1601 001c 8B78     		ldrb	r3, [r1, #2]
 1602 001e 5B02     		lsls	r3, r3, #9
 1603 0020 1A43     		orrs	r2, r3
 1604 0022 12B2     		sxth	r2, r2
 1605 0024 8023     		movs	r3, #128
 1606 0026 5B01     		lsls	r3, r3, #5
 1607 0028 1A43     		orrs	r2, r3
 787:Src/usb_pd_protocol.c **** 			pd[port].data_role, pd[port].msg_id, 1,
 1608              		.loc 1 787 11 view .LVU366
 1609 002a 92B2     		uxth	r2, r2
 1610              	.LVL123:
 791:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1611              		.loc 1 791 2 is_stmt 1 view .LVU367
 791:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1612              		.loc 1 791 12 is_stmt 0 view .LVU368
 1613 002c 01AB     		add	r3, sp, #4
 1614              	.LVL124:
 791:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1615              		.loc 1 791 12 view .LVU369
 1616 002e 0021     		movs	r1, #0
 1617 0030 FFF7FEFF 		bl	pd_transmit
 1618              	.LVL125:
 792:Src/usb_pd_protocol.c **** 		CPRINTF("REQ%d>\n", bit_len);
 1619              		.loc 1 792 2 is_stmt 1 view .LVU370
 795:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 71


 1620              		.loc 1 795 2 view .LVU371
 796:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
 1621              		.loc 1 796 1 is_stmt 0 view .LVU372
 1622 0034 03B0     		add	sp, sp, #12
 1623              		@ sp needed
 1624 0036 30BD     		pop	{r4, r5, pc}
 1625              	.L116:
 1626              		.align	2
 1627              	.L115:
 1628 0038 00000000 		.word	pd
 1629              		.cfi_endproc
 1630              	.LFE32:
 1632              		.section	.text.pd_send_request_msg,"ax",%progbits
 1633              		.align	1
 1634              		.syntax unified
 1635              		.code	16
 1636              		.thumb_func
 1637              		.fpu softvfp
 1639              	pd_send_request_msg:
 1640              	.LVL126:
 1641              	.LFB38:
 958:Src/usb_pd_protocol.c **** 	uint32_t rdo, curr_limit, supply_voltage;
 1642              		.loc 1 958 1 is_stmt 1 view -0
 1643              		.cfi_startproc
 1644              		@ args = 0, pretend = 0, frame = 16
 1645              		@ frame_needed = 0, uses_anonymous_args = 0
 958:Src/usb_pd_protocol.c **** 	uint32_t rdo, curr_limit, supply_voltage;
 1646              		.loc 1 958 1 is_stmt 0 view .LVU374
 1647 0000 70B5     		push	{r4, r5, r6, lr}
 1648              	.LCFI16:
 1649              		.cfi_def_cfa_offset 16
 1650              		.cfi_offset 4, -16
 1651              		.cfi_offset 5, -12
 1652              		.cfi_offset 6, -8
 1653              		.cfi_offset 14, -4
 1654 0002 86B0     		sub	sp, sp, #24
 1655              	.LCFI17:
 1656              		.cfi_def_cfa_offset 40
 1657 0004 0400     		movs	r4, r0
 1658 0006 0E00     		movs	r6, r1
 959:Src/usb_pd_protocol.c **** 	int res;
 1659              		.loc 1 959 2 is_stmt 1 view .LVU375
 960:Src/usb_pd_protocol.c **** 
 1660              		.loc 1 960 2 view .LVU376
 964:Src/usb_pd_protocol.c **** #else
 1661              		.loc 1 964 2 view .LVU377
 1662              	.LVL127:
 972:Src/usb_pd_protocol.c **** #endif
 1663              		.loc 1 972 2 view .LVU378
 976:Src/usb_pd_protocol.c **** 
 1664              		.loc 1 976 2 view .LVU379
 976:Src/usb_pd_protocol.c **** 
 1665              		.loc 1 976 29 is_stmt 0 view .LVU380
 1666 0008 C201     		lsls	r2, r0, #7
 1667 000a 1B4B     		ldr	r3, .L122
 1668 000c 9B18     		adds	r3, r3, r2
 1669 000e 0022     		movs	r2, #0
ARM GAS  /tmp/ccoQIC4J.s 			page 72


 1670 0010 9A63     		str	r2, [r3, #56]
 983:Src/usb_pd_protocol.c **** 			       charging && max_request_allowed ?
 1671              		.loc 1 983 2 is_stmt 1 view .LVU381
 983:Src/usb_pd_protocol.c **** 			       charging && max_request_allowed ?
 1672              		.loc 1 983 8 is_stmt 0 view .LVU382
 1673 0012 0123     		movs	r3, #1
 1674 0014 0093     		str	r3, [sp]
 1675 0016 03AB     		add	r3, sp, #12
 1676 0018 04AA     		add	r2, sp, #16
 1677 001a 05A9     		add	r1, sp, #20
 1678              	.LVL128:
 983:Src/usb_pd_protocol.c **** 			       charging && max_request_allowed ?
 1679              		.loc 1 983 8 view .LVU383
 1680 001c FFF7FEFF 		bl	pd_build_request
 1681              	.LVL129:
 983:Src/usb_pd_protocol.c **** 			       charging && max_request_allowed ?
 1682              		.loc 1 983 8 view .LVU384
 1683 0020 051E     		subs	r5, r0, #0
 1684              	.LVL130:
 987:Src/usb_pd_protocol.c **** 		/*
 1685              		.loc 1 987 2 is_stmt 1 view .LVU385
 987:Src/usb_pd_protocol.c **** 		/*
 1686              		.loc 1 987 5 is_stmt 0 view .LVU386
 1687 0022 24D1     		bne	.L120
 994:Src/usb_pd_protocol.c **** 		/* Don't re-request the same voltage */
 1688              		.loc 1 994 2 is_stmt 1 view .LVU387
 994:Src/usb_pd_protocol.c **** 		/* Don't re-request the same voltage */
 1689              		.loc 1 994 5 is_stmt 0 view .LVU388
 1690 0024 002E     		cmp	r6, #0
 1691 0026 06D1     		bne	.L119
 996:Src/usb_pd_protocol.c **** 			return EC_SUCCESS;
 1692              		.loc 1 996 3 is_stmt 1 view .LVU389
 996:Src/usb_pd_protocol.c **** 			return EC_SUCCESS;
 1693              		.loc 1 996 15 is_stmt 0 view .LVU390
 1694 0028 E201     		lsls	r2, r4, #7
 1695 002a 134B     		ldr	r3, .L122
 1696 002c 9B18     		adds	r3, r3, r2
 1697 002e DB6B     		ldr	r3, [r3, #60]
 996:Src/usb_pd_protocol.c **** 			return EC_SUCCESS;
 1698              		.loc 1 996 6 view .LVU391
 1699 0030 039A     		ldr	r2, [sp, #12]
 1700 0032 9342     		cmp	r3, r2
 1701 0034 1ED0     		beq	.L121
 1702              	.L119:
1006:Src/usb_pd_protocol.c **** 	if (rdo & RDO_CAP_MISMATCH)
 1703              		.loc 1 1006 30 is_stmt 1 view .LVU392
1007:Src/usb_pd_protocol.c **** 		CPRINTF(" Mismatch");
 1704              		.loc 1 1007 2 view .LVU393
1009:Src/usb_pd_protocol.c **** 
 1705              		.loc 1 1009 15 view .LVU394
1011:Src/usb_pd_protocol.c **** 	pd[port].supply_voltage = supply_voltage;
 1706              		.loc 1 1011 2 view .LVU395
1011:Src/usb_pd_protocol.c **** 	pd[port].supply_voltage = supply_voltage;
 1707              		.loc 1 1011 22 is_stmt 0 view .LVU396
 1708 0036 E201     		lsls	r2, r4, #7
 1709 0038 0F4B     		ldr	r3, .L122
 1710 003a 9B18     		adds	r3, r3, r2
ARM GAS  /tmp/ccoQIC4J.s 			page 73


 1711 003c 049A     		ldr	r2, [sp, #16]
 1712 003e 1A63     		str	r2, [r3, #48]
1012:Src/usb_pd_protocol.c **** 	pd[port].prev_request_mv = supply_voltage;
 1713              		.loc 1 1012 2 is_stmt 1 view .LVU397
1012:Src/usb_pd_protocol.c **** 	pd[port].prev_request_mv = supply_voltage;
 1714              		.loc 1 1012 26 is_stmt 0 view .LVU398
 1715 0040 039A     		ldr	r2, [sp, #12]
 1716 0042 5A63     		str	r2, [r3, #52]
1013:Src/usb_pd_protocol.c **** 	res = send_request(port, rdo);
 1717              		.loc 1 1013 2 is_stmt 1 view .LVU399
1013:Src/usb_pd_protocol.c **** 	res = send_request(port, rdo);
 1718              		.loc 1 1013 27 is_stmt 0 view .LVU400
 1719 0044 DA63     		str	r2, [r3, #60]
1014:Src/usb_pd_protocol.c **** 	if (res < 0)
 1720              		.loc 1 1014 2 is_stmt 1 view .LVU401
1014:Src/usb_pd_protocol.c **** 	if (res < 0)
 1721              		.loc 1 1014 8 is_stmt 0 view .LVU402
 1722 0046 0599     		ldr	r1, [sp, #20]
 1723 0048 2000     		movs	r0, r4
 1724              	.LVL131:
1014:Src/usb_pd_protocol.c **** 	if (res < 0)
 1725              		.loc 1 1014 8 view .LVU403
 1726 004a FFF7FEFF 		bl	send_request
 1727              	.LVL132:
1015:Src/usb_pd_protocol.c **** 		return res;
 1728              		.loc 1 1015 2 is_stmt 1 view .LVU404
1015:Src/usb_pd_protocol.c **** 		return res;
 1729              		.loc 1 1015 5 is_stmt 0 view .LVU405
 1730 004e 0028     		cmp	r0, #0
 1731 0050 0BDB     		blt	.L117
1017:Src/usb_pd_protocol.c **** 	return EC_SUCCESS;
 1732              		.loc 1 1017 2 is_stmt 1 view .LVU406
 1733              	.LVL133:
 1734              	.LBB186:
 1735              	.LBI186:
 326:Src/usb_pd_protocol.c **** {
 1736              		.loc 1 326 20 view .LVU407
 1737              	.LBB187:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 1738              		.loc 1 328 2 view .LVU408
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 1739              		.loc 1 333 2 view .LVU409
 1740              	.LBB188:
 1741              	.LBI188:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 1742              		.loc 1 261 20 view .LVU410
 1743              	.LBB189:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1744              		.loc 1 265 2 view .LVU411
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1745              		.loc 1 265 19 is_stmt 0 view .LVU412
 1746 0052 E401     		lsls	r4, r4, #7
 1747              	.LVL134:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1748              		.loc 1 265 19 view .LVU413
 1749 0054 084B     		ldr	r3, .L122
 1750 0056 1C19     		adds	r4, r3, r4
ARM GAS  /tmp/ccoQIC4J.s 			page 74


 1751 0058 0022     		movs	r2, #0
 1752 005a 0023     		movs	r3, #0
 1753 005c 2261     		str	r2, [r4, #16]
 1754 005e 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 1755              		.loc 1 266 2 is_stmt 1 view .LVU414
 266:Src/usb_pd_protocol.c **** }
 1756              		.loc 1 266 25 is_stmt 0 view .LVU415
 1757 0060 0023     		movs	r3, #0
 1758 0062 E371     		strb	r3, [r4, #7]
 1759              	.LVL135:
 266:Src/usb_pd_protocol.c **** }
 1760              		.loc 1 266 25 view .LVU416
 1761              	.LBE189:
 1762              	.LBE188:
 334:Src/usb_pd_protocol.c **** 
 1763              		.loc 1 334 2 is_stmt 1 view .LVU417
 334:Src/usb_pd_protocol.c **** 
 1764              		.loc 1 334 22 is_stmt 0 view .LVU418
 1765 0064 0633     		adds	r3, r3, #6
 1766 0066 2371     		strb	r3, [r4, #4]
 1767              	.LVL136:
 336:Src/usb_pd_protocol.c **** 		return;
 1768              		.loc 1 336 2 is_stmt 1 view .LVU419
 1769              	.LBE187:
 1770              	.LBE186:
1018:Src/usb_pd_protocol.c **** }
 1771              		.loc 1 1018 9 is_stmt 0 view .LVU420
 1772 0068 2800     		movs	r0, r5
 1773              	.LVL137:
 1774              	.L117:
1019:Src/usb_pd_protocol.c **** #endif
 1775              		.loc 1 1019 1 view .LVU421
 1776 006a 06B0     		add	sp, sp, #24
 1777              		@ sp needed
 1778              	.LVL138:
1019:Src/usb_pd_protocol.c **** #endif
 1779              		.loc 1 1019 1 view .LVU422
 1780 006c 70BD     		pop	{r4, r5, r6, pc}
 1781              	.LVL139:
 1782              	.L120:
 992:Src/usb_pd_protocol.c **** 
 1783              		.loc 1 992 10 view .LVU423
 1784 006e 0120     		movs	r0, #1
 1785              	.LVL140:
 992:Src/usb_pd_protocol.c **** 
 1786              		.loc 1 992 10 view .LVU424
 1787 0070 4042     		rsbs	r0, r0, #0
 1788 0072 FAE7     		b	.L117
 1789              	.LVL141:
 1790              	.L121:
 997:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1791              		.loc 1 997 11 view .LVU425
 1792 0074 3000     		movs	r0, r6
 1793              	.LVL142:
 997:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 1794              		.loc 1 997 11 view .LVU426
ARM GAS  /tmp/ccoQIC4J.s 			page 75


 1795 0076 F8E7     		b	.L117
 1796              	.L123:
 1797              		.align	2
 1798              	.L122:
 1799 0078 00000000 		.word	pd
 1800              		.cfi_endproc
 1801              	.LFE38:
 1803              		.section	.text.send_control,"ax",%progbits
 1804              		.align	1
 1805              		.syntax unified
 1806              		.code	16
 1807              		.thumb_func
 1808              		.fpu softvfp
 1810              	send_control:
 1811              	.LVL143:
 1812              	.LFB29:
 573:Src/usb_pd_protocol.c **** 	int bit_len;
 1813              		.loc 1 573 1 is_stmt 1 view -0
 1814              		.cfi_startproc
 1815              		@ args = 0, pretend = 0, frame = 0
 1816              		@ frame_needed = 0, uses_anonymous_args = 0
 573:Src/usb_pd_protocol.c **** 	int bit_len;
 1817              		.loc 1 573 1 is_stmt 0 view .LVU428
 1818 0000 70B5     		push	{r4, r5, r6, lr}
 1819              	.LCFI18:
 1820              		.cfi_def_cfa_offset 16
 1821              		.cfi_offset 4, -16
 1822              		.cfi_offset 5, -12
 1823              		.cfi_offset 6, -8
 1824              		.cfi_offset 14, -4
 574:Src/usb_pd_protocol.c **** 	uint16_t header = PD_HEADER(type, pd[port].power_role,
 1825              		.loc 1 574 2 is_stmt 1 view .LVU429
 575:Src/usb_pd_protocol.c **** 				pd[port].data_role, pd[port].msg_id, 0,
 1826              		.loc 1 575 2 view .LVU430
 575:Src/usb_pd_protocol.c **** 				pd[port].data_role, pd[port].msg_id, 0,
 1827              		.loc 1 575 20 is_stmt 0 view .LVU431
 1828 0002 4022     		movs	r2, #64
 1829 0004 0A43     		orrs	r2, r1
 1830 0006 12B2     		sxth	r2, r2
 1831 0008 094C     		ldr	r4, .L125
 1832 000a C501     		lsls	r5, r0, #7
 1833 000c 6319     		adds	r3, r4, r5
 1834 000e 5978     		ldrb	r1, [r3, #1]
 1835              	.LVL144:
 575:Src/usb_pd_protocol.c **** 				pd[port].data_role, pd[port].msg_id, 0,
 1836              		.loc 1 575 20 view .LVU432
 1837 0010 4901     		lsls	r1, r1, #5
 1838 0012 0A43     		orrs	r2, r1
 1839 0014 295D     		ldrb	r1, [r5, r4]
 1840 0016 0902     		lsls	r1, r1, #8
 1841 0018 0A43     		orrs	r2, r1
 1842 001a 12B2     		sxth	r2, r2
 1843 001c 9B78     		ldrb	r3, [r3, #2]
 1844 001e 5B02     		lsls	r3, r3, #9
 1845 0020 1A43     		orrs	r2, r3
 575:Src/usb_pd_protocol.c **** 				pd[port].data_role, pd[port].msg_id, 0,
 1846              		.loc 1 575 11 view .LVU433
ARM GAS  /tmp/ccoQIC4J.s 			page 76


 1847 0022 92B2     		uxth	r2, r2
 1848              	.LVL145:
 579:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1849              		.loc 1 579 2 is_stmt 1 view .LVU434
 579:Src/usb_pd_protocol.c **** 	if (debug_level >= 2)
 1850              		.loc 1 579 12 is_stmt 0 view .LVU435
 1851 0024 0023     		movs	r3, #0
 1852 0026 0021     		movs	r1, #0
 1853 0028 FFF7FEFF 		bl	pd_transmit
 1854              	.LVL146:
 580:Src/usb_pd_protocol.c **** 		CPRINTF("CTRL[%d]>%d\n", type, bit_len);
 1855              		.loc 1 580 2 is_stmt 1 view .LVU436
 583:Src/usb_pd_protocol.c **** }
 1856              		.loc 1 583 2 view .LVU437
 584:Src/usb_pd_protocol.c **** 
 1857              		.loc 1 584 1 is_stmt 0 view .LVU438
 1858              		@ sp needed
 1859 002c 70BD     		pop	{r4, r5, r6, pc}
 1860              	.L126:
 1861 002e C046     		.align	2
 1862              	.L125:
 1863 0030 00000000 		.word	pd
 1864              		.cfi_endproc
 1865              	.LFE29:
 1867              		.section	.text.handle_ctrl_request,"ax",%progbits
 1868              		.align	1
 1869              		.syntax unified
 1870              		.code	16
 1871              		.thumb_func
 1872              		.fpu softvfp
 1874              	handle_ctrl_request:
 1875              	.LVL147:
 1876              	.LFB45:
1274:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
 1877              		.loc 1 1274 1 is_stmt 1 view -0
 1878              		.cfi_startproc
 1879              		@ args = 0, pretend = 0, frame = 8
 1880              		@ frame_needed = 0, uses_anonymous_args = 0
1274:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
 1881              		.loc 1 1274 1 is_stmt 0 view .LVU440
 1882 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1883              	.LCFI19:
 1884              		.cfi_def_cfa_offset 20
 1885              		.cfi_offset 4, -20
 1886              		.cfi_offset 5, -16
 1887              		.cfi_offset 6, -12
 1888              		.cfi_offset 7, -8
 1889              		.cfi_offset 14, -4
 1890 0002 83B0     		sub	sp, sp, #12
 1891              	.LCFI20:
 1892              		.cfi_def_cfa_offset 32
 1893 0004 0400     		movs	r4, r0
1275:Src/usb_pd_protocol.c **** 	int res;
 1894              		.loc 1 1275 2 is_stmt 1 view .LVU441
 1895 0006 0F23     		movs	r3, #15
 1896 0008 1940     		ands	r1, r3
 1897              	.LVL148:
ARM GAS  /tmp/ccoQIC4J.s 			page 77


1276:Src/usb_pd_protocol.c **** 
 1898              		.loc 1 1276 2 view .LVU442
1278:Src/usb_pd_protocol.c **** 	case PD_CTRL_GOOD_CRC:
 1899              		.loc 1 1278 2 view .LVU443
 1900 000a CB1E     		subs	r3, r1, #3
 1901 000c 9AB2     		uxth	r2, r3
 1902              	.LVL149:
1278:Src/usb_pd_protocol.c **** 	case PD_CTRL_GOOD_CRC:
 1903              		.loc 1 1278 2 is_stmt 0 view .LVU444
 1904 000e 0A2A     		cmp	r2, #10
 1905 0010 1AD8     		bhi	.L127
 1906 0012 9300     		lsls	r3, r2, #2
 1907 0014 C24A     		ldr	r2, .L188
 1908 0016 D358     		ldr	r3, [r2, r3]
 1909 0018 9F46     		mov	pc, r3
 1910              		.section	.rodata.handle_ctrl_request,"a",%progbits
 1911              		.align	2
 1912              	.L130:
 1913 0000 06020000 		.word	.L138
 1914 0004 DE000000 		.word	.L131
 1915 0008 48000000 		.word	.L127
 1916 000c 4C000000 		.word	.L137
 1917 0010 1A000000 		.word	.L136
 1918 0014 44000000 		.word	.L135
 1919 0018 BE030000 		.word	.L134
 1920 001c 30030000 		.word	.L133
 1921 0020 FC030000 		.word	.L132
 1922 0024 DE000000 		.word	.L131
 1923 0028 12030000 		.word	.L129
 1924              		.section	.text.handle_ctrl_request
 1925              	.L136:
1286:Src/usb_pd_protocol.c **** 		if ((res >= 0) &&
 1926              		.loc 1 1286 3 is_stmt 1 view .LVU445
1286:Src/usb_pd_protocol.c **** 		if ((res >= 0) &&
 1927              		.loc 1 1286 9 is_stmt 0 view .LVU446
 1928 001a FFF7FEFF 		bl	send_source_cap
 1929              	.LVL150:
1287:Src/usb_pd_protocol.c **** 		    (pd[port].task_state == PD_STATE_SRC_DISCOVERY))
 1930              		.loc 1 1287 3 is_stmt 1 view .LVU447
1287:Src/usb_pd_protocol.c **** 		    (pd[port].task_state == PD_STATE_SRC_DISCOVERY))
 1931              		.loc 1 1287 6 is_stmt 0 view .LVU448
 1932 001e 0028     		cmp	r0, #0
 1933 0020 12DB     		blt	.L127
1288:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_NEGOCIATE);
 1934              		.loc 1 1288 16 discriminator 1 view .LVU449
 1935 0022 E201     		lsls	r2, r4, #7
 1936 0024 BF4B     		ldr	r3, .L188+4
 1937 0026 9B18     		adds	r3, r3, r2
 1938 0028 1B79     		ldrb	r3, [r3, #4]
1287:Src/usb_pd_protocol.c **** 		    (pd[port].task_state == PD_STATE_SRC_DISCOVERY))
 1939              		.loc 1 1287 18 discriminator 1 view .LVU450
 1940 002a 122B     		cmp	r3, #18
 1941 002c 0CD1     		bne	.L127
1289:Src/usb_pd_protocol.c **** 		break;
 1942              		.loc 1 1289 4 is_stmt 1 view .LVU451
 1943              	.LVL151:
 1944              	.LBB282:
ARM GAS  /tmp/ccoQIC4J.s 			page 78


 1945              	.LBI282:
 326:Src/usb_pd_protocol.c **** {
 1946              		.loc 1 326 20 view .LVU452
 1947              	.LBB283:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 1948              		.loc 1 328 2 view .LVU453
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 1949              		.loc 1 333 2 view .LVU454
 1950              	.LBB284:
 1951              	.LBI284:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 1952              		.loc 1 261 20 view .LVU455
 1953              	.LBB285:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1954              		.loc 1 265 2 view .LVU456
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1955              		.loc 1 265 19 is_stmt 0 view .LVU457
 1956 002e BD4B     		ldr	r3, .L188+4
 1957 0030 9C18     		adds	r4, r3, r2
 1958              	.LVL152:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 1959              		.loc 1 265 19 view .LVU458
 1960 0032 0022     		movs	r2, #0
 1961 0034 0023     		movs	r3, #0
 1962 0036 2261     		str	r2, [r4, #16]
 1963 0038 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 1964              		.loc 1 266 2 is_stmt 1 view .LVU459
 266:Src/usb_pd_protocol.c **** }
 1965              		.loc 1 266 25 is_stmt 0 view .LVU460
 1966 003a 0023     		movs	r3, #0
 1967 003c E371     		strb	r3, [r4, #7]
 1968              	.LVL153:
 266:Src/usb_pd_protocol.c **** }
 1969              		.loc 1 266 25 view .LVU461
 1970              	.LBE285:
 1971              	.LBE284:
 334:Src/usb_pd_protocol.c **** 
 1972              		.loc 1 334 2 is_stmt 1 view .LVU462
 334:Src/usb_pd_protocol.c **** 
 1973              		.loc 1 334 22 is_stmt 0 view .LVU463
 1974 003e 1333     		adds	r3, r3, #19
 1975 0040 2371     		strb	r3, [r4, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 1976              		.loc 1 336 2 is_stmt 1 view .LVU464
 1977 0042 01E0     		b	.L127
 1978              	.LVL154:
 1979              	.L135:
 336:Src/usb_pd_protocol.c **** 		return;
 1980              		.loc 1 336 2 is_stmt 0 view .LVU465
 1981              	.LBE283:
 1982              	.LBE282:
1293:Src/usb_pd_protocol.c **** #else
 1983              		.loc 1 1293 3 is_stmt 1 view .LVU466
 1984 0044 FFF7FEFF 		bl	send_sink_cap
 1985              	.LVL155:
1297:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
ARM GAS  /tmp/ccoQIC4J.s 			page 79


 1986              		.loc 1 1297 3 view .LVU467
 1987              	.L127:
1512:Src/usb_pd_protocol.c **** 
 1988              		.loc 1 1512 1 is_stmt 0 view .LVU468
 1989 0048 03B0     		add	sp, sp, #12
 1990              		@ sp needed
 1991 004a F0BD     		pop	{r4, r5, r6, r7, pc}
 1992              	.LVL156:
 1993              	.L137:
1317:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_STANDBY);
 1994              		.loc 1 1317 3 is_stmt 1 view .LVU469
1317:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_STANDBY);
 1995              		.loc 1 1317 15 is_stmt 0 view .LVU470
 1996 004c C201     		lsls	r2, r0, #7
 1997 004e B54B     		ldr	r3, .L188+4
 1998 0050 9B18     		adds	r3, r3, r2
 1999 0052 1B79     		ldrb	r3, [r3, #4]
1317:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_STANDBY);
 2000              		.loc 1 1317 6 view .LVU471
 2001 0054 0B2B     		cmp	r3, #11
 2002 0056 1BD0     		beq	.L169
1319:Src/usb_pd_protocol.c **** 			/* reset message ID and swap roles */
 2003              		.loc 1 1319 10 is_stmt 1 view .LVU472
1319:Src/usb_pd_protocol.c **** 			/* reset message ID and swap roles */
 2004              		.loc 1 1319 13 is_stmt 0 view .LVU473
 2005 0058 1D2B     		cmp	r3, #29
 2006 005a 24D0     		beq	.L170
1334:Src/usb_pd_protocol.c **** 			/* Don't know what power source is ready. Reset. */
 2007              		.loc 1 1334 10 is_stmt 1 view .LVU474
1334:Src/usb_pd_protocol.c **** 			/* Don't know what power source is ready. Reset. */
 2008              		.loc 1 1334 13 is_stmt 0 view .LVU475
 2009 005c 052B     		cmp	r3, #5
 2010 005e 32D0     		beq	.L171
1337:Src/usb_pd_protocol.c **** 			/* Do nothing, assume this is a redundant PD_RDY */
 2011              		.loc 1 1337 10 is_stmt 1 view .LVU476
1337:Src/usb_pd_protocol.c **** 			/* Do nothing, assume this is a redundant PD_RDY */
 2012              		.loc 1 1337 13 is_stmt 0 view .LVU477
 2013 0060 0C2B     		cmp	r3, #12
 2014 0062 F1D0     		beq	.L127
1339:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
 2015              		.loc 1 1339 10 is_stmt 1 view .LVU478
1339:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
 2016              		.loc 1 1339 22 is_stmt 0 view .LVU479
 2017 0064 C301     		lsls	r3, r0, #7
 2018 0066 AF4A     		ldr	r2, .L188+4
 2019 0068 9B5C     		ldrb	r3, [r3, r2]
1339:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
 2020              		.loc 1 1339 13 view .LVU480
 2021 006a 002B     		cmp	r3, #0
 2022 006c ECD1     		bne	.L127
1340:Src/usb_pd_protocol.c **** 			pd_set_input_current_limit(port, pd[port].curr_limit,
 2023              		.loc 1 1340 4 is_stmt 1 view .LVU481
 2024              	.LVL157:
 2025              	.LBB286:
 2026              	.LBI286:
 326:Src/usb_pd_protocol.c **** {
 2027              		.loc 1 326 20 view .LVU482
ARM GAS  /tmp/ccoQIC4J.s 			page 80


 2028              	.LBB287:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2029              		.loc 1 328 2 view .LVU483
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2030              		.loc 1 333 2 view .LVU484
 2031              	.LBB288:
 2032              	.LBI288:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2033              		.loc 1 261 20 view .LVU485
 2034              	.LBB289:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2035              		.loc 1 265 2 view .LVU486
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2036              		.loc 1 265 19 is_stmt 0 view .LVU487
 2037 006e C201     		lsls	r2, r0, #7
 2038 0070 AC4B     		ldr	r3, .L188+4
 2039 0072 9B18     		adds	r3, r3, r2
 2040 0074 0020     		movs	r0, #0
 2041              	.LVL158:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2042              		.loc 1 265 19 view .LVU488
 2043 0076 0021     		movs	r1, #0
 2044              	.LVL159:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2045              		.loc 1 265 19 view .LVU489
 2046 0078 1861     		str	r0, [r3, #16]
 2047 007a 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 2048              		.loc 1 266 2 is_stmt 1 view .LVU490
 266:Src/usb_pd_protocol.c **** }
 2049              		.loc 1 266 25 is_stmt 0 view .LVU491
 2050 007c 0022     		movs	r2, #0
 2051 007e DA71     		strb	r2, [r3, #7]
 2052              	.LVL160:
 266:Src/usb_pd_protocol.c **** }
 2053              		.loc 1 266 25 view .LVU492
 2054              	.LBE289:
 2055              	.LBE288:
 334:Src/usb_pd_protocol.c **** 
 2056              		.loc 1 334 2 is_stmt 1 view .LVU493
 334:Src/usb_pd_protocol.c **** 
 2057              		.loc 1 334 22 is_stmt 0 view .LVU494
 2058 0080 0832     		adds	r2, r2, #8
 2059 0082 1A71     		strb	r2, [r3, #4]
 2060              	.LVL161:
 336:Src/usb_pd_protocol.c **** 		return;
 2061              		.loc 1 336 2 is_stmt 1 view .LVU495
 336:Src/usb_pd_protocol.c **** 		return;
 2062              		.loc 1 336 2 is_stmt 0 view .LVU496
 2063              	.LBE287:
 2064              	.LBE286:
1341:Src/usb_pd_protocol.c **** 						   pd[port].supply_voltage);
 2065              		.loc 1 1341 4 is_stmt 1 view .LVU497
 2066 0084 5A6B     		ldr	r2, [r3, #52]
 2067 0086 196B     		ldr	r1, [r3, #48]
 2068 0088 2000     		movs	r0, r4
 2069 008a FFF7FEFF 		bl	pd_set_input_current_limit
ARM GAS  /tmp/ccoQIC4J.s 			page 81


 2070              	.LVL162:
 2071 008e DBE7     		b	.L127
 2072              	.LVL163:
 2073              	.L169:
1318:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SRC_SWAP_STANDBY) {
 2074              		.loc 1 1318 4 view .LVU498
 2075              	.LBB290:
 2076              	.LBI290:
 326:Src/usb_pd_protocol.c **** {
 2077              		.loc 1 326 20 view .LVU499
 2078              	.LBB291:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2079              		.loc 1 328 2 view .LVU500
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2080              		.loc 1 333 2 view .LVU501
 2081              	.LBB292:
 2082              	.LBI292:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2083              		.loc 1 261 20 view .LVU502
 2084              	.LBB293:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2085              		.loc 1 265 2 view .LVU503
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2086              		.loc 1 265 19 is_stmt 0 view .LVU504
 2087 0090 A44B     		ldr	r3, .L188+4
 2088 0092 9C18     		adds	r4, r3, r2
 2089 0094 0022     		movs	r2, #0
 2090 0096 0023     		movs	r3, #0
 2091 0098 2261     		str	r2, [r4, #16]
 2092 009a 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2093              		.loc 1 266 2 is_stmt 1 view .LVU505
 266:Src/usb_pd_protocol.c **** }
 2094              		.loc 1 266 25 is_stmt 0 view .LVU506
 2095 009c 0023     		movs	r3, #0
 2096 009e E371     		strb	r3, [r4, #7]
 2097              	.LVL164:
 266:Src/usb_pd_protocol.c **** }
 2098              		.loc 1 266 25 view .LVU507
 2099              	.LBE293:
 2100              	.LBE292:
 334:Src/usb_pd_protocol.c **** 
 2101              		.loc 1 334 2 is_stmt 1 view .LVU508
 334:Src/usb_pd_protocol.c **** 
 2102              		.loc 1 334 22 is_stmt 0 view .LVU509
 2103 00a0 0C33     		adds	r3, r3, #12
 2104 00a2 2371     		strb	r3, [r4, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 2105              		.loc 1 336 2 is_stmt 1 view .LVU510
 2106 00a4 D0E7     		b	.L127
 2107              	.LVL165:
 2108              	.L170:
 336:Src/usb_pd_protocol.c **** 		return;
 2109              		.loc 1 336 2 is_stmt 0 view .LVU511
 2110              	.LBE291:
 2111              	.LBE290:
1321:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
ARM GAS  /tmp/ccoQIC4J.s 			page 82


 2112              		.loc 1 1321 4 is_stmt 1 view .LVU512
1321:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
 2113              		.loc 1 1321 20 is_stmt 0 view .LVU513
 2114 00a6 9F4B     		ldr	r3, .L188+4
 2115 00a8 C201     		lsls	r2, r0, #7
 2116 00aa 9D18     		adds	r5, r3, r2
 2117 00ac 0026     		movs	r6, #0
 2118 00ae AE70     		strb	r6, [r5, #2]
1322:Src/usb_pd_protocol.c **** 			pd_update_roles(port);
 2119              		.loc 1 1322 4 is_stmt 1 view .LVU514
1322:Src/usb_pd_protocol.c **** 			pd_update_roles(port);
 2120              		.loc 1 1322 24 is_stmt 0 view .LVU515
 2121 00b0 D654     		strb	r6, [r2, r3]
1323:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
 2122              		.loc 1 1323 4 is_stmt 1 view .LVU516
 2123 00b2 FFF7FEFF 		bl	pd_update_roles
 2124              	.LVL166:
1324:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 2125              		.loc 1 1324 4 view .LVU517
 2126              	.LBB294:
 2127              	.LBI294:
 326:Src/usb_pd_protocol.c **** {
 2128              		.loc 1 326 20 view .LVU518
 2129              	.LBB295:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2130              		.loc 1 328 2 view .LVU519
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2131              		.loc 1 333 2 view .LVU520
 2132              	.LBB296:
 2133              	.LBI296:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2134              		.loc 1 261 20 view .LVU521
 2135              	.LBB297:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2136              		.loc 1 265 2 view .LVU522
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2137              		.loc 1 265 19 is_stmt 0 view .LVU523
 2138 00b6 0022     		movs	r2, #0
 2139 00b8 0023     		movs	r3, #0
 2140 00ba 2A61     		str	r2, [r5, #16]
 2141 00bc 6B61     		str	r3, [r5, #20]
 266:Src/usb_pd_protocol.c **** }
 2142              		.loc 1 266 2 is_stmt 1 view .LVU524
 266:Src/usb_pd_protocol.c **** }
 2143              		.loc 1 266 25 is_stmt 0 view .LVU525
 2144 00be EE71     		strb	r6, [r5, #7]
 2145              	.LVL167:
 266:Src/usb_pd_protocol.c **** }
 2146              		.loc 1 266 25 view .LVU526
 2147              	.LBE297:
 2148              	.LBE296:
 334:Src/usb_pd_protocol.c **** 
 2149              		.loc 1 334 2 is_stmt 1 view .LVU527
 334:Src/usb_pd_protocol.c **** 
 2150              		.loc 1 334 22 is_stmt 0 view .LVU528
 2151 00c0 0523     		movs	r3, #5
 2152 00c2 2B71     		strb	r3, [r5, #4]
ARM GAS  /tmp/ccoQIC4J.s 			page 83


 336:Src/usb_pd_protocol.c **** 		return;
 2153              		.loc 1 336 2 is_stmt 1 view .LVU529
 2154 00c4 C0E7     		b	.L127
 2155              	.LVL168:
 2156              	.L171:
 336:Src/usb_pd_protocol.c **** 		return;
 2157              		.loc 1 336 2 is_stmt 0 view .LVU530
 2158              	.LBE295:
 2159              	.LBE294:
1336:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_SWAP_STANDBY) {
 2160              		.loc 1 1336 4 is_stmt 1 view .LVU531
 2161              	.LBB298:
 2162              	.LBI298:
 326:Src/usb_pd_protocol.c **** {
 2163              		.loc 1 326 20 view .LVU532
 2164              	.LBB299:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2165              		.loc 1 328 2 view .LVU533
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2166              		.loc 1 333 2 view .LVU534
 2167              	.LBB300:
 2168              	.LBI300:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2169              		.loc 1 261 20 view .LVU535
 2170              	.LBB301:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2171              		.loc 1 265 2 view .LVU536
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2172              		.loc 1 265 19 is_stmt 0 view .LVU537
 2173 00c6 C401     		lsls	r4, r0, #7
 2174 00c8 964B     		ldr	r3, .L188+4
 2175 00ca 1C19     		adds	r4, r3, r4
 2176 00cc 0022     		movs	r2, #0
 2177 00ce 0023     		movs	r3, #0
 2178 00d0 2261     		str	r2, [r4, #16]
 2179 00d2 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2180              		.loc 1 266 2 is_stmt 1 view .LVU538
 266:Src/usb_pd_protocol.c **** }
 2181              		.loc 1 266 25 is_stmt 0 view .LVU539
 2182 00d4 0023     		movs	r3, #0
 2183 00d6 E371     		strb	r3, [r4, #7]
 2184              	.LVL169:
 266:Src/usb_pd_protocol.c **** }
 2185              		.loc 1 266 25 view .LVU540
 2186              	.LBE301:
 2187              	.LBE300:
 334:Src/usb_pd_protocol.c **** 
 2188              		.loc 1 334 2 is_stmt 1 view .LVU541
 334:Src/usb_pd_protocol.c **** 
 2189              		.loc 1 334 22 is_stmt 0 view .LVU542
 2190 00d8 1F33     		adds	r3, r3, #31
 2191 00da 2371     		strb	r3, [r4, #4]
 2192              	.LVL170:
 336:Src/usb_pd_protocol.c **** 		return;
 2193              		.loc 1 336 2 is_stmt 1 view .LVU543
 2194 00dc B4E7     		b	.L127
ARM GAS  /tmp/ccoQIC4J.s 			page 84


 2195              	.LVL171:
 2196              	.L131:
 336:Src/usb_pd_protocol.c **** 		return;
 2197              		.loc 1 336 2 is_stmt 0 view .LVU544
 2198              	.LBE299:
 2199              	.LBE298:
1354:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
 2200              		.loc 1 1354 3 is_stmt 1 view .LVU545
1354:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
 2201              		.loc 1 1354 15 is_stmt 0 view .LVU546
 2202 00de C201     		lsls	r2, r0, #7
 2203 00e0 904B     		ldr	r3, .L188+4
 2204 00e2 9B18     		adds	r3, r3, r2
 2205 00e4 1B79     		ldrb	r3, [r3, #4]
1354:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
 2206              		.loc 1 1354 6 view .LVU547
 2207 00e6 192B     		cmp	r3, #25
 2208 00e8 19D0     		beq	.L172
1361:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 2209              		.loc 1 1361 8 is_stmt 1 view .LVU548
1361:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 2210              		.loc 1 1361 11 is_stmt 0 view .LVU549
 2211 00ea 1A2B     		cmp	r3, #26
 2212 00ec 53D0     		beq	.L173
1363:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
 2213              		.loc 1 1363 8 is_stmt 1 view .LVU550
1363:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_READY);
 2214              		.loc 1 1363 11 is_stmt 0 view .LVU551
 2215 00ee 092B     		cmp	r3, #9
 2216 00f0 5DD0     		beq	.L174
1365:Src/usb_pd_protocol.c **** 			/*
 2217              		.loc 1 1365 8 is_stmt 1 view .LVU552
1365:Src/usb_pd_protocol.c **** 			/*
 2218              		.loc 1 1365 11 is_stmt 0 view .LVU553
 2219 00f2 062B     		cmp	r3, #6
 2220 00f4 A8D1     		bne	.L127
1381:Src/usb_pd_protocol.c **** 				/* We have an explicit contract */
 2221              		.loc 1 1381 4 is_stmt 1 view .LVU554
1381:Src/usb_pd_protocol.c **** 				/* We have an explicit contract */
 2222              		.loc 1 1381 16 is_stmt 0 view .LVU555
 2223 00f6 C201     		lsls	r2, r0, #7
 2224 00f8 8A4B     		ldr	r3, .L188+4
 2225 00fa 9B18     		adds	r3, r3, r2
 2226 00fc 9B68     		ldr	r3, [r3, #8]
1381:Src/usb_pd_protocol.c **** 				/* We have an explicit contract */
 2227              		.loc 1 1381 7 view .LVU556
 2228 00fe 5B06     		lsls	r3, r3, #25
 2229 0100 75D5     		bpl	.L150
1383:Src/usb_pd_protocol.c **** 					/*
 2230              		.loc 1 1383 5 is_stmt 1 view .LVU557
1383:Src/usb_pd_protocol.c **** 					/*
 2231              		.loc 1 1383 8 is_stmt 0 view .LVU558
 2232 0102 0C29     		cmp	r1, #12
 2233 0104 5FD0     		beq	.L175
1405:Src/usb_pd_protocol.c **** 				}
 2234              		.loc 1 1405 6 is_stmt 1 view .LVU559
 2235              	.LVL172:
ARM GAS  /tmp/ccoQIC4J.s 			page 85


 2236              	.LBB302:
 2237              	.LBI302:
 326:Src/usb_pd_protocol.c **** {
 2238              		.loc 1 326 20 view .LVU560
 2239              	.LBB303:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2240              		.loc 1 328 2 view .LVU561
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2241              		.loc 1 333 2 view .LVU562
 2242              	.LBB304:
 2243              	.LBI304:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2244              		.loc 1 261 20 view .LVU563
 2245              	.LBB305:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2246              		.loc 1 265 2 view .LVU564
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2247              		.loc 1 265 19 is_stmt 0 view .LVU565
 2248 0106 C401     		lsls	r4, r0, #7
 2249 0108 864B     		ldr	r3, .L188+4
 2250 010a 1C19     		adds	r4, r3, r4
 2251 010c 0022     		movs	r2, #0
 2252 010e 0023     		movs	r3, #0
 2253 0110 2261     		str	r2, [r4, #16]
 2254 0112 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2255              		.loc 1 266 2 is_stmt 1 view .LVU566
 266:Src/usb_pd_protocol.c **** }
 2256              		.loc 1 266 25 is_stmt 0 view .LVU567
 2257 0114 0023     		movs	r3, #0
 2258 0116 E371     		strb	r3, [r4, #7]
 2259              	.LVL173:
 266:Src/usb_pd_protocol.c **** }
 2260              		.loc 1 266 25 view .LVU568
 2261              	.LBE305:
 2262              	.LBE304:
 334:Src/usb_pd_protocol.c **** 
 2263              		.loc 1 334 2 is_stmt 1 view .LVU569
 334:Src/usb_pd_protocol.c **** 
 2264              		.loc 1 334 22 is_stmt 0 view .LVU570
 2265 0118 0833     		adds	r3, r3, #8
 2266 011a 2371     		strb	r3, [r4, #4]
 2267              	.LVL174:
 336:Src/usb_pd_protocol.c **** 		return;
 2268              		.loc 1 336 2 is_stmt 1 view .LVU571
 2269 011c 94E7     		b	.L127
 2270              	.LVL175:
 2271              	.L172:
 336:Src/usb_pd_protocol.c **** 		return;
 2272              		.loc 1 336 2 is_stmt 0 view .LVU572
 2273              	.LBE303:
 2274              	.LBE302:
1355:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 2275              		.loc 1 1355 4 is_stmt 1 view .LVU573
1355:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 2276              		.loc 1 1355 20 is_stmt 0 view .LVU574
 2277 011e 1300     		movs	r3, r2
ARM GAS  /tmp/ccoQIC4J.s 			page 86


 2278 0120 804A     		ldr	r2, .L188+4
 2279 0122 9B5C     		ldrb	r3, [r3, r2]
1355:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 2280              		.loc 1 1355 4 view .LVU575
 2281 0124 002B     		cmp	r3, #0
 2282 0126 2AD1     		bne	.L166
 2283 0128 0822     		movs	r2, #8
 2284              	.L143:
 2285              	.LVL176:
 2286              	.LBB306:
 2287              	.LBI306:
 326:Src/usb_pd_protocol.c **** {
 2288              		.loc 1 326 20 is_stmt 1 discriminator 4 view .LVU576
 2289              	.LBB307:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2290              		.loc 1 328 2 discriminator 4 view .LVU577
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2291              		.loc 1 328 17 is_stmt 0 discriminator 4 view .LVU578
 2292 012a E101     		lsls	r1, r4, #7
 2293              	.LVL177:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2294              		.loc 1 328 17 discriminator 4 view .LVU579
 2295 012c 7D4B     		ldr	r3, .L188+4
 2296 012e 5B18     		adds	r3, r3, r1
 2297 0130 1D79     		ldrb	r5, [r3, #4]
 2298              	.LVL178:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2299              		.loc 1 333 2 is_stmt 1 discriminator 4 view .LVU580
 2300              	.LBB308:
 2301              	.LBI308:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2302              		.loc 1 261 20 discriminator 4 view .LVU581
 2303              	.LBB309:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2304              		.loc 1 265 2 discriminator 4 view .LVU582
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2305              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU583
 2306 0132 0020     		movs	r0, #0
 2307              	.LVL179:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2308              		.loc 1 265 19 discriminator 4 view .LVU584
 2309 0134 0021     		movs	r1, #0
 2310 0136 1861     		str	r0, [r3, #16]
 2311 0138 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 2312              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU585
 266:Src/usb_pd_protocol.c **** }
 2313              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU586
 2314 013a 0021     		movs	r1, #0
 2315 013c D971     		strb	r1, [r3, #7]
 2316              	.LVL180:
 266:Src/usb_pd_protocol.c **** }
 2317              		.loc 1 266 25 discriminator 4 view .LVU587
 2318              	.LBE309:
 2319              	.LBE308:
 334:Src/usb_pd_protocol.c **** 
 2320              		.loc 1 334 2 is_stmt 1 discriminator 4 view .LVU588
ARM GAS  /tmp/ccoQIC4J.s 			page 87


 334:Src/usb_pd_protocol.c **** 
 2321              		.loc 1 334 22 is_stmt 0 discriminator 4 view .LVU589
 2322 013e 1A71     		strb	r2, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 2323              		.loc 1 336 2 is_stmt 1 discriminator 4 view .LVU590
 336:Src/usb_pd_protocol.c **** 		return;
 2324              		.loc 1 336 5 is_stmt 0 discriminator 4 view .LVU591
 2325 0140 AA42     		cmp	r2, r5
 2326 0142 00D1     		bne	.LCB2195
 2327 0144 80E7     		b	.L127	@long jump
 2328              	.LCB2195:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2329              		.loc 1 347 2 is_stmt 1 view .LVU592
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2330              		.loc 1 347 5 is_stmt 0 view .LVU593
 2331 0146 022D     		cmp	r5, #2
 2332 0148 1BD0     		beq	.L176
 2333              	.L144:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 2334              		.loc 1 348 48 view .LVU594
 2335 014a 0E2D     		cmp	r5, #14
 2336 014c 1CD0     		beq	.L177
 2337              	.L145:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2338              		.loc 1 353 2 is_stmt 1 view .LVU595
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2339              		.loc 1 353 5 is_stmt 0 view .LVU596
 2340 014e 0E2A     		cmp	r2, #14
 2341 0150 02D0     		beq	.L146
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2342              		.loc 1 353 46 view .LVU597
 2343 0152 022A     		cmp	r2, #2
 2344 0154 00D0     		beq	.LCB2208
 2345 0156 77E7     		b	.L127	@long jump
 2346              	.LCB2208:
 2347              	.L146:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 2348              		.loc 1 356 3 is_stmt 1 view .LVU598
 2349 0158 0022     		movs	r2, #0
 2350              	.LVL181:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 2351              		.loc 1 356 3 is_stmt 0 view .LVU599
 2352 015a 0021     		movs	r1, #0
 2353 015c 2000     		movs	r0, r4
 2354 015e FFF7FEFF 		bl	pd_set_input_current_limit
 2355              	.LVL182:
 373:Src/usb_pd_protocol.c **** 			/*
 2356              		.loc 1 373 3 is_stmt 1 view .LVU600
 373:Src/usb_pd_protocol.c **** 			/*
 2357              		.loc 1 373 15 is_stmt 0 view .LVU601
 2358 0162 E301     		lsls	r3, r4, #7
 2359 0164 6F4A     		ldr	r2, .L188+4
 2360 0166 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 2361              		.loc 1 373 6 view .LVU602
 2362 0168 012B     		cmp	r3, #1
 2363 016a 10D0     		beq	.L178
ARM GAS  /tmp/ccoQIC4J.s 			page 88


 2364              	.L147:
 405:Src/usb_pd_protocol.c **** 	}
 2365              		.loc 1 405 3 is_stmt 1 view .LVU603
 2366              	.LVL183:
 2367              	.LBB310:
 2368              	.LBI310:
  94:Inc/tcpm.h    **** {
 2369              		.loc 2 94 19 view .LVU604
 2370              	.LBB311:
  96:Inc/tcpm.h    **** }
 2371              		.loc 2 96 2 view .LVU605
  96:Inc/tcpm.h    **** }
 2372              		.loc 2 96 26 is_stmt 0 view .LVU606
 2373 016c 2201     		lsls	r2, r4, #4
 2374 016e 6E4B     		ldr	r3, .L188+8
 2375 0170 9B18     		adds	r3, r3, r2
 2376 0172 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 2377              		.loc 2 96 30 view .LVU607
 2378 0174 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 2379              		.loc 2 96 9 view .LVU608
 2380 0176 0021     		movs	r1, #0
 2381 0178 2000     		movs	r0, r4
 2382 017a 9847     		blx	r3
 2383              	.LVL184:
 2384 017c 64E7     		b	.L127
 2385              	.LVL185:
 2386              	.L166:
  96:Inc/tcpm.h    **** }
 2387              		.loc 2 96 9 view .LVU609
 2388              	.LBE311:
 2389              	.LBE310:
 2390              	.LBE307:
 2391              	.LBE306:
1355:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 2392              		.loc 1 1355 4 view .LVU610
 2393 017e 1722     		movs	r2, #23
 2394 0180 D3E7     		b	.L143
 2395              	.LVL186:
 2396              	.L176:
 2397              	.LBB313:
 2398              	.LBB312:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2399              		.loc 1 347 47 view .LVU611
 2400 0182 0E2A     		cmp	r2, #14
 2401 0184 E1D1     		bne	.L144
 2402 0186 5FE7     		b	.L127
 2403              	.L177:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 2404              		.loc 1 349 47 view .LVU612
 2405 0188 022A     		cmp	r2, #2
 2406 018a E0D1     		bne	.L145
 2407 018c 5CE7     		b	.L127
 2408              	.LVL187:
 2409              	.L178:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
ARM GAS  /tmp/ccoQIC4J.s 			page 89


 2410              		.loc 1 378 4 is_stmt 1 view .LVU613
 2411 018e 2000     		movs	r0, r4
 2412 0190 FFF7FEFF 		bl	pd_power_supply_reset
 2413              	.LVL188:
 2414 0194 EAE7     		b	.L147
 2415              	.LVL189:
 2416              	.L173:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 2417              		.loc 1 378 4 is_stmt 0 view .LVU614
 2418              	.LBE312:
 2419              	.LBE313:
1362:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SNK_SWAP_INIT)
 2420              		.loc 1 1362 4 is_stmt 1 view .LVU615
 2421              	.LBB314:
 2422              	.LBI314:
 326:Src/usb_pd_protocol.c **** {
 2423              		.loc 1 326 20 view .LVU616
 2424              	.LBB315:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2425              		.loc 1 328 2 view .LVU617
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2426              		.loc 1 333 2 view .LVU618
 2427              	.LBB316:
 2428              	.LBI316:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2429              		.loc 1 261 20 view .LVU619
 2430              	.LBB317:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2431              		.loc 1 265 2 view .LVU620
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2432              		.loc 1 265 19 is_stmt 0 view .LVU621
 2433 0196 C401     		lsls	r4, r0, #7
 2434 0198 624B     		ldr	r3, .L188+4
 2435 019a 1C19     		adds	r4, r3, r4
 2436 019c 0022     		movs	r2, #0
 2437 019e 0023     		movs	r3, #0
 2438 01a0 2261     		str	r2, [r4, #16]
 2439 01a2 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2440              		.loc 1 266 2 is_stmt 1 view .LVU622
 266:Src/usb_pd_protocol.c **** }
 2441              		.loc 1 266 25 is_stmt 0 view .LVU623
 2442 01a4 0023     		movs	r3, #0
 2443 01a6 E371     		strb	r3, [r4, #7]
 2444              	.LVL190:
 266:Src/usb_pd_protocol.c **** }
 2445              		.loc 1 266 25 view .LVU624
 2446              	.LBE317:
 2447              	.LBE316:
 334:Src/usb_pd_protocol.c **** 
 2448              		.loc 1 334 2 is_stmt 1 view .LVU625
 334:Src/usb_pd_protocol.c **** 
 2449              		.loc 1 334 22 is_stmt 0 view .LVU626
 2450 01a8 1733     		adds	r3, r3, #23
 2451 01aa 2371     		strb	r3, [r4, #4]
 2452              	.LVL191:
 336:Src/usb_pd_protocol.c **** 		return;
ARM GAS  /tmp/ccoQIC4J.s 			page 90


 2453              		.loc 1 336 2 is_stmt 1 view .LVU627
 2454 01ac 4CE7     		b	.L127
 2455              	.LVL192:
 2456              	.L174:
 336:Src/usb_pd_protocol.c **** 		return;
 2457              		.loc 1 336 2 is_stmt 0 view .LVU628
 2458              	.LBE315:
 2459              	.LBE314:
1364:Src/usb_pd_protocol.c **** 		else if (pd[port].task_state == PD_STATE_SNK_REQUESTED) {
 2460              		.loc 1 1364 4 is_stmt 1 view .LVU629
 2461              	.LBB318:
 2462              	.LBI318:
 326:Src/usb_pd_protocol.c **** {
 2463              		.loc 1 326 20 view .LVU630
 2464              	.LBB319:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2465              		.loc 1 328 2 view .LVU631
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2466              		.loc 1 333 2 view .LVU632
 2467              	.LBB320:
 2468              	.LBI320:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2469              		.loc 1 261 20 view .LVU633
 2470              	.LBB321:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2471              		.loc 1 265 2 view .LVU634
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2472              		.loc 1 265 19 is_stmt 0 view .LVU635
 2473 01ae C401     		lsls	r4, r0, #7
 2474 01b0 5C4B     		ldr	r3, .L188+4
 2475 01b2 1C19     		adds	r4, r3, r4
 2476 01b4 0022     		movs	r2, #0
 2477 01b6 0023     		movs	r3, #0
 2478 01b8 2261     		str	r2, [r4, #16]
 2479 01ba 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2480              		.loc 1 266 2 is_stmt 1 view .LVU636
 266:Src/usb_pd_protocol.c **** }
 2481              		.loc 1 266 25 is_stmt 0 view .LVU637
 2482 01bc 0023     		movs	r3, #0
 2483 01be E371     		strb	r3, [r4, #7]
 2484              	.LVL193:
 266:Src/usb_pd_protocol.c **** }
 2485              		.loc 1 266 25 view .LVU638
 2486              	.LBE321:
 2487              	.LBE320:
 334:Src/usb_pd_protocol.c **** 
 2488              		.loc 1 334 2 is_stmt 1 view .LVU639
 334:Src/usb_pd_protocol.c **** 
 2489              		.loc 1 334 22 is_stmt 0 view .LVU640
 2490 01c0 0833     		adds	r3, r3, #8
 2491 01c2 2371     		strb	r3, [r4, #4]
 2492              	.LVL194:
 336:Src/usb_pd_protocol.c **** 		return;
 2493              		.loc 1 336 2 is_stmt 1 view .LVU641
 2494 01c4 40E7     		b	.L127
 2495              	.LVL195:
ARM GAS  /tmp/ccoQIC4J.s 			page 91


 2496              	.L175:
 336:Src/usb_pd_protocol.c **** 		return;
 2497              		.loc 1 336 2 is_stmt 0 view .LVU642
 2498              	.LBE319:
 2499              	.LBE318:
1388:Src/usb_pd_protocol.c **** 
 2500              		.loc 1 1388 6 is_stmt 1 view .LVU643
1388:Src/usb_pd_protocol.c **** 
 2501              		.loc 1 1388 33 is_stmt 0 view .LVU644
 2502 01c6 574B     		ldr	r3, .L188+4
 2503 01c8 9C18     		adds	r4, r3, r2
 2504 01ca 0123     		movs	r3, #1
 2505 01cc A363     		str	r3, [r4, #56]
1394:Src/usb_pd_protocol.c **** 
 2506              		.loc 1 1394 6 is_stmt 1 view .LVU645
1394:Src/usb_pd_protocol.c **** 
 2507              		.loc 1 1394 31 is_stmt 0 view .LVU646
 2508 01ce 0023     		movs	r3, #0
 2509 01d0 E363     		str	r3, [r4, #60]
1400:Src/usb_pd_protocol.c **** 							PD_T_SINK_REQUEST,
 2510              		.loc 1 1400 6 is_stmt 1 view .LVU647
1400:Src/usb_pd_protocol.c **** 							PD_T_SINK_REQUEST,
 2511              		.loc 1 1400 30 is_stmt 0 view .LVU648
 2512 01d2 6846     		mov	r0, sp
 2513              	.LVL196:
1400:Src/usb_pd_protocol.c **** 							PD_T_SINK_REQUEST,
 2514              		.loc 1 1400 30 view .LVU649
 2515 01d4 FFF7FEFF 		bl	get_time
 2516              	.LVL197:
1400:Src/usb_pd_protocol.c **** 							PD_T_SINK_REQUEST,
 2517              		.loc 1 1400 6 view .LVU650
 2518 01d8 544A     		ldr	r2, .L188+12
 2519 01da 0023     		movs	r3, #0
 2520 01dc 0098     		ldr	r0, [sp]
 2521 01de 0199     		ldr	r1, [sp, #4]
 2522 01e0 1218     		adds	r2, r2, r0
 2523 01e2 4B41     		adcs	r3, r3, r1
 2524              	.LVL198:
 2525              	.LBB322:
 2526              	.LBI322:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2527              		.loc 1 261 20 is_stmt 1 view .LVU651
 2528              	.LBB323:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2529              		.loc 1 265 2 view .LVU652
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2530              		.loc 1 265 19 is_stmt 0 view .LVU653
 2531 01e4 2261     		str	r2, [r4, #16]
 2532 01e6 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2533              		.loc 1 266 2 is_stmt 1 view .LVU654
 266:Src/usb_pd_protocol.c **** }
 2534              		.loc 1 266 25 is_stmt 0 view .LVU655
 2535 01e8 0823     		movs	r3, #8
 2536 01ea E371     		strb	r3, [r4, #7]
 2537 01ec 2CE7     		b	.L127
 2538              	.LVL199:
ARM GAS  /tmp/ccoQIC4J.s 			page 92


 2539              	.L150:
 266:Src/usb_pd_protocol.c **** }
 2540              		.loc 1 266 25 view .LVU656
 2541              	.LBE323:
 2542              	.LBE322:
1409:Src/usb_pd_protocol.c **** 			}
 2543              		.loc 1 1409 5 is_stmt 1 view .LVU657
 2544              	.LBB324:
 2545              	.LBI324:
 326:Src/usb_pd_protocol.c **** {
 2546              		.loc 1 326 20 view .LVU658
 2547              	.LBB325:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2548              		.loc 1 328 2 view .LVU659
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2549              		.loc 1 333 2 view .LVU660
 2550              	.LBB326:
 2551              	.LBI326:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2552              		.loc 1 261 20 view .LVU661
 2553              	.LBB327:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2554              		.loc 1 265 2 view .LVU662
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2555              		.loc 1 265 19 is_stmt 0 view .LVU663
 2556 01ee C401     		lsls	r4, r0, #7
 2557 01f0 4C4B     		ldr	r3, .L188+4
 2558 01f2 1C19     		adds	r4, r3, r4
 2559 01f4 0022     		movs	r2, #0
 2560 01f6 0023     		movs	r3, #0
 2561 01f8 2261     		str	r2, [r4, #16]
 2562 01fa 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2563              		.loc 1 266 2 is_stmt 1 view .LVU664
 266:Src/usb_pd_protocol.c **** }
 2564              		.loc 1 266 25 is_stmt 0 view .LVU665
 2565 01fc 0023     		movs	r3, #0
 2566 01fe E371     		strb	r3, [r4, #7]
 2567              	.LVL200:
 266:Src/usb_pd_protocol.c **** }
 2568              		.loc 1 266 25 view .LVU666
 2569              	.LBE327:
 2570              	.LBE326:
 334:Src/usb_pd_protocol.c **** 
 2571              		.loc 1 334 2 is_stmt 1 view .LVU667
 334:Src/usb_pd_protocol.c **** 
 2572              		.loc 1 334 22 is_stmt 0 view .LVU668
 2573 0200 0533     		adds	r3, r3, #5
 2574 0202 2371     		strb	r3, [r4, #4]
 2575              	.LVL201:
 336:Src/usb_pd_protocol.c **** 		return;
 2576              		.loc 1 336 2 is_stmt 1 view .LVU669
 2577 0204 20E7     		b	.L127
 2578              	.LVL202:
 2579              	.L138:
 336:Src/usb_pd_protocol.c **** 		return;
 2580              		.loc 1 336 2 is_stmt 0 view .LVU670
ARM GAS  /tmp/ccoQIC4J.s 			page 93


 2581              	.LBE325:
 2582              	.LBE324:
1415:Src/usb_pd_protocol.c **** 			/*
 2583              		.loc 1 1415 3 is_stmt 1 view .LVU671
1415:Src/usb_pd_protocol.c **** 			/*
 2584              		.loc 1 1415 15 is_stmt 0 view .LVU672
 2585 0206 C201     		lsls	r2, r0, #7
 2586 0208 464B     		ldr	r3, .L188+4
 2587 020a 9B18     		adds	r3, r3, r2
 2588 020c 1B79     		ldrb	r3, [r3, #4]
1415:Src/usb_pd_protocol.c **** 			/*
 2589              		.loc 1 1415 6 view .LVU673
 2590 020e 1E2B     		cmp	r3, #30
 2591 0210 18D0     		beq	.L179
1422:Src/usb_pd_protocol.c **** 			/* switch data role */
 2592              		.loc 1 1422 10 is_stmt 1 view .LVU674
1422:Src/usb_pd_protocol.c **** 			/* switch data role */
 2593              		.loc 1 1422 13 is_stmt 0 view .LVU675
 2594 0212 192B     		cmp	r3, #25
 2595 0214 1FD0     		beq	.L180
1432:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
 2596              		.loc 1 1432 10 is_stmt 1 view .LVU676
1432:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
 2597              		.loc 1 1432 13 is_stmt 0 view .LVU677
 2598 0216 1A2B     		cmp	r3, #26
 2599 0218 5BD0     		beq	.L181
1436:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
 2600              		.loc 1 1436 10 is_stmt 1 view .LVU678
1436:Src/usb_pd_protocol.c **** 			/* explicit contract goes away for power swap */
 2601              		.loc 1 1436 13 is_stmt 0 view .LVU679
 2602 021a 092B     		cmp	r3, #9
 2603 021c 69D0     		beq	.L182
1440:Src/usb_pd_protocol.c **** 			/* explicit contract is now in place */
 2604              		.loc 1 1440 10 is_stmt 1 view .LVU680
1440:Src/usb_pd_protocol.c **** 			/* explicit contract is now in place */
 2605              		.loc 1 1440 13 is_stmt 0 view .LVU681
 2606 021e 062B     		cmp	r3, #6
 2607 0220 00D0     		beq	.LCB2489
 2608 0222 11E7     		b	.L127	@long jump
 2609              	.LCB2489:
1442:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
 2610              		.loc 1 1442 4 is_stmt 1 view .LVU682
1442:Src/usb_pd_protocol.c **** #ifdef CONFIG_BBRAM
 2611              		.loc 1 1442 19 is_stmt 0 view .LVU683
 2612 0224 C401     		lsls	r4, r0, #7
 2613 0226 3F4B     		ldr	r3, .L188+4
 2614 0228 1C19     		adds	r4, r3, r4
 2615 022a 4023     		movs	r3, #64
 2616 022c A268     		ldr	r2, [r4, #8]
 2617 022e 1343     		orrs	r3, r2
 2618 0230 A360     		str	r3, [r4, #8]
1446:Src/usb_pd_protocol.c **** #endif
 2619              		.loc 1 1446 4 is_stmt 1 view .LVU684
 2620              	.LVL203:
 2621              	.LBB328:
 2622              	.LBI328:
 326:Src/usb_pd_protocol.c **** {
ARM GAS  /tmp/ccoQIC4J.s 			page 94


 2623              		.loc 1 326 20 view .LVU685
 2624              	.LBB329:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2625              		.loc 1 328 2 view .LVU686
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2626              		.loc 1 333 2 view .LVU687
 2627              	.LBB330:
 2628              	.LBI330:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2629              		.loc 1 261 20 view .LVU688
 2630              	.LBB331:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2631              		.loc 1 265 2 view .LVU689
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2632              		.loc 1 265 19 is_stmt 0 view .LVU690
 2633 0232 0022     		movs	r2, #0
 2634 0234 0023     		movs	r3, #0
 2635 0236 2261     		str	r2, [r4, #16]
 2636 0238 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2637              		.loc 1 266 2 is_stmt 1 view .LVU691
 266:Src/usb_pd_protocol.c **** }
 2638              		.loc 1 266 25 is_stmt 0 view .LVU692
 2639 023a 0023     		movs	r3, #0
 2640 023c E371     		strb	r3, [r4, #7]
 2641              	.LVL204:
 266:Src/usb_pd_protocol.c **** }
 2642              		.loc 1 266 25 view .LVU693
 2643              	.LBE331:
 2644              	.LBE330:
 334:Src/usb_pd_protocol.c **** 
 2645              		.loc 1 334 2 is_stmt 1 view .LVU694
 334:Src/usb_pd_protocol.c **** 
 2646              		.loc 1 334 22 is_stmt 0 view .LVU695
 2647 023e 0733     		adds	r3, r3, #7
 2648 0240 2371     		strb	r3, [r4, #4]
 2649              	.LVL205:
 336:Src/usb_pd_protocol.c **** 		return;
 2650              		.loc 1 336 2 is_stmt 1 view .LVU696
 2651 0242 01E7     		b	.L127
 2652              	.LVL206:
 2653              	.L179:
 336:Src/usb_pd_protocol.c **** 		return;
 2654              		.loc 1 336 2 is_stmt 0 view .LVU697
 2655              	.LBE329:
 2656              	.LBE328:
1420:Src/usb_pd_protocol.c **** 			execute_soft_reset(port);
 2657              		.loc 1 1420 4 is_stmt 1 view .LVU698
1420:Src/usb_pd_protocol.c **** 			execute_soft_reset(port);
 2658              		.loc 1 1420 19 is_stmt 0 view .LVU699
 2659 0244 374B     		ldr	r3, .L188+4
 2660 0246 9B18     		adds	r3, r3, r2
 2661 0248 8022     		movs	r2, #128
 2662 024a 9968     		ldr	r1, [r3, #8]
 2663              	.LVL207:
1420:Src/usb_pd_protocol.c **** 			execute_soft_reset(port);
 2664              		.loc 1 1420 19 view .LVU700
ARM GAS  /tmp/ccoQIC4J.s 			page 95


 2665 024c 9143     		bics	r1, r2
 2666 024e 9960     		str	r1, [r3, #8]
1421:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_DR_SWAP) {
 2667              		.loc 1 1421 4 is_stmt 1 view .LVU701
 2668 0250 FFF7FEFF 		bl	execute_soft_reset
 2669              	.LVL208:
1421:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_DR_SWAP) {
 2670              		.loc 1 1421 4 is_stmt 0 view .LVU702
 2671 0254 F8E6     		b	.L127
 2672              	.LVL209:
 2673              	.L180:
1424:Src/usb_pd_protocol.c **** 			set_state(port, READY_RETURN_STATE(port));
 2674              		.loc 1 1424 4 is_stmt 1 view .LVU703
 2675 0256 FFF7FEFF 		bl	pd_dr_swap
 2676              	.LVL210:
1425:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 2677              		.loc 1 1425 4 view .LVU704
1425:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 2678              		.loc 1 1425 20 is_stmt 0 view .LVU705
 2679 025a E301     		lsls	r3, r4, #7
 2680 025c 314A     		ldr	r2, .L188+4
 2681 025e 9B5C     		ldrb	r3, [r3, r2]
1425:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 2682              		.loc 1 1425 4 view .LVU706
 2683 0260 002B     		cmp	r3, #0
 2684 0262 2AD1     		bne	.L167
 2685 0264 0822     		movs	r2, #8
 2686              	.L154:
 2687              	.LVL211:
 2688              	.LBB332:
 2689              	.LBI332:
 326:Src/usb_pd_protocol.c **** {
 2690              		.loc 1 326 20 is_stmt 1 discriminator 4 view .LVU707
 2691              	.LBB333:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2692              		.loc 1 328 2 discriminator 4 view .LVU708
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2693              		.loc 1 328 17 is_stmt 0 discriminator 4 view .LVU709
 2694 0266 E101     		lsls	r1, r4, #7
 2695 0268 2E4B     		ldr	r3, .L188+4
 2696 026a 5B18     		adds	r3, r3, r1
 2697 026c 1D79     		ldrb	r5, [r3, #4]
 2698              	.LVL212:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2699              		.loc 1 333 2 is_stmt 1 discriminator 4 view .LVU710
 2700              	.LBB334:
 2701              	.LBI334:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2702              		.loc 1 261 20 discriminator 4 view .LVU711
 2703              	.LBB335:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2704              		.loc 1 265 2 discriminator 4 view .LVU712
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2705              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU713
 2706 026e 0020     		movs	r0, #0
 2707 0270 0021     		movs	r1, #0
 2708 0272 1861     		str	r0, [r3, #16]
ARM GAS  /tmp/ccoQIC4J.s 			page 96


 2709 0274 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 2710              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU714
 266:Src/usb_pd_protocol.c **** }
 2711              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU715
 2712 0276 0021     		movs	r1, #0
 2713 0278 D971     		strb	r1, [r3, #7]
 2714              	.LVL213:
 266:Src/usb_pd_protocol.c **** }
 2715              		.loc 1 266 25 discriminator 4 view .LVU716
 2716              	.LBE335:
 2717              	.LBE334:
 334:Src/usb_pd_protocol.c **** 
 2718              		.loc 1 334 2 is_stmt 1 discriminator 4 view .LVU717
 334:Src/usb_pd_protocol.c **** 
 2719              		.loc 1 334 22 is_stmt 0 discriminator 4 view .LVU718
 2720 027a 1A71     		strb	r2, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 2721              		.loc 1 336 2 is_stmt 1 discriminator 4 view .LVU719
 336:Src/usb_pd_protocol.c **** 		return;
 2722              		.loc 1 336 5 is_stmt 0 discriminator 4 view .LVU720
 2723 027c AA42     		cmp	r2, r5
 2724 027e 00D1     		bne	.LCB2606
 2725 0280 E2E6     		b	.L127	@long jump
 2726              	.LCB2606:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2727              		.loc 1 347 2 is_stmt 1 view .LVU721
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2728              		.loc 1 347 5 is_stmt 0 view .LVU722
 2729 0282 022D     		cmp	r5, #2
 2730 0284 1BD0     		beq	.L183
 2731              	.L155:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 2732              		.loc 1 348 48 view .LVU723
 2733 0286 0E2D     		cmp	r5, #14
 2734 0288 1CD0     		beq	.L184
 2735              	.L156:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2736              		.loc 1 353 2 is_stmt 1 view .LVU724
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2737              		.loc 1 353 5 is_stmt 0 view .LVU725
 2738 028a 0E2A     		cmp	r2, #14
 2739 028c 02D0     		beq	.L157
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 2740              		.loc 1 353 46 view .LVU726
 2741 028e 022A     		cmp	r2, #2
 2742 0290 00D0     		beq	.LCB2619
 2743 0292 D9E6     		b	.L127	@long jump
 2744              	.LCB2619:
 2745              	.L157:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 2746              		.loc 1 356 3 is_stmt 1 view .LVU727
 2747 0294 0022     		movs	r2, #0
 2748              	.LVL214:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 2749              		.loc 1 356 3 is_stmt 0 view .LVU728
 2750 0296 0021     		movs	r1, #0
ARM GAS  /tmp/ccoQIC4J.s 			page 97


 2751 0298 2000     		movs	r0, r4
 2752 029a FFF7FEFF 		bl	pd_set_input_current_limit
 2753              	.LVL215:
 373:Src/usb_pd_protocol.c **** 			/*
 2754              		.loc 1 373 3 is_stmt 1 view .LVU729
 373:Src/usb_pd_protocol.c **** 			/*
 2755              		.loc 1 373 15 is_stmt 0 view .LVU730
 2756 029e E301     		lsls	r3, r4, #7
 2757 02a0 204A     		ldr	r2, .L188+4
 2758 02a2 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 2759              		.loc 1 373 6 view .LVU731
 2760 02a4 012B     		cmp	r3, #1
 2761 02a6 10D0     		beq	.L185
 2762              	.L158:
 405:Src/usb_pd_protocol.c **** 	}
 2763              		.loc 1 405 3 is_stmt 1 view .LVU732
 2764              	.LVL216:
 2765              	.LBB336:
 2766              	.LBI336:
  94:Inc/tcpm.h    **** {
 2767              		.loc 2 94 19 view .LVU733
 2768              	.LBB337:
  96:Inc/tcpm.h    **** }
 2769              		.loc 2 96 2 view .LVU734
  96:Inc/tcpm.h    **** }
 2770              		.loc 2 96 26 is_stmt 0 view .LVU735
 2771 02a8 2201     		lsls	r2, r4, #4
 2772 02aa 1F4B     		ldr	r3, .L188+8
 2773 02ac 9B18     		adds	r3, r3, r2
 2774 02ae 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 2775              		.loc 2 96 30 view .LVU736
 2776 02b0 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 2777              		.loc 2 96 9 view .LVU737
 2778 02b2 0021     		movs	r1, #0
 2779 02b4 2000     		movs	r0, r4
 2780 02b6 9847     		blx	r3
 2781              	.LVL217:
 2782 02b8 C6E6     		b	.L127
 2783              	.LVL218:
 2784              	.L167:
  96:Inc/tcpm.h    **** }
 2785              		.loc 2 96 9 view .LVU738
 2786              	.LBE337:
 2787              	.LBE336:
 2788              	.LBE333:
 2789              	.LBE332:
1425:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 2790              		.loc 1 1425 4 view .LVU739
 2791 02ba 1722     		movs	r2, #23
 2792 02bc D3E7     		b	.L154
 2793              	.LVL219:
 2794              	.L183:
 2795              	.LBB339:
 2796              	.LBB338:
ARM GAS  /tmp/ccoQIC4J.s 			page 98


 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 2797              		.loc 1 347 47 view .LVU740
 2798 02be 0E2A     		cmp	r2, #14
 2799 02c0 E1D1     		bne	.L155
 2800 02c2 C1E6     		b	.L127
 2801              	.L184:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 2802              		.loc 1 349 47 view .LVU741
 2803 02c4 022A     		cmp	r2, #2
 2804 02c6 E0D1     		bne	.L156
 2805 02c8 BEE6     		b	.L127
 2806              	.LVL220:
 2807              	.L185:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 2808              		.loc 1 378 4 is_stmt 1 view .LVU742
 2809 02ca 2000     		movs	r0, r4
 2810 02cc FFF7FEFF 		bl	pd_power_supply_reset
 2811              	.LVL221:
 2812 02d0 EAE7     		b	.L158
 2813              	.LVL222:
 2814              	.L181:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 2815              		.loc 1 378 4 is_stmt 0 view .LVU743
 2816              	.LBE338:
 2817              	.LBE339:
1434:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_SWAP_SNK_DISABLE);
 2818              		.loc 1 1434 4 is_stmt 1 view .LVU744
1434:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_SWAP_SNK_DISABLE);
 2819              		.loc 1 1434 19 is_stmt 0 view .LVU745
 2820 02d2 C401     		lsls	r4, r0, #7
 2821 02d4 134B     		ldr	r3, .L188+4
 2822 02d6 1C19     		adds	r4, r3, r4
 2823 02d8 4023     		movs	r3, #64
 2824 02da A268     		ldr	r2, [r4, #8]
 2825 02dc 9A43     		bics	r2, r3
 2826 02de A260     		str	r2, [r4, #8]
1435:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_SWAP_INIT) {
 2827              		.loc 1 1435 4 is_stmt 1 view .LVU746
 2828              	.LVL223:
 2829              	.LBB340:
 2830              	.LBI340:
 326:Src/usb_pd_protocol.c **** {
 2831              		.loc 1 326 20 view .LVU747
 2832              	.LBB341:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2833              		.loc 1 328 2 view .LVU748
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2834              		.loc 1 333 2 view .LVU749
 2835              	.LBB342:
 2836              	.LBI342:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2837              		.loc 1 261 20 view .LVU750
 2838              	.LBB343:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2839              		.loc 1 265 2 view .LVU751
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2840              		.loc 1 265 19 is_stmt 0 view .LVU752
ARM GAS  /tmp/ccoQIC4J.s 			page 99


 2841 02e0 0022     		movs	r2, #0
 2842 02e2 0023     		movs	r3, #0
 2843 02e4 2261     		str	r2, [r4, #16]
 2844 02e6 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2845              		.loc 1 266 2 is_stmt 1 view .LVU753
 266:Src/usb_pd_protocol.c **** }
 2846              		.loc 1 266 25 is_stmt 0 view .LVU754
 2847 02e8 0023     		movs	r3, #0
 2848 02ea E371     		strb	r3, [r4, #7]
 2849              	.LVL224:
 266:Src/usb_pd_protocol.c **** }
 2850              		.loc 1 266 25 view .LVU755
 2851              	.LBE343:
 2852              	.LBE342:
 334:Src/usb_pd_protocol.c **** 
 2853              		.loc 1 334 2 is_stmt 1 view .LVU756
 334:Src/usb_pd_protocol.c **** 
 2854              		.loc 1 334 22 is_stmt 0 view .LVU757
 2855 02ec 1B33     		adds	r3, r3, #27
 2856 02ee 2371     		strb	r3, [r4, #4]
 2857              	.LVL225:
 336:Src/usb_pd_protocol.c **** 		return;
 2858              		.loc 1 336 2 is_stmt 1 view .LVU758
 2859 02f0 AAE6     		b	.L127
 2860              	.LVL226:
 2861              	.L182:
 336:Src/usb_pd_protocol.c **** 		return;
 2862              		.loc 1 336 2 is_stmt 0 view .LVU759
 2863              	.LBE341:
 2864              	.LBE340:
1438:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_SNK_DISABLE);
 2865              		.loc 1 1438 4 is_stmt 1 view .LVU760
1438:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_SWAP_SNK_DISABLE);
 2866              		.loc 1 1438 19 is_stmt 0 view .LVU761
 2867 02f2 C401     		lsls	r4, r0, #7
 2868 02f4 0B4B     		ldr	r3, .L188+4
 2869 02f6 1C19     		adds	r4, r3, r4
 2870 02f8 4023     		movs	r3, #64
 2871 02fa A268     		ldr	r2, [r4, #8]
 2872 02fc 9A43     		bics	r2, r3
 2873 02fe A260     		str	r2, [r4, #8]
1439:Src/usb_pd_protocol.c **** 		} else if (pd[port].task_state == PD_STATE_SNK_REQUESTED) {
 2874              		.loc 1 1439 4 is_stmt 1 view .LVU762
 2875              	.LVL227:
 2876              	.LBB344:
 2877              	.LBI344:
 326:Src/usb_pd_protocol.c **** {
 2878              		.loc 1 326 20 view .LVU763
 2879              	.LBB345:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2880              		.loc 1 328 2 view .LVU764
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2881              		.loc 1 333 2 view .LVU765
 2882              	.LBB346:
 2883              	.LBI346:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
ARM GAS  /tmp/ccoQIC4J.s 			page 100


 2884              		.loc 1 261 20 view .LVU766
 2885              	.LBB347:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2886              		.loc 1 265 2 view .LVU767
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2887              		.loc 1 265 19 is_stmt 0 view .LVU768
 2888 0300 0022     		movs	r2, #0
 2889 0302 0023     		movs	r3, #0
 2890 0304 2261     		str	r2, [r4, #16]
 2891 0306 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 2892              		.loc 1 266 2 is_stmt 1 view .LVU769
 266:Src/usb_pd_protocol.c **** }
 2893              		.loc 1 266 25 is_stmt 0 view .LVU770
 2894 0308 0023     		movs	r3, #0
 2895 030a E371     		strb	r3, [r4, #7]
 2896              	.LVL228:
 266:Src/usb_pd_protocol.c **** }
 2897              		.loc 1 266 25 view .LVU771
 2898              	.LBE347:
 2899              	.LBE346:
 334:Src/usb_pd_protocol.c **** 
 2900              		.loc 1 334 2 is_stmt 1 view .LVU772
 334:Src/usb_pd_protocol.c **** 
 2901              		.loc 1 334 22 is_stmt 0 view .LVU773
 2902 030c 0A33     		adds	r3, r3, #10
 2903 030e 2371     		strb	r3, [r4, #4]
 2904              	.LVL229:
 336:Src/usb_pd_protocol.c **** 		return;
 2905              		.loc 1 336 2 is_stmt 1 view .LVU774
 2906 0310 9AE6     		b	.L127
 2907              	.LVL230:
 2908              	.L129:
 336:Src/usb_pd_protocol.c **** 		return;
 2909              		.loc 1 336 2 is_stmt 0 view .LVU775
 2910              	.LBE345:
 2911              	.LBE344:
1451:Src/usb_pd_protocol.c **** 		/* We are done, acknowledge with an Accept packet */
 2912              		.loc 1 1451 3 is_stmt 1 view .LVU776
 2913 0312 FFF7FEFF 		bl	execute_soft_reset
 2914              	.LVL231:
1453:Src/usb_pd_protocol.c **** 		break;
 2915              		.loc 1 1453 3 view .LVU777
 2916 0316 0321     		movs	r1, #3
 2917 0318 2000     		movs	r0, r4
 2918 031a FFF7FEFF 		bl	send_control
 2919              	.LVL232:
1454:Src/usb_pd_protocol.c **** 	case PD_CTRL_PR_SWAP:
 2920              		.loc 1 1454 3 view .LVU778
 2921 031e 93E6     		b	.L127
 2922              	.L189:
 2923              		.align	2
 2924              	.L188:
 2925 0320 00000000 		.word	.L130
 2926 0324 00000000 		.word	pd
 2927 0328 00000000 		.word	tcpc_config
 2928 032c A0860100 		.word	100000
ARM GAS  /tmp/ccoQIC4J.s 			page 101


 2929              	.LVL233:
 2930              	.L133:
1457:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_ACCEPT);
 2931              		.loc 1 1457 3 view .LVU779
1457:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_ACCEPT);
 2932              		.loc 1 1457 7 is_stmt 0 view .LVU780
 2933 0330 FFF7FEFF 		bl	pd_check_power_swap
 2934              	.LVL234:
1457:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_ACCEPT);
 2935              		.loc 1 1457 6 view .LVU781
 2936 0334 0028     		cmp	r0, #0
 2937 0336 3DD0     		beq	.L161
1458:Src/usb_pd_protocol.c **** 			/*
 2938              		.loc 1 1458 4 is_stmt 1 view .LVU782
 2939 0338 0321     		movs	r1, #3
 2940 033a 2000     		movs	r0, r4
 2941 033c FFF7FEFF 		bl	send_control
 2942              	.LVL235:
1463:Src/usb_pd_protocol.c **** 			set_state(port,
 2943              		.loc 1 1463 4 view .LVU783
1463:Src/usb_pd_protocol.c **** 			set_state(port,
 2944              		.loc 1 1463 19 is_stmt 0 view .LVU784
 2945 0340 304A     		ldr	r2, .L190
 2946 0342 E101     		lsls	r1, r4, #7
 2947 0344 5018     		adds	r0, r2, r1
 2948 0346 304B     		ldr	r3, .L190+4
 2949 0348 8568     		ldr	r5, [r0, #8]
 2950 034a 2B40     		ands	r3, r5
 2951 034c 8360     		str	r3, [r0, #8]
1464:Src/usb_pd_protocol.c **** 				  DUAL_ROLE_IF_ELSE(port,
 2952              		.loc 1 1464 4 is_stmt 1 view .LVU785
1465:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_SWAP_SNK_DISABLE,
 2953              		.loc 1 1465 7 is_stmt 0 view .LVU786
 2954 034e 8B5C     		ldrb	r3, [r1, r2]
1464:Src/usb_pd_protocol.c **** 				  DUAL_ROLE_IF_ELSE(port,
 2955              		.loc 1 1464 4 view .LVU787
 2956 0350 002B     		cmp	r3, #0
 2957 0352 26D1     		bne	.L168
 2958 0354 0A21     		movs	r1, #10
 2959              	.L162:
 2960              	.LVL236:
 2961              	.LBB348:
 2962              	.LBI348:
 326:Src/usb_pd_protocol.c **** {
 2963              		.loc 1 326 20 is_stmt 1 discriminator 4 view .LVU788
 2964              	.LBB349:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2965              		.loc 1 328 2 discriminator 4 view .LVU789
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 2966              		.loc 1 328 17 is_stmt 0 discriminator 4 view .LVU790
 2967 0356 E201     		lsls	r2, r4, #7
 2968 0358 2A4B     		ldr	r3, .L190
 2969 035a 9B18     		adds	r3, r3, r2
 2970 035c 1A79     		ldrb	r2, [r3, #4]
 2971              	.LVL237:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 2972              		.loc 1 333 2 is_stmt 1 discriminator 4 view .LVU791
ARM GAS  /tmp/ccoQIC4J.s 			page 102


 2973              	.LBB350:
 2974              	.LBI350:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 2975              		.loc 1 261 20 discriminator 4 view .LVU792
 2976              	.LBB351:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2977              		.loc 1 265 2 discriminator 4 view .LVU793
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 2978              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU794
 2979 035e 0026     		movs	r6, #0
 2980 0360 0027     		movs	r7, #0
 2981 0362 1E61     		str	r6, [r3, #16]
 2982 0364 5F61     		str	r7, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 2983              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU795
 266:Src/usb_pd_protocol.c **** }
 2984              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU796
 2985 0366 0020     		movs	r0, #0
 2986 0368 D871     		strb	r0, [r3, #7]
 2987              	.LVL238:
 266:Src/usb_pd_protocol.c **** }
 2988              		.loc 1 266 25 discriminator 4 view .LVU797
 2989              	.LBE351:
 2990              	.LBE350:
 334:Src/usb_pd_protocol.c **** 
 2991              		.loc 1 334 2 is_stmt 1 discriminator 4 view .LVU798
 334:Src/usb_pd_protocol.c **** 
 2992              		.loc 1 334 22 is_stmt 0 discriminator 4 view .LVU799
 2993 036a 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 2994              		.loc 1 336 2 is_stmt 1 discriminator 4 view .LVU800
 336:Src/usb_pd_protocol.c **** 		return;
 2995              		.loc 1 336 5 is_stmt 0 discriminator 4 view .LVU801
 2996 036c 9142     		cmp	r1, r2
 2997 036e 00D1     		bne	.LCB2891
 2998 0370 6AE6     		b	.L127	@long jump
 2999              	.LCB2891:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 3000              		.loc 1 347 2 is_stmt 1 view .LVU802
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 3001              		.loc 1 348 48 is_stmt 0 view .LVU803
 3002 0372 0E2A     		cmp	r2, #14
 3003 0374 17D0     		beq	.L186
 3004              	.L163:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 3005              		.loc 1 353 2 is_stmt 1 view .LVU804
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 3006              		.loc 1 353 46 is_stmt 0 view .LVU805
 3007 0376 0229     		cmp	r1, #2
 3008 0378 00D0     		beq	.LCB2899
 3009 037a 65E6     		b	.L127	@long jump
 3010              	.LCB2899:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 3011              		.loc 1 356 3 is_stmt 1 view .LVU806
 3012 037c 0022     		movs	r2, #0
 3013              	.LVL239:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
ARM GAS  /tmp/ccoQIC4J.s 			page 103


 3014              		.loc 1 356 3 is_stmt 0 view .LVU807
 3015 037e 0021     		movs	r1, #0
 3016              	.LVL240:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 3017              		.loc 1 356 3 view .LVU808
 3018 0380 2000     		movs	r0, r4
 3019 0382 FFF7FEFF 		bl	pd_set_input_current_limit
 3020              	.LVL241:
 373:Src/usb_pd_protocol.c **** 			/*
 3021              		.loc 1 373 3 is_stmt 1 view .LVU809
 373:Src/usb_pd_protocol.c **** 			/*
 3022              		.loc 1 373 15 is_stmt 0 view .LVU810
 3023 0386 E301     		lsls	r3, r4, #7
 3024 0388 1E4A     		ldr	r2, .L190
 3025 038a 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 3026              		.loc 1 373 6 view .LVU811
 3027 038c 012B     		cmp	r3, #1
 3028 038e 0DD0     		beq	.L187
 3029              	.L164:
 405:Src/usb_pd_protocol.c **** 	}
 3030              		.loc 1 405 3 is_stmt 1 view .LVU812
 3031              	.LVL242:
 3032              	.LBB352:
 3033              	.LBI352:
  94:Inc/tcpm.h    **** {
 3034              		.loc 2 94 19 view .LVU813
 3035              	.LBB353:
  96:Inc/tcpm.h    **** }
 3036              		.loc 2 96 2 view .LVU814
  96:Inc/tcpm.h    **** }
 3037              		.loc 2 96 26 is_stmt 0 view .LVU815
 3038 0390 2201     		lsls	r2, r4, #4
 3039 0392 1E4B     		ldr	r3, .L190+8
 3040 0394 9B18     		adds	r3, r3, r2
 3041 0396 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 3042              		.loc 2 96 30 view .LVU816
 3043 0398 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 3044              		.loc 2 96 9 view .LVU817
 3045 039a 0021     		movs	r1, #0
 3046 039c 2000     		movs	r0, r4
 3047 039e 9847     		blx	r3
 3048              	.LVL243:
 3049 03a0 52E6     		b	.L127
 3050              	.LVL244:
 3051              	.L168:
  96:Inc/tcpm.h    **** }
 3052              		.loc 2 96 9 view .LVU818
 3053              	.LBE353:
 3054              	.LBE352:
 3055              	.LBE349:
 3056              	.LBE348:
1464:Src/usb_pd_protocol.c **** 				  DUAL_ROLE_IF_ELSE(port,
 3057              		.loc 1 1464 4 view .LVU819
 3058 03a2 1B21     		movs	r1, #27
ARM GAS  /tmp/ccoQIC4J.s 			page 104


 3059 03a4 D7E7     		b	.L162
 3060              	.LVL245:
 3061              	.L186:
 3062              	.LBB355:
 3063              	.LBB354:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 3064              		.loc 1 349 47 view .LVU820
 3065 03a6 0229     		cmp	r1, #2
 3066 03a8 E5D1     		bne	.L163
 3067 03aa 4DE6     		b	.L127
 3068              	.LVL246:
 3069              	.L187:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 3070              		.loc 1 378 4 is_stmt 1 view .LVU821
 3071 03ac 2000     		movs	r0, r4
 3072 03ae FFF7FEFF 		bl	pd_power_supply_reset
 3073              	.LVL247:
 3074 03b2 EDE7     		b	.L164
 3075              	.LVL248:
 3076              	.L161:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 3077              		.loc 1 378 4 is_stmt 0 view .LVU822
 3078              	.LBE354:
 3079              	.LBE355:
1469:Src/usb_pd_protocol.c **** 		}
 3080              		.loc 1 1469 4 is_stmt 1 view .LVU823
 3081 03b4 0421     		movs	r1, #4
 3082 03b6 2000     		movs	r0, r4
 3083 03b8 FFF7FEFF 		bl	send_control
 3084              	.LVL249:
 3085 03bc 44E6     		b	.L127
 3086              	.LVL250:
 3087              	.L134:
1476:Src/usb_pd_protocol.c **** 			/*
 3088              		.loc 1 1476 3 view .LVU824
1476:Src/usb_pd_protocol.c **** 			/*
 3089              		.loc 1 1476 40 is_stmt 0 view .LVU825
 3090 03be C201     		lsls	r2, r0, #7
 3091 03c0 104B     		ldr	r3, .L190
 3092 03c2 9B18     		adds	r3, r3, r2
 3093 03c4 5978     		ldrb	r1, [r3, #1]
 3094              	.LVL251:
1476:Src/usb_pd_protocol.c **** 			/*
 3095              		.loc 1 1476 7 view .LVU826
 3096 03c6 FFF7FEFF 		bl	pd_check_data_swap
 3097              	.LVL252:
1476:Src/usb_pd_protocol.c **** 			/*
 3098              		.loc 1 1476 6 view .LVU827
 3099 03ca 0028     		cmp	r0, #0
 3100 03cc 11D0     		beq	.L165
1482:Src/usb_pd_protocol.c **** 			if (send_control(port, PD_CTRL_ACCEPT) >= 0)
 3101              		.loc 1 1482 4 is_stmt 1 view .LVU828
1482:Src/usb_pd_protocol.c **** 			if (send_control(port, PD_CTRL_ACCEPT) >= 0)
 3102              		.loc 1 1482 19 is_stmt 0 view .LVU829
 3103 03ce E201     		lsls	r2, r4, #7
 3104 03d0 0C4B     		ldr	r3, .L190
 3105 03d2 9B18     		adds	r3, r3, r2
ARM GAS  /tmp/ccoQIC4J.s 			page 105


 3106 03d4 0E4A     		ldr	r2, .L190+12
 3107 03d6 9968     		ldr	r1, [r3, #8]
 3108 03d8 0A40     		ands	r2, r1
 3109 03da 9A60     		str	r2, [r3, #8]
1483:Src/usb_pd_protocol.c **** 				pd_dr_swap(port);
 3110              		.loc 1 1483 4 is_stmt 1 view .LVU830
1483:Src/usb_pd_protocol.c **** 				pd_dr_swap(port);
 3111              		.loc 1 1483 8 is_stmt 0 view .LVU831
 3112 03dc 0321     		movs	r1, #3
 3113 03de 2000     		movs	r0, r4
 3114 03e0 FFF7FEFF 		bl	send_control
 3115              	.LVL253:
1483:Src/usb_pd_protocol.c **** 				pd_dr_swap(port);
 3116              		.loc 1 1483 7 view .LVU832
 3117 03e4 0028     		cmp	r0, #0
 3118 03e6 00DA     		bge	.LCB3012
 3119 03e8 2EE6     		b	.L127	@long jump
 3120              	.LCB3012:
1484:Src/usb_pd_protocol.c **** 		} else {
 3121              		.loc 1 1484 5 is_stmt 1 view .LVU833
 3122 03ea 2000     		movs	r0, r4
 3123 03ec FFF7FEFF 		bl	pd_dr_swap
 3124              	.LVL254:
 3125 03f0 2AE6     		b	.L127
 3126              	.L165:
1486:Src/usb_pd_protocol.c **** 
 3127              		.loc 1 1486 4 view .LVU834
 3128 03f2 0421     		movs	r1, #4
 3129 03f4 2000     		movs	r0, r4
 3130 03f6 FFF7FEFF 		bl	send_control
 3131              	.LVL255:
 3132 03fa 25E6     		b	.L127
 3133              	.LVL256:
 3134              	.L132:
1503:Src/usb_pd_protocol.c **** #endif
 3135              		.loc 1 1503 3 view .LVU835
 3136 03fc 0421     		movs	r1, #4
 3137              	.LVL257:
1503:Src/usb_pd_protocol.c **** #endif
 3138              		.loc 1 1503 3 is_stmt 0 view .LVU836
 3139 03fe FFF7FEFF 		bl	send_control
 3140              	.LVL258:
1505:Src/usb_pd_protocol.c **** 	default:
 3141              		.loc 1 1505 3 is_stmt 1 view .LVU837
1510:Src/usb_pd_protocol.c **** 	}
 3142              		.loc 1 1510 52 view .LVU838
1512:Src/usb_pd_protocol.c **** 
 3143              		.loc 1 1512 1 is_stmt 0 view .LVU839
 3144 0402 21E6     		b	.L127
 3145              	.L191:
 3146              		.align	2
 3147              	.L190:
 3148 0404 00000000 		.word	pd
 3149 0408 FFFDFFFF 		.word	-513
 3150 040c 00000000 		.word	tcpc_config
 3151 0410 FFFBFFFF 		.word	-1025
 3152              		.cfi_endproc
ARM GAS  /tmp/ccoQIC4J.s 			page 106


 3153              	.LFE45:
 3155              		.section	.text.handle_data_request,"ax",%progbits
 3156              		.align	1
 3157              		.syntax unified
 3158              		.code	16
 3159              		.thumb_func
 3160              		.fpu softvfp
 3162              	handle_data_request:
 3163              	.LVL259:
 3164              	.LFB40:
1081:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
 3165              		.loc 1 1081 1 is_stmt 1 view -0
 3166              		.cfi_startproc
 3167              		@ args = 0, pretend = 0, frame = 0
 3168              		@ frame_needed = 0, uses_anonymous_args = 0
1081:Src/usb_pd_protocol.c **** 	int type = PD_HEADER_TYPE(head);
 3169              		.loc 1 1081 1 is_stmt 0 view .LVU841
 3170 0000 70B5     		push	{r4, r5, r6, lr}
 3171              	.LCFI21:
 3172              		.cfi_def_cfa_offset 16
 3173              		.cfi_offset 4, -16
 3174              		.cfi_offset 5, -12
 3175              		.cfi_offset 6, -8
 3176              		.cfi_offset 14, -4
 3177 0002 0400     		movs	r4, r0
 3178 0004 1600     		movs	r6, r2
1082:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
 3179              		.loc 1 1082 2 is_stmt 1 view .LVU842
 3180              	.LVL260:
1083:Src/usb_pd_protocol.c **** 
 3181              		.loc 1 1083 2 view .LVU843
1083:Src/usb_pd_protocol.c **** 
 3182              		.loc 1 1083 12 is_stmt 0 view .LVU844
 3183 0006 0B0B     		lsrs	r3, r1, #12
1083:Src/usb_pd_protocol.c **** 
 3184              		.loc 1 1083 6 view .LVU845
 3185 0008 0725     		movs	r5, #7
 3186 000a 1D40     		ands	r5, r3
 3187              	.LVL261:
1085:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 3188              		.loc 1 1085 2 is_stmt 1 view .LVU846
 3189 000c 0F23     		movs	r3, #15
 3190 000e 0B40     		ands	r3, r1
 3191 0010 9B00     		lsls	r3, r3, #2
 3192 0012 6E4A     		ldr	r2, .L214
 3193              	.LVL262:
1085:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 3194              		.loc 1 1085 2 is_stmt 0 view .LVU847
 3195 0014 D358     		ldr	r3, [r2, r3]
 3196 0016 9F46     		mov	pc, r3
 3197              		.section	.rodata.handle_data_request,"a",%progbits
 3198              		.align	2
 3199              	.L195:
 3200 0000 C8010000 		.word	.L192
 3201 0004 18000000 		.word	.L199
 3202 0008 64000000 		.word	.L198
 3203 000c D6000000 		.word	.L197
ARM GAS  /tmp/ccoQIC4J.s 			page 107


 3204 0010 8E010000 		.word	.L196
 3205 0014 C8010000 		.word	.L192
 3206 0018 C8010000 		.word	.L192
 3207 001c C8010000 		.word	.L192
 3208 0020 C8010000 		.word	.L192
 3209 0024 C8010000 		.word	.L192
 3210 0028 C8010000 		.word	.L192
 3211 002c C8010000 		.word	.L192
 3212 0030 C8010000 		.word	.L192
 3213 0034 C8010000 		.word	.L192
 3214 0038 C8010000 		.word	.L192
 3215 003c C0010000 		.word	.L194
 3216              		.section	.text.handle_data_request
 3217              	.L199:
1088:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_TRANSITION)
 3218              		.loc 1 1088 3 is_stmt 1 view .LVU848
1088:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_TRANSITION)
 3219              		.loc 1 1088 16 is_stmt 0 view .LVU849
 3220 0018 C201     		lsls	r2, r0, #7
 3221 001a 6D4B     		ldr	r3, .L214+4
 3222 001c 9B18     		adds	r3, r3, r2
 3223 001e 1B79     		ldrb	r3, [r3, #4]
1088:Src/usb_pd_protocol.c **** 			|| (pd[port].task_state == PD_STATE_SNK_TRANSITION)
 3224              		.loc 1 1088 6 view .LVU850
 3225 0020 052B     		cmp	r3, #5
 3226 0022 04D0     		beq	.L200
1089:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_NONE
 3227              		.loc 1 1089 4 view .LVU851
 3228 0024 072B     		cmp	r3, #7
 3229 0026 02D0     		beq	.L200
1094:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3230              		.loc 1 1094 4 view .LVU852
 3231 0028 082B     		cmp	r3, #8
 3232 002a 00D0     		beq	.LCB3102
 3233 002c CCE0     		b	.L192	@long jump
 3234              	.LCB3102:
 3235              	.L200:
1103:Src/usb_pd_protocol.c **** 
 3236              		.loc 1 1103 4 is_stmt 1 view .LVU853
1103:Src/usb_pd_protocol.c **** 
 3237              		.loc 1 1103 19 is_stmt 0 view .LVU854
 3238 002e E201     		lsls	r2, r4, #7
 3239 0030 674B     		ldr	r3, .L214+4
 3240 0032 9B18     		adds	r3, r3, r2
 3241 0034 8022     		movs	r2, #128
 3242 0036 5200     		lsls	r2, r2, #1
 3243 0038 9968     		ldr	r1, [r3, #8]
 3244              	.LVL263:
1103:Src/usb_pd_protocol.c **** 
 3245              		.loc 1 1103 19 view .LVU855
 3246 003a 0A43     		orrs	r2, r1
 3247 003c 9A60     		str	r2, [r3, #8]
1106:Src/usb_pd_protocol.c **** 
 3248              		.loc 1 1106 4 is_stmt 1 view .LVU856
 3249 003e 3168     		ldr	r1, [r6]
 3250 0040 2000     		movs	r0, r4
 3251              	.LVL264:
ARM GAS  /tmp/ccoQIC4J.s 			page 108


1106:Src/usb_pd_protocol.c **** 
 3252              		.loc 1 1106 4 is_stmt 0 view .LVU857
 3253 0042 FFF7FEFF 		bl	pd_update_pdo_flags
 3254              	.LVL265:
1108:Src/usb_pd_protocol.c **** 			pd_process_source_cap_callback(port, cnt, payload);
 3255              		.loc 1 1108 4 is_stmt 1 view .LVU858
 3256 0046 3200     		movs	r2, r6
 3257 0048 2900     		movs	r1, r5
 3258 004a 2000     		movs	r0, r4
 3259 004c FFF7FEFF 		bl	pd_process_source_cap
 3260              	.LVL266:
1109:Src/usb_pd_protocol.c **** 
 3261              		.loc 1 1109 4 view .LVU859
 3262 0050 3200     		movs	r2, r6
 3263 0052 2900     		movs	r1, r5
 3264 0054 2000     		movs	r0, r4
 3265 0056 FFF7FEFF 		bl	pd_process_source_cap_callback
 3266              	.LVL267:
1112:Src/usb_pd_protocol.c **** 		}
 3267              		.loc 1 1112 4 view .LVU860
 3268 005a 0121     		movs	r1, #1
 3269 005c 2000     		movs	r0, r4
 3270 005e FFF7FEFF 		bl	pd_send_request_msg
 3271              	.LVL268:
 3272 0062 B1E0     		b	.L192
 3273              	.LVL269:
 3274              	.L198:
1117:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3275              		.loc 1 1117 3 view .LVU861
1117:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3276              		.loc 1 1117 16 is_stmt 0 view .LVU862
 3277 0064 C301     		lsls	r3, r0, #7
 3278 0066 5A4A     		ldr	r2, .L214+4
 3279 0068 9B5C     		ldrb	r3, [r3, r2]
1117:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3280              		.loc 1 1117 6 view .LVU863
 3281 006a 012B     		cmp	r3, #1
 3282 006c 01D1     		bne	.L201
1117:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3283              		.loc 1 1117 47 discriminator 1 view .LVU864
 3284 006e 012D     		cmp	r5, #1
 3285 0070 0FD0     		beq	.L210
 3286              	.LVL270:
 3287              	.L201:
1156:Src/usb_pd_protocol.c **** 		/* keep last contract in place (whether implicit or explicit) */
 3288              		.loc 1 1156 3 is_stmt 1 view .LVU865
 3289 0072 0421     		movs	r1, #4
 3290 0074 2000     		movs	r0, r4
 3291 0076 FFF7FEFF 		bl	send_control
 3292              	.LVL271:
1158:Src/usb_pd_protocol.c **** 		break;
 3293              		.loc 1 1158 3 view .LVU866
 3294              	.LBB380:
 3295              	.LBI380:
 326:Src/usb_pd_protocol.c **** {
 3296              		.loc 1 326 20 view .LVU867
 3297              	.LBB381:
ARM GAS  /tmp/ccoQIC4J.s 			page 109


 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 3298              		.loc 1 328 2 view .LVU868
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 3299              		.loc 1 333 2 view .LVU869
 3300              	.LBB382:
 3301              	.LBI382:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 3302              		.loc 1 261 20 view .LVU870
 3303              	.LBB383:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3304              		.loc 1 265 2 view .LVU871
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3305              		.loc 1 265 19 is_stmt 0 view .LVU872
 3306 007a E401     		lsls	r4, r4, #7
 3307              	.LVL272:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3308              		.loc 1 265 19 view .LVU873
 3309 007c 544B     		ldr	r3, .L214+4
 3310 007e 1C19     		adds	r4, r3, r4
 3311 0080 0022     		movs	r2, #0
 3312 0082 0023     		movs	r3, #0
 3313 0084 2261     		str	r2, [r4, #16]
 3314 0086 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 3315              		.loc 1 266 2 is_stmt 1 view .LVU874
 266:Src/usb_pd_protocol.c **** }
 3316              		.loc 1 266 25 is_stmt 0 view .LVU875
 3317 0088 0023     		movs	r3, #0
 3318 008a E371     		strb	r3, [r4, #7]
 3319              	.LVL273:
 266:Src/usb_pd_protocol.c **** }
 3320              		.loc 1 266 25 view .LVU876
 3321              	.LBE383:
 3322              	.LBE382:
 334:Src/usb_pd_protocol.c **** 
 3323              		.loc 1 334 2 is_stmt 1 view .LVU877
 334:Src/usb_pd_protocol.c **** 
 3324              		.loc 1 334 22 is_stmt 0 view .LVU878
 3325 008c 1733     		adds	r3, r3, #23
 3326 008e 2371     		strb	r3, [r4, #4]
 3327              	.LVL274:
 336:Src/usb_pd_protocol.c **** 		return;
 3328              		.loc 1 336 2 is_stmt 1 view .LVU879
 3329 0090 9AE0     		b	.L192
 3330              	.LVL275:
 3331              	.L210:
 336:Src/usb_pd_protocol.c **** 		return;
 3332              		.loc 1 336 2 is_stmt 0 view .LVU880
 3333              	.LBE381:
 3334              	.LBE380:
1125:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
 3335              		.loc 1 1125 4 is_stmt 1 view .LVU881
1125:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
 3336              		.loc 1 1125 9 is_stmt 0 view .LVU882
 3337 0092 0100     		movs	r1, r0
 3338              	.LVL276:
1125:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
ARM GAS  /tmp/ccoQIC4J.s 			page 110


 3339              		.loc 1 1125 9 view .LVU883
 3340 0094 3068     		ldr	r0, [r6]
 3341              	.LVL277:
1125:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
 3342              		.loc 1 1125 9 view .LVU884
 3343 0096 FFF7FEFF 		bl	pd_check_requested_voltage
 3344              	.LVL278:
1125:Src/usb_pd_protocol.c **** 				if (send_control(port, PD_CTRL_ACCEPT) < 0)
 3345              		.loc 1 1125 7 view .LVU885
 3346 009a 0028     		cmp	r0, #0
 3347 009c E9D1     		bne	.L201
1126:Src/usb_pd_protocol.c **** 					/*
 3348              		.loc 1 1126 5 is_stmt 1 view .LVU886
1126:Src/usb_pd_protocol.c **** 					/*
 3349              		.loc 1 1126 9 is_stmt 0 view .LVU887
 3350 009e 0321     		movs	r1, #3
 3351 00a0 2000     		movs	r0, r4
 3352 00a2 FFF7FEFF 		bl	send_control
 3353              	.LVL279:
1126:Src/usb_pd_protocol.c **** 					/*
 3354              		.loc 1 1126 8 view .LVU888
 3355 00a6 0028     		cmp	r0, #0
 3356 00a8 00DA     		bge	.LCB3227
 3357 00aa 8DE0     		b	.L192	@long jump
 3358              	.LCB3227:
1135:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3359              		.loc 1 1135 5 is_stmt 1 view .LVU889
1135:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3360              		.loc 1 1135 20 is_stmt 0 view .LVU890
 3361 00ac E401     		lsls	r4, r4, #7
 3362              	.LVL280:
1135:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
 3363              		.loc 1 1135 20 view .LVU891
 3364 00ae 484B     		ldr	r3, .L214+4
 3365 00b0 1C19     		adds	r4, r3, r4
 3366 00b2 4023     		movs	r3, #64
 3367 00b4 A268     		ldr	r2, [r4, #8]
 3368 00b6 1343     		orrs	r3, r2
 3369 00b8 A360     		str	r3, [r4, #8]
1150:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_ACCEPTED);
 3370              		.loc 1 1150 5 is_stmt 1 view .LVU892
1150:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_ACCEPTED);
 3371              		.loc 1 1150 30 is_stmt 0 view .LVU893
 3372 00ba 3268     		ldr	r2, [r6]
 3373 00bc 120F     		lsrs	r2, r2, #28
 3374 00be 0723     		movs	r3, #7
 3375 00c0 1340     		ands	r3, r2
1150:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_ACCEPTED);
 3376              		.loc 1 1150 28 view .LVU894
 3377 00c2 E362     		str	r3, [r4, #44]
1151:Src/usb_pd_protocol.c **** 				return;
 3378              		.loc 1 1151 5 is_stmt 1 view .LVU895
 3379              	.LVL281:
 3380              	.LBB384:
 3381              	.LBI384:
 326:Src/usb_pd_protocol.c **** {
 3382              		.loc 1 326 20 view .LVU896
ARM GAS  /tmp/ccoQIC4J.s 			page 111


 3383              	.LBB385:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 3384              		.loc 1 328 2 view .LVU897
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 3385              		.loc 1 333 2 view .LVU898
 3386              	.LBB386:
 3387              	.LBI386:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 3388              		.loc 1 261 20 view .LVU899
 3389              	.LBB387:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3390              		.loc 1 265 2 view .LVU900
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3391              		.loc 1 265 19 is_stmt 0 view .LVU901
 3392 00c4 0022     		movs	r2, #0
 3393 00c6 0023     		movs	r3, #0
 3394 00c8 2261     		str	r2, [r4, #16]
 3395 00ca 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 3396              		.loc 1 266 2 is_stmt 1 view .LVU902
 266:Src/usb_pd_protocol.c **** }
 3397              		.loc 1 266 25 is_stmt 0 view .LVU903
 3398 00cc 0023     		movs	r3, #0
 3399 00ce E371     		strb	r3, [r4, #7]
 3400              	.LVL282:
 266:Src/usb_pd_protocol.c **** }
 3401              		.loc 1 266 25 view .LVU904
 3402              	.LBE387:
 3403              	.LBE386:
 334:Src/usb_pd_protocol.c **** 
 3404              		.loc 1 334 2 is_stmt 1 view .LVU905
 334:Src/usb_pd_protocol.c **** 
 3405              		.loc 1 334 22 is_stmt 0 view .LVU906
 3406 00d0 1433     		adds	r3, r3, #20
 3407 00d2 2371     		strb	r3, [r4, #4]
 3408              	.LVL283:
 336:Src/usb_pd_protocol.c **** 		return;
 3409              		.loc 1 336 2 is_stmt 1 view .LVU907
 3410 00d4 78E0     		b	.L192
 3411              	.LVL284:
 3412              	.L197:
 336:Src/usb_pd_protocol.c **** 		return;
 3413              		.loc 1 336 2 is_stmt 0 view .LVU908
 3414              	.LBE385:
 3415              	.LBE384:
1162:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3416              		.loc 1 1162 3 is_stmt 1 view .LVU909
1162:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3417              		.loc 1 1162 7 is_stmt 0 view .LVU910
 3418 00d6 C301     		lsls	r3, r0, #7
 3419 00d8 3D4A     		ldr	r2, .L214+4
 3420 00da 9B5C     		ldrb	r3, [r3, r2]
 3421 00dc 002B     		cmp	r3, #0
 3422 00de 41D1     		bne	.L202
1162:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3423              		.loc 1 1162 7 discriminator 1 view .LVU911
 3424 00e0 C201     		lsls	r2, r0, #7
ARM GAS  /tmp/ccoQIC4J.s 			page 112


 3425 00e2 3B4B     		ldr	r3, .L214+4
 3426 00e4 9B18     		adds	r3, r3, r2
 3427 00e6 1B79     		ldrb	r3, [r3, #4]
 3428 00e8 083B     		subs	r3, r3, #8
 3429 00ea 5A42     		rsbs	r2, r3, #0
 3430 00ec 5341     		adcs	r3, r3, r2
 3431 00ee DBB2     		uxtb	r3, r3
 3432              	.L203:
1162:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3433              		.loc 1 1162 6 discriminator 4 view .LVU912
 3434 00f0 002B     		cmp	r3, #0
 3435 00f2 69D0     		beq	.L192
1166:Src/usb_pd_protocol.c **** 				/* bist data object mode is 2 */
 3436              		.loc 1 1166 4 is_stmt 1 view .LVU913
1166:Src/usb_pd_protocol.c **** 				/* bist data object mode is 2 */
 3437              		.loc 1 1166 16 is_stmt 0 view .LVU914
 3438 00f4 3368     		ldr	r3, [r6]
1166:Src/usb_pd_protocol.c **** 				/* bist data object mode is 2 */
 3439              		.loc 1 1166 20 view .LVU915
 3440 00f6 1B0F     		lsrs	r3, r3, #28
1166:Src/usb_pd_protocol.c **** 				/* bist data object mode is 2 */
 3441              		.loc 1 1166 7 view .LVU916
 3442 00f8 052B     		cmp	r3, #5
 3443 00fa 65D1     		bne	.L192
1168:Src/usb_pd_protocol.c **** 					    NULL);
 3444              		.loc 1 1168 5 is_stmt 1 view .LVU917
 3445 00fc 0023     		movs	r3, #0
 3446 00fe 0022     		movs	r2, #0
 3447 0100 0721     		movs	r1, #7
 3448              	.LVL285:
1168:Src/usb_pd_protocol.c **** 					    NULL);
 3449              		.loc 1 1168 5 is_stmt 0 view .LVU918
 3450 0102 2000     		movs	r0, r4
 3451              	.LVL286:
1168:Src/usb_pd_protocol.c **** 					    NULL);
 3452              		.loc 1 1168 5 view .LVU919
 3453 0104 FFF7FEFF 		bl	pd_transmit
 3454              	.LVL287:
1171:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
 3455              		.loc 1 1171 5 is_stmt 1 view .LVU920
1171:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
 3456              		.loc 1 1171 21 is_stmt 0 view .LVU921
 3457 0108 E301     		lsls	r3, r4, #7
 3458 010a 314A     		ldr	r2, .L214+4
 3459 010c 9B5C     		ldrb	r3, [r3, r2]
1171:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
 3460              		.loc 1 1171 5 view .LVU922
 3461 010e 002B     		cmp	r3, #0
 3462 0110 31D1     		bne	.L209
 3463 0112 0222     		movs	r2, #2
 3464              	.L204:
 3465              	.LVL288:
 3466              	.LBB388:
 3467              	.LBI388:
 326:Src/usb_pd_protocol.c **** {
 3468              		.loc 1 326 20 is_stmt 1 discriminator 4 view .LVU923
 3469              	.LBB389:
ARM GAS  /tmp/ccoQIC4J.s 			page 113


 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 3470              		.loc 1 328 2 discriminator 4 view .LVU924
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 3471              		.loc 1 328 17 is_stmt 0 discriminator 4 view .LVU925
 3472 0114 E101     		lsls	r1, r4, #7
 3473 0116 2E4B     		ldr	r3, .L214+4
 3474 0118 5B18     		adds	r3, r3, r1
 3475 011a 1D79     		ldrb	r5, [r3, #4]
 3476              	.LVL289:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 3477              		.loc 1 333 2 is_stmt 1 discriminator 4 view .LVU926
 3478              	.LBB390:
 3479              	.LBI390:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 3480              		.loc 1 261 20 discriminator 4 view .LVU927
 3481              	.LBB391:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3482              		.loc 1 265 2 discriminator 4 view .LVU928
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3483              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU929
 3484 011c 0020     		movs	r0, #0
 3485 011e 0021     		movs	r1, #0
 3486 0120 1861     		str	r0, [r3, #16]
 3487 0122 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 3488              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU930
 266:Src/usb_pd_protocol.c **** }
 3489              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU931
 3490 0124 0021     		movs	r1, #0
 3491 0126 D971     		strb	r1, [r3, #7]
 3492              	.LVL290:
 266:Src/usb_pd_protocol.c **** }
 3493              		.loc 1 266 25 discriminator 4 view .LVU932
 3494              	.LBE391:
 3495              	.LBE390:
 334:Src/usb_pd_protocol.c **** 
 3496              		.loc 1 334 2 is_stmt 1 discriminator 4 view .LVU933
 334:Src/usb_pd_protocol.c **** 
 3497              		.loc 1 334 22 is_stmt 0 discriminator 4 view .LVU934
 3498 0128 1A71     		strb	r2, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 3499              		.loc 1 336 2 is_stmt 1 discriminator 4 view .LVU935
 336:Src/usb_pd_protocol.c **** 		return;
 3500              		.loc 1 336 5 is_stmt 0 discriminator 4 view .LVU936
 3501 012a AA42     		cmp	r2, r5
 3502 012c 4CD0     		beq	.L192
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 3503              		.loc 1 347 2 is_stmt 1 view .LVU937
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 3504              		.loc 1 347 5 is_stmt 0 view .LVU938
 3505 012e 022D     		cmp	r5, #2
 3506 0130 23D0     		beq	.L211
 3507              	.L205:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 3508              		.loc 1 348 48 view .LVU939
 3509 0132 0E2D     		cmp	r5, #14
 3510 0134 24D0     		beq	.L212
ARM GAS  /tmp/ccoQIC4J.s 			page 114


 3511              	.L206:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 3512              		.loc 1 353 2 is_stmt 1 view .LVU940
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 3513              		.loc 1 353 5 is_stmt 0 view .LVU941
 3514 0136 0E2A     		cmp	r2, #14
 3515 0138 01D0     		beq	.L207
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 3516              		.loc 1 353 46 view .LVU942
 3517 013a 022A     		cmp	r2, #2
 3518 013c 44D1     		bne	.L192
 3519              	.L207:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 3520              		.loc 1 356 3 is_stmt 1 view .LVU943
 3521 013e 0022     		movs	r2, #0
 3522              	.LVL291:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 3523              		.loc 1 356 3 is_stmt 0 view .LVU944
 3524 0140 0021     		movs	r1, #0
 3525 0142 2000     		movs	r0, r4
 3526 0144 FFF7FEFF 		bl	pd_set_input_current_limit
 3527              	.LVL292:
 373:Src/usb_pd_protocol.c **** 			/*
 3528              		.loc 1 373 3 is_stmt 1 view .LVU945
 373:Src/usb_pd_protocol.c **** 			/*
 3529              		.loc 1 373 15 is_stmt 0 view .LVU946
 3530 0148 E301     		lsls	r3, r4, #7
 3531 014a 214A     		ldr	r2, .L214+4
 3532 014c 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 3533              		.loc 1 373 6 view .LVU947
 3534 014e 012B     		cmp	r3, #1
 3535 0150 19D0     		beq	.L213
 3536              	.L208:
 405:Src/usb_pd_protocol.c **** 	}
 3537              		.loc 1 405 3 is_stmt 1 view .LVU948
 3538              	.LVL293:
 3539              	.LBB392:
 3540              	.LBI392:
  94:Inc/tcpm.h    **** {
 3541              		.loc 2 94 19 view .LVU949
 3542              	.LBB393:
  96:Inc/tcpm.h    **** }
 3543              		.loc 2 96 2 view .LVU950
  96:Inc/tcpm.h    **** }
 3544              		.loc 2 96 26 is_stmt 0 view .LVU951
 3545 0152 2201     		lsls	r2, r4, #4
 3546 0154 1F4B     		ldr	r3, .L214+8
 3547 0156 9B18     		adds	r3, r3, r2
 3548 0158 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 3549              		.loc 2 96 30 view .LVU952
 3550 015a 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 3551              		.loc 2 96 9 view .LVU953
 3552 015c 0021     		movs	r1, #0
 3553 015e 2000     		movs	r0, r4
ARM GAS  /tmp/ccoQIC4J.s 			page 115


 3554 0160 9847     		blx	r3
 3555              	.LVL294:
 3556 0162 31E0     		b	.L192
 3557              	.LVL295:
 3558              	.L202:
  96:Inc/tcpm.h    **** }
 3559              		.loc 2 96 9 view .LVU954
 3560              	.LBE393:
 3561              	.LBE392:
 3562              	.LBE389:
 3563              	.LBE388:
1162:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 3564              		.loc 1 1162 7 discriminator 2 view .LVU955
 3565 0164 C201     		lsls	r2, r0, #7
 3566 0166 1A4B     		ldr	r3, .L214+4
 3567 0168 9B18     		adds	r3, r3, r2
 3568 016a 1B79     		ldrb	r3, [r3, #4]
 3569 016c 173B     		subs	r3, r3, #23
 3570 016e 5A42     		rsbs	r2, r3, #0
 3571 0170 5341     		adcs	r3, r3, r2
 3572 0172 DBB2     		uxtb	r3, r3
 3573 0174 BCE7     		b	.L203
 3574              	.LVL296:
 3575              	.L209:
1171:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED,
 3576              		.loc 1 1171 5 view .LVU956
 3577 0176 0E22     		movs	r2, #14
 3578 0178 CCE7     		b	.L204
 3579              	.LVL297:
 3580              	.L211:
 3581              	.LBB395:
 3582              	.LBB394:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 3583              		.loc 1 347 47 view .LVU957
 3584 017a 0E2A     		cmp	r2, #14
 3585 017c D9D1     		bne	.L205
 3586 017e 23E0     		b	.L192
 3587              	.L212:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 3588              		.loc 1 349 47 view .LVU958
 3589 0180 022A     		cmp	r2, #2
 3590 0182 D8D1     		bne	.L206
 3591 0184 20E0     		b	.L192
 3592              	.LVL298:
 3593              	.L213:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 3594              		.loc 1 378 4 is_stmt 1 view .LVU959
 3595 0186 2000     		movs	r0, r4
 3596 0188 FFF7FEFF 		bl	pd_power_supply_reset
 3597              	.LVL299:
 3598 018c E1E7     		b	.L208
 3599              	.LVL300:
 3600              	.L196:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 3601              		.loc 1 378 4 is_stmt 0 view .LVU960
 3602              	.LBE394:
 3603              	.LBE395:
ARM GAS  /tmp/ccoQIC4J.s 			page 116


1178:Src/usb_pd_protocol.c **** 		/* snk cap 0 should be fixed PDO */
 3604              		.loc 1 1178 3 is_stmt 1 view .LVU961
1178:Src/usb_pd_protocol.c **** 		/* snk cap 0 should be fixed PDO */
 3605              		.loc 1 1178 18 is_stmt 0 view .LVU962
 3606 018e C301     		lsls	r3, r0, #7
 3607 0190 0F4D     		ldr	r5, .L214+4
 3608              	.LVL301:
1178:Src/usb_pd_protocol.c **** 		/* snk cap 0 should be fixed PDO */
 3609              		.loc 1 1178 18 view .LVU963
 3610 0192 ED18     		adds	r5, r5, r3
 3611 0194 1023     		movs	r3, #16
 3612 0196 AA68     		ldr	r2, [r5, #8]
 3613 0198 1343     		orrs	r3, r2
 3614 019a AB60     		str	r3, [r5, #8]
1180:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SRC_GET_SINK_CAP)
 3615              		.loc 1 1180 3 is_stmt 1 view .LVU964
 3616 019c 3168     		ldr	r1, [r6]
 3617              	.LVL302:
1180:Src/usb_pd_protocol.c **** 		if (pd[port].task_state == PD_STATE_SRC_GET_SINK_CAP)
 3618              		.loc 1 1180 3 is_stmt 0 view .LVU965
 3619 019e FFF7FEFF 		bl	pd_update_pdo_flags
 3620              	.LVL303:
1181:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 3621              		.loc 1 1181 3 is_stmt 1 view .LVU966
1181:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 3622              		.loc 1 1181 15 is_stmt 0 view .LVU967
 3623 01a2 2B79     		ldrb	r3, [r5, #4]
1181:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 3624              		.loc 1 1181 6 view .LVU968
 3625 01a4 182B     		cmp	r3, #24
 3626 01a6 0FD1     		bne	.L192
1182:Src/usb_pd_protocol.c **** 		break;
 3627              		.loc 1 1182 4 is_stmt 1 view .LVU969
 3628              	.LVL304:
 3629              	.LBB396:
 3630              	.LBI396:
 326:Src/usb_pd_protocol.c **** {
 3631              		.loc 1 326 20 view .LVU970
 3632              	.LBB397:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 3633              		.loc 1 328 2 view .LVU971
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 3634              		.loc 1 333 2 view .LVU972
 3635              	.LBB398:
 3636              	.LBI398:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 3637              		.loc 1 261 20 view .LVU973
 3638              	.LBB399:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3639              		.loc 1 265 2 view .LVU974
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3640              		.loc 1 265 19 is_stmt 0 view .LVU975
 3641 01a8 E401     		lsls	r4, r4, #7
 3642              	.LVL305:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 3643              		.loc 1 265 19 view .LVU976
 3644 01aa 094B     		ldr	r3, .L214+4
ARM GAS  /tmp/ccoQIC4J.s 			page 117


 3645 01ac 1C19     		adds	r4, r3, r4
 3646 01ae 0022     		movs	r2, #0
 3647 01b0 0023     		movs	r3, #0
 3648 01b2 2261     		str	r2, [r4, #16]
 3649 01b4 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 3650              		.loc 1 266 2 is_stmt 1 view .LVU977
 266:Src/usb_pd_protocol.c **** }
 3651              		.loc 1 266 25 is_stmt 0 view .LVU978
 3652 01b6 0023     		movs	r3, #0
 3653 01b8 E371     		strb	r3, [r4, #7]
 3654              	.LVL306:
 266:Src/usb_pd_protocol.c **** }
 3655              		.loc 1 266 25 view .LVU979
 3656              	.LBE399:
 3657              	.LBE398:
 334:Src/usb_pd_protocol.c **** 
 3658              		.loc 1 334 2 is_stmt 1 view .LVU980
 334:Src/usb_pd_protocol.c **** 
 3659              		.loc 1 334 22 is_stmt 0 view .LVU981
 3660 01ba 1733     		adds	r3, r3, #23
 3661 01bc 2371     		strb	r3, [r4, #4]
 3662              	.LVL307:
 336:Src/usb_pd_protocol.c **** 		return;
 3663              		.loc 1 336 2 is_stmt 1 view .LVU982
 3664 01be 03E0     		b	.L192
 3665              	.LVL308:
 3666              	.L194:
 336:Src/usb_pd_protocol.c **** 		return;
 3667              		.loc 1 336 2 is_stmt 0 view .LVU983
 3668              	.LBE397:
 3669              	.LBE396:
1189:Src/usb_pd_protocol.c **** 		break;
 3670              		.loc 1 1189 3 is_stmt 1 view .LVU984
 3671 01c0 3200     		movs	r2, r6
 3672 01c2 2900     		movs	r1, r5
 3673              	.LVL309:
1189:Src/usb_pd_protocol.c **** 		break;
 3674              		.loc 1 1189 3 is_stmt 0 view .LVU985
 3675 01c4 FFF7FEFF 		bl	handle_vdm_request
 3676              	.LVL310:
1190:Src/usb_pd_protocol.c **** 	default:
 3677              		.loc 1 1190 3 is_stmt 1 view .LVU986
1192:Src/usb_pd_protocol.c **** 	}
 3678              		.loc 1 1192 52 view .LVU987
 3679              	.L192:
1194:Src/usb_pd_protocol.c **** 
 3680              		.loc 1 1194 1 is_stmt 0 view .LVU988
 3681              		@ sp needed
 3682              	.LVL311:
1194:Src/usb_pd_protocol.c **** 
 3683              		.loc 1 1194 1 view .LVU989
 3684 01c8 70BD     		pop	{r4, r5, r6, pc}
 3685              	.L215:
 3686 01ca C046     		.align	2
 3687              	.L214:
 3688 01cc 00000000 		.word	.L195
ARM GAS  /tmp/ccoQIC4J.s 			page 118


 3689 01d0 00000000 		.word	pd
 3690 01d4 00000000 		.word	tcpc_config
 3691              		.cfi_endproc
 3692              	.LFE40:
 3694              		.section	.text.pd_is_connected,"ax",%progbits
 3695              		.align	1
 3696              		.global	pd_is_connected
 3697              		.syntax unified
 3698              		.code	16
 3699              		.thumb_func
 3700              		.fpu softvfp
 3702              	pd_is_connected:
 3703              	.LVL312:
 3704              	.LFB20:
 283:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_DISABLED)
 3705              		.loc 1 283 1 is_stmt 1 view -0
 3706              		.cfi_startproc
 3707              		@ args = 0, pretend = 0, frame = 0
 3708              		@ frame_needed = 0, uses_anonymous_args = 0
 3709              		@ link register save eliminated.
 284:Src/usb_pd_protocol.c **** 		return 0;
 3710              		.loc 1 284 2 view .LVU991
 284:Src/usb_pd_protocol.c **** 		return 0;
 3711              		.loc 1 284 14 is_stmt 0 view .LVU992
 3712 0000 C201     		lsls	r2, r0, #7
 3713 0002 0D4B     		ldr	r3, .L220
 3714 0004 9B18     		adds	r3, r3, r2
 3715 0006 1B79     		ldrb	r3, [r3, #4]
 284:Src/usb_pd_protocol.c **** 		return 0;
 3716              		.loc 1 284 5 view .LVU993
 3717 0008 002B     		cmp	r3, #0
 3718 000a 12D0     		beq	.L219
 292:Src/usb_pd_protocol.c **** 		/* sink */
 3719              		.loc 1 292 2 is_stmt 1 view .LVU994
 292:Src/usb_pd_protocol.c **** 		/* sink */
 3720              		.loc 1 292 9 is_stmt 0 view .LVU995
 3721 000c 1000     		movs	r0, r2
 3722              	.LVL313:
 292:Src/usb_pd_protocol.c **** 		/* sink */
 3723              		.loc 1 292 9 view .LVU996
 3724 000e 0A4A     		ldr	r2, .L220
 3725 0010 825C     		ldrb	r2, [r0, r2]
 3726 0012 002A     		cmp	r2, #0
 3727 0014 06D1     		bne	.L218
 292:Src/usb_pd_protocol.c **** 		/* sink */
 3728              		.loc 1 292 9 discriminator 1 view .LVU997
 3729 0016 023B     		subs	r3, r3, #2
 3730 0018 DBB2     		uxtb	r3, r3
 3731 001a 0120     		movs	r0, #1
 3732 001c 9842     		cmp	r0, r3
 3733 001e 8041     		sbcs	r0, r0, r0
 3734 0020 4042     		rsbs	r0, r0, #0
 3735 0022 07E0     		b	.L216
 3736              	.L218:
 292:Src/usb_pd_protocol.c **** 		/* sink */
 3737              		.loc 1 292 9 discriminator 2 view .LVU998
 3738 0024 0E3B     		subs	r3, r3, #14
ARM GAS  /tmp/ccoQIC4J.s 			page 119


 3739 0026 DBB2     		uxtb	r3, r3
 3740 0028 0120     		movs	r0, #1
 3741 002a 9842     		cmp	r0, r3
 3742 002c 8041     		sbcs	r0, r0, r0
 3743 002e 4042     		rsbs	r0, r0, #0
 3744 0030 00E0     		b	.L216
 3745              	.LVL314:
 3746              	.L219:
 285:Src/usb_pd_protocol.c **** 
 3747              		.loc 1 285 10 view .LVU999
 3748 0032 0020     		movs	r0, #0
 3749              	.LVL315:
 3750              	.L216:
 299:Src/usb_pd_protocol.c **** 
 3751              		.loc 1 299 1 view .LVU1000
 3752              		@ sp needed
 3753 0034 7047     		bx	lr
 3754              	.L221:
 3755 0036 C046     		.align	2
 3756              	.L220:
 3757 0038 00000000 		.word	pd
 3758              		.cfi_endproc
 3759              	.LFE20:
 3761              		.section	.text.pd_vdm_send_state_machine,"ax",%progbits
 3762              		.align	1
 3763              		.syntax unified
 3764              		.code	16
 3765              		.thumb_func
 3766              		.fpu softvfp
 3768              	pd_vdm_send_state_machine:
 3769              	.LVL316:
 3770              	.LFB50:
1630:Src/usb_pd_protocol.c **** 	int res;
 3771              		.loc 1 1630 1 is_stmt 1 view -0
 3772              		.cfi_startproc
 3773              		@ args = 0, pretend = 0, frame = 8
 3774              		@ frame_needed = 0, uses_anonymous_args = 0
1630:Src/usb_pd_protocol.c **** 	int res;
 3775              		.loc 1 1630 1 is_stmt 0 view .LVU1002
 3776 0000 30B5     		push	{r4, r5, lr}
 3777              	.LCFI22:
 3778              		.cfi_def_cfa_offset 12
 3779              		.cfi_offset 4, -12
 3780              		.cfi_offset 5, -8
 3781              		.cfi_offset 14, -4
 3782 0002 83B0     		sub	sp, sp, #12
 3783              	.LCFI23:
 3784              		.cfi_def_cfa_offset 24
 3785 0004 0400     		movs	r4, r0
1631:Src/usb_pd_protocol.c **** 	uint16_t header;
 3786              		.loc 1 1631 2 is_stmt 1 view .LVU1003
1632:Src/usb_pd_protocol.c **** 
 3787              		.loc 1 1632 2 view .LVU1004
1634:Src/usb_pd_protocol.c **** 	case VDM_STATE_READY:
 3788              		.loc 1 1634 2 view .LVU1005
1634:Src/usb_pd_protocol.c **** 	case VDM_STATE_READY:
 3789              		.loc 1 1634 18 is_stmt 0 view .LVU1006
ARM GAS  /tmp/ccoQIC4J.s 			page 120


 3790 0006 C201     		lsls	r2, r0, #7
 3791 0008 4C4B     		ldr	r3, .L236
 3792 000a 9B18     		adds	r3, r3, r2
 3793 000c 4833     		adds	r3, r3, #72
 3794 000e 1B78     		ldrb	r3, [r3]
 3795 0010 5BB2     		sxtb	r3, r3
 3796 0012 022B     		cmp	r3, #2
 3797 0014 00D1     		bne	.LCB3673
 3798 0016 70E0     		b	.L223	@long jump
 3799              	.LCB3673:
 3800 0018 032B     		cmp	r3, #3
 3801 001a 53D0     		beq	.L224
 3802 001c 012B     		cmp	r3, #1
 3803 001e 01D0     		beq	.L235
 3804              	.LVL317:
 3805              	.L222:
1682:Src/usb_pd_protocol.c **** 
 3806              		.loc 1 1682 1 view .LVU1007
 3807 0020 03B0     		add	sp, sp, #12
 3808              		@ sp needed
 3809 0022 30BD     		pop	{r4, r5, pc}
 3810              	.LVL318:
 3811              	.L235:
1637:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_BUSY;
 3812              		.loc 1 1637 3 is_stmt 1 view .LVU1008
1637:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_BUSY;
 3813              		.loc 1 1637 8 is_stmt 0 view .LVU1009
 3814 0024 FFF7FEFF 		bl	pd_is_connected
 3815              	.LVL319:
1637:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_BUSY;
 3816              		.loc 1 1637 6 view .LVU1010
 3817 0028 0028     		cmp	r0, #0
 3818 002a 06D1     		bne	.L226
1638:Src/usb_pd_protocol.c **** 			break;
 3819              		.loc 1 1638 4 is_stmt 1 view .LVU1011
1638:Src/usb_pd_protocol.c **** 			break;
 3820              		.loc 1 1638 23 is_stmt 0 view .LVU1012
 3821 002c E301     		lsls	r3, r4, #7
 3822 002e 434C     		ldr	r4, .L236
 3823              	.LVL320:
1638:Src/usb_pd_protocol.c **** 			break;
 3824              		.loc 1 1638 23 view .LVU1013
 3825 0030 E418     		adds	r4, r4, r3
 3826 0032 4834     		adds	r4, r4, #72
 3827 0034 FD23     		movs	r3, #253
 3828 0036 2370     		strb	r3, [r4]
1639:Src/usb_pd_protocol.c **** 		}
 3829              		.loc 1 1639 4 is_stmt 1 view .LVU1014
 3830 0038 F2E7     		b	.L222
 3831              	.LVL321:
 3832              	.L226:
1646:Src/usb_pd_protocol.c **** 			break;
 3833              		.loc 1 1646 3 view .LVU1015
 3834              	.LBB400:
 3835              	.LBI400:
1589:Src/usb_pd_protocol.c **** {
 3836              		.loc 1 1589 19 view .LVU1016
ARM GAS  /tmp/ccoQIC4J.s 			page 121


 3837              	.LBB401:
1596:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 3838              		.loc 1 1596 2 view .LVU1017
1596:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 3839              		.loc 1 1596 20 is_stmt 0 view .LVU1018
 3840 003a E201     		lsls	r2, r4, #7
 3841 003c 3F4B     		ldr	r3, .L236
 3842 003e 9B18     		adds	r3, r3, r2
 3843 0040 1A79     		ldrb	r2, [r3, #4]
1596:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 3844              		.loc 1 1596 32 view .LVU1019
 3845 0042 1300     		movs	r3, r2
 3846 0044 173B     		subs	r3, r3, #23
 3847 0046 591E     		subs	r1, r3, #1
 3848 0048 8B41     		sbcs	r3, r3, r1
 3849 004a DBB2     		uxtb	r3, r3
 3850              	.LVL322:
1598:Src/usb_pd_protocol.c **** #endif
 3851              		.loc 1 1598 2 is_stmt 1 view .LVU1020
1600:Src/usb_pd_protocol.c **** }
 3852              		.loc 1 1600 2 view .LVU1021
1600:Src/usb_pd_protocol.c **** }
 3853              		.loc 1 1600 2 is_stmt 0 view .LVU1022
 3854              	.LBE401:
 3855              	.LBE400:
1646:Src/usb_pd_protocol.c **** 			break;
 3856              		.loc 1 1646 6 view .LVU1023
 3857 004c 082A     		cmp	r2, #8
 3858 004e 01D0     		beq	.L232
 3859 0050 002B     		cmp	r3, #0
 3860 0052 E5D1     		bne	.L222
 3861              	.L232:
1650:Src/usb_pd_protocol.c **** 				   pd[port].data_role, pd[port].msg_id,
 3862              		.loc 1 1650 3 is_stmt 1 view .LVU1024
1650:Src/usb_pd_protocol.c **** 				   pd[port].data_role, pd[port].msg_id,
 3863              		.loc 1 1650 12 is_stmt 0 view .LVU1025
 3864 0054 394B     		ldr	r3, .L236
 3865 0056 E101     		lsls	r1, r4, #7
 3866 0058 5818     		adds	r0, r3, r1
 3867 005a 4278     		ldrb	r2, [r0, #1]
 3868 005c 5201     		lsls	r2, r2, #5
 3869 005e 4F25     		movs	r5, #79
 3870 0060 2A43     		orrs	r2, r5
 3871 0062 CD5C     		ldrb	r5, [r1, r3]
 3872 0064 2D02     		lsls	r5, r5, #8
 3873 0066 2A43     		orrs	r2, r5
 3874 0068 12B2     		sxth	r2, r2
 3875 006a 8578     		ldrb	r5, [r0, #2]
 3876 006c 6D02     		lsls	r5, r5, #9
 3877 006e 2A43     		orrs	r2, r5
 3878 0070 12B2     		sxth	r2, r2
 3879 0072 7430     		adds	r0, r0, #116
 3880 0074 0078     		ldrb	r0, [r0]
 3881 0076 0003     		lsls	r0, r0, #12
 3882 0078 0243     		orrs	r2, r0
 3883 007a 12B2     		sxth	r2, r2
1650:Src/usb_pd_protocol.c **** 				   pd[port].data_role, pd[port].msg_id,
ARM GAS  /tmp/ccoQIC4J.s 			page 122


 3884              		.loc 1 1650 10 view .LVU1026
 3885 007c 92B2     		uxth	r2, r2
 3886              	.LVL323:
1654:Src/usb_pd_protocol.c **** 				  pd[port].vdo_data);
 3887              		.loc 1 1654 3 is_stmt 1 view .LVU1027
1655:Src/usb_pd_protocol.c **** 		if (res < 0) {
 3888              		.loc 1 1655 15 is_stmt 0 view .LVU1028
 3889 007e 5831     		adds	r1, r1, #88
 3890 0080 CB18     		adds	r3, r1, r3
1654:Src/usb_pd_protocol.c **** 				  pd[port].vdo_data);
 3891              		.loc 1 1654 9 view .LVU1029
 3892 0082 0021     		movs	r1, #0
 3893 0084 2000     		movs	r0, r4
 3894 0086 FFF7FEFF 		bl	pd_transmit
 3895              	.LVL324:
1656:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_SEND;
 3896              		.loc 1 1656 3 is_stmt 1 view .LVU1030
1656:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_SEND;
 3897              		.loc 1 1656 6 is_stmt 0 view .LVU1031
 3898 008a 0028     		cmp	r0, #0
 3899 008c 06DA     		bge	.L228
1657:Src/usb_pd_protocol.c **** 		} else {
 3900              		.loc 1 1657 4 is_stmt 1 view .LVU1032
1657:Src/usb_pd_protocol.c **** 		} else {
 3901              		.loc 1 1657 23 is_stmt 0 view .LVU1033
 3902 008e E401     		lsls	r4, r4, #7
 3903              	.LVL325:
1657:Src/usb_pd_protocol.c **** 		} else {
 3904              		.loc 1 1657 23 view .LVU1034
 3905 0090 2A4B     		ldr	r3, .L236
 3906 0092 1C19     		adds	r4, r3, r4
 3907 0094 4834     		adds	r4, r4, #72
 3908 0096 FE22     		movs	r2, #254
 3909 0098 2270     		strb	r2, [r4]
 3910 009a C1E7     		b	.L222
 3911              	.LVL326:
 3912              	.L228:
1659:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 3913              		.loc 1 1659 4 is_stmt 1 view .LVU1035
1659:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 3914              		.loc 1 1659 23 is_stmt 0 view .LVU1036
 3915 009c E401     		lsls	r4, r4, #7
 3916              	.LVL327:
1659:Src/usb_pd_protocol.c **** 			pd[port].vdm_timeout.val = get_time().val +
 3917              		.loc 1 1659 23 view .LVU1037
 3918 009e 274B     		ldr	r3, .L236
 3919 00a0 1C19     		adds	r4, r3, r4
 3920 00a2 2300     		movs	r3, r4
 3921 00a4 4833     		adds	r3, r3, #72
 3922 00a6 0222     		movs	r2, #2
 3923 00a8 1A70     		strb	r2, [r3]
1660:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
 3924              		.loc 1 1660 4 is_stmt 1 view .LVU1038
1660:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
 3925              		.loc 1 1660 31 is_stmt 0 view .LVU1039
 3926 00aa 6846     		mov	r0, sp
 3927              	.LVL328:
ARM GAS  /tmp/ccoQIC4J.s 			page 123


1660:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
 3928              		.loc 1 1660 31 view .LVU1040
 3929 00ac FFF7FEFF 		bl	get_time
 3930              	.LVL329:
1661:Src/usb_pd_protocol.c **** 		}
 3931              		.loc 1 1661 5 view .LVU1041
 3932 00b0 A06D     		ldr	r0, [r4, #88]
 3933 00b2 FFF7FEFF 		bl	vdm_get_ready_timeout
 3934              	.LVL330:
1660:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
 3935              		.loc 1 1660 46 view .LVU1042
 3936 00b6 009A     		ldr	r2, [sp]
 3937 00b8 019B     		ldr	r3, [sp, #4]
 3938 00ba 1218     		adds	r2, r2, r0
 3939 00bc 4B41     		adcs	r3, r3, r1
1660:Src/usb_pd_protocol.c **** 				vdm_get_ready_timeout(pd[port].vdo_data[0]);
 3940              		.loc 1 1660 29 view .LVU1043
 3941 00be 2265     		str	r2, [r4, #80]
 3942 00c0 6365     		str	r3, [r4, #84]
 3943 00c2 ADE7     		b	.L222
 3944              	.LVL331:
 3945              	.L224:
1666:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
 3946              		.loc 1 1666 3 is_stmt 1 view .LVU1044
1666:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
 3947              		.loc 1 1666 7 is_stmt 0 view .LVU1045
 3948 00c4 6846     		mov	r0, sp
 3949              	.LVL332:
1666:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
 3950              		.loc 1 1666 7 view .LVU1046
 3951 00c6 FFF7FEFF 		bl	get_time
 3952              	.LVL333:
1666:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
 3953              		.loc 1 1666 17 view .LVU1047
 3954 00ca 0098     		ldr	r0, [sp]
 3955 00cc 0199     		ldr	r1, [sp, #4]
1666:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
 3956              		.loc 1 1666 44 view .LVU1048
 3957 00ce E201     		lsls	r2, r4, #7
 3958 00d0 1A4B     		ldr	r3, .L236
 3959 00d2 9B18     		adds	r3, r3, r2
 3960 00d4 1A6D     		ldr	r2, [r3, #80]
 3961 00d6 5B6D     		ldr	r3, [r3, #84]
1666:Src/usb_pd_protocol.c **** 			pd[port].vdo_data[0] = pd[port].vdo_retry;
 3962              		.loc 1 1666 6 view .LVU1049
 3963 00d8 9942     		cmp	r1, r3
 3964 00da 02D8     		bhi	.L233
 3965 00dc A0D1     		bne	.L222
 3966 00de 9042     		cmp	r0, r2
 3967 00e0 9ED9     		bls	.L222
 3968              	.L233:
1667:Src/usb_pd_protocol.c **** 			pd[port].vdo_count = 1;
 3969              		.loc 1 1667 4 is_stmt 1 view .LVU1050
1667:Src/usb_pd_protocol.c **** 			pd[port].vdo_count = 1;
 3970              		.loc 1 1667 35 is_stmt 0 view .LVU1051
 3971 00e2 E401     		lsls	r4, r4, #7
 3972              	.LVL334:
ARM GAS  /tmp/ccoQIC4J.s 			page 124


1667:Src/usb_pd_protocol.c **** 			pd[port].vdo_count = 1;
 3973              		.loc 1 1667 35 view .LVU1052
 3974 00e4 154B     		ldr	r3, .L236
 3975 00e6 1C19     		adds	r4, r3, r4
1667:Src/usb_pd_protocol.c **** 			pd[port].vdo_count = 1;
 3976              		.loc 1 1667 25 view .LVU1053
 3977 00e8 A36F     		ldr	r3, [r4, #120]
 3978 00ea A365     		str	r3, [r4, #88]
1668:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_READY;
 3979              		.loc 1 1668 4 is_stmt 1 view .LVU1054
1668:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_READY;
 3980              		.loc 1 1668 23 is_stmt 0 view .LVU1055
 3981 00ec 2200     		movs	r2, r4
 3982 00ee 7432     		adds	r2, r2, #116
 3983 00f0 0123     		movs	r3, #1
 3984 00f2 1370     		strb	r3, [r2]
1669:Src/usb_pd_protocol.c **** 		}
 3985              		.loc 1 1669 4 is_stmt 1 view .LVU1056
1669:Src/usb_pd_protocol.c **** 		}
 3986              		.loc 1 1669 23 is_stmt 0 view .LVU1057
 3987 00f4 4834     		adds	r4, r4, #72
 3988 00f6 2370     		strb	r3, [r4]
 3989 00f8 92E7     		b	.L222
 3990              	.LVL335:
 3991              	.L223:
1674:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 3992              		.loc 1 1674 3 is_stmt 1 view .LVU1058
1674:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 3993              		.loc 1 1674 27 is_stmt 0 view .LVU1059
 3994 00fa C201     		lsls	r2, r0, #7
 3995 00fc 0F4B     		ldr	r3, .L236
 3996 00fe 9B18     		adds	r3, r3, r2
 3997 0100 1A6D     		ldr	r2, [r3, #80]
 3998 0102 596D     		ldr	r1, [r3, #84]
1674:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 3999              		.loc 1 1674 6 view .LVU1060
 4000 0104 1300     		movs	r3, r2
 4001 0106 0B43     		orrs	r3, r1
 4002 0108 00D1     		bne	.LCB3864
 4003 010a 89E7     		b	.L222	@long jump
 4004              	.LCB3864:
1675:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_TMOUT;
 4005              		.loc 1 1675 8 view .LVU1061
 4006 010c 6846     		mov	r0, sp
 4007              	.LVL336:
1675:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_TMOUT;
 4008              		.loc 1 1675 8 view .LVU1062
 4009 010e FFF7FEFF 		bl	get_time
 4010              	.LVL337:
1675:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_TMOUT;
 4011              		.loc 1 1675 18 view .LVU1063
 4012 0112 0098     		ldr	r0, [sp]
 4013 0114 0199     		ldr	r1, [sp, #4]
1675:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_ERR_TMOUT;
 4014              		.loc 1 1675 45 view .LVU1064
 4015 0116 E201     		lsls	r2, r4, #7
 4016 0118 084B     		ldr	r3, .L236
ARM GAS  /tmp/ccoQIC4J.s 			page 125


 4017 011a 9B18     		adds	r3, r3, r2
 4018 011c 1A6D     		ldr	r2, [r3, #80]
 4019 011e 5B6D     		ldr	r3, [r3, #84]
1674:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 4020              		.loc 1 1674 32 view .LVU1065
 4021 0120 9942     		cmp	r1, r3
 4022 0122 04D8     		bhi	.L234
1674:Src/usb_pd_protocol.c **** 		    (get_time().val > pd[port].vdm_timeout.val)) {
 4023              		.loc 1 1674 32 discriminator 1 view .LVU1066
 4024 0124 00D0     		beq	.LCB3879
 4025 0126 7BE7     		b	.L222	@long jump
 4026              	.LCB3879:
 4027 0128 9042     		cmp	r0, r2
 4028 012a 00D8     		bhi	.LCB3881
 4029 012c 78E7     		b	.L222	@long jump
 4030              	.LCB3881:
 4031              	.L234:
1676:Src/usb_pd_protocol.c **** 		}
 4032              		.loc 1 1676 4 is_stmt 1 view .LVU1067
1676:Src/usb_pd_protocol.c **** 		}
 4033              		.loc 1 1676 23 is_stmt 0 view .LVU1068
 4034 012e E401     		lsls	r4, r4, #7
 4035              	.LVL338:
1676:Src/usb_pd_protocol.c **** 		}
 4036              		.loc 1 1676 23 view .LVU1069
 4037 0130 024B     		ldr	r3, .L236
 4038 0132 1C19     		adds	r4, r3, r4
 4039 0134 4834     		adds	r4, r4, #72
 4040 0136 FF23     		movs	r3, #255
 4041 0138 2370     		strb	r3, [r4]
1682:Src/usb_pd_protocol.c **** 
 4042              		.loc 1 1682 1 view .LVU1070
 4043 013a 71E7     		b	.L222
 4044              	.L237:
 4045              		.align	2
 4046              	.L236:
 4047 013c 00000000 		.word	pd
 4048              		.cfi_endproc
 4049              	.LFE50:
 4051              		.section	.text.handle_request,"ax",%progbits
 4052              		.align	1
 4053              		.syntax unified
 4054              		.code	16
 4055              		.thumb_func
 4056              		.fpu softvfp
 4058              	handle_request:
 4059              	.LVL339:
 4060              	.LFB46:
1536:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
 4061              		.loc 1 1536 1 is_stmt 1 view -0
 4062              		.cfi_startproc
 4063              		@ args = 0, pretend = 0, frame = 0
 4064              		@ frame_needed = 0, uses_anonymous_args = 0
1536:Src/usb_pd_protocol.c **** 	int cnt = PD_HEADER_CNT(head);
 4065              		.loc 1 1536 1 is_stmt 0 view .LVU1072
 4066 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4067              	.LCFI24:
ARM GAS  /tmp/ccoQIC4J.s 			page 126


 4068              		.cfi_def_cfa_offset 24
 4069              		.cfi_offset 3, -24
 4070              		.cfi_offset 4, -20
 4071              		.cfi_offset 5, -16
 4072              		.cfi_offset 6, -12
 4073              		.cfi_offset 7, -8
 4074              		.cfi_offset 14, -4
 4075 0002 0500     		movs	r5, r0
 4076 0004 0E00     		movs	r6, r1
 4077 0006 1700     		movs	r7, r2
1537:Src/usb_pd_protocol.c **** 	int p;
 4078              		.loc 1 1537 2 is_stmt 1 view .LVU1073
1537:Src/usb_pd_protocol.c **** 	int p;
 4079              		.loc 1 1537 12 is_stmt 0 view .LVU1074
 4080 0008 0B0B     		lsrs	r3, r1, #12
 4081 000a 0724     		movs	r4, #7
 4082 000c 1C40     		ands	r4, r3
 4083              	.LVL340:
1538:Src/usb_pd_protocol.c **** 
 4084              		.loc 1 1538 2 is_stmt 1 view .LVU1075
1541:Src/usb_pd_protocol.c **** 	    debug_level >= 3) {
 4085              		.loc 1 1541 2 view .LVU1076
1546:Src/usb_pd_protocol.c **** 	}
 4086              		.loc 1 1546 16 view .LVU1077
1553:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_HARD_RESET_SEND);
 4087              		.loc 1 1553 2 view .LVU1078
1553:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_HARD_RESET_SEND);
 4088              		.loc 1 1553 7 is_stmt 0 view .LVU1079
 4089 000e FFF7FEFF 		bl	pd_is_connected
 4090              	.LVL341:
1553:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_HARD_RESET_SEND);
 4091              		.loc 1 1553 5 view .LVU1080
 4092 0012 0028     		cmp	r0, #0
 4093 0014 07D0     		beq	.L242
 4094              	.L239:
1563:Src/usb_pd_protocol.c **** 		handle_data_request(port, head, payload);
 4095              		.loc 1 1563 2 is_stmt 1 view .LVU1081
1563:Src/usb_pd_protocol.c **** 		handle_data_request(port, head, payload);
 4096              		.loc 1 1563 5 is_stmt 0 view .LVU1082
 4097 0016 002C     		cmp	r4, #0
 4098 0018 11D0     		beq	.L240
1564:Src/usb_pd_protocol.c **** 	else
 4099              		.loc 1 1564 3 is_stmt 1 view .LVU1083
 4100 001a 3A00     		movs	r2, r7
 4101 001c 3100     		movs	r1, r6
 4102 001e 2800     		movs	r0, r5
 4103 0020 FFF7FEFF 		bl	handle_data_request
 4104              	.LVL342:
 4105              	.L238:
1567:Src/usb_pd_protocol.c **** 
 4106              		.loc 1 1567 1 is_stmt 0 view .LVU1084
 4107              		@ sp needed
 4108              	.LVL343:
 4109              	.LVL344:
 4110              	.LVL345:
 4111              	.LVL346:
1567:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 127


 4112              		.loc 1 1567 1 view .LVU1085
 4113 0024 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4114              	.LVL347:
 4115              	.L242:
1554:Src/usb_pd_protocol.c **** 
 4116              		.loc 1 1554 3 is_stmt 1 view .LVU1086
 4117              	.LBB408:
 4118              	.LBI408:
 326:Src/usb_pd_protocol.c **** {
 4119              		.loc 1 326 20 view .LVU1087
 4120              	.LBB409:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4121              		.loc 1 328 2 view .LVU1088
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 4122              		.loc 1 333 2 view .LVU1089
 4123              	.LBB410:
 4124              	.LBI410:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 4125              		.loc 1 261 20 view .LVU1090
 4126              	.LBB411:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4127              		.loc 1 265 2 view .LVU1091
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4128              		.loc 1 265 19 is_stmt 0 view .LVU1092
 4129 0026 EA01     		lsls	r2, r5, #7
 4130 0028 084B     		ldr	r3, .L243
 4131 002a 9B18     		adds	r3, r3, r2
 4132 002c 0020     		movs	r0, #0
 4133 002e 0021     		movs	r1, #0
 4134 0030 1861     		str	r0, [r3, #16]
 4135 0032 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 4136              		.loc 1 266 2 is_stmt 1 view .LVU1093
 266:Src/usb_pd_protocol.c **** }
 4137              		.loc 1 266 25 is_stmt 0 view .LVU1094
 4138 0034 0022     		movs	r2, #0
 4139 0036 DA71     		strb	r2, [r3, #7]
 4140              	.LVL348:
 266:Src/usb_pd_protocol.c **** }
 4141              		.loc 1 266 25 view .LVU1095
 4142              	.LBE411:
 4143              	.LBE410:
 334:Src/usb_pd_protocol.c **** 
 4144              		.loc 1 334 2 is_stmt 1 view .LVU1096
 334:Src/usb_pd_protocol.c **** 
 4145              		.loc 1 334 22 is_stmt 0 view .LVU1097
 4146 0038 1F32     		adds	r2, r2, #31
 4147 003a 1A71     		strb	r2, [r3, #4]
 4148              	.LVL349:
 336:Src/usb_pd_protocol.c **** 		return;
 4149              		.loc 1 336 2 is_stmt 1 view .LVU1098
 4150 003c EBE7     		b	.L239
 4151              	.LVL350:
 4152              	.L240:
 336:Src/usb_pd_protocol.c **** 		return;
 4153              		.loc 1 336 2 is_stmt 0 view .LVU1099
 4154              	.LBE409:
ARM GAS  /tmp/ccoQIC4J.s 			page 128


 4155              	.LBE408:
1566:Src/usb_pd_protocol.c **** }
 4156              		.loc 1 1566 3 is_stmt 1 view .LVU1100
 4157 003e 3A00     		movs	r2, r7
 4158 0040 3100     		movs	r1, r6
 4159 0042 2800     		movs	r0, r5
 4160 0044 FFF7FEFF 		bl	handle_ctrl_request
 4161              	.LVL351:
1567:Src/usb_pd_protocol.c **** 
 4162              		.loc 1 1567 1 is_stmt 0 view .LVU1101
 4163 0048 ECE7     		b	.L238
 4164              	.L244:
 4165 004a C046     		.align	2
 4166              	.L243:
 4167 004c 00000000 		.word	pd
 4168              		.cfi_endproc
 4169              	.LFE46:
 4171              		.section	.text.pd_ts_dts_plugged,"ax",%progbits
 4172              		.align	1
 4173              		.global	pd_ts_dts_plugged
 4174              		.syntax unified
 4175              		.code	16
 4176              		.thumb_func
 4177              		.fpu softvfp
 4179              	pd_ts_dts_plugged:
 4180              	.LVL352:
 4181              	.LFB21:
 306:Src/usb_pd_protocol.c **** 	return pd[port].flags & PD_FLAGS_TS_DTS_PARTNER;
 4182              		.loc 1 306 1 is_stmt 1 view -0
 4183              		.cfi_startproc
 4184              		@ args = 0, pretend = 0, frame = 0
 4185              		@ frame_needed = 0, uses_anonymous_args = 0
 4186              		@ link register save eliminated.
 307:Src/usb_pd_protocol.c **** }
 4187              		.loc 1 307 2 view .LVU1103
 307:Src/usb_pd_protocol.c **** }
 4188              		.loc 1 307 17 is_stmt 0 view .LVU1104
 4189 0000 C301     		lsls	r3, r0, #7
 4190 0002 0348     		ldr	r0, .L246
 4191              	.LVL353:
 307:Src/usb_pd_protocol.c **** }
 4192              		.loc 1 307 17 view .LVU1105
 4193 0004 C018     		adds	r0, r0, r3
 4194 0006 8068     		ldr	r0, [r0, #8]
 307:Src/usb_pd_protocol.c **** }
 4195              		.loc 1 307 24 view .LVU1106
 4196 0008 8023     		movs	r3, #128
 4197 000a 5B02     		lsls	r3, r3, #9
 4198 000c 1840     		ands	r0, r3
 308:Src/usb_pd_protocol.c **** 
 4199              		.loc 1 308 1 view .LVU1107
 4200              		@ sp needed
 4201 000e 7047     		bx	lr
 4202              	.L247:
 4203              		.align	2
 4204              	.L246:
 4205 0010 00000000 		.word	pd
ARM GAS  /tmp/ccoQIC4J.s 			page 129


 4206              		.cfi_endproc
 4207              	.LFE21:
 4209              		.section	.text.pd_vbus_low,"ax",%progbits
 4210              		.align	1
 4211              		.global	pd_vbus_low
 4212              		.syntax unified
 4213              		.code	16
 4214              		.thumb_func
 4215              		.fpu softvfp
 4217              	pd_vbus_low:
 4218              	.LVL354:
 4219              	.LFB22:
 312:Src/usb_pd_protocol.c **** 	pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
 4220              		.loc 1 312 1 is_stmt 1 view -0
 4221              		.cfi_startproc
 4222              		@ args = 0, pretend = 0, frame = 0
 4223              		@ frame_needed = 0, uses_anonymous_args = 0
 4224              		@ link register save eliminated.
 313:Src/usb_pd_protocol.c **** }
 4225              		.loc 1 313 2 view .LVU1109
 313:Src/usb_pd_protocol.c **** }
 4226              		.loc 1 313 17 is_stmt 0 view .LVU1110
 4227 0000 C301     		lsls	r3, r0, #7
 4228 0002 0348     		ldr	r0, .L249
 4229              	.LVL355:
 313:Src/usb_pd_protocol.c **** }
 4230              		.loc 1 313 17 view .LVU1111
 4231 0004 C018     		adds	r0, r0, r3
 4232 0006 8023     		movs	r3, #128
 4233 0008 8268     		ldr	r2, [r0, #8]
 4234 000a 9A43     		bics	r2, r3
 4235 000c 8260     		str	r2, [r0, #8]
 314:Src/usb_pd_protocol.c **** 
 4236              		.loc 1 314 1 view .LVU1112
 4237              		@ sp needed
 4238 000e 7047     		bx	lr
 4239              	.L250:
 4240              		.align	2
 4241              	.L249:
 4242 0010 00000000 		.word	pd
 4243              		.cfi_endproc
 4244              	.LFE22:
 4246              		.section	.text.pd_transmit_complete,"ax",%progbits
 4247              		.align	1
 4248              		.global	pd_transmit_complete
 4249              		.syntax unified
 4250              		.code	16
 4251              		.thumb_func
 4252              		.fpu softvfp
 4254              	pd_transmit_complete:
 4255              	.LVL356:
 4256              	.LFB26:
 447:Src/usb_pd_protocol.c **** 	if (status == TCPC_TX_COMPLETE_SUCCESS)
 4257              		.loc 1 447 1 is_stmt 1 view -0
 4258              		.cfi_startproc
 4259              		@ args = 0, pretend = 0, frame = 0
 4260              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/ccoQIC4J.s 			page 130


 447:Src/usb_pd_protocol.c **** 	if (status == TCPC_TX_COMPLETE_SUCCESS)
 4261              		.loc 1 447 1 is_stmt 0 view .LVU1114
 4262 0000 70B5     		push	{r4, r5, r6, lr}
 4263              	.LCFI25:
 4264              		.cfi_def_cfa_offset 16
 4265              		.cfi_offset 4, -16
 4266              		.cfi_offset 5, -12
 4267              		.cfi_offset 6, -8
 4268              		.cfi_offset 14, -4
 4269 0002 0400     		movs	r4, r0
 4270 0004 0D1E     		subs	r5, r1, #0
 448:Src/usb_pd_protocol.c **** 		inc_id(port);
 4271              		.loc 1 448 2 is_stmt 1 view .LVU1115
 448:Src/usb_pd_protocol.c **** 		inc_id(port);
 4272              		.loc 1 448 5 is_stmt 0 view .LVU1116
 4273 0006 09D0     		beq	.L253
 4274              	.LVL357:
 4275              	.L252:
 451:Src/usb_pd_protocol.c **** 	//task_set_event(PD_PORT_TO_TASK_ID(port), PD_EVENT_TX, 0);
 4276              		.loc 1 451 2 is_stmt 1 view .LVU1117
 451:Src/usb_pd_protocol.c **** 	//task_set_event(PD_PORT_TO_TASK_ID(port), PD_EVENT_TX, 0);
 4277              		.loc 1 451 21 is_stmt 0 view .LVU1118
 4278 0008 E401     		lsls	r4, r4, #7
 4279              	.LVL358:
 451:Src/usb_pd_protocol.c **** 	//task_set_event(PD_PORT_TO_TASK_ID(port), PD_EVENT_TX, 0);
 4280              		.loc 1 451 21 view .LVU1119
 4281 000a 0648     		ldr	r0, .L254
 4282 000c 0019     		adds	r0, r0, r4
 4283 000e 2930     		adds	r0, r0, #41
 4284 0010 0570     		strb	r5, [r0]
 453:Src/usb_pd_protocol.c **** }
 4285              		.loc 1 453 2 is_stmt 1 view .LVU1120
 4286 0012 0021     		movs	r1, #0
 4287 0014 0820     		movs	r0, #8
 4288 0016 FFF7FEFF 		bl	pd_task_set_event
 4289              	.LVL359:
 454:Src/usb_pd_protocol.c **** 
 4290              		.loc 1 454 1 is_stmt 0 view .LVU1121
 4291              		@ sp needed
 4292              	.LVL360:
 454:Src/usb_pd_protocol.c **** 
 4293              		.loc 1 454 1 view .LVU1122
 4294 001a 70BD     		pop	{r4, r5, r6, pc}
 4295              	.LVL361:
 4296              	.L253:
 449:Src/usb_pd_protocol.c **** 
 4297              		.loc 1 449 3 is_stmt 1 view .LVU1123
 4298 001c FFF7FEFF 		bl	inc_id
 4299              	.LVL362:
 449:Src/usb_pd_protocol.c **** 
 4300              		.loc 1 449 3 is_stmt 0 view .LVU1124
 4301 0020 F2E7     		b	.L252
 4302              	.L255:
 4303 0022 C046     		.align	2
 4304              	.L254:
 4305 0024 00000000 		.word	pd
 4306              		.cfi_endproc
ARM GAS  /tmp/ccoQIC4J.s 			page 131


 4307              	.LFE26:
 4309              		.section	.text.pd_execute_hard_reset,"ax",%progbits
 4310              		.align	1
 4311              		.global	pd_execute_hard_reset
 4312              		.syntax unified
 4313              		.code	16
 4314              		.thumb_func
 4315              		.fpu softvfp
 4317              	pd_execute_hard_reset:
 4318              	.LVL363:
 4319              	.LFB35:
 880:Src/usb_pd_protocol.c **** 	if (pd[port].last_state == PD_STATE_HARD_RESET_SEND)
 4320              		.loc 1 880 1 is_stmt 1 view -0
 4321              		.cfi_startproc
 4322              		@ args = 0, pretend = 0, frame = 8
 4323              		@ frame_needed = 0, uses_anonymous_args = 0
 880:Src/usb_pd_protocol.c **** 	if (pd[port].last_state == PD_STATE_HARD_RESET_SEND)
 4324              		.loc 1 880 1 is_stmt 0 view .LVU1126
 4325 0000 10B5     		push	{r4, lr}
 4326              	.LCFI26:
 4327              		.cfi_def_cfa_offset 8
 4328              		.cfi_offset 4, -8
 4329              		.cfi_offset 14, -4
 4330 0002 82B0     		sub	sp, sp, #8
 4331              	.LCFI27:
 4332              		.cfi_def_cfa_offset 16
 4333 0004 0400     		movs	r4, r0
 881:Src/usb_pd_protocol.c **** 		CPRINTF("C%d HARD RST TX\n", port);
 4334              		.loc 1 881 2 is_stmt 1 view .LVU1127
 886:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 4335              		.loc 1 886 2 view .LVU1128
 886:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
 4336              		.loc 1 886 18 is_stmt 0 view .LVU1129
 4337 0006 C201     		lsls	r2, r0, #7
 4338 0008 234B     		ldr	r3, .L262
 4339 000a 9B18     		adds	r3, r3, r2
 4340 000c 0022     		movs	r2, #0
 4341 000e 9A70     		strb	r2, [r3, #2]
 899:Src/usb_pd_protocol.c **** 
 4342              		.loc 1 899 2 is_stmt 1 view .LVU1130
 899:Src/usb_pd_protocol.c **** 
 4343              		.loc 1 899 22 is_stmt 0 view .LVU1131
 4344 0010 2032     		adds	r2, r2, #32
 4345 0012 5A71     		strb	r2, [r3, #5]
 906:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE) {
 4346              		.loc 1 906 2 is_stmt 1 view .LVU1132
 906:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE) {
 4347              		.loc 1 906 14 is_stmt 0 view .LVU1133
 4348 0014 1B79     		ldrb	r3, [r3, #4]
 906:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE) {
 4349              		.loc 1 906 55 view .LVU1134
 4350 0016 0C3B     		subs	r3, r3, #12
 4351 0018 DBB2     		uxtb	r3, r3
 906:Src/usb_pd_protocol.c **** 	    pd[port].task_state == PD_STATE_SNK_SWAP_COMPLETE) {
 4352              		.loc 1 906 5 view .LVU1135
 4353 001a 012B     		cmp	r3, #1
 4354 001c 1FD9     		bls	.L260
ARM GAS  /tmp/ccoQIC4J.s 			page 132


 4355              	.LVL364:
 4356              	.L257:
 912:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 4357              		.loc 1 912 2 is_stmt 1 view .LVU1136
 912:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 4358              		.loc 1 912 14 is_stmt 0 view .LVU1137
 4359 001e E301     		lsls	r3, r4, #7
 4360 0020 1D4A     		ldr	r2, .L262
 4361 0022 9B5C     		ldrb	r3, [r3, r2]
 912:Src/usb_pd_protocol.c **** 		/* Clear the input current limit */
 4362              		.loc 1 912 5 view .LVU1138
 4363 0024 002B     		cmp	r3, #0
 4364 0026 25D0     		beq	.L261
 927:Src/usb_pd_protocol.c **** 	pd[port].src_recover = get_time().val + PD_T_SRC_RECOVER;
 4365              		.loc 1 927 2 is_stmt 1 view .LVU1139
 4366 0028 2000     		movs	r0, r4
 4367 002a FFF7FEFF 		bl	pd_power_supply_reset
 4368              	.LVL365:
 928:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 4369              		.loc 1 928 2 view .LVU1140
 928:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 4370              		.loc 1 928 25 is_stmt 0 view .LVU1141
 4371 002e 6846     		mov	r0, sp
 4372 0030 FFF7FEFF 		bl	get_time
 4373              	.LVL366:
 928:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 4374              		.loc 1 928 40 view .LVU1142
 4375 0034 194A     		ldr	r2, .L262+4
 4376 0036 0023     		movs	r3, #0
 4377 0038 0098     		ldr	r0, [sp]
 4378 003a 0199     		ldr	r1, [sp, #4]
 4379 003c 1218     		adds	r2, r2, r0
 4380 003e 4B41     		adcs	r3, r3, r1
 928:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 4381              		.loc 1 928 23 view .LVU1143
 4382 0040 E401     		lsls	r4, r4, #7
 4383              	.LVL367:
 928:Src/usb_pd_protocol.c **** 	set_state(port, PD_STATE_SRC_HARD_RESET_RECOVER);
 4384              		.loc 1 928 23 view .LVU1144
 4385 0042 1549     		ldr	r1, .L262
 4386 0044 0C19     		adds	r4, r1, r4
 4387 0046 A261     		str	r2, [r4, #24]
 4388 0048 E361     		str	r3, [r4, #28]
 929:Src/usb_pd_protocol.c **** }
 4389              		.loc 1 929 2 is_stmt 1 view .LVU1145
 4390              	.LVL368:
 4391              	.LBB426:
 4392              	.LBI426:
 326:Src/usb_pd_protocol.c **** {
 4393              		.loc 1 326 20 view .LVU1146
 4394              	.LBB427:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4395              		.loc 1 328 2 view .LVU1147
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 4396              		.loc 1 333 2 view .LVU1148
 4397              	.LBB428:
 4398              	.LBI428:
ARM GAS  /tmp/ccoQIC4J.s 			page 133


 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 4399              		.loc 1 261 20 view .LVU1149
 4400              	.LBB429:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4401              		.loc 1 265 2 view .LVU1150
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4402              		.loc 1 265 19 is_stmt 0 view .LVU1151
 4403 004a 0022     		movs	r2, #0
 4404 004c 0023     		movs	r3, #0
 4405 004e 2261     		str	r2, [r4, #16]
 4406 0050 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 4407              		.loc 1 266 2 is_stmt 1 view .LVU1152
 266:Src/usb_pd_protocol.c **** }
 4408              		.loc 1 266 25 is_stmt 0 view .LVU1153
 4409 0052 0023     		movs	r3, #0
 4410 0054 E371     		strb	r3, [r4, #7]
 4411              	.LVL369:
 266:Src/usb_pd_protocol.c **** }
 4412              		.loc 1 266 25 view .LVU1154
 4413              	.LBE429:
 4414              	.LBE428:
 334:Src/usb_pd_protocol.c **** 
 4415              		.loc 1 334 2 is_stmt 1 view .LVU1155
 334:Src/usb_pd_protocol.c **** 
 4416              		.loc 1 334 22 is_stmt 0 view .LVU1156
 4417 0056 1033     		adds	r3, r3, #16
 4418 0058 2371     		strb	r3, [r4, #4]
 4419              	.LVL370:
 336:Src/usb_pd_protocol.c **** 		return;
 4420              		.loc 1 336 2 is_stmt 1 view .LVU1157
 4421              	.L256:
 336:Src/usb_pd_protocol.c **** 		return;
 4422              		.loc 1 336 2 is_stmt 0 view .LVU1158
 4423              	.LBE427:
 4424              	.LBE426:
 930:Src/usb_pd_protocol.c **** 
 4425              		.loc 1 930 1 view .LVU1159
 4426 005a 02B0     		add	sp, sp, #8
 4427              		@ sp needed
 4428 005c 10BD     		pop	{r4, pc}
 4429              	.LVL371:
 4430              	.L260:
 908:Src/usb_pd_protocol.c **** 		pd_power_supply_reset(port);
 4431              		.loc 1 908 3 is_stmt 1 view .LVU1160
 4432              	.LBB430:
 4433              	.LBI430:
  73:Inc/tcpm.h    **** {
 4434              		.loc 2 73 19 view .LVU1161
 4435              	.LBB431:
  75:Inc/tcpm.h    **** }
 4436              		.loc 2 75 2 view .LVU1162
  75:Inc/tcpm.h    **** }
 4437              		.loc 2 75 26 is_stmt 0 view .LVU1163
 4438 005e 0201     		lsls	r2, r0, #4
 4439 0060 0F4B     		ldr	r3, .L262+8
 4440 0062 9B18     		adds	r3, r3, r2
ARM GAS  /tmp/ccoQIC4J.s 			page 134


 4441 0064 9B68     		ldr	r3, [r3, #8]
  75:Inc/tcpm.h    **** }
 4442              		.loc 2 75 30 view .LVU1164
 4443 0066 5B69     		ldr	r3, [r3, #20]
  75:Inc/tcpm.h    **** }
 4444              		.loc 2 75 9 view .LVU1165
 4445 0068 0221     		movs	r1, #2
 4446 006a 9847     		blx	r3
 4447              	.LVL372:
  75:Inc/tcpm.h    **** }
 4448              		.loc 2 75 9 view .LVU1166
 4449              	.LBE431:
 4450              	.LBE430:
 909:Src/usb_pd_protocol.c **** 	}
 4451              		.loc 1 909 3 is_stmt 1 view .LVU1167
 4452 006c 2000     		movs	r0, r4
 4453 006e FFF7FEFF 		bl	pd_power_supply_reset
 4454              	.LVL373:
 4455 0072 D4E7     		b	.L257
 4456              	.L261:
 914:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 4457              		.loc 1 914 3 view .LVU1168
 4458 0074 0022     		movs	r2, #0
 4459 0076 0021     		movs	r1, #0
 4460 0078 2000     		movs	r0, r4
 4461 007a FFF7FEFF 		bl	pd_set_input_current_limit
 4462              	.LVL374:
 921:Src/usb_pd_protocol.c **** 		return;
 4463              		.loc 1 921 3 view .LVU1169
 4464              	.LBB432:
 4465              	.LBI432:
 326:Src/usb_pd_protocol.c **** {
 4466              		.loc 1 326 20 view .LVU1170
 4467              	.LBB433:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4468              		.loc 1 328 2 view .LVU1171
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 4469              		.loc 1 333 2 view .LVU1172
 4470              	.LBB434:
 4471              	.LBI434:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 4472              		.loc 1 261 20 view .LVU1173
 4473              	.LBB435:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4474              		.loc 1 265 2 view .LVU1174
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4475              		.loc 1 265 19 is_stmt 0 view .LVU1175
 4476 007e E401     		lsls	r4, r4, #7
 4477              	.LVL375:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4478              		.loc 1 265 19 view .LVU1176
 4479 0080 054B     		ldr	r3, .L262
 4480 0082 1C19     		adds	r4, r3, r4
 4481 0084 0022     		movs	r2, #0
 4482 0086 0023     		movs	r3, #0
 4483 0088 2261     		str	r2, [r4, #16]
 4484 008a 6361     		str	r3, [r4, #20]
ARM GAS  /tmp/ccoQIC4J.s 			page 135


 266:Src/usb_pd_protocol.c **** }
 4485              		.loc 1 266 2 is_stmt 1 view .LVU1177
 266:Src/usb_pd_protocol.c **** }
 4486              		.loc 1 266 25 is_stmt 0 view .LVU1178
 4487 008c 0023     		movs	r3, #0
 4488 008e E371     		strb	r3, [r4, #7]
 4489              	.LVL376:
 266:Src/usb_pd_protocol.c **** }
 4490              		.loc 1 266 25 view .LVU1179
 4491              	.LBE435:
 4492              	.LBE434:
 334:Src/usb_pd_protocol.c **** 
 4493              		.loc 1 334 2 is_stmt 1 view .LVU1180
 334:Src/usb_pd_protocol.c **** 
 4494              		.loc 1 334 22 is_stmt 0 view .LVU1181
 4495 0090 0433     		adds	r3, r3, #4
 4496 0092 2371     		strb	r3, [r4, #4]
 4497              	.LVL377:
 336:Src/usb_pd_protocol.c **** 		return;
 4498              		.loc 1 336 2 is_stmt 1 view .LVU1182
 4499 0094 E1E7     		b	.L256
 4500              	.L263:
 4501 0096 C046     		.align	2
 4502              	.L262:
 4503 0098 00000000 		.word	pd
 4504 009c C0980B00 		.word	760000
 4505 00a0 00000000 		.word	tcpc_config
 4506              	.LBE433:
 4507              	.LBE432:
 4508              		.cfi_endproc
 4509              	.LFE35:
 4511              		.section	.text.pd_soft_reset,"ax",%progbits
 4512              		.align	1
 4513              		.global	pd_soft_reset
 4514              		.syntax unified
 4515              		.code	16
 4516              		.thumb_func
 4517              		.fpu softvfp
 4519              	pd_soft_reset:
 4520              	.LFB37:
 941:Src/usb_pd_protocol.c **** 	int i;
 4521              		.loc 1 941 1 view -0
 4522              		.cfi_startproc
 4523              		@ args = 0, pretend = 0, frame = 0
 4524              		@ frame_needed = 0, uses_anonymous_args = 0
 4525 0000 10B5     		push	{r4, lr}
 4526              	.LCFI28:
 4527              		.cfi_def_cfa_offset 8
 4528              		.cfi_offset 4, -8
 4529              		.cfi_offset 14, -4
 942:Src/usb_pd_protocol.c **** 
 4530              		.loc 1 942 2 view .LVU1184
 944:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 4531              		.loc 1 944 2 view .LVU1185
 4532              	.LVL378:
 944:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 4533              		.loc 1 944 9 is_stmt 0 view .LVU1186
ARM GAS  /tmp/ccoQIC4J.s 			page 136


 4534 0002 0024     		movs	r4, #0
 4535              	.LVL379:
 4536              	.L265:
 944:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 4537              		.loc 1 944 2 discriminator 1 view .LVU1187
 4538 0004 002C     		cmp	r4, #0
 4539 0006 00DD     		ble	.L267
 950:Src/usb_pd_protocol.c **** 
 4540              		.loc 1 950 1 view .LVU1188
 4541              		@ sp needed
 4542              	.LVL380:
 950:Src/usb_pd_protocol.c **** 
 4543              		.loc 1 950 1 view .LVU1189
 4544 0008 10BD     		pop	{r4, pc}
 4545              	.LVL381:
 4546              	.L267:
 945:Src/usb_pd_protocol.c **** 			set_state(i, PD_STATE_SOFT_RESET);
 4547              		.loc 1 945 3 is_stmt 1 view .LVU1190
 945:Src/usb_pd_protocol.c **** 			set_state(i, PD_STATE_SOFT_RESET);
 4548              		.loc 1 945 7 is_stmt 0 view .LVU1191
 4549 000a 2000     		movs	r0, r4
 4550 000c FFF7FEFF 		bl	pd_is_connected
 4551              	.LVL382:
 945:Src/usb_pd_protocol.c **** 			set_state(i, PD_STATE_SOFT_RESET);
 4552              		.loc 1 945 6 view .LVU1192
 4553 0010 0028     		cmp	r0, #0
 4554 0012 01D1     		bne	.L268
 4555              	.L266:
 944:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 4556              		.loc 1 944 44 discriminator 2 view .LVU1193
 4557 0014 0134     		adds	r4, r4, #1
 4558              	.LVL383:
 944:Src/usb_pd_protocol.c **** 		if (pd_is_connected(i)) {
 4559              		.loc 1 944 44 discriminator 2 view .LVU1194
 4560 0016 F5E7     		b	.L265
 4561              	.L268:
 946:Src/usb_pd_protocol.c **** 			// getting rid of task stuff
 4562              		.loc 1 946 4 is_stmt 1 view .LVU1195
 4563              	.LVL384:
 4564              	.LBB442:
 4565              	.LBI442:
 326:Src/usb_pd_protocol.c **** {
 4566              		.loc 1 326 20 view .LVU1196
 4567              	.LBB443:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4568              		.loc 1 328 2 view .LVU1197
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 4569              		.loc 1 333 2 view .LVU1198
 4570              	.LBB444:
 4571              	.LBI444:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 4572              		.loc 1 261 20 view .LVU1199
 4573              	.LBB445:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4574              		.loc 1 265 2 view .LVU1200
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4575              		.loc 1 265 19 is_stmt 0 view .LVU1201
ARM GAS  /tmp/ccoQIC4J.s 			page 137


 4576 0018 E201     		lsls	r2, r4, #7
 4577 001a 054B     		ldr	r3, .L269
 4578 001c 9B18     		adds	r3, r3, r2
 4579 001e 0020     		movs	r0, #0
 4580 0020 0021     		movs	r1, #0
 4581 0022 1861     		str	r0, [r3, #16]
 4582 0024 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 4583              		.loc 1 266 2 is_stmt 1 view .LVU1202
 266:Src/usb_pd_protocol.c **** }
 4584              		.loc 1 266 25 is_stmt 0 view .LVU1203
 4585 0026 0022     		movs	r2, #0
 4586 0028 DA71     		strb	r2, [r3, #7]
 4587              	.LVL385:
 266:Src/usb_pd_protocol.c **** }
 4588              		.loc 1 266 25 view .LVU1204
 4589              	.LBE445:
 4590              	.LBE444:
 334:Src/usb_pd_protocol.c **** 
 4591              		.loc 1 334 2 is_stmt 1 view .LVU1205
 334:Src/usb_pd_protocol.c **** 
 4592              		.loc 1 334 22 is_stmt 0 view .LVU1206
 4593 002a 1E32     		adds	r2, r2, #30
 4594 002c 1A71     		strb	r2, [r3, #4]
 4595              	.LVL386:
 336:Src/usb_pd_protocol.c **** 		return;
 4596              		.loc 1 336 2 is_stmt 1 view .LVU1207
 4597 002e F1E7     		b	.L266
 4598              	.L270:
 4599              		.align	2
 4600              	.L269:
 4601 0030 00000000 		.word	pd
 4602              	.LBE443:
 4603              	.LBE442:
 4604              		.cfi_endproc
 4605              	.LFE37:
 4607              		.section	.text.pd_request_power_swap,"ax",%progbits
 4608              		.align	1
 4609              		.global	pd_request_power_swap
 4610              		.syntax unified
 4611              		.code	16
 4612              		.thumb_func
 4613              		.fpu softvfp
 4615              	pd_request_power_swap:
 4616              	.LVL387:
 4617              	.LFB41:
1198:Src/usb_pd_protocol.c **** 	if (pd[port].task_state == PD_STATE_SRC_READY)
 4618              		.loc 1 1198 1 view -0
 4619              		.cfi_startproc
 4620              		@ args = 0, pretend = 0, frame = 0
 4621              		@ frame_needed = 0, uses_anonymous_args = 0
 4622              		@ link register save eliminated.
1199:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_SWAP_INIT);
 4623              		.loc 1 1199 2 view .LVU1209
1199:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_SWAP_INIT);
 4624              		.loc 1 1199 14 is_stmt 0 view .LVU1210
 4625 0000 C201     		lsls	r2, r0, #7
ARM GAS  /tmp/ccoQIC4J.s 			page 138


 4626 0002 0F4B     		ldr	r3, .L276
 4627 0004 9B18     		adds	r3, r3, r2
 4628 0006 1B79     		ldrb	r3, [r3, #4]
1199:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_SWAP_INIT);
 4629              		.loc 1 1199 5 view .LVU1211
 4630 0008 172B     		cmp	r3, #23
 4631 000a 02D0     		beq	.L274
1201:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_SWAP_INIT);
 4632              		.loc 1 1201 7 is_stmt 1 view .LVU1212
1201:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_SWAP_INIT);
 4633              		.loc 1 1201 10 is_stmt 0 view .LVU1213
 4634 000c 082B     		cmp	r3, #8
 4635 000e 0BD0     		beq	.L275
 4636              	.LVL388:
 4637              	.L271:
1205:Src/usb_pd_protocol.c **** 
 4638              		.loc 1 1205 1 view .LVU1214
 4639              		@ sp needed
 4640 0010 7047     		bx	lr
 4641              	.LVL389:
 4642              	.L274:
1200:Src/usb_pd_protocol.c **** 	else if (pd[port].task_state == PD_STATE_SNK_READY)
 4643              		.loc 1 1200 3 is_stmt 1 view .LVU1215
 4644              	.LBB458:
 4645              	.LBI458:
 326:Src/usb_pd_protocol.c **** {
 4646              		.loc 1 326 20 view .LVU1216
 4647              	.LBB459:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4648              		.loc 1 328 2 view .LVU1217
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 4649              		.loc 1 333 2 view .LVU1218
 4650              	.LBB460:
 4651              	.LBI460:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 4652              		.loc 1 261 20 view .LVU1219
 4653              	.LBB461:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4654              		.loc 1 265 2 view .LVU1220
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4655              		.loc 1 265 19 is_stmt 0 view .LVU1221
 4656 0012 0B4B     		ldr	r3, .L276
 4657 0014 9818     		adds	r0, r3, r2
 4658              	.LVL390:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4659              		.loc 1 265 19 view .LVU1222
 4660 0016 0022     		movs	r2, #0
 4661 0018 0023     		movs	r3, #0
 4662 001a 0261     		str	r2, [r0, #16]
 4663 001c 4361     		str	r3, [r0, #20]
 266:Src/usb_pd_protocol.c **** }
 4664              		.loc 1 266 2 is_stmt 1 view .LVU1223
 266:Src/usb_pd_protocol.c **** }
 4665              		.loc 1 266 25 is_stmt 0 view .LVU1224
 4666 001e 0023     		movs	r3, #0
 4667 0020 C371     		strb	r3, [r0, #7]
 4668              	.LVL391:
ARM GAS  /tmp/ccoQIC4J.s 			page 139


 266:Src/usb_pd_protocol.c **** }
 4669              		.loc 1 266 25 view .LVU1225
 4670              	.LBE461:
 4671              	.LBE460:
 334:Src/usb_pd_protocol.c **** 
 4672              		.loc 1 334 2 is_stmt 1 view .LVU1226
 334:Src/usb_pd_protocol.c **** 
 4673              		.loc 1 334 22 is_stmt 0 view .LVU1227
 4674 0022 1A33     		adds	r3, r3, #26
 4675 0024 0371     		strb	r3, [r0, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 4676              		.loc 1 336 2 is_stmt 1 view .LVU1228
 4677 0026 F3E7     		b	.L271
 4678              	.LVL392:
 4679              	.L275:
 336:Src/usb_pd_protocol.c **** 		return;
 4680              		.loc 1 336 2 is_stmt 0 view .LVU1229
 4681              	.LBE459:
 4682              	.LBE458:
1202:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
 4683              		.loc 1 1202 3 is_stmt 1 view .LVU1230
 4684              	.LBB462:
 4685              	.LBI462:
 326:Src/usb_pd_protocol.c **** {
 4686              		.loc 1 326 20 view .LVU1231
 4687              	.LBB463:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4688              		.loc 1 328 2 view .LVU1232
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 4689              		.loc 1 333 2 view .LVU1233
 4690              	.LBB464:
 4691              	.LBI464:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 4692              		.loc 1 261 20 view .LVU1234
 4693              	.LBB465:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4694              		.loc 1 265 2 view .LVU1235
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4695              		.loc 1 265 19 is_stmt 0 view .LVU1236
 4696 0028 C001     		lsls	r0, r0, #7
 4697              	.LVL393:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4698              		.loc 1 265 19 view .LVU1237
 4699 002a 054B     		ldr	r3, .L276
 4700 002c 1818     		adds	r0, r3, r0
 4701 002e 0022     		movs	r2, #0
 4702 0030 0023     		movs	r3, #0
 4703 0032 0261     		str	r2, [r0, #16]
 4704 0034 4361     		str	r3, [r0, #20]
 266:Src/usb_pd_protocol.c **** }
 4705              		.loc 1 266 2 is_stmt 1 view .LVU1238
 266:Src/usb_pd_protocol.c **** }
 4706              		.loc 1 266 25 is_stmt 0 view .LVU1239
 4707 0036 0023     		movs	r3, #0
 4708 0038 C371     		strb	r3, [r0, #7]
 4709              	.LVL394:
 266:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 140


 4710              		.loc 1 266 25 view .LVU1240
 4711              	.LBE465:
 4712              	.LBE464:
 334:Src/usb_pd_protocol.c **** 
 4713              		.loc 1 334 2 is_stmt 1 view .LVU1241
 334:Src/usb_pd_protocol.c **** 
 4714              		.loc 1 334 22 is_stmt 0 view .LVU1242
 4715 003a 0933     		adds	r3, r3, #9
 4716 003c 0371     		strb	r3, [r0, #4]
 4717              	.LVL395:
 336:Src/usb_pd_protocol.c **** 		return;
 4718              		.loc 1 336 2 is_stmt 1 view .LVU1243
 4719              	.LBE463:
 4720              	.LBE462:
1205:Src/usb_pd_protocol.c **** 
 4721              		.loc 1 1205 1 is_stmt 0 view .LVU1244
 4722 003e E7E7     		b	.L271
 4723              	.L277:
 4724              		.align	2
 4725              	.L276:
 4726 0040 00000000 		.word	pd
 4727              		.cfi_endproc
 4728              	.LFE41:
 4730              		.section	.text.pd_request_data_swap,"ax",%progbits
 4731              		.align	1
 4732              		.global	pd_request_data_swap
 4733              		.syntax unified
 4734              		.code	16
 4735              		.thumb_func
 4736              		.fpu softvfp
 4738              	pd_request_data_swap:
 4739              	.LVL396:
 4740              	.LFB42:
1232:Src/usb_pd_protocol.c **** 	if (DUAL_ROLE_IF_ELSE(port,
 4741              		.loc 1 1232 1 is_stmt 1 view -0
 4742              		.cfi_startproc
 4743              		@ args = 0, pretend = 0, frame = 0
 4744              		@ frame_needed = 0, uses_anonymous_args = 0
 4745              		@ link register save eliminated.
1233:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 4746              		.loc 1 1233 2 view .LVU1246
1233:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 4747              		.loc 1 1233 6 is_stmt 0 view .LVU1247
 4748 0000 C201     		lsls	r2, r0, #7
 4749 0002 114B     		ldr	r3, .L283
 4750 0004 D35C     		ldrb	r3, [r2, r3]
 4751 0006 002B     		cmp	r3, #0
 4752 0008 09D1     		bne	.L279
1233:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 4753              		.loc 1 1233 6 discriminator 1 view .LVU1248
 4754 000a 0F4B     		ldr	r3, .L283
 4755 000c 9B18     		adds	r3, r3, r2
 4756 000e 1B79     		ldrb	r3, [r3, #4]
 4757 0010 083B     		subs	r3, r3, #8
 4758 0012 5A42     		rsbs	r2, r3, #0
 4759 0014 5341     		adcs	r3, r3, r2
 4760 0016 DBB2     		uxtb	r3, r3
ARM GAS  /tmp/ccoQIC4J.s 			page 141


 4761              	.L280:
1233:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 4762              		.loc 1 1233 5 discriminator 4 view .LVU1249
 4763 0018 002B     		cmp	r3, #0
 4764 001a 09D1     		bne	.L282
 4765              	.LVL397:
 4766              	.L278:
1239:Src/usb_pd_protocol.c **** 
 4767              		.loc 1 1239 1 view .LVU1250
 4768              		@ sp needed
 4769 001c 7047     		bx	lr
 4770              	.LVL398:
 4771              	.L279:
1233:Src/usb_pd_protocol.c **** 				pd[port].task_state == PD_STATE_SNK_READY,
 4772              		.loc 1 1233 6 discriminator 2 view .LVU1251
 4773 001e C201     		lsls	r2, r0, #7
 4774 0020 094B     		ldr	r3, .L283
 4775 0022 9B18     		adds	r3, r3, r2
 4776 0024 1B79     		ldrb	r3, [r3, #4]
 4777 0026 173B     		subs	r3, r3, #23
 4778 0028 5A42     		rsbs	r2, r3, #0
 4779 002a 5341     		adcs	r3, r3, r2
 4780 002c DBB2     		uxtb	r3, r3
 4781 002e F3E7     		b	.L280
 4782              	.L282:
1236:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
 4783              		.loc 1 1236 3 is_stmt 1 view .LVU1252
 4784              	.LVL399:
 4785              	.LBB472:
 4786              	.LBI472:
 326:Src/usb_pd_protocol.c **** {
 4787              		.loc 1 326 20 view .LVU1253
 4788              	.LBB473:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 4789              		.loc 1 328 2 view .LVU1254
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 4790              		.loc 1 333 2 view .LVU1255
 4791              	.LBB474:
 4792              	.LBI474:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 4793              		.loc 1 261 20 view .LVU1256
 4794              	.LBB475:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4795              		.loc 1 265 2 view .LVU1257
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4796              		.loc 1 265 19 is_stmt 0 view .LVU1258
 4797 0030 C001     		lsls	r0, r0, #7
 4798              	.LVL400:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 4799              		.loc 1 265 19 view .LVU1259
 4800 0032 054B     		ldr	r3, .L283
 4801 0034 1818     		adds	r0, r3, r0
 4802 0036 0022     		movs	r2, #0
 4803 0038 0023     		movs	r3, #0
 4804 003a 0261     		str	r2, [r0, #16]
 4805 003c 4361     		str	r3, [r0, #20]
 266:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 142


 4806              		.loc 1 266 2 is_stmt 1 view .LVU1260
 266:Src/usb_pd_protocol.c **** }
 4807              		.loc 1 266 25 is_stmt 0 view .LVU1261
 4808 003e 0023     		movs	r3, #0
 4809 0040 C371     		strb	r3, [r0, #7]
 4810              	.LVL401:
 266:Src/usb_pd_protocol.c **** }
 4811              		.loc 1 266 25 view .LVU1262
 4812              	.LBE475:
 4813              	.LBE474:
 334:Src/usb_pd_protocol.c **** 
 4814              		.loc 1 334 2 is_stmt 1 view .LVU1263
 334:Src/usb_pd_protocol.c **** 
 4815              		.loc 1 334 22 is_stmt 0 view .LVU1264
 4816 0042 1933     		adds	r3, r3, #25
 4817 0044 0371     		strb	r3, [r0, #4]
 4818              	.LVL402:
 336:Src/usb_pd_protocol.c **** 		return;
 4819              		.loc 1 336 2 is_stmt 1 view .LVU1265
 4820              	.LBE473:
 4821              	.LBE472:
1239:Src/usb_pd_protocol.c **** 
 4822              		.loc 1 1239 1 is_stmt 0 view .LVU1266
 4823 0046 E9E7     		b	.L278
 4824              	.L284:
 4825              		.align	2
 4826              	.L283:
 4827 0048 00000000 		.word	pd
 4828              		.cfi_endproc
 4829              	.LFE42:
 4831              		.section	.text.pd_send_vdm,"ax",%progbits
 4832              		.align	1
 4833              		.global	pd_send_vdm
 4834              		.syntax unified
 4835              		.code	16
 4836              		.thumb_func
 4837              		.fpu softvfp
 4839              	pd_send_vdm:
 4840              	.LVL403:
 4841              	.LFB47:
1571:Src/usb_pd_protocol.c **** 	if (count > VDO_MAX_SIZE - 1) {
 4842              		.loc 1 1571 1 is_stmt 1 view -0
 4843              		.cfi_startproc
 4844              		@ args = 4, pretend = 0, frame = 0
 4845              		@ frame_needed = 0, uses_anonymous_args = 0
1571:Src/usb_pd_protocol.c **** 	if (count > VDO_MAX_SIZE - 1) {
 4846              		.loc 1 1571 1 is_stmt 0 view .LVU1268
 4847 0000 70B5     		push	{r4, r5, r6, lr}
 4848              	.LCFI29:
 4849              		.cfi_def_cfa_offset 16
 4850              		.cfi_offset 4, -16
 4851              		.cfi_offset 5, -12
 4852              		.cfi_offset 6, -8
 4853              		.cfi_offset 14, -4
 4854 0002 1D00     		movs	r5, r3
1572:Src/usb_pd_protocol.c **** 		CPRINTF("VDM over max size\n");
 4855              		.loc 1 1572 2 is_stmt 1 view .LVU1269
ARM GAS  /tmp/ccoQIC4J.s 			page 143


1572:Src/usb_pd_protocol.c **** 		CPRINTF("VDM over max size\n");
 4856              		.loc 1 1572 5 is_stmt 0 view .LVU1270
 4857 0004 049B     		ldr	r3, [sp, #16]
 4858              	.LVL404:
1572:Src/usb_pd_protocol.c **** 		CPRINTF("VDM over max size\n");
 4859              		.loc 1 1572 5 view .LVU1271
 4860 0006 062B     		cmp	r3, #6
 4861 0008 1CDC     		bgt	.L285
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4862              		.loc 1 1578 2 is_stmt 1 view .LVU1272
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4863              		.loc 1 1578 25 is_stmt 0 view .LVU1273
 4864 000a 0B04     		lsls	r3, r1, #16
 4865 000c FF24     		movs	r4, #255
 4866 000e 2402     		lsls	r4, r4, #8
 4867 0010 2140     		ands	r1, r4
 4868              	.LVL405:
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4869              		.loc 1 1578 25 view .LVU1274
 4870 0012 A142     		cmp	r1, r4
 4871 0014 05D0     		beq	.L288
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4872              		.loc 1 1578 25 discriminator 2 view .LVU1275
 4873 0016 1F21     		movs	r1, #31
 4874 0018 1140     		ands	r1, r2
 4875 001a 0629     		cmp	r1, #6
 4876 001c 13DC     		bgt	.L289
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4877              		.loc 1 1578 25 view .LVU1276
 4878 001e 0121     		movs	r1, #1
 4879 0020 00E0     		b	.L287
 4880              	.L288:
 4881 0022 0121     		movs	r1, #1
 4882              	.L287:
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4883              		.loc 1 1578 25 discriminator 6 view .LVU1277
 4884 0024 C903     		lsls	r1, r1, #15
 4885 0026 1943     		orrs	r1, r3
 4886 0028 5304     		lsls	r3, r2, #17
 4887 002a 5B0C     		lsrs	r3, r3, #17
 4888 002c 0B43     		orrs	r3, r1
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4889              		.loc 1 1578 23 discriminator 6 view .LVU1278
 4890 002e 074A     		ldr	r2, .L290
 4891              	.LVL406:
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4892              		.loc 1 1578 23 discriminator 6 view .LVU1279
 4893 0030 C401     		lsls	r4, r0, #7
 4894 0032 1119     		adds	r1, r2, r4
 4895 0034 8B65     		str	r3, [r1, #88]
1583:Src/usb_pd_protocol.c **** 
 4896              		.loc 1 1583 2 is_stmt 1 discriminator 6 view .LVU1280
1583:Src/usb_pd_protocol.c **** 
 4897              		.loc 1 1583 26 is_stmt 0 discriminator 6 view .LVU1281
 4898 0036 2100     		movs	r1, r4
 4899 0038 5831     		adds	r1, r1, #88
 4900 003a 8918     		adds	r1, r1, r2
ARM GAS  /tmp/ccoQIC4J.s 			page 144


1583:Src/usb_pd_protocol.c **** 
 4901              		.loc 1 1583 2 discriminator 6 view .LVU1282
 4902 003c 049B     		ldr	r3, [sp, #16]
 4903 003e 2A00     		movs	r2, r5
 4904 0040 FFF7FEFF 		bl	queue_vdm
 4905              	.LVL407:
 4906              	.L285:
1587:Src/usb_pd_protocol.c **** 
 4907              		.loc 1 1587 1 view .LVU1283
 4908              		@ sp needed
 4909              	.LVL408:
1587:Src/usb_pd_protocol.c **** 
 4910              		.loc 1 1587 1 view .LVU1284
 4911 0044 70BD     		pop	{r4, r5, r6, pc}
 4912              	.LVL409:
 4913              	.L289:
1578:Src/usb_pd_protocol.c **** 				   1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION), cmd);
 4914              		.loc 1 1578 25 view .LVU1285
 4915 0046 0021     		movs	r1, #0
 4916 0048 ECE7     		b	.L287
 4917              	.L291:
 4918 004a C046     		.align	2
 4919              	.L290:
 4920 004c 00000000 		.word	pd
 4921              		.cfi_endproc
 4922              	.LFE47:
 4924              		.section	.text.pd_dev_store_rw_hash,"ax",%progbits
 4925              		.align	1
 4926              		.global	pd_dev_store_rw_hash
 4927              		.syntax unified
 4928              		.code	16
 4929              		.thumb_func
 4930              		.fpu softvfp
 4932              	pd_dev_store_rw_hash:
 4933              	.LVL410:
 4934              	.LFB51:
1700:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 4935              		.loc 1 1700 1 is_stmt 1 view -0
 4936              		.cfi_startproc
 4937              		@ args = 0, pretend = 0, frame = 0
 4938              		@ frame_needed = 0, uses_anonymous_args = 0
 4939              		@ link register save eliminated.
1725:Src/usb_pd_protocol.c **** }
 4940              		.loc 1 1725 2 view .LVU1287
1726:Src/usb_pd_protocol.c **** 
 4941              		.loc 1 1726 1 is_stmt 0 view .LVU1288
 4942 0000 0020     		movs	r0, #0
 4943              	.LVL411:
1726:Src/usb_pd_protocol.c **** 
 4944              		.loc 1 1726 1 view .LVU1289
 4945              		@ sp needed
 4946 0002 7047     		bx	lr
 4947              		.cfi_endproc
 4948              	.LFE51:
 4950              		.section	.text.pd_get_dual_role,"ax",%progbits
 4951              		.align	1
 4952              		.global	pd_get_dual_role
ARM GAS  /tmp/ccoQIC4J.s 			page 145


 4953              		.syntax unified
 4954              		.code	16
 4955              		.thumb_func
 4956              		.fpu softvfp
 4958              	pd_get_dual_role:
 4959              	.LFB52:
1730:Src/usb_pd_protocol.c **** 	return drp_state;
 4960              		.loc 1 1730 1 is_stmt 1 view -0
 4961              		.cfi_startproc
 4962              		@ args = 0, pretend = 0, frame = 0
 4963              		@ frame_needed = 0, uses_anonymous_args = 0
 4964              		@ link register save eliminated.
1731:Src/usb_pd_protocol.c **** }
 4965              		.loc 1 1731 2 view .LVU1291
1731:Src/usb_pd_protocol.c **** }
 4966              		.loc 1 1731 9 is_stmt 0 view .LVU1292
 4967 0000 014B     		ldr	r3, .L294
 4968 0002 1878     		ldrb	r0, [r3]
1732:Src/usb_pd_protocol.c **** 
 4969              		.loc 1 1732 1 view .LVU1293
 4970              		@ sp needed
 4971 0004 7047     		bx	lr
 4972              	.L295:
 4973 0006 C046     		.align	2
 4974              	.L294:
 4975 0008 00000000 		.word	.LANCHOR0
 4976              		.cfi_endproc
 4977              	.LFE52:
 4979              		.section	.text.pd_set_dual_role,"ax",%progbits
 4980              		.align	1
 4981              		.global	pd_set_dual_role
 4982              		.syntax unified
 4983              		.code	16
 4984              		.thumb_func
 4985              		.fpu softvfp
 4987              	pd_set_dual_role:
 4988              	.LVL412:
 4989              	.LFB53:
1774:Src/usb_pd_protocol.c **** 	int i;
 4990              		.loc 1 1774 1 is_stmt 1 view -0
 4991              		.cfi_startproc
 4992              		@ args = 0, pretend = 0, frame = 0
 4993              		@ frame_needed = 0, uses_anonymous_args = 0
 4994              		@ link register save eliminated.
1775:Src/usb_pd_protocol.c **** 	drp_state = state;
 4995              		.loc 1 1775 2 view .LVU1295
1776:Src/usb_pd_protocol.c **** 
 4996              		.loc 1 1776 2 view .LVU1296
1776:Src/usb_pd_protocol.c **** 
 4997              		.loc 1 1776 12 is_stmt 0 view .LVU1297
 4998 0000 034B     		ldr	r3, .L299
 4999 0002 1870     		strb	r0, [r3]
1783:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 5000              		.loc 1 1783 2 is_stmt 1 view .LVU1298
 5001              	.LVL413:
1783:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 5002              		.loc 1 1783 9 is_stmt 0 view .LVU1299
ARM GAS  /tmp/ccoQIC4J.s 			page 146


 5003 0004 0023     		movs	r3, #0
 5004              	.LVL414:
 5005              	.L297:
1783:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 5006              		.loc 1 1783 2 discriminator 1 view .LVU1300
 5007 0006 002B     		cmp	r3, #0
 5008 0008 00DD     		ble	.L298
1788:Src/usb_pd_protocol.c **** 
 5009              		.loc 1 1788 1 view .LVU1301
 5010              		@ sp needed
 5011 000a 7047     		bx	lr
 5012              	.L298:
1787:Src/usb_pd_protocol.c **** }
 5013              		.loc 1 1787 3 is_stmt 1 discriminator 3 view .LVU1302
1783:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 5014              		.loc 1 1783 45 is_stmt 0 discriminator 3 view .LVU1303
 5015 000c 0133     		adds	r3, r3, #1
 5016              	.LVL415:
1783:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
 5017              		.loc 1 1783 45 discriminator 3 view .LVU1304
 5018 000e FAE7     		b	.L297
 5019              	.L300:
 5020              		.align	2
 5021              	.L299:
 5022 0010 00000000 		.word	.LANCHOR0
 5023              		.cfi_endproc
 5024              	.LFE53:
 5026              		.section	.text.pd_update_dual_role_config,"ax",%progbits
 5027              		.align	1
 5028              		.global	pd_update_dual_role_config
 5029              		.syntax unified
 5030              		.code	16
 5031              		.thumb_func
 5032              		.fpu softvfp
 5034              	pd_update_dual_role_config:
 5035              	.LVL416:
 5036              	.LFB54:
1791:Src/usb_pd_protocol.c **** 	/*
 5037              		.loc 1 1791 1 is_stmt 1 view -0
 5038              		.cfi_startproc
 5039              		@ args = 0, pretend = 0, frame = 0
 5040              		@ frame_needed = 0, uses_anonymous_args = 0
1791:Src/usb_pd_protocol.c **** 	/*
 5041              		.loc 1 1791 1 is_stmt 0 view .LVU1306
 5042 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 5043              	.LCFI30:
 5044              		.cfi_def_cfa_offset 24
 5045              		.cfi_offset 3, -24
 5046              		.cfi_offset 4, -20
 5047              		.cfi_offset 5, -16
 5048              		.cfi_offset 6, -12
 5049              		.cfi_offset 7, -8
 5050              		.cfi_offset 14, -4
 5051 0002 0400     		movs	r4, r0
1798:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
 5052              		.loc 1 1798 2 is_stmt 1 view .LVU1307
1798:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
ARM GAS  /tmp/ccoQIC4J.s 			page 147


 5053              		.loc 1 1798 14 is_stmt 0 view .LVU1308
 5054 0004 C201     		lsls	r2, r0, #7
 5055 0006 414B     		ldr	r3, .L315
 5056 0008 D35C     		ldrb	r3, [r2, r3]
1798:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
 5057              		.loc 1 1798 5 view .LVU1309
 5058 000a 012B     		cmp	r3, #1
 5059 000c 09D0     		beq	.L310
 5060              	.LVL417:
 5061              	.L302:
1813:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
 5062              		.loc 1 1813 2 is_stmt 1 view .LVU1310
1813:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
 5063              		.loc 1 1813 14 is_stmt 0 view .LVU1311
 5064 000e E301     		lsls	r3, r4, #7
 5065 0010 3E4A     		ldr	r2, .L315
 5066 0012 9B5C     		ldrb	r3, [r3, r2]
1813:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
 5067              		.loc 1 1813 5 view .LVU1312
 5068 0014 002B     		cmp	r3, #0
 5069 0016 03D1     		bne	.L301
1814:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
 5070              		.loc 1 1814 16 discriminator 1 view .LVU1313
 5071 0018 3D4B     		ldr	r3, .L315+4
 5072 001a 1B78     		ldrb	r3, [r3]
1813:Src/usb_pd_protocol.c **** 	    drp_state == PD_DRP_FORCE_SOURCE) {
 5073              		.loc 1 1813 42 discriminator 1 view .LVU1314
 5074 001c 042B     		cmp	r3, #4
 5075 001e 44D0     		beq	.L311
 5076              	.L301:
1825:Src/usb_pd_protocol.c **** 
 5077              		.loc 1 1825 1 view .LVU1315
 5078              		@ sp needed
 5079              	.LVL418:
1825:Src/usb_pd_protocol.c **** 
 5080              		.loc 1 1825 1 view .LVU1316
 5081 0020 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 5082              	.LVL419:
 5083              	.L310:
1799:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
 5084              		.loc 1 1799 18 discriminator 1 view .LVU1317
 5085 0022 3B4B     		ldr	r3, .L315+4
 5086 0024 1D78     		ldrb	r5, [r3]
1798:Src/usb_pd_protocol.c **** 	    ((drp_state == PD_DRP_FORCE_SINK && !pd_ts_dts_plugged(port)) ||
 5087              		.loc 1 1798 44 discriminator 1 view .LVU1318
 5088 0026 032D     		cmp	r5, #3
 5089 0028 08D0     		beq	.L312
 5090              	.LVL420:
 5091              	.L303:
1799:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
 5092              		.loc 1 1799 68 discriminator 1 view .LVU1319
 5093 002a 012D     		cmp	r5, #1
 5094 002c EFD1     		bne	.L302
1801:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SINK;
 5095              		.loc 1 1801 19 view .LVU1320
 5096 002e E201     		lsls	r2, r4, #7
 5097 0030 364B     		ldr	r3, .L315
ARM GAS  /tmp/ccoQIC4J.s 			page 148


 5098 0032 9B18     		adds	r3, r3, r2
 5099 0034 1B79     		ldrb	r3, [r3, #4]
1801:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SINK;
 5100              		.loc 1 1801 8 view .LVU1321
 5101 0036 0E2B     		cmp	r3, #14
 5102 0038 E9D1     		bne	.L302
 5103 003a 03E0     		b	.L304
 5104              	.LVL421:
 5105              	.L312:
1799:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
 5106              		.loc 1 1799 43 view .LVU1322
 5107 003c FFF7FEFF 		bl	pd_ts_dts_plugged
 5108              	.LVL422:
1799:Src/usb_pd_protocol.c **** 	     (drp_state == PD_DRP_TOGGLE_OFF
 5109              		.loc 1 1799 39 view .LVU1323
 5110 0040 0028     		cmp	r0, #0
 5111 0042 F2D1     		bne	.L303
 5112              	.L304:
1802:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_DISCONNECTED);
 5113              		.loc 1 1802 3 is_stmt 1 view .LVU1324
1802:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_DISCONNECTED);
 5114              		.loc 1 1802 23 is_stmt 0 view .LVU1325
 5115 0044 314B     		ldr	r3, .L315
 5116 0046 E201     		lsls	r2, r4, #7
 5117 0048 0021     		movs	r1, #0
 5118 004a D154     		strb	r1, [r2, r3]
1803:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RD);
 5119              		.loc 1 1803 3 is_stmt 1 view .LVU1326
 5120              	.LVL423:
 5121              	.LBB492:
 5122              	.LBI492:
 326:Src/usb_pd_protocol.c **** {
 5123              		.loc 1 326 20 view .LVU1327
 5124              	.LBB493:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5125              		.loc 1 328 2 view .LVU1328
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5126              		.loc 1 328 17 is_stmt 0 view .LVU1329
 5127 004c 9B18     		adds	r3, r3, r2
 5128 004e 1A79     		ldrb	r2, [r3, #4]
 5129              	.LVL424:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 5130              		.loc 1 333 2 is_stmt 1 view .LVU1330
 5131              	.LBB494:
 5132              	.LBI494:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 5133              		.loc 1 261 20 view .LVU1331
 5134              	.LBB495:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5135              		.loc 1 265 2 view .LVU1332
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5136              		.loc 1 265 19 is_stmt 0 view .LVU1333
 5137 0050 0026     		movs	r6, #0
 5138 0052 0027     		movs	r7, #0
 5139 0054 1E61     		str	r6, [r3, #16]
 5140 0056 5F61     		str	r7, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 149


 5141              		.loc 1 266 2 is_stmt 1 view .LVU1334
 266:Src/usb_pd_protocol.c **** }
 5142              		.loc 1 266 25 is_stmt 0 view .LVU1335
 5143 0058 D971     		strb	r1, [r3, #7]
 5144              	.LVL425:
 266:Src/usb_pd_protocol.c **** }
 5145              		.loc 1 266 25 view .LVU1336
 5146              	.LBE495:
 5147              	.LBE494:
 334:Src/usb_pd_protocol.c **** 
 5148              		.loc 1 334 2 is_stmt 1 view .LVU1337
 334:Src/usb_pd_protocol.c **** 
 5149              		.loc 1 334 22 is_stmt 0 view .LVU1338
 5150 005a 0231     		adds	r1, r1, #2
 5151 005c 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 5152              		.loc 1 336 2 is_stmt 1 view .LVU1339
 336:Src/usb_pd_protocol.c **** 		return;
 5153              		.loc 1 336 5 is_stmt 0 view .LVU1340
 5154 005e 022A     		cmp	r2, #2
 5155 0060 13D0     		beq	.L305
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5156              		.loc 1 347 2 is_stmt 1 view .LVU1341
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 5157              		.loc 1 348 48 is_stmt 0 view .LVU1342
 5158 0062 0E2A     		cmp	r2, #14
 5159 0064 11D0     		beq	.L305
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 5160              		.loc 1 353 2 is_stmt 1 view .LVU1343
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5161              		.loc 1 356 3 view .LVU1344
 5162 0066 0022     		movs	r2, #0
 5163              	.LVL426:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5164              		.loc 1 356 3 is_stmt 0 view .LVU1345
 5165 0068 0021     		movs	r1, #0
 5166 006a 2000     		movs	r0, r4
 5167 006c FFF7FEFF 		bl	pd_set_input_current_limit
 5168              	.LVL427:
 373:Src/usb_pd_protocol.c **** 			/*
 5169              		.loc 1 373 3 is_stmt 1 view .LVU1346
 373:Src/usb_pd_protocol.c **** 			/*
 5170              		.loc 1 373 15 is_stmt 0 view .LVU1347
 5171 0070 E301     		lsls	r3, r4, #7
 5172 0072 264A     		ldr	r2, .L315
 5173 0074 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 5174              		.loc 1 373 6 view .LVU1348
 5175 0076 012B     		cmp	r3, #1
 5176 0078 13D0     		beq	.L313
 5177              	.L306:
 405:Src/usb_pd_protocol.c **** 	}
 5178              		.loc 1 405 3 is_stmt 1 view .LVU1349
 5179              	.LVL428:
 5180              	.LBB496:
 5181              	.LBI496:
  94:Inc/tcpm.h    **** {
ARM GAS  /tmp/ccoQIC4J.s 			page 150


 5182              		.loc 2 94 19 view .LVU1350
 5183              	.LBB497:
  96:Inc/tcpm.h    **** }
 5184              		.loc 2 96 2 view .LVU1351
  96:Inc/tcpm.h    **** }
 5185              		.loc 2 96 26 is_stmt 0 view .LVU1352
 5186 007a 2201     		lsls	r2, r4, #4
 5187 007c 254B     		ldr	r3, .L315+8
 5188 007e 9B18     		adds	r3, r3, r2
 5189 0080 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 5190              		.loc 2 96 30 view .LVU1353
 5191 0082 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 5192              		.loc 2 96 9 view .LVU1354
 5193 0084 0021     		movs	r1, #0
 5194 0086 2000     		movs	r0, r4
 5195 0088 9847     		blx	r3
 5196              	.LVL429:
 5197              	.L305:
  96:Inc/tcpm.h    **** }
 5198              		.loc 2 96 9 view .LVU1355
 5199              	.LBE497:
 5200              	.LBE496:
 5201              	.LBE493:
 5202              	.LBE492:
1804:Src/usb_pd_protocol.c **** 		/* Make sure we're not sourcing VBUS. */
 5203              		.loc 1 1804 3 is_stmt 1 view .LVU1356
 5204              	.LBB499:
 5205              	.LBI499:
  73:Inc/tcpm.h    **** {
 5206              		.loc 2 73 19 view .LVU1357
 5207              	.LBB500:
  75:Inc/tcpm.h    **** }
 5208              		.loc 2 75 2 view .LVU1358
  75:Inc/tcpm.h    **** }
 5209              		.loc 2 75 26 is_stmt 0 view .LVU1359
 5210 008a 2201     		lsls	r2, r4, #4
 5211 008c 214B     		ldr	r3, .L315+8
 5212 008e 9B18     		adds	r3, r3, r2
 5213 0090 9B68     		ldr	r3, [r3, #8]
  75:Inc/tcpm.h    **** }
 5214              		.loc 2 75 30 view .LVU1360
 5215 0092 5B69     		ldr	r3, [r3, #20]
  75:Inc/tcpm.h    **** }
 5216              		.loc 2 75 9 view .LVU1361
 5217 0094 0221     		movs	r1, #2
 5218 0096 2000     		movs	r0, r4
 5219 0098 9847     		blx	r3
 5220              	.LVL430:
  75:Inc/tcpm.h    **** }
 5221              		.loc 2 75 9 view .LVU1362
 5222              	.LBE500:
 5223              	.LBE499:
1806:Src/usb_pd_protocol.c **** 	}
 5224              		.loc 1 1806 3 is_stmt 1 view .LVU1363
 5225 009a 2000     		movs	r0, r4
ARM GAS  /tmp/ccoQIC4J.s 			page 151


 5226 009c FFF7FEFF 		bl	pd_power_supply_reset
 5227              	.LVL431:
 5228 00a0 B5E7     		b	.L302
 5229              	.LVL432:
 5230              	.L313:
 5231              	.LBB501:
 5232              	.LBB498:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 5233              		.loc 1 378 4 view .LVU1364
 5234 00a2 2000     		movs	r0, r4
 5235 00a4 FFF7FEFF 		bl	pd_power_supply_reset
 5236              	.LVL433:
 5237 00a8 E7E7     		b	.L306
 5238              	.LVL434:
 5239              	.L311:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 5240              		.loc 1 378 4 is_stmt 0 view .LVU1365
 5241              	.LBE498:
 5242              	.LBE501:
1815:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCONNECTED);
 5243              		.loc 1 1815 3 is_stmt 1 view .LVU1366
1815:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCONNECTED);
 5244              		.loc 1 1815 23 is_stmt 0 view .LVU1367
 5245 00aa 1300     		movs	r3, r2
 5246 00ac E201     		lsls	r2, r4, #7
 5247 00ae 0121     		movs	r1, #1
 5248 00b0 D154     		strb	r1, [r2, r3]
1816:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, TYPEC_CC_RP);
 5249              		.loc 1 1816 3 is_stmt 1 view .LVU1368
 5250              	.LVL435:
 5251              	.LBB502:
 5252              	.LBI502:
 326:Src/usb_pd_protocol.c **** {
 5253              		.loc 1 326 20 view .LVU1369
 5254              	.LBB503:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5255              		.loc 1 328 2 view .LVU1370
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5256              		.loc 1 328 17 is_stmt 0 view .LVU1371
 5257 00b2 9B18     		adds	r3, r3, r2
 5258 00b4 1A79     		ldrb	r2, [r3, #4]
 5259              	.LVL436:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 5260              		.loc 1 333 2 is_stmt 1 view .LVU1372
 5261              	.LBB504:
 5262              	.LBI504:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 5263              		.loc 1 261 20 view .LVU1373
 5264              	.LBB505:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5265              		.loc 1 265 2 view .LVU1374
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5266              		.loc 1 265 19 is_stmt 0 view .LVU1375
 5267 00b6 0020     		movs	r0, #0
 5268 00b8 0021     		movs	r1, #0
 5269 00ba 1861     		str	r0, [r3, #16]
 5270 00bc 5961     		str	r1, [r3, #20]
ARM GAS  /tmp/ccoQIC4J.s 			page 152


 266:Src/usb_pd_protocol.c **** }
 5271              		.loc 1 266 2 is_stmt 1 view .LVU1376
 266:Src/usb_pd_protocol.c **** }
 5272              		.loc 1 266 25 is_stmt 0 view .LVU1377
 5273 00be 0021     		movs	r1, #0
 5274 00c0 D971     		strb	r1, [r3, #7]
 5275              	.LVL437:
 266:Src/usb_pd_protocol.c **** }
 5276              		.loc 1 266 25 view .LVU1378
 5277              	.LBE505:
 5278              	.LBE504:
 334:Src/usb_pd_protocol.c **** 
 5279              		.loc 1 334 2 is_stmt 1 view .LVU1379
 334:Src/usb_pd_protocol.c **** 
 5280              		.loc 1 334 22 is_stmt 0 view .LVU1380
 5281 00c2 0E31     		adds	r1, r1, #14
 5282 00c4 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 5283              		.loc 1 336 2 is_stmt 1 view .LVU1381
 336:Src/usb_pd_protocol.c **** 		return;
 5284              		.loc 1 336 5 is_stmt 0 view .LVU1382
 5285 00c6 0E2A     		cmp	r2, #14
 5286 00c8 13D0     		beq	.L308
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5287              		.loc 1 347 2 is_stmt 1 view .LVU1383
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5288              		.loc 1 347 5 is_stmt 0 view .LVU1384
 5289 00ca 022A     		cmp	r2, #2
 5290 00cc 11D0     		beq	.L308
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 5291              		.loc 1 353 2 is_stmt 1 view .LVU1385
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5292              		.loc 1 356 3 view .LVU1386
 5293 00ce 0022     		movs	r2, #0
 5294              	.LVL438:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5295              		.loc 1 356 3 is_stmt 0 view .LVU1387
 5296 00d0 0021     		movs	r1, #0
 5297 00d2 2000     		movs	r0, r4
 5298 00d4 FFF7FEFF 		bl	pd_set_input_current_limit
 5299              	.LVL439:
 373:Src/usb_pd_protocol.c **** 			/*
 5300              		.loc 1 373 3 is_stmt 1 view .LVU1388
 373:Src/usb_pd_protocol.c **** 			/*
 5301              		.loc 1 373 15 is_stmt 0 view .LVU1389
 5302 00d8 E301     		lsls	r3, r4, #7
 5303 00da 0C4A     		ldr	r2, .L315
 5304 00dc 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 5305              		.loc 1 373 6 view .LVU1390
 5306 00de 012B     		cmp	r3, #1
 5307 00e0 10D0     		beq	.L314
 5308              	.L309:
 405:Src/usb_pd_protocol.c **** 	}
 5309              		.loc 1 405 3 is_stmt 1 view .LVU1391
 5310              	.LVL440:
 5311              	.LBB506:
ARM GAS  /tmp/ccoQIC4J.s 			page 153


 5312              	.LBI506:
  94:Inc/tcpm.h    **** {
 5313              		.loc 2 94 19 view .LVU1392
 5314              	.LBB507:
  96:Inc/tcpm.h    **** }
 5315              		.loc 2 96 2 view .LVU1393
  96:Inc/tcpm.h    **** }
 5316              		.loc 2 96 26 is_stmt 0 view .LVU1394
 5317 00e2 2201     		lsls	r2, r4, #4
 5318 00e4 0B4B     		ldr	r3, .L315+8
 5319 00e6 9B18     		adds	r3, r3, r2
 5320 00e8 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 5321              		.loc 2 96 30 view .LVU1395
 5322 00ea 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 5323              		.loc 2 96 9 view .LVU1396
 5324 00ec 0021     		movs	r1, #0
 5325 00ee 2000     		movs	r0, r4
 5326 00f0 9847     		blx	r3
 5327              	.LVL441:
 5328              	.L308:
  96:Inc/tcpm.h    **** }
 5329              		.loc 2 96 9 view .LVU1397
 5330              	.LBE507:
 5331              	.LBE506:
 5332              	.LBE503:
 5333              	.LBE502:
1817:Src/usb_pd_protocol.c **** 	}
 5334              		.loc 1 1817 3 is_stmt 1 view .LVU1398
 5335              	.LBB509:
 5336              	.LBI509:
  73:Inc/tcpm.h    **** {
 5337              		.loc 2 73 19 view .LVU1399
 5338              	.LBB510:
  75:Inc/tcpm.h    **** }
 5339              		.loc 2 75 2 view .LVU1400
  75:Inc/tcpm.h    **** }
 5340              		.loc 2 75 26 is_stmt 0 view .LVU1401
 5341 00f2 2201     		lsls	r2, r4, #4
 5342 00f4 074B     		ldr	r3, .L315+8
 5343 00f6 9B18     		adds	r3, r3, r2
 5344 00f8 9B68     		ldr	r3, [r3, #8]
  75:Inc/tcpm.h    **** }
 5345              		.loc 2 75 30 view .LVU1402
 5346 00fa 5B69     		ldr	r3, [r3, #20]
  75:Inc/tcpm.h    **** }
 5347              		.loc 2 75 9 view .LVU1403
 5348 00fc 0121     		movs	r1, #1
 5349 00fe 2000     		movs	r0, r4
 5350 0100 9847     		blx	r3
 5351              	.LVL442:
 5352              	.LBE510:
 5353              	.LBE509:
1825:Src/usb_pd_protocol.c **** 
 5354              		.loc 1 1825 1 view .LVU1404
 5355 0102 8DE7     		b	.L301
ARM GAS  /tmp/ccoQIC4J.s 			page 154


 5356              	.LVL443:
 5357              	.L314:
 5358              	.LBB511:
 5359              	.LBB508:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 5360              		.loc 1 378 4 is_stmt 1 view .LVU1405
 5361 0104 2000     		movs	r0, r4
 5362 0106 FFF7FEFF 		bl	pd_power_supply_reset
 5363              	.LVL444:
 5364 010a EAE7     		b	.L309
 5365              	.L316:
 5366              		.align	2
 5367              	.L315:
 5368 010c 00000000 		.word	pd
 5369 0110 00000000 		.word	.LANCHOR0
 5370 0114 00000000 		.word	tcpc_config
 5371              	.LBE508:
 5372              	.LBE511:
 5373              		.cfi_endproc
 5374              	.LFE54:
 5376              		.section	.text.pd_get_role,"ax",%progbits
 5377              		.align	1
 5378              		.global	pd_get_role
 5379              		.syntax unified
 5380              		.code	16
 5381              		.thumb_func
 5382              		.fpu softvfp
 5384              	pd_get_role:
 5385              	.LVL445:
 5386              	.LFB55:
1828:Src/usb_pd_protocol.c **** 	return pd[port].power_role;
 5387              		.loc 1 1828 1 view -0
 5388              		.cfi_startproc
 5389              		@ args = 0, pretend = 0, frame = 0
 5390              		@ frame_needed = 0, uses_anonymous_args = 0
 5391              		@ link register save eliminated.
1829:Src/usb_pd_protocol.c **** }
 5392              		.loc 1 1829 2 view .LVU1407
1829:Src/usb_pd_protocol.c **** }
 5393              		.loc 1 1829 17 is_stmt 0 view .LVU1408
 5394 0000 C001     		lsls	r0, r0, #7
 5395              	.LVL446:
1829:Src/usb_pd_protocol.c **** }
 5396              		.loc 1 1829 17 view .LVU1409
 5397 0002 014B     		ldr	r3, .L318
 5398 0004 C05C     		ldrb	r0, [r0, r3]
1830:Src/usb_pd_protocol.c **** 
 5399              		.loc 1 1830 1 view .LVU1410
 5400              		@ sp needed
 5401 0006 7047     		bx	lr
 5402              	.L319:
 5403              		.align	2
 5404              	.L318:
 5405 0008 00000000 		.word	pd
 5406              		.cfi_endproc
 5407              	.LFE55:
 5409              		.section	.text.pd_get_polarity,"ax",%progbits
ARM GAS  /tmp/ccoQIC4J.s 			page 155


 5410              		.align	1
 5411              		.global	pd_get_polarity
 5412              		.syntax unified
 5413              		.code	16
 5414              		.thumb_func
 5415              		.fpu softvfp
 5417              	pd_get_polarity:
 5418              	.LVL447:
 5419              	.LFB58:
1877:Src/usb_pd_protocol.c **** 	return pd[port].polarity;
 5420              		.loc 1 1877 1 is_stmt 1 view -0
 5421              		.cfi_startproc
 5422              		@ args = 0, pretend = 0, frame = 0
 5423              		@ frame_needed = 0, uses_anonymous_args = 0
 5424              		@ link register save eliminated.
1878:Src/usb_pd_protocol.c **** }
 5425              		.loc 1 1878 2 view .LVU1412
1878:Src/usb_pd_protocol.c **** }
 5426              		.loc 1 1878 17 is_stmt 0 view .LVU1413
 5427 0000 C301     		lsls	r3, r0, #7
 5428 0002 0248     		ldr	r0, .L321
 5429              	.LVL448:
1878:Src/usb_pd_protocol.c **** }
 5430              		.loc 1 1878 17 view .LVU1414
 5431 0004 C018     		adds	r0, r0, r3
 5432 0006 C078     		ldrb	r0, [r0, #3]
1879:Src/usb_pd_protocol.c **** 
 5433              		.loc 1 1879 1 view .LVU1415
 5434              		@ sp needed
 5435 0008 7047     		bx	lr
 5436              	.L322:
 5437 000a C046     		.align	2
 5438              	.L321:
 5439 000c 00000000 		.word	pd
 5440              		.cfi_endproc
 5441              	.LFE58:
 5443              		.section	.text.pd_get_partner_data_swap_capable,"ax",%progbits
 5444              		.align	1
 5445              		.global	pd_get_partner_data_swap_capable
 5446              		.syntax unified
 5447              		.code	16
 5448              		.thumb_func
 5449              		.fpu softvfp
 5451              	pd_get_partner_data_swap_capable:
 5452              	.LVL449:
 5453              	.LFB59:
1882:Src/usb_pd_protocol.c **** 	/* return data swap capable status of port partner */
 5454              		.loc 1 1882 1 is_stmt 1 view -0
 5455              		.cfi_startproc
 5456              		@ args = 0, pretend = 0, frame = 0
 5457              		@ frame_needed = 0, uses_anonymous_args = 0
 5458              		@ link register save eliminated.
1884:Src/usb_pd_protocol.c **** }
 5459              		.loc 1 1884 2 view .LVU1417
1884:Src/usb_pd_protocol.c **** }
 5460              		.loc 1 1884 17 is_stmt 0 view .LVU1418
 5461 0000 C301     		lsls	r3, r0, #7
ARM GAS  /tmp/ccoQIC4J.s 			page 156


 5462 0002 0348     		ldr	r0, .L324
 5463              	.LVL450:
1884:Src/usb_pd_protocol.c **** }
 5464              		.loc 1 1884 17 view .LVU1419
 5465 0004 C018     		adds	r0, r0, r3
 5466 0006 8368     		ldr	r3, [r0, #8]
1884:Src/usb_pd_protocol.c **** }
 5467              		.loc 1 1884 24 view .LVU1420
 5468 0008 0420     		movs	r0, #4
 5469 000a 1840     		ands	r0, r3
1885:Src/usb_pd_protocol.c **** 
 5470              		.loc 1 1885 1 view .LVU1421
 5471              		@ sp needed
 5472 000c 7047     		bx	lr
 5473              	.L325:
 5474 000e C046     		.align	2
 5475              	.L324:
 5476 0010 00000000 		.word	pd
 5477              		.cfi_endproc
 5478              	.LFE59:
 5480              		.section	.text.pd_ping_enable,"ax",%progbits
 5481              		.align	1
 5482              		.global	pd_ping_enable
 5483              		.syntax unified
 5484              		.code	16
 5485              		.thumb_func
 5486              		.fpu softvfp
 5488              	pd_ping_enable:
 5489              	.LVL451:
 5490              	.LFB60:
1911:Src/usb_pd_protocol.c **** 	if (enable)
 5491              		.loc 1 1911 1 is_stmt 1 view -0
 5492              		.cfi_startproc
 5493              		@ args = 0, pretend = 0, frame = 0
 5494              		@ frame_needed = 0, uses_anonymous_args = 0
 5495              		@ link register save eliminated.
1912:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PING_ENABLED;
 5496              		.loc 1 1912 2 view .LVU1423
1912:Src/usb_pd_protocol.c **** 		pd[port].flags |= PD_FLAGS_PING_ENABLED;
 5497              		.loc 1 1912 5 is_stmt 0 view .LVU1424
 5498 0000 0029     		cmp	r1, #0
 5499 0002 07D0     		beq	.L327
1913:Src/usb_pd_protocol.c **** 	else
 5500              		.loc 1 1913 3 is_stmt 1 view .LVU1425
1913:Src/usb_pd_protocol.c **** 	else
 5501              		.loc 1 1913 18 is_stmt 0 view .LVU1426
 5502 0004 C001     		lsls	r0, r0, #7
 5503              	.LVL452:
1913:Src/usb_pd_protocol.c **** 	else
 5504              		.loc 1 1913 18 view .LVU1427
 5505 0006 074B     		ldr	r3, .L329
 5506 0008 1818     		adds	r0, r3, r0
 5507 000a 0123     		movs	r3, #1
 5508 000c 8268     		ldr	r2, [r0, #8]
 5509 000e 1343     		orrs	r3, r2
 5510 0010 8360     		str	r3, [r0, #8]
 5511              	.L326:
ARM GAS  /tmp/ccoQIC4J.s 			page 157


1916:Src/usb_pd_protocol.c **** 
 5512              		.loc 1 1916 1 view .LVU1428
 5513              		@ sp needed
 5514 0012 7047     		bx	lr
 5515              	.LVL453:
 5516              	.L327:
1915:Src/usb_pd_protocol.c **** }
 5517              		.loc 1 1915 3 is_stmt 1 view .LVU1429
1915:Src/usb_pd_protocol.c **** }
 5518              		.loc 1 1915 18 is_stmt 0 view .LVU1430
 5519 0014 C001     		lsls	r0, r0, #7
 5520              	.LVL454:
1915:Src/usb_pd_protocol.c **** }
 5521              		.loc 1 1915 18 view .LVU1431
 5522 0016 034B     		ldr	r3, .L329
 5523 0018 1818     		adds	r0, r3, r0
 5524 001a 0123     		movs	r3, #1
 5525 001c 8268     		ldr	r2, [r0, #8]
 5526 001e 9A43     		bics	r2, r3
 5527 0020 8260     		str	r2, [r0, #8]
1916:Src/usb_pd_protocol.c **** 
 5528              		.loc 1 1916 1 view .LVU1432
 5529 0022 F6E7     		b	.L326
 5530              	.L330:
 5531              		.align	2
 5532              	.L329:
 5533 0024 00000000 		.word	pd
 5534              		.cfi_endproc
 5535              	.LFE60:
 5537              		.section	.text.pd_set_new_power_request,"ax",%progbits
 5538              		.align	1
 5539              		.global	pd_set_new_power_request
 5540              		.syntax unified
 5541              		.code	16
 5542              		.thumb_func
 5543              		.fpu softvfp
 5545              	pd_set_new_power_request:
 5546              	.LVL455:
 5547              	.LFB64:
1980:Src/usb_pd_protocol.c **** 	pd[port].new_power_request = 1;
 5548              		.loc 1 1980 1 is_stmt 1 view -0
 5549              		.cfi_startproc
 5550              		@ args = 0, pretend = 0, frame = 0
 5551              		@ frame_needed = 0, uses_anonymous_args = 0
 5552              		@ link register save eliminated.
1981:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
 5553              		.loc 1 1981 2 view .LVU1434
1981:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
 5554              		.loc 1 1981 29 is_stmt 0 view .LVU1435
 5555 0000 C301     		lsls	r3, r0, #7
 5556 0002 0248     		ldr	r0, .L332
 5557              	.LVL456:
1981:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
 5558              		.loc 1 1981 29 view .LVU1436
 5559 0004 C018     		adds	r0, r0, r3
 5560 0006 0123     		movs	r3, #1
 5561 0008 8363     		str	r3, [r0, #56]
ARM GAS  /tmp/ccoQIC4J.s 			page 158


1984:Src/usb_pd_protocol.c **** #endif /* CONFIG_CHARGE_MANAGER */
 5562              		.loc 1 1984 1 view .LVU1437
 5563              		@ sp needed
 5564 000a 7047     		bx	lr
 5565              	.L333:
 5566              		.align	2
 5567              	.L332:
 5568 000c 00000000 		.word	pd
 5569              		.cfi_endproc
 5570              	.LFE64:
 5572              		.section	.text.pd_init,"ax",%progbits
 5573              		.align	1
 5574              		.global	pd_init
 5575              		.syntax unified
 5576              		.code	16
 5577              		.thumb_func
 5578              		.fpu softvfp
 5580              	pd_init:
 5581              	.LVL457:
 5582              	.LFB66:
2043:Src/usb_pd_protocol.c **** #endif
2044:Src/usb_pd_protocol.c **** 
2045:Src/usb_pd_protocol.c **** void pd_init(int port)
2046:Src/usb_pd_protocol.c **** {
 5583              		.loc 1 2046 1 is_stmt 1 view -0
 5584              		.cfi_startproc
 5585              		@ args = 0, pretend = 0, frame = 8
 5586              		@ frame_needed = 0, uses_anonymous_args = 0
 5587              		.loc 1 2046 1 is_stmt 0 view .LVU1439
 5588 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 5589              	.LCFI31:
 5590              		.cfi_def_cfa_offset 20
 5591              		.cfi_offset 4, -20
 5592              		.cfi_offset 5, -16
 5593              		.cfi_offset 6, -12
 5594              		.cfi_offset 7, -8
 5595              		.cfi_offset 14, -4
 5596 0002 CE46     		mov	lr, r9
 5597 0004 4746     		mov	r7, r8
 5598 0006 80B5     		push	{r7, lr}
 5599              	.LCFI32:
 5600              		.cfi_def_cfa_offset 28
 5601              		.cfi_offset 8, -28
 5602              		.cfi_offset 9, -24
 5603 0008 83B0     		sub	sp, sp, #12
 5604              	.LCFI33:
 5605              		.cfi_def_cfa_offset 40
 5606 000a 0400     		movs	r4, r0
2047:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
2048:Src/usb_pd_protocol.c **** 	pd_init_tasks();
2049:Src/usb_pd_protocol.c **** #endif
2050:Src/usb_pd_protocol.c **** 
2051:Src/usb_pd_protocol.c **** 	/* Ensure the power supply is in the default state */
2052:Src/usb_pd_protocol.c **** 	pd_power_supply_reset(port);
 5607              		.loc 1 2052 2 is_stmt 1 view .LVU1440
 5608 000c FFF7FEFF 		bl	pd_power_supply_reset
 5609              	.LVL458:
ARM GAS  /tmp/ccoQIC4J.s 			page 159


2053:Src/usb_pd_protocol.c **** 
2054:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC_BOARD_INIT
2055:Src/usb_pd_protocol.c **** 	/* Board specific TCPC init */
2056:Src/usb_pd_protocol.c **** 	board_tcpc_init();
2057:Src/usb_pd_protocol.c **** #endif
2058:Src/usb_pd_protocol.c **** 
2059:Src/usb_pd_protocol.c **** 	/* Initialize TCPM driver and wait for TCPC to be ready */
2060:Src/usb_pd_protocol.c **** 	res = tcpm_init(port);
 5610              		.loc 1 2060 2 view .LVU1441
 5611              	.LBB529:
 5612              	.LBI529:
  38:Inc/tcpm.h    **** {
 5613              		.loc 2 38 19 view .LVU1442
 5614              	.LBB530:
  40:Inc/tcpm.h    **** 
 5615              		.loc 2 40 2 view .LVU1443
  42:Inc/tcpm.h    **** 	if (rv)
 5616              		.loc 2 42 2 view .LVU1444
  42:Inc/tcpm.h    **** 	if (rv)
 5617              		.loc 2 42 24 is_stmt 0 view .LVU1445
 5618 0010 2201     		lsls	r2, r4, #4
 5619 0012 3D4B     		ldr	r3, .L348
 5620 0014 9B18     		adds	r3, r3, r2
 5621 0016 9B68     		ldr	r3, [r3, #8]
  42:Inc/tcpm.h    **** 	if (rv)
 5622              		.loc 2 42 28 view .LVU1446
 5623 0018 1B68     		ldr	r3, [r3]
  42:Inc/tcpm.h    **** 	if (rv)
 5624              		.loc 2 42 7 view .LVU1447
 5625 001a 2000     		movs	r0, r4
 5626 001c 9847     		blx	r3
 5627              	.LVL459:
  43:Inc/tcpm.h    **** 		return rv;
 5628              		.loc 2 43 2 is_stmt 1 view .LVU1448
  43:Inc/tcpm.h    **** 		return rv;
 5629              		.loc 2 43 5 is_stmt 0 view .LVU1449
 5630 001e 0028     		cmp	r0, #0
 5631 0020 05D1     		bne	.L335
  47:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
 5632              		.loc 2 47 2 is_stmt 1 view .LVU1450
  47:Inc/tcpm.h    **** 		rv = board_tcpc_post_init(port);
 5633              		.loc 2 47 5 is_stmt 0 view .LVU1451
 5634 0022 3A4B     		ldr	r3, .L348+4
 5635 0024 002B     		cmp	r3, #0
 5636 0026 02D0     		beq	.L335
  48:Inc/tcpm.h    **** 
 5637              		.loc 2 48 3 is_stmt 1 view .LVU1452
  48:Inc/tcpm.h    **** 
 5638              		.loc 2 48 8 is_stmt 0 view .LVU1453
 5639 0028 2000     		movs	r0, r4
 5640              	.LVL460:
  48:Inc/tcpm.h    **** 
 5641              		.loc 2 48 8 view .LVU1454
 5642 002a FFF7FEFF 		bl	board_tcpc_post_init
 5643              	.LVL461:
 5644              	.L335:
  48:Inc/tcpm.h    **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 160


 5645              		.loc 2 48 8 view .LVU1455
 5646              	.LBE530:
 5647              	.LBE529:
2061:Src/usb_pd_protocol.c **** 
2062:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2063:Src/usb_pd_protocol.c **** 	//pd_partner_port_reset(port);
2064:Src/usb_pd_protocol.c **** #endif
2065:Src/usb_pd_protocol.c **** 
2066:Src/usb_pd_protocol.c **** 	CPRINTS("TCPC p%d init %s", port, res ? "failed" : "ready");
 5648              		.loc 1 2066 61 is_stmt 1 view .LVU1456
2067:Src/usb_pd_protocol.c **** 	this_state = res ? PD_STATE_SUSPENDED : PD_DEFAULT_STATE(port);
 5649              		.loc 1 2067 2 view .LVU1457
 5650              		.loc 1 2067 40 is_stmt 0 view .LVU1458
 5651 002e 0028     		cmp	r0, #0
 5652 0030 4AD0     		beq	.L344
 5653 0032 0122     		movs	r2, #1
 5654              	.L336:
 5655              		.loc 1 2067 13 discriminator 4 view .LVU1459
 5656 0034 364B     		ldr	r3, .L348+8
 5657 0036 1A70     		strb	r2, [r3]
2068:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
2069:Src/usb_pd_protocol.c **** 	if (!res) {
 5658              		.loc 1 2069 2 is_stmt 1 discriminator 4 view .LVU1460
 5659              		.loc 1 2069 5 is_stmt 0 discriminator 4 view .LVU1461
 5660 0038 0028     		cmp	r0, #0
 5661 003a 0AD1     		bne	.L337
 5662              	.LBB531:
2070:Src/usb_pd_protocol.c **** 		struct ec_response_pd_chip_info *info;
 5663              		.loc 1 2070 3 is_stmt 1 view .LVU1462
2071:Src/usb_pd_protocol.c **** 		tcpm_get_chip_info(port, 0, &info);
 5664              		.loc 1 2071 3 view .LVU1463
 5665              	.LVL462:
 5666              	.LBB532:
 5667              	.LBI532:
 108:Inc/tcpm.h    **** }
 109:Inc/tcpm.h    **** 
 110:Inc/tcpm.h    **** static inline void tcpc_alert(int port)
 111:Inc/tcpm.h    **** {
 112:Inc/tcpm.h    **** 	tcpc_config[port].drv->tcpc_alert(port);
 113:Inc/tcpm.h    **** }
 114:Inc/tcpm.h    **** 
 115:Inc/tcpm.h    **** static inline void tcpc_discharge_vbus(int port, int enable)
 116:Inc/tcpm.h    **** {
 117:Inc/tcpm.h    **** 	tcpc_config[port].drv->tcpc_discharge_vbus(port, enable);
 118:Inc/tcpm.h    **** }
 119:Inc/tcpm.h    **** 
 120:Inc/tcpm.h    **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
 121:Inc/tcpm.h    **** static inline int tcpm_auto_toggle_supported(int port)
 122:Inc/tcpm.h    **** {
 123:Inc/tcpm.h    **** 	return !!tcpc_config[port].drv->drp_toggle;
 124:Inc/tcpm.h    **** }
 125:Inc/tcpm.h    **** 
 126:Inc/tcpm.h    **** static inline int tcpm_set_drp_toggle(int port, int enable)
 127:Inc/tcpm.h    **** {
 128:Inc/tcpm.h    **** 	return tcpc_config[port].drv->drp_toggle(port, enable);
 129:Inc/tcpm.h    **** }
 130:Inc/tcpm.h    **** #endif
ARM GAS  /tmp/ccoQIC4J.s 			page 161


 131:Inc/tcpm.h    **** 
 132:Inc/tcpm.h    **** #ifdef CONFIG_CMD_I2C_STRESS_TEST_TCPC
 133:Inc/tcpm.h    **** static inline int tcpc_i2c_read(const int port, const int addr,
 134:Inc/tcpm.h    **** 				const int reg, int *data)
 135:Inc/tcpm.h    **** {
 136:Inc/tcpm.h    **** 	return tcpc_read(port, reg, data);
 137:Inc/tcpm.h    **** }
 138:Inc/tcpm.h    **** 
 139:Inc/tcpm.h    **** static inline int tcpc_i2c_write(const int port, const int addr,
 140:Inc/tcpm.h    **** 				 const int reg, int data)
 141:Inc/tcpm.h    **** {
 142:Inc/tcpm.h    **** 	return tcpc_write(port, reg, data);
 143:Inc/tcpm.h    **** }
 144:Inc/tcpm.h    **** #endif
 145:Inc/tcpm.h    **** 
 146:Inc/tcpm.h    **** static inline int tcpm_get_chip_info(int port, int renew,
 5668              		.loc 2 146 19 view .LVU1464
 5669              	.LBB533:
 147:Inc/tcpm.h    **** 				     struct ec_response_pd_chip_info **info)
 148:Inc/tcpm.h    **** {
 149:Inc/tcpm.h    **** 	if (tcpc_config[port].drv->get_chip_info)
 5670              		.loc 2 149 2 view .LVU1465
 5671              		.loc 2 149 23 is_stmt 0 view .LVU1466
 5672 003c 2201     		lsls	r2, r4, #4
 5673 003e 324B     		ldr	r3, .L348
 5674 0040 9B18     		adds	r3, r3, r2
 5675 0042 9B68     		ldr	r3, [r3, #8]
 5676              		.loc 2 149 27 view .LVU1467
 5677 0044 9B6B     		ldr	r3, [r3, #56]
 5678              		.loc 2 149 5 view .LVU1468
 5679 0046 002B     		cmp	r3, #0
 5680 0048 03D0     		beq	.L337
 150:Inc/tcpm.h    **** 		return tcpc_config[port].drv->get_chip_info(port, renew, info);
 5681              		.loc 2 150 3 is_stmt 1 view .LVU1469
 5682              		.loc 2 150 10 is_stmt 0 view .LVU1470
 5683 004a 01AA     		add	r2, sp, #4
 5684              	.LVL463:
 5685              		.loc 2 150 10 view .LVU1471
 5686 004c 0021     		movs	r1, #0
 5687 004e 2000     		movs	r0, r4
 5688 0050 9847     		blx	r3
 5689              	.LVL464:
 5690              		.loc 2 150 10 view .LVU1472
 5691              	.LBE533:
 5692              	.LBE532:
2072:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d VID:0x%x PID:0x%x DID:0x%x FWV:0x%lx",
2073:Src/usb_pd_protocol.c **** 			port, info->vendor_id, info->product_id,
2074:Src/usb_pd_protocol.c **** 			info->device_id, info->fw_version_number);
 5693              		.loc 1 2074 45 is_stmt 1 view .LVU1473
 5694              	.L337:
 5695              		.loc 1 2074 45 is_stmt 0 view .LVU1474
 5696              	.LBE531:
2075:Src/usb_pd_protocol.c **** 	}
2076:Src/usb_pd_protocol.c **** #endif
2077:Src/usb_pd_protocol.c **** 
2078:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
2079:Src/usb_pd_protocol.c **** 	/* Set Revision to highest */
ARM GAS  /tmp/ccoQIC4J.s 			page 162


2080:Src/usb_pd_protocol.c **** 	pd[port].rev = PD_REV30;
2081:Src/usb_pd_protocol.c **** 	pd_ca_reset(port);
2082:Src/usb_pd_protocol.c **** #endif
2083:Src/usb_pd_protocol.c **** 
2084:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2085:Src/usb_pd_protocol.c **** 	/*
2086:Src/usb_pd_protocol.c **** 	 * If VBUS is high, then initialize flag for VBUS has always been
2087:Src/usb_pd_protocol.c **** 	 * present. This flag is used to maintain a PD connection after a
2088:Src/usb_pd_protocol.c **** 	 * reset by sending a soft reset.
2089:Src/usb_pd_protocol.c **** 	 */
2090:Src/usb_pd_protocol.c **** 	//pd[port].flags = pd_is_vbus_present(port) ? PD_FLAGS_VBUS_NEVER_LOW : 0;
2091:Src/usb_pd_protocol.c **** 	pd[port].flags = 0;
 5697              		.loc 1 2091 2 is_stmt 1 view .LVU1475
 5698              		.loc 1 2091 17 is_stmt 0 view .LVU1476
 5699 0052 304B     		ldr	r3, .L348+12
 5700 0054 9846     		mov	r8, r3
 5701 0056 E301     		lsls	r3, r4, #7
 5702 0058 9946     		mov	r9, r3
 5703 005a 4546     		mov	r5, r8
 5704 005c 4D44     		add	r5, r5, r9
 5705 005e 0026     		movs	r6, #0
 5706 0060 AE60     		str	r6, [r5, #8]
2092:Src/usb_pd_protocol.c **** #endif
2093:Src/usb_pd_protocol.c **** 
2094:Src/usb_pd_protocol.c **** 	/* Disable TCPC RX until connection is established */
2095:Src/usb_pd_protocol.c **** 	tcpm_set_rx_enable(port, 0);
 5707              		.loc 1 2095 2 is_stmt 1 view .LVU1477
 5708              	.LVL465:
 5709              	.LBB534:
 5710              	.LBI534:
  94:Inc/tcpm.h    **** {
 5711              		.loc 2 94 19 view .LVU1478
 5712              	.LBB535:
  96:Inc/tcpm.h    **** }
 5713              		.loc 2 96 2 view .LVU1479
  96:Inc/tcpm.h    **** }
 5714              		.loc 2 96 26 is_stmt 0 view .LVU1480
 5715 0062 2201     		lsls	r2, r4, #4
 5716 0064 284B     		ldr	r3, .L348
 5717 0066 9B18     		adds	r3, r3, r2
 5718 0068 9F68     		ldr	r7, [r3, #8]
  96:Inc/tcpm.h    **** }
 5719              		.loc 2 96 9 view .LVU1481
 5720 006a 0021     		movs	r1, #0
 5721 006c 2000     		movs	r0, r4
 5722 006e 7B6A     		ldr	r3, [r7, #36]
 5723 0070 9847     		blx	r3
 5724              	.LVL466:
  96:Inc/tcpm.h    **** }
 5725              		.loc 2 96 9 view .LVU1482
 5726              	.LBE535:
 5727              	.LBE534:
2096:Src/usb_pd_protocol.c **** 
2097:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
2098:Src/usb_pd_protocol.c **** 	/* Initialize USB mux to its default state */
2099:Src/usb_pd_protocol.c **** 	usb_mux_init(port);
2100:Src/usb_pd_protocol.c **** #endif
ARM GAS  /tmp/ccoQIC4J.s 			page 163


2101:Src/usb_pd_protocol.c **** 
2102:Src/usb_pd_protocol.c **** 	/* Initialize PD protocol state variables for each port. */
2103:Src/usb_pd_protocol.c **** 	pd[port].power_role = PD_ROLE_DEFAULT(port);
 5728              		.loc 1 2103 2 is_stmt 1 view .LVU1483
 5729              		.loc 1 2103 22 is_stmt 0 view .LVU1484
 5730 0072 4346     		mov	r3, r8
 5731 0074 4A46     		mov	r2, r9
 5732 0076 D654     		strb	r6, [r2, r3]
2104:Src/usb_pd_protocol.c **** 	pd[port].vdm_state = VDM_STATE_DONE;
 5733              		.loc 1 2104 2 is_stmt 1 view .LVU1485
 5734              		.loc 1 2104 21 is_stmt 0 view .LVU1486
 5735 0078 2B00     		movs	r3, r5
 5736 007a 4833     		adds	r3, r3, #72
 5737 007c 1E70     		strb	r6, [r3]
2105:Src/usb_pd_protocol.c **** 	set_state(port, this_state);
 5738              		.loc 1 2105 2 is_stmt 1 view .LVU1487
 5739 007e 244B     		ldr	r3, .L348+8
 5740 0080 1B78     		ldrb	r3, [r3]
 5741              	.LVL467:
 5742              	.LBB536:
 5743              	.LBI536:
 326:Src/usb_pd_protocol.c **** {
 5744              		.loc 1 326 20 view .LVU1488
 5745              	.LBB537:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5746              		.loc 1 328 2 view .LVU1489
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 5747              		.loc 1 328 17 is_stmt 0 view .LVU1490
 5748 0082 2A79     		ldrb	r2, [r5, #4]
 5749              	.LVL468:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 5750              		.loc 1 333 2 is_stmt 1 view .LVU1491
 5751              	.LBB538:
 5752              	.LBI538:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 5753              		.loc 1 261 20 view .LVU1492
 5754              	.LBB539:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5755              		.loc 1 265 2 view .LVU1493
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 5756              		.loc 1 265 19 is_stmt 0 view .LVU1494
 5757 0084 0020     		movs	r0, #0
 5758 0086 0021     		movs	r1, #0
 5759 0088 2861     		str	r0, [r5, #16]
 5760 008a 6961     		str	r1, [r5, #20]
 266:Src/usb_pd_protocol.c **** }
 5761              		.loc 1 266 2 is_stmt 1 view .LVU1495
 266:Src/usb_pd_protocol.c **** }
 5762              		.loc 1 266 25 is_stmt 0 view .LVU1496
 5763 008c EE71     		strb	r6, [r5, #7]
 5764              	.LVL469:
 266:Src/usb_pd_protocol.c **** }
 5765              		.loc 1 266 25 view .LVU1497
 5766              	.LBE539:
 5767              	.LBE538:
 334:Src/usb_pd_protocol.c **** 
 5768              		.loc 1 334 2 is_stmt 1 view .LVU1498
ARM GAS  /tmp/ccoQIC4J.s 			page 164


 334:Src/usb_pd_protocol.c **** 
 5769              		.loc 1 334 22 is_stmt 0 view .LVU1499
 5770 008e 2B71     		strb	r3, [r5, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 5771              		.loc 1 336 2 is_stmt 1 view .LVU1500
 336:Src/usb_pd_protocol.c **** 		return;
 5772              		.loc 1 336 5 is_stmt 0 view .LVU1501
 5773 0090 9342     		cmp	r3, r2
 5774 0092 07D0     		beq	.L339
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5775              		.loc 1 347 2 is_stmt 1 view .LVU1502
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5776              		.loc 1 347 5 is_stmt 0 view .LVU1503
 5777 0094 022A     		cmp	r2, #2
 5778 0096 19D0     		beq	.L345
 5779              	.L340:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 5780              		.loc 1 348 48 view .LVU1504
 5781 0098 0E2A     		cmp	r2, #14
 5782 009a 1AD0     		beq	.L346
 5783              	.L341:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 5784              		.loc 1 353 2 is_stmt 1 view .LVU1505
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 5785              		.loc 1 353 5 is_stmt 0 view .LVU1506
 5786 009c 0E2B     		cmp	r3, #14
 5787 009e 1BD0     		beq	.L342
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 5788              		.loc 1 353 46 view .LVU1507
 5789 00a0 022B     		cmp	r3, #2
 5790 00a2 19D0     		beq	.L342
 5791              	.LVL470:
 5792              	.L339:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 5793              		.loc 1 353 46 view .LVU1508
 5794              	.LBE537:
 5795              	.LBE536:
2106:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT
2107:Src/usb_pd_protocol.c **** 	ASSERT(PD_ROLE_DEFAULT(port) == PD_ROLE_SINK);
2108:Src/usb_pd_protocol.c **** 	tcpm_select_rp_value(port, CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT);
2109:Src/usb_pd_protocol.c **** #else
2110:Src/usb_pd_protocol.c **** 	tcpm_select_rp_value(port, CONFIG_USB_PD_PULLUP);
 5796              		.loc 1 2110 2 is_stmt 1 view .LVU1509
 5797              	.LBB543:
 5798              	.LBI543:
  68:Inc/tcpm.h    **** {
 5799              		.loc 2 68 19 view .LVU1510
 5800              	.LBB544:
  70:Inc/tcpm.h    **** }
 5801              		.loc 2 70 2 view .LVU1511
  70:Inc/tcpm.h    **** }
 5802              		.loc 2 70 9 is_stmt 0 view .LVU1512
 5803 00a4 0021     		movs	r1, #0
 5804 00a6 2000     		movs	r0, r4
 5805 00a8 3B69     		ldr	r3, [r7, #16]
 5806 00aa 9847     		blx	r3
 5807              	.LVL471:
ARM GAS  /tmp/ccoQIC4J.s 			page 165


  70:Inc/tcpm.h    **** }
 5808              		.loc 2 70 9 view .LVU1513
 5809              	.LBE544:
 5810              	.LBE543:
2111:Src/usb_pd_protocol.c **** #endif
2112:Src/usb_pd_protocol.c **** 	tcpm_set_cc(port, PD_ROLE_DEFAULT(port) == PD_ROLE_SOURCE ?
 5811              		.loc 1 2112 2 is_stmt 1 view .LVU1514
 5812              	.LBB545:
 5813              	.LBI545:
  73:Inc/tcpm.h    **** {
 5814              		.loc 2 73 19 view .LVU1515
 5815              	.LBB546:
  75:Inc/tcpm.h    **** }
 5816              		.loc 2 75 2 view .LVU1516
  75:Inc/tcpm.h    **** }
 5817              		.loc 2 75 30 is_stmt 0 view .LVU1517
 5818 00ac 7B69     		ldr	r3, [r7, #20]
  75:Inc/tcpm.h    **** }
 5819              		.loc 2 75 9 view .LVU1518
 5820 00ae 0221     		movs	r1, #2
 5821 00b0 2000     		movs	r0, r4
 5822 00b2 9847     		blx	r3
 5823              	.LVL472:
  75:Inc/tcpm.h    **** }
 5824              		.loc 2 75 9 view .LVU1519
 5825              	.LBE546:
 5826              	.LBE545:
2113:Src/usb_pd_protocol.c **** 		    TYPEC_CC_RP : TYPEC_CC_RD);
2114:Src/usb_pd_protocol.c **** 
2115:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_ALT_MODE_DFP
2116:Src/usb_pd_protocol.c **** 	/* Initialize PD Policy engine */
2117:Src/usb_pd_protocol.c **** 	pd_dfp_pe_init(port);
2118:Src/usb_pd_protocol.c **** #endif
2119:Src/usb_pd_protocol.c **** 
2120:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
2121:Src/usb_pd_protocol.c **** 	/* Initialize PD and type-C supplier current limits to 0 */
2122:Src/usb_pd_protocol.c **** 	pd_set_input_current_limit(port, 0, 0);
 5827              		.loc 1 2122 2 is_stmt 1 view .LVU1520
 5828 00b4 0022     		movs	r2, #0
 5829 00b6 0021     		movs	r1, #0
 5830 00b8 2000     		movs	r0, r4
 5831 00ba FFF7FEFF 		bl	pd_set_input_current_limit
 5832              	.LVL473:
2123:Src/usb_pd_protocol.c **** 	//typec_set_input_current_limit(port, 0, 0);
2124:Src/usb_pd_protocol.c **** 	//charge_manager_update_dualrole(port, CAP_UNKNOWN);
2125:Src/usb_pd_protocol.c **** #endif
2126:Src/usb_pd_protocol.c **** }
 5833              		.loc 1 2126 1 is_stmt 0 view .LVU1521
 5834 00be 03B0     		add	sp, sp, #12
 5835              		@ sp needed
 5836              	.LVL474:
 5837              		.loc 1 2126 1 view .LVU1522
 5838 00c0 0CBC     		pop	{r2, r3}
 5839 00c2 9046     		mov	r8, r2
 5840 00c4 9946     		mov	r9, r3
 5841 00c6 F0BD     		pop	{r4, r5, r6, r7, pc}
 5842              	.LVL475:
ARM GAS  /tmp/ccoQIC4J.s 			page 166


 5843              	.L344:
2067:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
 5844              		.loc 1 2067 40 view .LVU1523
 5845 00c8 0222     		movs	r2, #2
 5846 00ca B3E7     		b	.L336
 5847              	.LVL476:
 5848              	.L345:
 5849              	.LBB547:
 5850              	.LBB542:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 5851              		.loc 1 347 47 view .LVU1524
 5852 00cc 0E2B     		cmp	r3, #14
 5853 00ce E3D1     		bne	.L340
 5854 00d0 E8E7     		b	.L339
 5855              	.L346:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 5856              		.loc 1 349 47 view .LVU1525
 5857 00d2 022B     		cmp	r3, #2
 5858 00d4 E2D1     		bne	.L341
 5859 00d6 E5E7     		b	.L339
 5860              	.L342:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5861              		.loc 1 356 3 is_stmt 1 view .LVU1526
 5862 00d8 0022     		movs	r2, #0
 5863              	.LVL477:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 5864              		.loc 1 356 3 is_stmt 0 view .LVU1527
 5865 00da 0021     		movs	r1, #0
 5866 00dc 2000     		movs	r0, r4
 5867 00de FFF7FEFF 		bl	pd_set_input_current_limit
 5868              	.LVL478:
 373:Src/usb_pd_protocol.c **** 			/*
 5869              		.loc 1 373 3 is_stmt 1 view .LVU1528
 373:Src/usb_pd_protocol.c **** 			/*
 5870              		.loc 1 373 15 is_stmt 0 view .LVU1529
 5871 00e2 E301     		lsls	r3, r4, #7
 5872 00e4 0B4A     		ldr	r2, .L348+12
 5873 00e6 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 5874              		.loc 1 373 6 view .LVU1530
 5875 00e8 012B     		cmp	r3, #1
 5876 00ea 08D0     		beq	.L347
 5877              	.L343:
 405:Src/usb_pd_protocol.c **** 	}
 5878              		.loc 1 405 3 is_stmt 1 view .LVU1531
 5879              	.LVL479:
 5880              	.LBB540:
 5881              	.LBI540:
  94:Inc/tcpm.h    **** {
 5882              		.loc 2 94 19 view .LVU1532
 5883              	.LBB541:
  96:Inc/tcpm.h    **** }
 5884              		.loc 2 96 2 view .LVU1533
  96:Inc/tcpm.h    **** }
 5885              		.loc 2 96 26 is_stmt 0 view .LVU1534
 5886 00ec 2201     		lsls	r2, r4, #4
 5887 00ee 064B     		ldr	r3, .L348
ARM GAS  /tmp/ccoQIC4J.s 			page 167


 5888 00f0 9B18     		adds	r3, r3, r2
 5889 00f2 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 5890              		.loc 2 96 30 view .LVU1535
 5891 00f4 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 5892              		.loc 2 96 9 view .LVU1536
 5893 00f6 0021     		movs	r1, #0
 5894 00f8 2000     		movs	r0, r4
 5895 00fa 9847     		blx	r3
 5896              	.LVL480:
 5897 00fc D2E7     		b	.L339
 5898              	.LVL481:
 5899              	.L347:
  96:Inc/tcpm.h    **** }
 5900              		.loc 2 96 9 view .LVU1537
 5901              	.LBE541:
 5902              	.LBE540:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 5903              		.loc 1 378 4 is_stmt 1 view .LVU1538
 5904 00fe 2000     		movs	r0, r4
 5905 0100 FFF7FEFF 		bl	pd_power_supply_reset
 5906              	.LVL482:
 5907 0104 F2E7     		b	.L343
 5908              	.L349:
 5909 0106 C046     		.align	2
 5910              	.L348:
 5911 0108 00000000 		.word	tcpc_config
 5912 010c 00000000 		.word	board_tcpc_post_init
 5913 0110 00000000 		.word	.LANCHOR1
 5914 0114 00000000 		.word	pd
 5915              	.LBE542:
 5916              	.LBE547:
 5917              		.cfi_endproc
 5918              	.LFE66:
 5920              		.section	.text.pd_run_state_machine,"ax",%progbits
 5921              		.align	1
 5922              		.global	pd_run_state_machine
 5923              		.syntax unified
 5924              		.code	16
 5925              		.thumb_func
 5926              		.fpu softvfp
 5928              	pd_run_state_machine:
 5929              	.LVL483:
 5930              	.LFB67:
2127:Src/usb_pd_protocol.c **** 
2128:Src/usb_pd_protocol.c **** void pd_run_state_machine(int port)
2129:Src/usb_pd_protocol.c **** {
 5931              		.loc 1 2129 1 view -0
 5932              		.cfi_startproc
 5933              		@ args = 0, pretend = 0, frame = 16
 5934              		@ frame_needed = 0, uses_anonymous_args = 0
 5935              		.loc 1 2129 1 is_stmt 0 view .LVU1540
 5936 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 5937              	.LCFI34:
 5938              		.cfi_def_cfa_offset 20
 5939              		.cfi_offset 4, -20
ARM GAS  /tmp/ccoQIC4J.s 			page 168


 5940              		.cfi_offset 5, -16
 5941              		.cfi_offset 6, -12
 5942              		.cfi_offset 7, -8
 5943              		.cfi_offset 14, -4
 5944 0002 C646     		mov	lr, r8
 5945 0004 00B5     		push	{lr}
 5946              	.LCFI35:
 5947              		.cfi_def_cfa_offset 24
 5948              		.cfi_offset 8, -24
 5949 0006 86B0     		sub	sp, sp, #24
 5950              	.LCFI36:
 5951              		.cfi_def_cfa_offset 48
 5952 0008 0600     		movs	r6, r0
2130:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_REV30
2131:Src/usb_pd_protocol.c **** 	/* send any pending messages */
2132:Src/usb_pd_protocol.c **** 	pd_ca_send_pending(port);
2133:Src/usb_pd_protocol.c **** #endif
2134:Src/usb_pd_protocol.c **** 	/* process VDM messages last */
2135:Src/usb_pd_protocol.c **** 	pd_vdm_send_state_machine(port);
 5953              		.loc 1 2135 2 is_stmt 1 view .LVU1541
 5954 000a FFF7FEFF 		bl	pd_vdm_send_state_machine
 5955              	.LVL484:
2136:Src/usb_pd_protocol.c **** 
2137:Src/usb_pd_protocol.c **** 	/* Verify board specific health status : current, voltages... */
2138:Src/usb_pd_protocol.c **** 	res = pd_board_checks();
 5956              		.loc 1 2138 2 view .LVU1542
 5957              		.loc 1 2138 8 is_stmt 0 view .LVU1543
 5958 000e FFF7FEFF 		bl	pd_board_checks
 5959              	.LVL485:
2139:Src/usb_pd_protocol.c **** 	if (res != EC_SUCCESS) {
 5960              		.loc 1 2139 2 is_stmt 1 view .LVU1544
 5961              		.loc 1 2139 5 is_stmt 0 view .LVU1545
 5962 0012 0028     		cmp	r0, #0
 5963 0014 24D1     		bne	.L519
 5964              	.L351:
2140:Src/usb_pd_protocol.c **** 		/* cut the power */
2141:Src/usb_pd_protocol.c **** 		pd_execute_hard_reset(port);
2142:Src/usb_pd_protocol.c **** 		/* notify the other side of the issue */
2143:Src/usb_pd_protocol.c **** 		pd_transmit(port, TCPC_TX_HARD_RESET, 0, NULL);
2144:Src/usb_pd_protocol.c **** 	}
2145:Src/usb_pd_protocol.c **** 
2146:Src/usb_pd_protocol.c **** 	/* wait for next event/packet or timeout expiration */
2147:Src/usb_pd_protocol.c **** 	// getting rid of task stuff
2148:Src/usb_pd_protocol.c **** 	//evt = task_wait_event(timeout);
2149:Src/usb_pd_protocol.c **** 
2150:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2151:Src/usb_pd_protocol.c **** 	if (evt & PD_EVENT_UPDATE_DUAL_ROLE)
 5965              		.loc 1 2151 2 is_stmt 1 view .LVU1546
2152:Src/usb_pd_protocol.c **** 		pd_update_dual_role_config(port);
2153:Src/usb_pd_protocol.c **** #endif
2154:Src/usb_pd_protocol.c **** 
2155:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC
2156:Src/usb_pd_protocol.c **** 	/*
2157:Src/usb_pd_protocol.c **** 		* run port controller task to check CC and/or read incoming
2158:Src/usb_pd_protocol.c **** 		* messages
2159:Src/usb_pd_protocol.c **** 		*/
2160:Src/usb_pd_protocol.c **** 	tcpc_run(port, evt);
ARM GAS  /tmp/ccoQIC4J.s 			page 169


2161:Src/usb_pd_protocol.c **** #else
2162:Src/usb_pd_protocol.c **** 	/* if TCPC has reset, then need to initialize it again */
2163:Src/usb_pd_protocol.c **** 	if (evt & PD_EVENT_TCPC_RESET) {
 5966              		.loc 1 2163 2 view .LVU1547
2164:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d reset!", port);
2165:Src/usb_pd_protocol.c **** 		if (tcpm_init(port) != EC_SUCCESS)
2166:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d init failed", port);
2167:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
2168:Src/usb_pd_protocol.c **** 	}
2169:Src/usb_pd_protocol.c **** 
2170:Src/usb_pd_protocol.c **** 	if ((evt & PD_EVENT_TCPC_RESET) &&
2171:Src/usb_pd_protocol.c **** 		(pd[port].task_state != PD_STATE_DRP_AUTO_TOGGLE)) {
2172:Src/usb_pd_protocol.c **** #endif
2173:Src/usb_pd_protocol.c **** 		/* Ensure CC termination is default */
2174:Src/usb_pd_protocol.c **** 		tcpm_set_cc(port, PD_ROLE_DEFAULT(port) ==
2175:Src/usb_pd_protocol.c **** 				PD_ROLE_SOURCE ? TYPEC_CC_RP : TYPEC_CC_RD);
2176:Src/usb_pd_protocol.c **** 
2177:Src/usb_pd_protocol.c **** 		/*
2178:Src/usb_pd_protocol.c **** 			* If we have a stable contract in the default role,
2179:Src/usb_pd_protocol.c **** 			* then simply update TCPC with some missing info
2180:Src/usb_pd_protocol.c **** 			* so that we can continue without resetting PD comms.
2181:Src/usb_pd_protocol.c **** 			* Otherwise, go to the default disconnected state
2182:Src/usb_pd_protocol.c **** 			* and force renegotiation.
2183:Src/usb_pd_protocol.c **** 			*/
2184:Src/usb_pd_protocol.c **** 		if (pd[port].vdm_state == VDM_STATE_DONE && (
2185:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2186:Src/usb_pd_protocol.c **** 			    (PD_ROLE_DEFAULT(port) == PD_ROLE_SINK &&
2187:Src/usb_pd_protocol.c **** 			    pd[port].task_state == PD_STATE_SNK_READY) ||
2188:Src/usb_pd_protocol.c **** #endif
2189:Src/usb_pd_protocol.c **** 			    (PD_ROLE_DEFAULT(port) == PD_ROLE_SOURCE &&
2190:Src/usb_pd_protocol.c **** 			    pd[port].task_state == PD_STATE_SRC_READY))) {
2191:Src/usb_pd_protocol.c **** 			tcpm_set_polarity(port, pd[port].polarity);
2192:Src/usb_pd_protocol.c **** 			tcpm_set_msg_header(port, pd[port].power_role,
2193:Src/usb_pd_protocol.c **** 						pd[port].data_role);
2194:Src/usb_pd_protocol.c **** 			tcpm_set_rx_enable(port, 1);
2195:Src/usb_pd_protocol.c **** 		} else {
2196:Src/usb_pd_protocol.c **** 			/* Ensure state variables are at default */
2197:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_DEFAULT(port);
2198:Src/usb_pd_protocol.c **** 			pd[port].vdm_state = VDM_STATE_DONE;
2199:Src/usb_pd_protocol.c **** 			set_state(port, PD_DEFAULT_STATE(port));
2200:Src/usb_pd_protocol.c **** 		}
2201:Src/usb_pd_protocol.c **** 	}
2202:Src/usb_pd_protocol.c **** #endif
2203:Src/usb_pd_protocol.c **** 
2204:Src/usb_pd_protocol.c **** 	/* process any potential incoming message */
2205:Src/usb_pd_protocol.c **** 	incoming_packet = evt & PD_EVENT_RX;
 5967              		.loc 1 2205 2 view .LVU1548
 5968              		.loc 1 2205 18 is_stmt 0 view .LVU1549
 5969 0016 D94B     		ldr	r3, .L581
 5970 0018 0022     		movs	r2, #0
 5971 001a 1A60     		str	r2, [r3]
2206:Src/usb_pd_protocol.c **** 	//if (incoming_packet) {
2207:Src/usb_pd_protocol.c **** 		if (!tcpm_get_message(port, payload, &head))
 5972              		.loc 1 2207 3 is_stmt 1 view .LVU1550
 5973              	.LVL486:
 5974              	.LBB855:
 5975              	.LBI855:
ARM GAS  /tmp/ccoQIC4J.s 			page 170


  99:Inc/tcpm.h    **** {
 5976              		.loc 2 99 19 view .LVU1551
 5977              	.LBB856:
 101:Inc/tcpm.h    **** }
 5978              		.loc 2 101 2 view .LVU1552
 101:Inc/tcpm.h    **** }
 5979              		.loc 2 101 26 is_stmt 0 view .LVU1553
 5980 001c 3201     		lsls	r2, r6, #4
 5981 001e D84B     		ldr	r3, .L581+4
 5982 0020 9B18     		adds	r3, r3, r2
 5983 0022 9F68     		ldr	r7, [r3, #8]
 101:Inc/tcpm.h    **** }
 5984              		.loc 2 101 9 view .LVU1554
 5985 0024 D74A     		ldr	r2, .L581+8
 5986 0026 D849     		ldr	r1, .L581+12
 5987 0028 3000     		movs	r0, r6
 5988 002a BB6A     		ldr	r3, [r7, #40]
 5989 002c 9847     		blx	r3
 5990              	.LVL487:
 101:Inc/tcpm.h    **** }
 5991              		.loc 2 101 9 view .LVU1555
 5992              	.LBE856:
 5993              	.LBE855:
 5994              		.loc 1 2207 6 view .LVU1556
 5995 002e 0028     		cmp	r0, #0
 5996 0030 20D0     		beq	.L520
 5997              	.L352:
2208:Src/usb_pd_protocol.c **** 			handle_request(port, head, payload);
2209:Src/usb_pd_protocol.c **** 	//}
2210:Src/usb_pd_protocol.c **** 
2211:Src/usb_pd_protocol.c **** 	if (pd[port].req_suspend_state)
 5998              		.loc 1 2211 2 is_stmt 1 view .LVU1557
 5999              		.loc 1 2211 14 is_stmt 0 view .LVU1558
 6000 0032 F201     		lsls	r2, r6, #7
 6001 0034 D54B     		ldr	r3, .L581+16
 6002 0036 9B18     		adds	r3, r3, r2
 6003 0038 9B79     		ldrb	r3, [r3, #6]
 6004              		.loc 1 2211 5 view .LVU1559
 6005 003a 002B     		cmp	r3, #0
 6006 003c 21D1     		bne	.L521
 6007              	.L353:
2212:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SUSPENDED);
2213:Src/usb_pd_protocol.c **** 
2214:Src/usb_pd_protocol.c **** 	/* if nothing to do, verify the state of the world in 500ms */
2215:Src/usb_pd_protocol.c **** 	this_state = pd[port].task_state;
 6008              		.loc 1 2215 2 is_stmt 1 view .LVU1560
 6009              		.loc 1 2215 23 is_stmt 0 view .LVU1561
 6010 003e F201     		lsls	r2, r6, #7
 6011 0040 D24B     		ldr	r3, .L581+16
 6012 0042 9B18     		adds	r3, r3, r2
 6013 0044 1B79     		ldrb	r3, [r3, #4]
 6014              		.loc 1 2215 13 view .LVU1562
 6015 0046 D24A     		ldr	r2, .L581+20
 6016 0048 1370     		strb	r3, [r2]
2216:Src/usb_pd_protocol.c **** 	timeout = 500*MSEC_US;
 6017              		.loc 1 2216 2 is_stmt 1 view .LVU1563
 6018              		.loc 1 2216 10 is_stmt 0 view .LVU1564
ARM GAS  /tmp/ccoQIC4J.s 			page 171


 6019 004a D24A     		ldr	r2, .L581+24
 6020 004c D249     		ldr	r1, .L581+28
 6021 004e 1160     		str	r1, [r2]
2217:Src/usb_pd_protocol.c **** 	switch (this_state) {
 6022              		.loc 1 2217 2 is_stmt 1 view .LVU1565
 6023 0050 202B     		cmp	r3, #32
 6024 0052 01D9     		bls	.LCB5676
 6025 0054 01F006F9 		bl	.L354	@far jump
 6026              	.LCB5676:
 6027 0058 9A00     		lsls	r2, r3, #2
 6028 005a D049     		ldr	r1, .L581+32
 6029 005c 8A58     		ldr	r2, [r1, r2]
 6030 005e 9746     		mov	pc, r2
 6031              		.section	.rodata.pd_run_state_machine,"a",%progbits
 6032              		.align	2
 6033              	.L356:
 6034 0000 64120000 		.word	.L354
 6035 0004 080B0000 		.word	.L387
 6036 0008 7A0B0000 		.word	.L386
 6037 000c 7C0C0000 		.word	.L385
 6038 0010 500E0000 		.word	.L384
 6039 0014 100F0000 		.word	.L383
 6040 0018 08100000 		.word	.L382
 6041 001c 3E100000 		.word	.L381
 6042 0020 6E100000 		.word	.L380
 6043 0024 90110000 		.word	.L379
 6044 0028 3E120000 		.word	.L378
 6045 002c FA120000 		.word	.L377
 6046 0030 28130000 		.word	.L376
 6047 0034 CA130000 		.word	.L375
 6048 0038 98000000 		.word	.L374
 6049 003c E8010000 		.word	.L373
 6050 0040 E2030000 		.word	.L372
 6051 0044 8E040000 		.word	.L371
 6052 0048 D4040000 		.word	.L370
 6053 004c 72050000 		.word	.L369
 6054 0050 A6050000 		.word	.L368
 6055 0054 DA050000 		.word	.L367
 6056 0058 12060000 		.word	.L366
 6057 005c 96060000 		.word	.L365
 6058 0060 FA070000 		.word	.L364
 6059 0064 2E080000 		.word	.L363
 6060 0068 0C090000 		.word	.L362
 6061 006c CE090000 		.word	.L361
 6062 0070 020A0000 		.word	.L360
 6063 0074 3C0A0000 		.word	.L359
 6064 0078 70140000 		.word	.L358
 6065 007c FA140000 		.word	.L357
 6066 0080 A6150000 		.word	.L355
 6067              		.section	.text.pd_run_state_machine
 6068              	.L519:
2141:Src/usb_pd_protocol.c **** 		/* notify the other side of the issue */
 6069              		.loc 1 2141 3 view .LVU1566
 6070 0060 3000     		movs	r0, r6
 6071 0062 FFF7FEFF 		bl	pd_execute_hard_reset
 6072              	.LVL488:
2143:Src/usb_pd_protocol.c **** 	}
ARM GAS  /tmp/ccoQIC4J.s 			page 172


 6073              		.loc 1 2143 3 view .LVU1567
 6074 0066 0023     		movs	r3, #0
 6075 0068 0022     		movs	r2, #0
 6076 006a 0521     		movs	r1, #5
 6077 006c 3000     		movs	r0, r6
 6078 006e FFF7FEFF 		bl	pd_transmit
 6079              	.LVL489:
 6080 0072 D0E7     		b	.L351
 6081              	.L520:
2208:Src/usb_pd_protocol.c **** 	//}
 6082              		.loc 1 2208 4 view .LVU1568
 6083 0074 C34B     		ldr	r3, .L581+8
 6084 0076 1988     		ldrh	r1, [r3]
 6085 0078 C34A     		ldr	r2, .L581+12
 6086 007a 3000     		movs	r0, r6
 6087 007c FFF7FEFF 		bl	handle_request
 6088              	.LVL490:
 6089 0080 D7E7     		b	.L352
 6090              	.L521:
2212:Src/usb_pd_protocol.c **** 
 6091              		.loc 1 2212 3 view .LVU1569
 6092              	.LVL491:
 6093              	.LBB857:
 6094              	.LBI857:
 326:Src/usb_pd_protocol.c **** {
 6095              		.loc 1 326 20 view .LVU1570
 6096              	.LBB858:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6097              		.loc 1 328 2 view .LVU1571
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 6098              		.loc 1 333 2 view .LVU1572
 6099              	.LBB859:
 6100              	.LBI859:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 6101              		.loc 1 261 20 view .LVU1573
 6102              	.LBB860:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6103              		.loc 1 265 2 view .LVU1574
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6104              		.loc 1 265 19 is_stmt 0 view .LVU1575
 6105 0082 C24B     		ldr	r3, .L581+16
 6106 0084 9B18     		adds	r3, r3, r2
 6107 0086 0020     		movs	r0, #0
 6108 0088 0021     		movs	r1, #0
 6109 008a 1861     		str	r0, [r3, #16]
 6110 008c 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 6111              		.loc 1 266 2 is_stmt 1 view .LVU1576
 266:Src/usb_pd_protocol.c **** }
 6112              		.loc 1 266 25 is_stmt 0 view .LVU1577
 6113 008e 0022     		movs	r2, #0
 6114 0090 DA71     		strb	r2, [r3, #7]
 6115              	.LVL492:
 266:Src/usb_pd_protocol.c **** }
 6116              		.loc 1 266 25 view .LVU1578
 6117              	.LBE860:
 6118              	.LBE859:
ARM GAS  /tmp/ccoQIC4J.s 			page 173


 334:Src/usb_pd_protocol.c **** 
 6119              		.loc 1 334 2 is_stmt 1 view .LVU1579
 334:Src/usb_pd_protocol.c **** 
 6120              		.loc 1 334 22 is_stmt 0 view .LVU1580
 6121 0092 0132     		adds	r2, r2, #1
 6122 0094 1A71     		strb	r2, [r3, #4]
 6123              	.LVL493:
 336:Src/usb_pd_protocol.c **** 		return;
 6124              		.loc 1 336 2 is_stmt 1 view .LVU1581
 6125 0096 D2E7     		b	.L353
 6126              	.LVL494:
 6127              	.L374:
 336:Src/usb_pd_protocol.c **** 		return;
 6128              		.loc 1 336 2 is_stmt 0 view .LVU1582
 6129              	.LBE858:
 6130              	.LBE857:
2218:Src/usb_pd_protocol.c **** 	case PD_STATE_DISABLED:
2219:Src/usb_pd_protocol.c **** 		/* Nothing to do */
2220:Src/usb_pd_protocol.c **** 		break;
2221:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_DISCONNECTED:
2222:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
 6131              		.loc 1 2222 3 is_stmt 1 view .LVU1583
 6132              		.loc 1 2222 11 is_stmt 0 view .LVU1584
 6133 0098 BE4B     		ldr	r3, .L581+24
 6134 009a C14A     		ldr	r2, .L581+36
 6135 009c 1A60     		str	r2, [r3]
2223:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
 6136              		.loc 1 2223 3 is_stmt 1 view .LVU1585
 6137              	.LVL495:
 6138              	.LBB861:
 6139              	.LBI861:
  58:Inc/tcpm.h    **** {
 6140              		.loc 2 58 19 view .LVU1586
 6141              	.LBB862:
  60:Inc/tcpm.h    **** }
 6142              		.loc 2 60 2 view .LVU1587
  60:Inc/tcpm.h    **** }
 6143              		.loc 2 60 9 is_stmt 0 view .LVU1588
 6144 009e C14C     		ldr	r4, .L581+40
 6145 00a0 C14A     		ldr	r2, .L581+44
 6146 00a2 2100     		movs	r1, r4
 6147 00a4 3000     		movs	r0, r6
 6148 00a6 BB68     		ldr	r3, [r7, #8]
 6149 00a8 9847     		blx	r3
 6150              	.LVL496:
  60:Inc/tcpm.h    **** }
 6151              		.loc 2 60 9 view .LVU1589
 6152              	.LBE862:
 6153              	.LBE861:
2224:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
2225:Src/usb_pd_protocol.c **** 		/*
2226:Src/usb_pd_protocol.c **** 			* Attempt TCPC auto DRP toggle if it is
2227:Src/usb_pd_protocol.c **** 			* not already auto toggling and not try.src
2228:Src/usb_pd_protocol.c **** 			*/
2229:Src/usb_pd_protocol.c **** 		if (auto_toggle_supported &&
2230:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TCPC_DRP_TOGGLE) &&
2231:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
ARM GAS  /tmp/ccoQIC4J.s 			page 174


2232:Src/usb_pd_protocol.c **** 			(cc1 == TYPEC_CC_VOLT_OPEN &&
2233:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_OPEN)) {
2234:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_DRP_AUTO_TOGGLE);
2235:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC_US;
2236:Src/usb_pd_protocol.c **** 			break;
2237:Src/usb_pd_protocol.c **** 		}
2238:Src/usb_pd_protocol.c **** #endif
2239:Src/usb_pd_protocol.c **** 
2240:Src/usb_pd_protocol.c **** 		/* Vnc monitoring */
2241:Src/usb_pd_protocol.c **** 		if ((cc1 == TYPEC_CC_VOLT_RD ||
 6154              		.loc 1 2241 3 is_stmt 1 view .LVU1590
 6155              		.loc 1 2241 12 is_stmt 0 view .LVU1591
 6156 00aa 2368     		ldr	r3, [r4]
 6157              		.loc 1 2241 6 view .LVU1592
 6158 00ac 022B     		cmp	r3, #2
 6159 00ae 31D0     		beq	.L388
2242:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RD) ||
 6160              		.loc 1 2242 12 discriminator 1 view .LVU1593
 6161 00b0 BD4A     		ldr	r2, .L581+44
 6162 00b2 1268     		ldr	r2, [r2]
2241:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RD) ||
 6163              		.loc 1 2241 32 discriminator 1 view .LVU1594
 6164 00b4 022A     		cmp	r2, #2
 6165 00b6 2DD0     		beq	.L388
 6166              		.loc 1 2242 33 view .LVU1595
 6167 00b8 012B     		cmp	r3, #1
 6168 00ba 29D0     		beq	.L522
 6169              	.L389:
2243:Src/usb_pd_protocol.c **** 			(cc1 == TYPEC_CC_VOLT_RA &&
2244:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RA)) {
2245:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP
2246:Src/usb_pd_protocol.c **** 			/* Enable VBUS */
2247:Src/usb_pd_protocol.c **** 			if (pd_set_power_supply_ready(port))
2248:Src/usb_pd_protocol.c **** 				break;
2249:Src/usb_pd_protocol.c **** #endif
2250:Src/usb_pd_protocol.c **** 			pd[port].cc_state = PD_CC_NONE;
2251:Src/usb_pd_protocol.c **** 			set_state(port,
2252:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_DISCONNECTED_DEBOUNCE);
2253:Src/usb_pd_protocol.c **** 		}
2254:Src/usb_pd_protocol.c **** #if defined(CONFIG_USB_PD_DUAL_ROLE)
2255:Src/usb_pd_protocol.c **** 		/*
2256:Src/usb_pd_protocol.c **** 			* Try.SRC state is embedded here. Wait for SNK
2257:Src/usb_pd_protocol.c **** 			* detect, or if timer expires, transition to
2258:Src/usb_pd_protocol.c **** 			* SNK_DISCONNETED.
2259:Src/usb_pd_protocol.c **** 			*
2260:Src/usb_pd_protocol.c **** 			* If Try.SRC state is not active, then this block
2261:Src/usb_pd_protocol.c **** 			* handles the normal DRP toggle from SRC->SNK
2262:Src/usb_pd_protocol.c **** 			*/
2263:Src/usb_pd_protocol.c **** 		else if ((pd[port].flags & PD_FLAGS_TRY_SRC &&
 6170              		.loc 1 2263 8 is_stmt 1 view .LVU1596
 6171              		.loc 1 2263 21 is_stmt 0 view .LVU1597
 6172 00bc F201     		lsls	r2, r6, #7
 6173 00be B34B     		ldr	r3, .L581+16
 6174 00c0 9B18     		adds	r3, r3, r2
 6175 00c2 9B68     		ldr	r3, [r3, #8]
 6176              		.loc 1 2263 11 view .LVU1598
 6177 00c4 9B04     		lsls	r3, r3, #18
ARM GAS  /tmp/ccoQIC4J.s 			page 175


 6178 00c6 35D4     		bmi	.L523
 6179              	.L390:
2264:Src/usb_pd_protocol.c **** 				get_time().val >= pd[port].try_src_marker) ||
2265:Src/usb_pd_protocol.c **** 				(!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
 6180              		.loc 1 2265 16 view .LVU1599
 6181 00c8 F201     		lsls	r2, r6, #7
 6182 00ca B04B     		ldr	r3, .L581+16
 6183 00cc 9B18     		adds	r3, r3, r2
 6184 00ce 9B68     		ldr	r3, [r3, #8]
2264:Src/usb_pd_protocol.c **** 				get_time().val >= pd[port].try_src_marker) ||
 6185              		.loc 1 2264 48 view .LVU1600
 6186 00d0 9B04     		lsls	r3, r3, #18
 6187 00d2 01D5     		bpl	.LCB5811
 6188 00d4 01F0C6F8 		bl	.L354	@far jump
 6189              	.LCB5811:
2266:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SOURCE &&
 6190              		.loc 1 2266 15 view .LVU1601
 6191 00d8 B44B     		ldr	r3, .L581+48
 6192 00da 1B78     		ldrb	r3, [r3]
2265:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SOURCE &&
 6193              		.loc 1 2265 43 view .LVU1602
 6194 00dc 042B     		cmp	r3, #4
 6195 00de 01D1     		bne	.LCB5815
 6196 00e0 01F0C0F8 		bl	.L354	@far jump
 6197              	.LCB5815:
 6198              		.loc 1 2266 38 view .LVU1603
 6199 00e4 022B     		cmp	r3, #2
 6200 00e6 01D1     		bne	.LCB5817
 6201 00e8 01F0BCF8 		bl	.L354	@far jump
 6202              	.LCB5817:
2267:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FREEZE &&
2268:Src/usb_pd_protocol.c **** 				get_time().val >= next_role_swap)) {
 6203              		.loc 1 2268 5 view .LVU1604
 6204 00ec 04A8     		add	r0, sp, #16
 6205 00ee FFF7FEFF 		bl	get_time
 6206              	.LVL497:
 6207              		.loc 1 2268 15 view .LVU1605
 6208 00f2 0499     		ldr	r1, [sp, #16]
 6209 00f4 059B     		ldr	r3, [sp, #20]
 6210              		.loc 1 2268 20 view .LVU1606
 6211 00f6 AE4A     		ldr	r2, .L581+52
 6212 00f8 1068     		ldr	r0, [r2]
 6213 00fa 5268     		ldr	r2, [r2, #4]
2267:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FREEZE &&
 6214              		.loc 1 2267 32 view .LVU1607
 6215 00fc 9A42     		cmp	r2, r3
 6216 00fe 01D9     		bls	.LCB5826
 6217 0100 01F0B0F8 		bl	.L354	@far jump
 6218              	.LCB5826:
 6219 0104 25D1     		bne	.L391
 6220 0106 8842     		cmp	r0, r1
 6221 0108 01D9     		bls	.LCB5830
 6222 010a 01F0ABF8 		bl	.L354	@far jump
 6223              	.LCB5830:
 6224 010e 20E0     		b	.L391
 6225              	.L522:
2243:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_RA)) {
ARM GAS  /tmp/ccoQIC4J.s 			page 176


 6226              		.loc 1 2243 29 view .LVU1608
 6227 0110 012A     		cmp	r2, #1
 6228 0112 D3D1     		bne	.L389
 6229              	.L388:
2250:Src/usb_pd_protocol.c **** 			set_state(port,
 6230              		.loc 1 2250 4 is_stmt 1 view .LVU1609
2250:Src/usb_pd_protocol.c **** 			set_state(port,
 6231              		.loc 1 2250 22 is_stmt 0 view .LVU1610
 6232 0114 F201     		lsls	r2, r6, #7
 6233 0116 9D4B     		ldr	r3, .L581+16
 6234 0118 9B18     		adds	r3, r3, r2
 6235 011a 1900     		movs	r1, r3
 6236 011c 2831     		adds	r1, r1, #40
 6237 011e 0022     		movs	r2, #0
 6238 0120 0A70     		strb	r2, [r1]
2251:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_DISCONNECTED_DEBOUNCE);
 6239              		.loc 1 2251 4 is_stmt 1 view .LVU1611
 6240              	.LVL498:
 6241              	.LBB863:
 6242              	.LBI863:
 326:Src/usb_pd_protocol.c **** {
 6243              		.loc 1 326 20 view .LVU1612
 6244              	.LBB864:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6245              		.loc 1 328 2 view .LVU1613
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 6246              		.loc 1 333 2 view .LVU1614
 6247              	.LBB865:
 6248              	.LBI865:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 6249              		.loc 1 261 20 view .LVU1615
 6250              	.LBB866:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6251              		.loc 1 265 2 view .LVU1616
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6252              		.loc 1 265 19 is_stmt 0 view .LVU1617
 6253 0122 0020     		movs	r0, #0
 6254 0124 0021     		movs	r1, #0
 6255 0126 1861     		str	r0, [r3, #16]
 6256 0128 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 6257              		.loc 1 266 2 is_stmt 1 view .LVU1618
 266:Src/usb_pd_protocol.c **** }
 6258              		.loc 1 266 25 is_stmt 0 view .LVU1619
 6259 012a DA71     		strb	r2, [r3, #7]
 6260              	.LVL499:
 266:Src/usb_pd_protocol.c **** }
 6261              		.loc 1 266 25 view .LVU1620
 6262              	.LBE866:
 6263              	.LBE865:
 334:Src/usb_pd_protocol.c **** 
 6264              		.loc 1 334 2 is_stmt 1 view .LVU1621
 334:Src/usb_pd_protocol.c **** 
 6265              		.loc 1 334 22 is_stmt 0 view .LVU1622
 6266 012c 0F32     		adds	r2, r2, #15
 6267 012e 1A71     		strb	r2, [r3, #4]
 6268              	.LVL500:
ARM GAS  /tmp/ccoQIC4J.s 			page 177


 336:Src/usb_pd_protocol.c **** 		return;
 6269              		.loc 1 336 2 is_stmt 1 view .LVU1623
 6270 0130 01F098F8 		bl	.L354	@ far jump
 6271              	.LVL501:
 6272              	.L523:
 336:Src/usb_pd_protocol.c **** 		return;
 6273              		.loc 1 336 2 is_stmt 0 view .LVU1624
 6274              	.LBE864:
 6275              	.LBE863:
2264:Src/usb_pd_protocol.c **** 				(!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
 6276              		.loc 1 2264 5 discriminator 1 view .LVU1625
 6277 0134 04A8     		add	r0, sp, #16
 6278 0136 FFF7FEFF 		bl	get_time
 6279              	.LVL502:
2264:Src/usb_pd_protocol.c **** 				(!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
 6280              		.loc 1 2264 15 discriminator 1 view .LVU1626
 6281 013a 0498     		ldr	r0, [sp, #16]
 6282 013c 0599     		ldr	r1, [sp, #20]
2264:Src/usb_pd_protocol.c **** 				(!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
 6283              		.loc 1 2264 31 discriminator 1 view .LVU1627
 6284 013e F201     		lsls	r2, r6, #7
 6285 0140 924B     		ldr	r3, .L581+16
 6286 0142 9B18     		adds	r3, r3, r2
 6287 0144 1A6C     		ldr	r2, [r3, #64]
 6288 0146 5B6C     		ldr	r3, [r3, #68]
2263:Src/usb_pd_protocol.c **** 				get_time().val >= pd[port].try_src_marker) ||
 6289              		.loc 1 2263 47 discriminator 1 view .LVU1628
 6290 0148 8B42     		cmp	r3, r1
 6291 014a BDD8     		bhi	.L390
 6292 014c 01D1     		bne	.L391
 6293 014e 8242     		cmp	r2, r0
 6294 0150 BAD8     		bhi	.L390
 6295              	.L391:
2269:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
 6296              		.loc 1 2269 4 is_stmt 1 view .LVU1629
 6297              		.loc 1 2269 24 is_stmt 0 view .LVU1630
 6298 0152 8E4B     		ldr	r3, .L581+16
 6299 0154 F201     		lsls	r2, r6, #7
 6300 0156 0024     		movs	r4, #0
 6301 0158 D454     		strb	r4, [r2, r3]
2270:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
 6302              		.loc 1 2270 4 is_stmt 1 view .LVU1631
 6303              	.LVL503:
 6304              	.LBB867:
 6305              	.LBI867:
 326:Src/usb_pd_protocol.c **** {
 6306              		.loc 1 326 20 view .LVU1632
 6307              	.LBB868:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6308              		.loc 1 328 2 view .LVU1633
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6309              		.loc 1 328 17 is_stmt 0 view .LVU1634
 6310 015a 9B18     		adds	r3, r3, r2
 6311 015c 1A79     		ldrb	r2, [r3, #4]
 6312              	.LVL504:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 6313              		.loc 1 333 2 is_stmt 1 view .LVU1635
ARM GAS  /tmp/ccoQIC4J.s 			page 178


 6314              	.LBB869:
 6315              	.LBI869:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 6316              		.loc 1 261 20 view .LVU1636
 6317              	.LBB870:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6318              		.loc 1 265 2 view .LVU1637
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6319              		.loc 1 265 19 is_stmt 0 view .LVU1638
 6320 015e 0020     		movs	r0, #0
 6321 0160 0021     		movs	r1, #0
 6322 0162 1861     		str	r0, [r3, #16]
 6323 0164 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 6324              		.loc 1 266 2 is_stmt 1 view .LVU1639
 266:Src/usb_pd_protocol.c **** }
 6325              		.loc 1 266 25 is_stmt 0 view .LVU1640
 6326 0166 DC71     		strb	r4, [r3, #7]
 6327              	.LVL505:
 266:Src/usb_pd_protocol.c **** }
 6328              		.loc 1 266 25 view .LVU1641
 6329              	.LBE870:
 6330              	.LBE869:
 334:Src/usb_pd_protocol.c **** 
 6331              		.loc 1 334 2 is_stmt 1 view .LVU1642
 334:Src/usb_pd_protocol.c **** 
 6332              		.loc 1 334 22 is_stmt 0 view .LVU1643
 6333 0168 0221     		movs	r1, #2
 6334 016a 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 6335              		.loc 1 336 2 is_stmt 1 view .LVU1644
 336:Src/usb_pd_protocol.c **** 		return;
 6336              		.loc 1 336 5 is_stmt 0 view .LVU1645
 6337 016c 022A     		cmp	r2, #2
 6338 016e 13D0     		beq	.L394
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6339              		.loc 1 347 2 is_stmt 1 view .LVU1646
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 6340              		.loc 1 348 48 is_stmt 0 view .LVU1647
 6341 0170 0E2A     		cmp	r2, #14
 6342 0172 11D0     		beq	.L394
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 6343              		.loc 1 353 2 is_stmt 1 view .LVU1648
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6344              		.loc 1 356 3 view .LVU1649
 6345 0174 0022     		movs	r2, #0
 6346              	.LVL506:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6347              		.loc 1 356 3 is_stmt 0 view .LVU1650
 6348 0176 0021     		movs	r1, #0
 6349 0178 3000     		movs	r0, r6
 6350 017a FFF7FEFF 		bl	pd_set_input_current_limit
 6351              	.LVL507:
 373:Src/usb_pd_protocol.c **** 			/*
 6352              		.loc 1 373 3 is_stmt 1 view .LVU1651
 373:Src/usb_pd_protocol.c **** 			/*
 6353              		.loc 1 373 15 is_stmt 0 view .LVU1652
ARM GAS  /tmp/ccoQIC4J.s 			page 179


 6354 017e F301     		lsls	r3, r6, #7
 6355 0180 824A     		ldr	r2, .L581+16
 6356 0182 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 6357              		.loc 1 373 6 view .LVU1653
 6358 0184 012B     		cmp	r3, #1
 6359 0186 2BD0     		beq	.L524
 6360              	.L395:
 405:Src/usb_pd_protocol.c **** 	}
 6361              		.loc 1 405 3 is_stmt 1 view .LVU1654
 6362              	.LVL508:
 6363              	.LBB871:
 6364              	.LBI871:
  94:Inc/tcpm.h    **** {
 6365              		.loc 2 94 19 view .LVU1655
 6366              	.LBB872:
  96:Inc/tcpm.h    **** }
 6367              		.loc 2 96 2 view .LVU1656
  96:Inc/tcpm.h    **** }
 6368              		.loc 2 96 26 is_stmt 0 view .LVU1657
 6369 0188 3201     		lsls	r2, r6, #4
 6370 018a 7D4B     		ldr	r3, .L581+4
 6371 018c 9B18     		adds	r3, r3, r2
 6372 018e 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 6373              		.loc 2 96 30 view .LVU1658
 6374 0190 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 6375              		.loc 2 96 9 view .LVU1659
 6376 0192 0021     		movs	r1, #0
 6377 0194 3000     		movs	r0, r6
 6378 0196 9847     		blx	r3
 6379              	.LVL509:
 6380              	.L394:
  96:Inc/tcpm.h    **** }
 6381              		.loc 2 96 9 view .LVU1660
 6382              	.LBE872:
 6383              	.LBE871:
 6384              	.LBE868:
 6385              	.LBE867:
2271:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
 6386              		.loc 1 2271 4 is_stmt 1 view .LVU1661
 6387              	.LBB874:
 6388              	.LBI874:
  73:Inc/tcpm.h    **** {
 6389              		.loc 2 73 19 view .LVU1662
 6390              	.LBB875:
  75:Inc/tcpm.h    **** }
 6391              		.loc 2 75 2 view .LVU1663
  75:Inc/tcpm.h    **** }
 6392              		.loc 2 75 9 is_stmt 0 view .LVU1664
 6393 0198 0221     		movs	r1, #2
 6394 019a 3000     		movs	r0, r6
 6395 019c 7B69     		ldr	r3, [r7, #20]
 6396 019e 9847     		blx	r3
 6397              	.LVL510:
  75:Inc/tcpm.h    **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 180


 6398              		.loc 2 75 9 view .LVU1665
 6399              	.LBE875:
 6400              	.LBE874:
2272:Src/usb_pd_protocol.c **** 			next_role_swap = get_time().val + PD_T_DRP_SNK;
 6401              		.loc 1 2272 4 is_stmt 1 view .LVU1666
 6402              		.loc 1 2272 21 is_stmt 0 view .LVU1667
 6403 01a0 04A8     		add	r0, sp, #16
 6404 01a2 FFF7FEFF 		bl	get_time
 6405              	.LVL511:
 6406              		.loc 1 2272 36 view .LVU1668
 6407 01a6 834A     		ldr	r2, .L581+56
 6408 01a8 0023     		movs	r3, #0
 6409 01aa 0498     		ldr	r0, [sp, #16]
 6410 01ac 0599     		ldr	r1, [sp, #20]
 6411 01ae 1218     		adds	r2, r2, r0
 6412 01b0 4B41     		adcs	r3, r3, r1
 6413              		.loc 1 2272 19 view .LVU1669
 6414 01b2 7F49     		ldr	r1, .L581+52
 6415 01b4 0A60     		str	r2, [r1]
 6416 01b6 4B60     		str	r3, [r1, #4]
2273:Src/usb_pd_protocol.c **** 			pd[port].try_src_marker = get_time().val
 6417              		.loc 1 2273 4 is_stmt 1 view .LVU1670
 6418              		.loc 1 2273 30 is_stmt 0 view .LVU1671
 6419 01b8 04A8     		add	r0, sp, #16
 6420 01ba FFF7FEFF 		bl	get_time
 6421              	.LVL512:
2274:Src/usb_pd_protocol.c **** 				+ PD_T_TRY_WAIT;
 6422              		.loc 1 2274 5 view .LVU1672
 6423 01be 7E48     		ldr	r0, .L581+60
 6424 01c0 0021     		movs	r1, #0
 6425 01c2 049B     		ldr	r3, [sp, #16]
 6426 01c4 059C     		ldr	r4, [sp, #20]
 6427 01c6 C018     		adds	r0, r0, r3
 6428 01c8 6141     		adcs	r1, r1, r4
2273:Src/usb_pd_protocol.c **** 			pd[port].try_src_marker = get_time().val
 6429              		.loc 1 2273 28 view .LVU1673
 6430 01ca F201     		lsls	r2, r6, #7
 6431 01cc 6F4B     		ldr	r3, .L581+16
 6432 01ce 9B18     		adds	r3, r3, r2
 6433 01d0 1864     		str	r0, [r3, #64]
 6434 01d2 5964     		str	r1, [r3, #68]
2275:Src/usb_pd_protocol.c **** 
2276:Src/usb_pd_protocol.c **** 			/* Swap states quickly */
2277:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC_US;
 6435              		.loc 1 2277 4 is_stmt 1 view .LVU1674
 6436              		.loc 1 2277 12 is_stmt 0 view .LVU1675
 6437 01d4 6F4B     		ldr	r3, .L581+24
 6438 01d6 FA22     		movs	r2, #250
 6439 01d8 D200     		lsls	r2, r2, #3
 6440 01da 1A60     		str	r2, [r3]
 6441 01dc 01F042F8 		bl	.L354	@ far jump
 6442              	.LVL513:
 6443              	.L524:
 6444              	.LBB876:
 6445              	.LBB873:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 6446              		.loc 1 378 4 is_stmt 1 view .LVU1676
ARM GAS  /tmp/ccoQIC4J.s 			page 181


 6447 01e0 3000     		movs	r0, r6
 6448 01e2 FFF7FEFF 		bl	pd_power_supply_reset
 6449              	.LVL514:
 6450 01e6 CFE7     		b	.L395
 6451              	.LVL515:
 6452              	.L373:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 6453              		.loc 1 378 4 is_stmt 0 view .LVU1677
 6454              	.LBE873:
 6455              	.LBE876:
2278:Src/usb_pd_protocol.c **** 		}
2279:Src/usb_pd_protocol.c **** #endif
2280:Src/usb_pd_protocol.c **** 		break;
2281:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_DISCONNECTED_DEBOUNCE:
2282:Src/usb_pd_protocol.c **** 		timeout = 20*MSEC_US;
 6456              		.loc 1 2282 3 is_stmt 1 view .LVU1678
 6457              		.loc 1 2282 11 is_stmt 0 view .LVU1679
 6458 01e8 6A4B     		ldr	r3, .L581+24
 6459 01ea 744A     		ldr	r2, .L581+64
 6460 01ec 1A60     		str	r2, [r3]
2283:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
 6461              		.loc 1 2283 3 is_stmt 1 view .LVU1680
 6462              	.LVL516:
 6463              	.LBB877:
 6464              	.LBI877:
  58:Inc/tcpm.h    **** {
 6465              		.loc 2 58 19 view .LVU1681
 6466              	.LBB878:
  60:Inc/tcpm.h    **** }
 6467              		.loc 2 60 2 view .LVU1682
  60:Inc/tcpm.h    **** }
 6468              		.loc 2 60 9 is_stmt 0 view .LVU1683
 6469 01ee 6D4C     		ldr	r4, .L581+40
 6470 01f0 6D4A     		ldr	r2, .L581+44
 6471 01f2 2100     		movs	r1, r4
 6472 01f4 3000     		movs	r0, r6
 6473 01f6 BB68     		ldr	r3, [r7, #8]
 6474 01f8 9847     		blx	r3
 6475              	.LVL517:
  60:Inc/tcpm.h    **** }
 6476              		.loc 2 60 9 view .LVU1684
 6477              	.LBE878:
 6478              	.LBE877:
2284:Src/usb_pd_protocol.c **** 
2285:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_RD &&
 6479              		.loc 1 2285 3 is_stmt 1 view .LVU1685
 6480              		.loc 1 2285 11 is_stmt 0 view .LVU1686
 6481 01fa 2368     		ldr	r3, [r4]
 6482              		.loc 1 2285 6 view .LVU1687
 6483 01fc 022B     		cmp	r3, #2
 6484 01fe 30D0     		beq	.L525
 6485              	.L396:
2286:Src/usb_pd_protocol.c **** 			cc2 == TYPEC_CC_VOLT_RD) {
2287:Src/usb_pd_protocol.c **** 			/* Debug accessory */
2288:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_DEBUG_ACC;
2289:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RD ||
 6486              		.loc 1 2289 10 is_stmt 1 view .LVU1688
ARM GAS  /tmp/ccoQIC4J.s 			page 182


 6487              		.loc 1 2289 13 is_stmt 0 view .LVU1689
 6488 0200 022B     		cmp	r3, #2
 6489 0202 36D0     		beq	.L398
2290:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RD) {
 6490              		.loc 1 2290 9 discriminator 1 view .LVU1690
 6491 0204 684A     		ldr	r2, .L581+44
 6492 0206 1268     		ldr	r2, [r2]
2289:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RD) {
 6493              		.loc 1 2289 38 discriminator 1 view .LVU1691
 6494 0208 022A     		cmp	r2, #2
 6495 020a 32D0     		beq	.L398
2291:Src/usb_pd_protocol.c **** 			/* UFP attached */
2292:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_UFP_ATTACHED;
2293:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RA &&
 6496              		.loc 1 2293 10 is_stmt 1 view .LVU1692
 6497              		.loc 1 2293 13 is_stmt 0 view .LVU1693
 6498 020c 012B     		cmp	r3, #1
 6499 020e 01D1     		bne	.L400
 6500              		.loc 1 2293 38 discriminator 1 view .LVU1694
 6501 0210 012A     		cmp	r2, #1
 6502 0212 53D0     		beq	.L526
 6503              	.L400:
2294:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RA) {
2295:Src/usb_pd_protocol.c **** 			/* Audio accessory */
2296:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_AUDIO_ACC;
2297:Src/usb_pd_protocol.c **** 		} else {
2298:Src/usb_pd_protocol.c **** 			/* No UFP */
2299:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
 6504              		.loc 1 2299 4 is_stmt 1 view .LVU1695
 6505              	.LVL518:
 6506              	.LBB879:
 6507              	.LBI879:
 326:Src/usb_pd_protocol.c **** {
 6508              		.loc 1 326 20 view .LVU1696
 6509              	.LBB880:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6510              		.loc 1 328 2 view .LVU1697
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6511              		.loc 1 328 17 is_stmt 0 view .LVU1698
 6512 0214 F201     		lsls	r2, r6, #7
 6513 0216 5D4B     		ldr	r3, .L581+16
 6514 0218 9B18     		adds	r3, r3, r2
 6515 021a 1A79     		ldrb	r2, [r3, #4]
 6516              	.LVL519:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 6517              		.loc 1 333 2 is_stmt 1 view .LVU1699
 6518              	.LBB881:
 6519              	.LBI881:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 6520              		.loc 1 261 20 view .LVU1700
 6521              	.LBB882:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6522              		.loc 1 265 2 view .LVU1701
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6523              		.loc 1 265 19 is_stmt 0 view .LVU1702
 6524 021c 0020     		movs	r0, #0
 6525 021e 0021     		movs	r1, #0
ARM GAS  /tmp/ccoQIC4J.s 			page 183


 6526 0220 1861     		str	r0, [r3, #16]
 6527 0222 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 6528              		.loc 1 266 2 is_stmt 1 view .LVU1703
 266:Src/usb_pd_protocol.c **** }
 6529              		.loc 1 266 25 is_stmt 0 view .LVU1704
 6530 0224 0021     		movs	r1, #0
 6531 0226 D971     		strb	r1, [r3, #7]
 6532              	.LVL520:
 266:Src/usb_pd_protocol.c **** }
 6533              		.loc 1 266 25 view .LVU1705
 6534              	.LBE882:
 6535              	.LBE881:
 334:Src/usb_pd_protocol.c **** 
 6536              		.loc 1 334 2 is_stmt 1 view .LVU1706
 334:Src/usb_pd_protocol.c **** 
 6537              		.loc 1 334 22 is_stmt 0 view .LVU1707
 6538 0228 0E31     		adds	r1, r1, #14
 6539 022a 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 6540              		.loc 1 336 2 is_stmt 1 view .LVU1708
 336:Src/usb_pd_protocol.c **** 		return;
 6541              		.loc 1 336 5 is_stmt 0 view .LVU1709
 6542 022c 0E2A     		cmp	r2, #14
 6543 022e 13D0     		beq	.L401
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6544              		.loc 1 347 2 is_stmt 1 view .LVU1710
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6545              		.loc 1 347 5 is_stmt 0 view .LVU1711
 6546 0230 022A     		cmp	r2, #2
 6547 0232 11D0     		beq	.L401
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 6548              		.loc 1 353 2 is_stmt 1 view .LVU1712
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6549              		.loc 1 356 3 view .LVU1713
 6550 0234 0022     		movs	r2, #0
 6551              	.LVL521:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6552              		.loc 1 356 3 is_stmt 0 view .LVU1714
 6553 0236 0021     		movs	r1, #0
 6554 0238 3000     		movs	r0, r6
 6555 023a FFF7FEFF 		bl	pd_set_input_current_limit
 6556              	.LVL522:
 373:Src/usb_pd_protocol.c **** 			/*
 6557              		.loc 1 373 3 is_stmt 1 view .LVU1715
 373:Src/usb_pd_protocol.c **** 			/*
 6558              		.loc 1 373 15 is_stmt 0 view .LVU1716
 6559 023e F301     		lsls	r3, r6, #7
 6560 0240 524A     		ldr	r2, .L581+16
 6561 0242 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 6562              		.loc 1 373 6 view .LVU1717
 6563 0244 012B     		cmp	r3, #1
 6564 0246 3DD0     		beq	.L527
 6565              	.L402:
 405:Src/usb_pd_protocol.c **** 	}
 6566              		.loc 1 405 3 is_stmt 1 view .LVU1718
ARM GAS  /tmp/ccoQIC4J.s 			page 184


 6567              	.LVL523:
 6568              	.LBB883:
 6569              	.LBI883:
  94:Inc/tcpm.h    **** {
 6570              		.loc 2 94 19 view .LVU1719
 6571              	.LBB884:
  96:Inc/tcpm.h    **** }
 6572              		.loc 2 96 2 view .LVU1720
  96:Inc/tcpm.h    **** }
 6573              		.loc 2 96 26 is_stmt 0 view .LVU1721
 6574 0248 3201     		lsls	r2, r6, #4
 6575 024a 4D4B     		ldr	r3, .L581+4
 6576 024c 9B18     		adds	r3, r3, r2
 6577 024e 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 6578              		.loc 2 96 30 view .LVU1722
 6579 0250 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 6580              		.loc 2 96 9 view .LVU1723
 6581 0252 0021     		movs	r1, #0
 6582 0254 3000     		movs	r0, r6
 6583 0256 9847     		blx	r3
 6584              	.LVL524:
 6585              	.L401:
  96:Inc/tcpm.h    **** }
 6586              		.loc 2 96 9 view .LVU1724
 6587              	.LBE884:
 6588              	.LBE883:
 6589              	.LBE880:
 6590              	.LBE879:
2300:Src/usb_pd_protocol.c **** 			timeout = 5*MSEC_US;
 6591              		.loc 1 2300 4 is_stmt 1 view .LVU1725
 6592              		.loc 1 2300 12 is_stmt 0 view .LVU1726
 6593 0258 4E4B     		ldr	r3, .L581+24
 6594 025a 594A     		ldr	r2, .L581+68
 6595 025c 1A60     		str	r2, [r3]
2301:Src/usb_pd_protocol.c **** 			break;
 6596              		.loc 1 2301 4 is_stmt 1 view .LVU1727
 6597 025e 01F001F8 		bl	.L354	@ far jump
 6598              	.L525:
2286:Src/usb_pd_protocol.c **** 			/* Debug accessory */
 6599              		.loc 1 2286 8 is_stmt 0 discriminator 1 view .LVU1728
 6600 0262 514A     		ldr	r2, .L581+44
 6601 0264 1268     		ldr	r2, [r2]
2285:Src/usb_pd_protocol.c **** 			cc2 == TYPEC_CC_VOLT_RD) {
 6602              		.loc 1 2285 31 discriminator 1 view .LVU1729
 6603 0266 022A     		cmp	r2, #2
 6604 0268 CAD1     		bne	.L396
2288:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RD ||
 6605              		.loc 1 2288 4 is_stmt 1 view .LVU1730
2288:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RD ||
 6606              		.loc 1 2288 17 is_stmt 0 view .LVU1731
 6607 026a 564B     		ldr	r3, .L581+72
 6608 026c 0132     		adds	r2, r2, #1
 6609 026e 1A70     		strb	r2, [r3]
 6610 0270 02E0     		b	.L397
 6611              	.L398:
ARM GAS  /tmp/ccoQIC4J.s 			page 185


2292:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RA &&
 6612              		.loc 1 2292 4 is_stmt 1 view .LVU1732
2292:Src/usb_pd_protocol.c **** 		} else if (cc1 == TYPEC_CC_VOLT_RA &&
 6613              		.loc 1 2292 17 is_stmt 0 view .LVU1733
 6614 0272 544B     		ldr	r3, .L581+72
 6615 0274 0422     		movs	r2, #4
 6616 0276 1A70     		strb	r2, [r3]
 6617              	.L397:
2302:Src/usb_pd_protocol.c **** 		}
2303:Src/usb_pd_protocol.c **** 		/* If in Try.SRC state, then don't need to debounce */
2304:Src/usb_pd_protocol.c **** 		if (!(pd[port].flags & PD_FLAGS_TRY_SRC)) {
 6618              		.loc 1 2304 3 is_stmt 1 view .LVU1734
 6619              		.loc 1 2304 17 is_stmt 0 view .LVU1735
 6620 0278 F201     		lsls	r2, r6, #7
 6621 027a 444B     		ldr	r3, .L581+16
 6622 027c 9B18     		adds	r3, r3, r2
 6623 027e 9B68     		ldr	r3, [r3, #8]
 6624              		.loc 1 2304 6 view .LVU1736
 6625 0280 9B04     		lsls	r3, r3, #18
 6626 0282 36D4     		bmi	.L403
2305:Src/usb_pd_protocol.c **** 			/* Debounce the cc state */
2306:Src/usb_pd_protocol.c **** 			if (new_cc_state != pd[port].cc_state) {
 6627              		.loc 1 2306 4 is_stmt 1 view .LVU1737
 6628              		.loc 1 2306 32 is_stmt 0 view .LVU1738
 6629 0284 414B     		ldr	r3, .L581+16
 6630 0286 9B18     		adds	r3, r3, r2
 6631 0288 2833     		adds	r3, r3, #40
 6632 028a 1A78     		ldrb	r2, [r3]
 6633              		.loc 1 2306 21 view .LVU1739
 6634 028c 4D4B     		ldr	r3, .L581+72
 6635 028e 1B78     		ldrb	r3, [r3]
 6636              		.loc 1 2306 7 view .LVU1740
 6637 0290 9A42     		cmp	r2, r3
 6638 0292 1BD0     		beq	.L404
2307:Src/usb_pd_protocol.c **** 				pd[port].cc_debounce = get_time().val +
 6639              		.loc 1 2307 5 is_stmt 1 view .LVU1741
 6640              		.loc 1 2307 28 is_stmt 0 view .LVU1742
 6641 0294 04A8     		add	r0, sp, #16
 6642 0296 FFF7FEFF 		bl	get_time
 6643              	.LVL525:
 6644              		.loc 1 2307 43 view .LVU1743
 6645 029a 4B48     		ldr	r0, .L581+76
 6646 029c 0021     		movs	r1, #0
 6647 029e 049B     		ldr	r3, [sp, #16]
 6648 02a0 059C     		ldr	r4, [sp, #20]
 6649 02a2 C018     		adds	r0, r0, r3
 6650 02a4 6141     		adcs	r1, r1, r4
 6651              		.loc 1 2307 26 view .LVU1744
 6652 02a6 F201     		lsls	r2, r6, #7
 6653 02a8 384B     		ldr	r3, .L581+16
 6654 02aa 9B18     		adds	r3, r3, r2
 6655 02ac 1862     		str	r0, [r3, #32]
 6656 02ae 5962     		str	r1, [r3, #36]
2308:Src/usb_pd_protocol.c **** 					PD_T_CC_DEBOUNCE;
2309:Src/usb_pd_protocol.c **** 				pd[port].cc_state = new_cc_state;
 6657              		.loc 1 2309 5 is_stmt 1 view .LVU1745
 6658              		.loc 1 2309 23 is_stmt 0 view .LVU1746
ARM GAS  /tmp/ccoQIC4J.s 			page 186


 6659 02b0 2833     		adds	r3, r3, #40
 6660 02b2 444A     		ldr	r2, .L581+72
 6661 02b4 1278     		ldrb	r2, [r2]
 6662 02b6 1A70     		strb	r2, [r3]
2310:Src/usb_pd_protocol.c **** 				break;
 6663              		.loc 1 2310 5 is_stmt 1 view .LVU1747
 6664 02b8 00F0D4FF 		bl	.L354	@ far jump
 6665              	.L526:
2296:Src/usb_pd_protocol.c **** 		} else {
 6666              		.loc 1 2296 4 view .LVU1748
2296:Src/usb_pd_protocol.c **** 		} else {
 6667              		.loc 1 2296 17 is_stmt 0 view .LVU1749
 6668 02bc 414B     		ldr	r3, .L581+72
 6669 02be 0132     		adds	r2, r2, #1
 6670 02c0 1A70     		strb	r2, [r3]
 6671 02c2 D9E7     		b	.L397
 6672              	.LVL526:
 6673              	.L527:
 6674              	.LBB886:
 6675              	.LBB885:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 6676              		.loc 1 378 4 is_stmt 1 view .LVU1750
 6677 02c4 3000     		movs	r0, r6
 6678 02c6 FFF7FEFF 		bl	pd_power_supply_reset
 6679              	.LVL527:
 6680 02ca BDE7     		b	.L402
 6681              	.LVL528:
 6682              	.L404:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 6683              		.loc 1 378 4 is_stmt 0 view .LVU1751
 6684              	.LBE885:
 6685              	.LBE886:
2311:Src/usb_pd_protocol.c **** 			} else if (get_time().val <
 6686              		.loc 1 2311 11 is_stmt 1 view .LVU1752
 6687              		.loc 1 2311 15 is_stmt 0 view .LVU1753
 6688 02cc 04A8     		add	r0, sp, #16
 6689 02ce FFF7FEFF 		bl	get_time
 6690              	.LVL529:
 6691              		.loc 1 2311 25 view .LVU1754
 6692 02d2 0498     		ldr	r0, [sp, #16]
 6693 02d4 0599     		ldr	r1, [sp, #20]
2312:Src/usb_pd_protocol.c **** 					pd[port].cc_debounce) {
 6694              		.loc 1 2312 14 view .LVU1755
 6695 02d6 F201     		lsls	r2, r6, #7
 6696 02d8 2C4B     		ldr	r3, .L581+16
 6697 02da 9B18     		adds	r3, r3, r2
 6698 02dc 1A6A     		ldr	r2, [r3, #32]
 6699 02de 5B6A     		ldr	r3, [r3, #36]
2311:Src/usb_pd_protocol.c **** 			} else if (get_time().val <
 6700              		.loc 1 2311 14 view .LVU1756
 6701 02e0 8B42     		cmp	r3, r1
 6702 02e2 01D9     		bls	.LCB6291
 6703 02e4 00F0BEFF 		bl	.L354	@far jump
 6704              	.LCB6291:
 6705 02e8 03D1     		bne	.L403
 6706 02ea 8242     		cmp	r2, r0
 6707 02ec 01D9     		bls	.LCB6295
ARM GAS  /tmp/ccoQIC4J.s 			page 187


 6708 02ee 00F0B9FF 		bl	.L354	@far jump
 6709              	.LCB6295:
 6710              	.L403:
2313:Src/usb_pd_protocol.c **** 				break;
2314:Src/usb_pd_protocol.c **** 			}
2315:Src/usb_pd_protocol.c **** 		}
2316:Src/usb_pd_protocol.c **** 
2317:Src/usb_pd_protocol.c **** 		/* Debounce complete */
2318:Src/usb_pd_protocol.c **** 		/* UFP is attached */
2319:Src/usb_pd_protocol.c **** 		if (new_cc_state == PD_CC_UFP_ATTACHED ||
 6711              		.loc 1 2319 3 is_stmt 1 view .LVU1757
 6712              		.loc 1 2319 42 is_stmt 0 view .LVU1758
 6713 02f2 344B     		ldr	r3, .L581+72
 6714 02f4 1B78     		ldrb	r3, [r3]
 6715 02f6 033B     		subs	r3, r3, #3
 6716 02f8 DBB2     		uxtb	r3, r3
 6717              		.loc 1 2319 6 view .LVU1759
 6718 02fa 012B     		cmp	r3, #1
 6719 02fc 01D9     		bls	.LCB6304
 6720 02fe 00F0B1FF 		bl	.L354	@far jump
 6721              	.LCB6304:
2320:Src/usb_pd_protocol.c **** 			new_cc_state == PD_CC_DEBUG_ACC) {
2321:Src/usb_pd_protocol.c **** 			pd[port].polarity = (cc1 != TYPEC_CC_VOLT_RD);
 6722              		.loc 1 2321 4 is_stmt 1 view .LVU1760
 6723              		.loc 1 2321 29 is_stmt 0 view .LVU1761
 6724 0302 284B     		ldr	r3, .L581+40
 6725 0304 1968     		ldr	r1, [r3]
 6726 0306 0239     		subs	r1, r1, #2
 6727 0308 4B1E     		subs	r3, r1, #1
 6728 030a 9941     		sbcs	r1, r1, r3
 6729 030c C9B2     		uxtb	r1, r1
 6730              		.loc 1 2321 22 view .LVU1762
 6731 030e F201     		lsls	r2, r6, #7
 6732 0310 1E4B     		ldr	r3, .L581+16
 6733 0312 9B18     		adds	r3, r3, r2
 6734 0314 D970     		strb	r1, [r3, #3]
2322:Src/usb_pd_protocol.c **** 			tcpm_set_polarity(port, pd[port].polarity);
 6735              		.loc 1 2322 4 is_stmt 1 view .LVU1763
 6736              	.LVL530:
 6737              	.LBB887:
 6738              	.LBI887:
  78:Inc/tcpm.h    **** {
 6739              		.loc 2 78 19 view .LVU1764
 6740              	.LBB888:
  80:Inc/tcpm.h    **** }
 6741              		.loc 2 80 2 view .LVU1765
  80:Inc/tcpm.h    **** }
 6742              		.loc 2 80 9 is_stmt 0 view .LVU1766
 6743 0316 3000     		movs	r0, r6
 6744 0318 BB69     		ldr	r3, [r7, #24]
 6745 031a 9847     		blx	r3
 6746              	.LVL531:
  80:Inc/tcpm.h    **** }
 6747              		.loc 2 80 9 view .LVU1767
 6748              	.LBE888:
 6749              	.LBE887:
2323:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 188


2324:Src/usb_pd_protocol.c **** 			/* initial data role for source is DFP */
2325:Src/usb_pd_protocol.c **** 			pd_set_data_role(port, PD_ROLE_DFP);
 6750              		.loc 1 2325 4 is_stmt 1 view .LVU1768
 6751 031c 0121     		movs	r1, #1
 6752 031e 3000     		movs	r0, r6
 6753 0320 FFF7FEFF 		bl	pd_set_data_role
 6754              	.LVL532:
2326:Src/usb_pd_protocol.c **** 
2327:Src/usb_pd_protocol.c **** 			if (new_cc_state == PD_CC_DEBUG_ACC)
 6755              		.loc 1 2327 4 view .LVU1769
 6756              		.loc 1 2327 21 is_stmt 0 view .LVU1770
 6757 0324 274B     		ldr	r3, .L581+72
 6758 0326 1B78     		ldrb	r3, [r3]
 6759              		.loc 1 2327 7 view .LVU1771
 6760 0328 032B     		cmp	r3, #3
 6761 032a 51D0     		beq	.L528
 6762              	.L406:
2328:Src/usb_pd_protocol.c **** 				pd[port].flags |=
2329:Src/usb_pd_protocol.c **** 					PD_FLAGS_TS_DTS_PARTNER;
2330:Src/usb_pd_protocol.c **** 
2331:Src/usb_pd_protocol.c **** #ifndef CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP
2332:Src/usb_pd_protocol.c **** 			/* Enable VBUS */
2333:Src/usb_pd_protocol.c **** 			if (pd_set_power_supply_ready(port)) {
 6763              		.loc 1 2333 4 is_stmt 1 view .LVU1772
 6764              		.loc 1 2333 8 is_stmt 0 view .LVU1773
 6765 032c 3000     		movs	r0, r6
 6766 032e FFF7FEFF 		bl	pd_set_power_supply_ready
 6767              	.LVL533:
 6768              		.loc 1 2333 7 view .LVU1774
 6769 0332 0028     		cmp	r0, #0
 6770 0334 01D0     		beq	.LCB6345
 6771 0336 00F095FF 		bl	.L354	@far jump
 6772              	.LCB6345:
2334:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_SS_MUX
2335:Src/usb_pd_protocol.c **** 				usb_mux_set(port, TYPEC_MUX_NONE,
2336:Src/usb_pd_protocol.c **** 						USB_SWITCH_DISCONNECT,
2337:Src/usb_pd_protocol.c **** 						pd[port].polarity);
2338:Src/usb_pd_protocol.c **** #endif
2339:Src/usb_pd_protocol.c **** 				break;
2340:Src/usb_pd_protocol.c **** 			}
2341:Src/usb_pd_protocol.c **** #endif
2342:Src/usb_pd_protocol.c **** 			/* If PD comm is enabled, enable TCPC RX */
2343:Src/usb_pd_protocol.c **** 			if (pd_comm_is_enabled(port))
 6773              		.loc 1 2343 4 is_stmt 1 view .LVU1775
 6774              		.loc 1 2343 8 is_stmt 0 view .LVU1776
 6775 033a 3000     		movs	r0, r6
 6776 033c FFF7FEFF 		bl	pd_comm_is_enabled
 6777              	.LVL534:
 6778              		.loc 1 2343 7 view .LVU1777
 6779 0340 0028     		cmp	r0, #0
 6780 0342 03D0     		beq	.L407
2344:Src/usb_pd_protocol.c **** 				tcpm_set_rx_enable(port, 1);
 6781              		.loc 1 2344 5 is_stmt 1 view .LVU1778
 6782              	.LVL535:
 6783              	.LBB889:
 6784              	.LBI889:
  94:Inc/tcpm.h    **** {
ARM GAS  /tmp/ccoQIC4J.s 			page 189


 6785              		.loc 2 94 19 view .LVU1779
 6786              	.LBB890:
  96:Inc/tcpm.h    **** }
 6787              		.loc 2 96 2 view .LVU1780
  96:Inc/tcpm.h    **** }
 6788              		.loc 2 96 9 is_stmt 0 view .LVU1781
 6789 0344 0121     		movs	r1, #1
 6790 0346 3000     		movs	r0, r6
 6791 0348 7B6A     		ldr	r3, [r7, #36]
 6792 034a 9847     		blx	r3
 6793              	.LVL536:
 6794              	.L407:
  96:Inc/tcpm.h    **** }
 6795              		.loc 2 96 9 view .LVU1782
 6796              	.LBE890:
 6797              	.LBE889:
2345:Src/usb_pd_protocol.c **** 
2346:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN
2347:Src/usb_pd_protocol.c **** 			tcpm_set_vconn(port, 1);
2348:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_VCONN_ON;
2349:Src/usb_pd_protocol.c **** #endif
2350:Src/usb_pd_protocol.c **** 
2351:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_PR_ROLE |
 6798              		.loc 1 2351 4 is_stmt 1 view .LVU1783
 6799              		.loc 1 2351 19 is_stmt 0 view .LVU1784
 6800 034c F201     		lsls	r2, r6, #7
 6801 034e 0F4B     		ldr	r3, .L581+16
 6802 0350 9B18     		adds	r3, r3, r2
 6803 0352 C022     		movs	r2, #192
 6804 0354 D200     		lsls	r2, r2, #3
 6805 0356 9968     		ldr	r1, [r3, #8]
 6806 0358 0A43     		orrs	r2, r1
 6807 035a 9A60     		str	r2, [r3, #8]
2352:Src/usb_pd_protocol.c **** 						PD_FLAGS_CHECK_DR_ROLE;
2353:Src/usb_pd_protocol.c **** 			hard_reset_count = 0;
 6808              		.loc 1 2353 4 is_stmt 1 view .LVU1785
 6809              		.loc 1 2353 21 is_stmt 0 view .LVU1786
 6810 035c 0022     		movs	r2, #0
 6811 035e 1B49     		ldr	r1, .L581+80
 6812 0360 0A60     		str	r2, [r1]
2354:Src/usb_pd_protocol.c **** 			timeout = 5*MSEC_US;
 6813              		.loc 1 2354 4 is_stmt 1 view .LVU1787
 6814              		.loc 1 2354 12 is_stmt 0 view .LVU1788
 6815 0362 0C49     		ldr	r1, .L581+24
 6816 0364 1648     		ldr	r0, .L581+68
 6817 0366 0860     		str	r0, [r1]
2355:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_STARTUP);
 6818              		.loc 1 2355 4 is_stmt 1 view .LVU1789
 6819              	.LVL537:
 6820              	.LBB891:
 6821              	.LBI891:
 326:Src/usb_pd_protocol.c **** {
 6822              		.loc 1 326 20 view .LVU1790
 6823              	.LBB892:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6824              		.loc 1 328 2 view .LVU1791
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
ARM GAS  /tmp/ccoQIC4J.s 			page 190


 6825              		.loc 1 333 2 view .LVU1792
 6826              	.LBB893:
 6827              	.LBI893:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 6828              		.loc 1 261 20 view .LVU1793
 6829              	.LBB894:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6830              		.loc 1 265 2 view .LVU1794
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6831              		.loc 1 265 19 is_stmt 0 view .LVU1795
 6832 0368 0020     		movs	r0, #0
 6833 036a 0021     		movs	r1, #0
 6834 036c 1861     		str	r0, [r3, #16]
 6835 036e 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 6836              		.loc 1 266 2 is_stmt 1 view .LVU1796
 266:Src/usb_pd_protocol.c **** }
 6837              		.loc 1 266 25 is_stmt 0 view .LVU1797
 6838 0370 DA71     		strb	r2, [r3, #7]
 6839              	.LVL538:
 266:Src/usb_pd_protocol.c **** }
 6840              		.loc 1 266 25 view .LVU1798
 6841              	.LBE894:
 6842              	.LBE893:
 334:Src/usb_pd_protocol.c **** 
 6843              		.loc 1 334 2 is_stmt 1 view .LVU1799
 334:Src/usb_pd_protocol.c **** 
 6844              		.loc 1 334 22 is_stmt 0 view .LVU1800
 6845 0372 1132     		adds	r2, r2, #17
 6846 0374 1A71     		strb	r2, [r3, #4]
 6847              	.LVL539:
 336:Src/usb_pd_protocol.c **** 		return;
 6848              		.loc 1 336 2 is_stmt 1 view .LVU1801
 6849 0376 00F075FF 		bl	.L354	@ far jump
 6850              	.L582:
 6851 037a C046     		.align	2
 6852              	.L581:
 6853 037c 00000000 		.word	.LANCHOR2
 6854 0380 00000000 		.word	tcpc_config
 6855 0384 00000000 		.word	.LANCHOR3
 6856 0388 00000000 		.word	.LANCHOR4
 6857 038c 00000000 		.word	pd
 6858 0390 00000000 		.word	.LANCHOR1
 6859 0394 00000000 		.word	.LANCHOR5
 6860 0398 20A10700 		.word	500000
 6861 039c 00000000 		.word	.L356
 6862 03a0 10270000 		.word	10000
 6863 03a4 00000000 		.word	.LANCHOR7
 6864 03a8 00000000 		.word	.LANCHOR6
 6865 03ac 00000000 		.word	.LANCHOR0
 6866 03b0 00000000 		.word	.LANCHOR8
 6867 03b4 409C0000 		.word	40000
 6868 03b8 C0270900 		.word	600000
 6869 03bc 204E0000 		.word	20000
 6870 03c0 88130000 		.word	5000
 6871 03c4 00000000 		.word	.LANCHOR9
 6872 03c8 A0860100 		.word	100000
ARM GAS  /tmp/ccoQIC4J.s 			page 191


 6873 03cc 00000000 		.word	.LANCHOR10
 6874              	.LVL540:
 6875              	.L528:
 336:Src/usb_pd_protocol.c **** 		return;
 6876              		.loc 1 336 2 is_stmt 0 view .LVU1802
 6877              	.LBE892:
 6878              	.LBE891:
2328:Src/usb_pd_protocol.c **** 					PD_FLAGS_TS_DTS_PARTNER;
 6879              		.loc 1 2328 5 is_stmt 1 view .LVU1803
2328:Src/usb_pd_protocol.c **** 					PD_FLAGS_TS_DTS_PARTNER;
 6880              		.loc 1 2328 20 is_stmt 0 view .LVU1804
 6881 03d0 F201     		lsls	r2, r6, #7
 6882 03d2 E54B     		ldr	r3, .L583
 6883 03d4 9B18     		adds	r3, r3, r2
 6884 03d6 8022     		movs	r2, #128
 6885 03d8 5202     		lsls	r2, r2, #9
 6886 03da 9968     		ldr	r1, [r3, #8]
 6887 03dc 0A43     		orrs	r2, r1
 6888 03de 9A60     		str	r2, [r3, #8]
 6889 03e0 A4E7     		b	.L406
 6890              	.L372:
2356:Src/usb_pd_protocol.c **** 		}
2357:Src/usb_pd_protocol.c **** 		/*
2358:Src/usb_pd_protocol.c **** 			* AUDIO_ACC will remain in this state indefinitely
2359:Src/usb_pd_protocol.c **** 			* until disconnect.
2360:Src/usb_pd_protocol.c **** 			*/
2361:Src/usb_pd_protocol.c **** 		break;
2362:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_HARD_RESET_RECOVER:
2363:Src/usb_pd_protocol.c **** 		/* Do not continue until hard reset recovery time */
2364:Src/usb_pd_protocol.c **** 		if (get_time().val < pd[port].src_recover) {
 6891              		.loc 1 2364 3 is_stmt 1 view .LVU1805
 6892              		.loc 1 2364 7 is_stmt 0 view .LVU1806
 6893 03e2 04A8     		add	r0, sp, #16
 6894 03e4 FFF7FEFF 		bl	get_time
 6895              	.LVL541:
 6896              		.loc 1 2364 17 view .LVU1807
 6897 03e8 0498     		ldr	r0, [sp, #16]
 6898 03ea 0599     		ldr	r1, [sp, #20]
 6899              		.loc 1 2364 32 view .LVU1808
 6900 03ec F201     		lsls	r2, r6, #7
 6901 03ee DE4B     		ldr	r3, .L583
 6902 03f0 9B18     		adds	r3, r3, r2
 6903 03f2 9A69     		ldr	r2, [r3, #24]
 6904 03f4 DB69     		ldr	r3, [r3, #28]
 6905              		.loc 1 2364 6 view .LVU1809
 6906 03f6 8B42     		cmp	r3, r1
 6907 03f8 04D9     		bls	.L529
 6908              	.L513:
2365:Src/usb_pd_protocol.c **** 			timeout = 50*MSEC_US;
 6909              		.loc 1 2365 4 is_stmt 1 view .LVU1810
 6910              		.loc 1 2365 12 is_stmt 0 view .LVU1811
 6911 03fa DC4B     		ldr	r3, .L583+4
 6912 03fc DC4A     		ldr	r2, .L583+8
 6913 03fe 1A60     		str	r2, [r3]
2366:Src/usb_pd_protocol.c **** 			break;
 6914              		.loc 1 2366 4 is_stmt 1 view .LVU1812
 6915 0400 00F030FF 		bl	.L354	@ far jump
ARM GAS  /tmp/ccoQIC4J.s 			page 192


 6916              	.L529:
2364:Src/usb_pd_protocol.c **** 			timeout = 50*MSEC_US;
 6917              		.loc 1 2364 6 is_stmt 0 view .LVU1813
 6918 0404 8B42     		cmp	r3, r1
 6919 0406 01D1     		bne	.L408
 6920 0408 8242     		cmp	r2, r0
 6921 040a F6D8     		bhi	.L513
 6922              	.L408:
2367:Src/usb_pd_protocol.c **** 		}
2368:Src/usb_pd_protocol.c **** 
2369:Src/usb_pd_protocol.c **** 		/* Enable VBUS */
2370:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
 6923              		.loc 1 2370 3 is_stmt 1 view .LVU1814
 6924              		.loc 1 2370 11 is_stmt 0 view .LVU1815
 6925 040c D74B     		ldr	r3, .L583+4
 6926 040e D94A     		ldr	r2, .L583+12
 6927 0410 1A60     		str	r2, [r3]
2371:Src/usb_pd_protocol.c **** 		if (pd_set_power_supply_ready(port)) {
 6928              		.loc 1 2371 3 is_stmt 1 view .LVU1816
 6929              		.loc 1 2371 7 is_stmt 0 view .LVU1817
 6930 0412 3000     		movs	r0, r6
 6931 0414 FFF7FEFF 		bl	pd_set_power_supply_ready
 6932              	.LVL542:
 6933              		.loc 1 2371 6 view .LVU1818
 6934 0418 0028     		cmp	r0, #0
 6935 041a 2BD0     		beq	.L410
2372:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
 6936              		.loc 1 2372 4 is_stmt 1 view .LVU1819
 6937              	.LVL543:
 6938              	.LBB895:
 6939              	.LBI895:
 326:Src/usb_pd_protocol.c **** {
 6940              		.loc 1 326 20 view .LVU1820
 6941              	.LBB896:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6942              		.loc 1 328 2 view .LVU1821
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 6943              		.loc 1 328 17 is_stmt 0 view .LVU1822
 6944 041c F201     		lsls	r2, r6, #7
 6945 041e D24B     		ldr	r3, .L583
 6946 0420 9B18     		adds	r3, r3, r2
 6947 0422 1A79     		ldrb	r2, [r3, #4]
 6948              	.LVL544:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 6949              		.loc 1 333 2 is_stmt 1 view .LVU1823
 6950              	.LBB897:
 6951              	.LBI897:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 6952              		.loc 1 261 20 view .LVU1824
 6953              	.LBB898:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6954              		.loc 1 265 2 view .LVU1825
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 6955              		.loc 1 265 19 is_stmt 0 view .LVU1826
 6956 0424 0020     		movs	r0, #0
 6957 0426 0021     		movs	r1, #0
 6958 0428 1861     		str	r0, [r3, #16]
ARM GAS  /tmp/ccoQIC4J.s 			page 193


 6959 042a 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 6960              		.loc 1 266 2 is_stmt 1 view .LVU1827
 266:Src/usb_pd_protocol.c **** }
 6961              		.loc 1 266 25 is_stmt 0 view .LVU1828
 6962 042c 0021     		movs	r1, #0
 6963 042e D971     		strb	r1, [r3, #7]
 6964              	.LVL545:
 266:Src/usb_pd_protocol.c **** }
 6965              		.loc 1 266 25 view .LVU1829
 6966              	.LBE898:
 6967              	.LBE897:
 334:Src/usb_pd_protocol.c **** 
 6968              		.loc 1 334 2 is_stmt 1 view .LVU1830
 334:Src/usb_pd_protocol.c **** 
 6969              		.loc 1 334 22 is_stmt 0 view .LVU1831
 6970 0430 0E31     		adds	r1, r1, #14
 6971 0432 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 6972              		.loc 1 336 2 is_stmt 1 view .LVU1832
 336:Src/usb_pd_protocol.c **** 		return;
 6973              		.loc 1 336 5 is_stmt 0 view .LVU1833
 6974 0434 0E2A     		cmp	r2, #14
 6975 0436 01D1     		bne	.LCB6542
 6976 0438 00F014FF 		bl	.L354	@far jump
 6977              	.LCB6542:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6978              		.loc 1 347 2 is_stmt 1 view .LVU1834
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 6979              		.loc 1 347 5 is_stmt 0 view .LVU1835
 6980 043c 022A     		cmp	r2, #2
 6981 043e 01D1     		bne	.LCB6545
 6982 0440 00F010FF 		bl	.L354	@far jump
 6983              	.LCB6545:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 6984              		.loc 1 353 2 is_stmt 1 view .LVU1836
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6985              		.loc 1 356 3 view .LVU1837
 6986 0444 0022     		movs	r2, #0
 6987              	.LVL546:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 6988              		.loc 1 356 3 is_stmt 0 view .LVU1838
 6989 0446 0021     		movs	r1, #0
 6990 0448 3000     		movs	r0, r6
 6991 044a FFF7FEFF 		bl	pd_set_input_current_limit
 6992              	.LVL547:
 373:Src/usb_pd_protocol.c **** 			/*
 6993              		.loc 1 373 3 is_stmt 1 view .LVU1839
 373:Src/usb_pd_protocol.c **** 			/*
 6994              		.loc 1 373 15 is_stmt 0 view .LVU1840
 6995 044e F301     		lsls	r3, r6, #7
 6996 0450 C54A     		ldr	r2, .L583
 6997 0452 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 6998              		.loc 1 373 6 view .LVU1841
 6999 0454 012B     		cmp	r3, #1
 7000 0456 09D0     		beq	.L530
ARM GAS  /tmp/ccoQIC4J.s 			page 194


 7001              	.L411:
 405:Src/usb_pd_protocol.c **** 	}
 7002              		.loc 1 405 3 is_stmt 1 view .LVU1842
 7003              	.LVL548:
 7004              	.LBB899:
 7005              	.LBI899:
  94:Inc/tcpm.h    **** {
 7006              		.loc 2 94 19 view .LVU1843
 7007              	.LBB900:
  96:Inc/tcpm.h    **** }
 7008              		.loc 2 96 2 view .LVU1844
  96:Inc/tcpm.h    **** }
 7009              		.loc 2 96 26 is_stmt 0 view .LVU1845
 7010 0458 3201     		lsls	r2, r6, #4
 7011 045a C74B     		ldr	r3, .L583+16
 7012 045c 9B18     		adds	r3, r3, r2
 7013 045e 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 7014              		.loc 2 96 30 view .LVU1846
 7015 0460 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 7016              		.loc 2 96 9 view .LVU1847
 7017 0462 0021     		movs	r1, #0
 7018 0464 3000     		movs	r0, r6
 7019 0466 9847     		blx	r3
 7020              	.LVL549:
 7021 0468 00F0FCFE 		bl	.L354	@ far jump
 7022              	.LVL550:
 7023              	.L530:
  96:Inc/tcpm.h    **** }
 7024              		.loc 2 96 9 view .LVU1848
 7025              	.LBE900:
 7026              	.LBE899:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 7027              		.loc 1 378 4 is_stmt 1 view .LVU1849
 7028 046c 3000     		movs	r0, r6
 7029 046e FFF7FEFF 		bl	pd_power_supply_reset
 7030              	.LVL551:
 7031 0472 F1E7     		b	.L411
 7032              	.LVL552:
 7033              	.L410:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 7034              		.loc 1 378 4 is_stmt 0 view .LVU1850
 7035              	.LBE896:
 7036              	.LBE895:
2373:Src/usb_pd_protocol.c **** 			break;
2374:Src/usb_pd_protocol.c **** 		}
2375:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPM_TCPCI
2376:Src/usb_pd_protocol.c **** 		/*
2377:Src/usb_pd_protocol.c **** 			* After transmitting hard reset, TCPM writes
2378:Src/usb_pd_protocol.c **** 			* to RECEIVE_DETECT register to enable
2379:Src/usb_pd_protocol.c **** 			* PD message passing.
2380:Src/usb_pd_protocol.c **** 			*/
2381:Src/usb_pd_protocol.c **** 		if (pd_comm_is_enabled(port))
2382:Src/usb_pd_protocol.c **** 			tcpm_set_rx_enable(port, 1);
2383:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_TCPM_TCPCI */
2384:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 195


2385:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_STARTUP);
 7037              		.loc 1 2385 3 is_stmt 1 view .LVU1851
 7038              	.LBB901:
 7039              	.LBI901:
 326:Src/usb_pd_protocol.c **** {
 7040              		.loc 1 326 20 view .LVU1852
 7041              	.LBB902:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7042              		.loc 1 328 2 view .LVU1853
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 7043              		.loc 1 333 2 view .LVU1854
 7044              	.LBB903:
 7045              	.LBI903:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7046              		.loc 1 261 20 view .LVU1855
 7047              	.LBB904:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7048              		.loc 1 265 2 view .LVU1856
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7049              		.loc 1 265 19 is_stmt 0 view .LVU1857
 7050 0474 F201     		lsls	r2, r6, #7
 7051 0476 BC4B     		ldr	r3, .L583
 7052 0478 9B18     		adds	r3, r3, r2
 7053 047a 0020     		movs	r0, #0
 7054 047c 0021     		movs	r1, #0
 7055 047e 1861     		str	r0, [r3, #16]
 7056 0480 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7057              		.loc 1 266 2 is_stmt 1 view .LVU1858
 266:Src/usb_pd_protocol.c **** }
 7058              		.loc 1 266 25 is_stmt 0 view .LVU1859
 7059 0482 0022     		movs	r2, #0
 7060 0484 DA71     		strb	r2, [r3, #7]
 7061              	.LVL553:
 266:Src/usb_pd_protocol.c **** }
 7062              		.loc 1 266 25 view .LVU1860
 7063              	.LBE904:
 7064              	.LBE903:
 334:Src/usb_pd_protocol.c **** 
 7065              		.loc 1 334 2 is_stmt 1 view .LVU1861
 334:Src/usb_pd_protocol.c **** 
 7066              		.loc 1 334 22 is_stmt 0 view .LVU1862
 7067 0486 1132     		adds	r2, r2, #17
 7068 0488 1A71     		strb	r2, [r3, #4]
 7069              	.LVL554:
 336:Src/usb_pd_protocol.c **** 		return;
 7070              		.loc 1 336 2 is_stmt 1 view .LVU1863
 7071 048a 00F0EBFE 		bl	.L354	@ far jump
 7072              	.LVL555:
 7073              	.L371:
 336:Src/usb_pd_protocol.c **** 		return;
 7074              		.loc 1 336 2 is_stmt 0 view .LVU1864
 7075              	.LBE902:
 7076              	.LBE901:
2386:Src/usb_pd_protocol.c **** 		break;
2387:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_STARTUP:
2388:Src/usb_pd_protocol.c **** 		/* Wait for power source to enable */
ARM GAS  /tmp/ccoQIC4J.s 			page 196


2389:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 7077              		.loc 1 2389 3 is_stmt 1 view .LVU1865
 7078              		.loc 1 2389 15 is_stmt 0 view .LVU1866
 7079 048e F101     		lsls	r1, r6, #7
 7080 0490 B54A     		ldr	r2, .L583
 7081 0492 5218     		adds	r2, r2, r1
 7082 0494 5279     		ldrb	r2, [r2, #5]
 7083              		.loc 1 2389 6 view .LVU1867
 7084 0496 9342     		cmp	r3, r2
 7085 0498 01D1     		bne	.LCB6650
 7086 049a 00F0E3FE 		bl	.L354	@far jump
 7087              	.LCB6650:
2390:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 7088              		.loc 1 2390 4 is_stmt 1 view .LVU1868
 7089              		.loc 1 2390 19 is_stmt 0 view .LVU1869
 7090 049e B24C     		ldr	r4, .L583
 7091 04a0 6418     		adds	r4, r4, r1
 7092 04a2 0823     		movs	r3, #8
 7093 04a4 A268     		ldr	r2, [r4, #8]
 7094 04a6 1343     		orrs	r3, r2
 7095 04a8 A360     		str	r3, [r4, #8]
2391:Src/usb_pd_protocol.c **** 			/* reset various counters */
2392:Src/usb_pd_protocol.c **** 			caps_count = 0;
 7096              		.loc 1 2392 4 is_stmt 1 view .LVU1870
 7097              		.loc 1 2392 15 is_stmt 0 view .LVU1871
 7098 04aa 0023     		movs	r3, #0
 7099 04ac B34A     		ldr	r2, .L583+20
 7100 04ae 1360     		str	r3, [r2]
2393:Src/usb_pd_protocol.c **** 			pd[port].msg_id = 0;
 7101              		.loc 1 2393 4 is_stmt 1 view .LVU1872
 7102              		.loc 1 2393 20 is_stmt 0 view .LVU1873
 7103 04b0 A370     		strb	r3, [r4, #2]
2394:Src/usb_pd_protocol.c **** 			snk_cap_count = 0;
 7104              		.loc 1 2394 4 is_stmt 1 view .LVU1874
 7105              		.loc 1 2394 18 is_stmt 0 view .LVU1875
 7106 04b2 B34A     		ldr	r2, .L583+24
 7107 04b4 1360     		str	r3, [r2]
2395:Src/usb_pd_protocol.c **** 			set_state_timeout(
 7108              		.loc 1 2395 4 is_stmt 1 view .LVU1876
2396:Src/usb_pd_protocol.c **** 				port,
2397:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_BACKWARDS_COMPATIBLE_DFP
2398:Src/usb_pd_protocol.c **** 				/*
2399:Src/usb_pd_protocol.c **** 					* delay for power supply to start up.
2400:Src/usb_pd_protocol.c **** 					* subtract out debounce time if coming
2401:Src/usb_pd_protocol.c **** 					* from debounce state since vbus is
2402:Src/usb_pd_protocol.c **** 					* on during debounce.
2403:Src/usb_pd_protocol.c **** 					*/
2404:Src/usb_pd_protocol.c **** 				get_time().val +
2405:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY -
2406:Src/usb_pd_protocol.c **** 					(pd[port].last_state ==
2407:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_DISCONNECTED_DEBOUNCE
2408:Src/usb_pd_protocol.c **** 					? PD_T_CC_DEBOUNCE : 0),
2409:Src/usb_pd_protocol.c **** #else
2410:Src/usb_pd_protocol.c **** 				get_time().val +
 7109              		.loc 1 2410 5 is_stmt 0 view .LVU1877
 7110 04b6 04A8     		add	r0, sp, #16
 7111 04b8 FFF7FEFF 		bl	get_time
ARM GAS  /tmp/ccoQIC4J.s 			page 197


 7112              	.LVL556:
2395:Src/usb_pd_protocol.c **** 			set_state_timeout(
 7113              		.loc 1 2395 4 view .LVU1878
 7114 04bc AD4A     		ldr	r2, .L583+12
 7115 04be 0023     		movs	r3, #0
 7116 04c0 0498     		ldr	r0, [sp, #16]
 7117 04c2 0599     		ldr	r1, [sp, #20]
 7118 04c4 1218     		adds	r2, r2, r0
 7119 04c6 4B41     		adcs	r3, r3, r1
 7120              	.LVL557:
 7121              	.LBB905:
 7122              	.LBI905:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7123              		.loc 1 261 20 is_stmt 1 view .LVU1879
 7124              	.LBB906:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7125              		.loc 1 265 2 view .LVU1880
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7126              		.loc 1 265 19 is_stmt 0 view .LVU1881
 7127 04c8 2261     		str	r2, [r4, #16]
 7128 04ca 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 7129              		.loc 1 266 2 is_stmt 1 view .LVU1882
 266:Src/usb_pd_protocol.c **** }
 7130              		.loc 1 266 25 is_stmt 0 view .LVU1883
 7131 04cc 1223     		movs	r3, #18
 7132 04ce E371     		strb	r3, [r4, #7]
 7133 04d0 00F0C8FE 		bl	.L354	@ far jump
 7134              	.LVL558:
 7135              	.L370:
 266:Src/usb_pd_protocol.c **** }
 7136              		.loc 1 266 25 view .LVU1884
 7137              	.LBE906:
 7138              	.LBE905:
2411:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
2412:Src/usb_pd_protocol.c **** #endif
2413:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_DISCOVERY);
2414:Src/usb_pd_protocol.c **** 		}
2415:Src/usb_pd_protocol.c **** 		break;
2416:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_DISCOVERY:
2417:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 7139              		.loc 1 2417 3 is_stmt 1 view .LVU1885
 7140              		.loc 1 2417 15 is_stmt 0 view .LVU1886
 7141 04d4 F101     		lsls	r1, r6, #7
 7142 04d6 A44A     		ldr	r2, .L583
 7143 04d8 5218     		adds	r2, r2, r1
 7144 04da 5279     		ldrb	r2, [r2, #5]
 7145              		.loc 1 2417 6 view .LVU1887
 7146 04dc 9342     		cmp	r3, r2
 7147 04de 04D0     		beq	.L412
2418:Src/usb_pd_protocol.c **** 			/*
2419:Src/usb_pd_protocol.c **** 				* If we have had PD connection with this port
2420:Src/usb_pd_protocol.c **** 				* partner, then start NoResponseTimer.
2421:Src/usb_pd_protocol.c **** 				*/
2422:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_PREVIOUS_PD_CONN)
 7148              		.loc 1 2422 4 is_stmt 1 view .LVU1888
 7149              		.loc 1 2422 16 is_stmt 0 view .LVU1889
ARM GAS  /tmp/ccoQIC4J.s 			page 198


 7150 04e0 A14B     		ldr	r3, .L583
 7151 04e2 5B18     		adds	r3, r3, r1
 7152 04e4 9B68     		ldr	r3, [r3, #8]
 7153              		.loc 1 2422 7 view .LVU1890
 7154 04e6 DB05     		lsls	r3, r3, #23
 7155 04e8 13D4     		bmi	.L531
 7156              	.L412:
2423:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2424:Src/usb_pd_protocol.c **** 					get_time().val +
2425:Src/usb_pd_protocol.c **** 					PD_T_NO_RESPONSE,
2426:Src/usb_pd_protocol.c **** 					hard_reset_count <
2427:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
2428:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND :
2429:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED);
2430:Src/usb_pd_protocol.c **** 		}
2431:Src/usb_pd_protocol.c **** 
2432:Src/usb_pd_protocol.c **** 		/* Send source cap some minimum number of times */
2433:Src/usb_pd_protocol.c **** 		if (caps_count < PD_CAPS_COUNT) {
 7157              		.loc 1 2433 3 is_stmt 1 view .LVU1891
 7158              		.loc 1 2433 18 is_stmt 0 view .LVU1892
 7159 04ea A44B     		ldr	r3, .L583+20
 7160 04ec 1B68     		ldr	r3, [r3]
 7161              		.loc 1 2433 6 view .LVU1893
 7162 04ee 312B     		cmp	r3, #49
 7163 04f0 01DD     		ble	.LCB6717
 7164 04f2 00F0B7FE 		bl	.L354	@far jump
 7165              	.LCB6717:
2434:Src/usb_pd_protocol.c **** 			/* Query capabilities of the other side */
2435:Src/usb_pd_protocol.c **** 			res = send_source_cap(port);
 7166              		.loc 1 2435 4 is_stmt 1 view .LVU1894
 7167              		.loc 1 2435 10 is_stmt 0 view .LVU1895
 7168 04f6 3000     		movs	r0, r6
 7169 04f8 FFF7FEFF 		bl	send_source_cap
 7170              	.LVL559:
2436:Src/usb_pd_protocol.c **** 			/* packet was acked => PD capable device) */
2437:Src/usb_pd_protocol.c **** 			if (res >= 0) {
 7171              		.loc 1 2437 4 is_stmt 1 view .LVU1896
 7172              		.loc 1 2437 7 is_stmt 0 view .LVU1897
 7173 04fc 0028     		cmp	r0, #0
 7174 04fe 1FDA     		bge	.L532
2438:Src/usb_pd_protocol.c **** 				set_state(port,
2439:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_NEGOCIATE);
2440:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
2441:Src/usb_pd_protocol.c **** 				hard_reset_count = 0;
2442:Src/usb_pd_protocol.c **** 				caps_count = 0;
2443:Src/usb_pd_protocol.c **** 				/* Port partner is PD capable */
2444:Src/usb_pd_protocol.c **** 				pd[port].flags |=
2445:Src/usb_pd_protocol.c **** 					PD_FLAGS_PREVIOUS_PD_CONN;
2446:Src/usb_pd_protocol.c **** 			} else { /* failed, retry later */
2447:Src/usb_pd_protocol.c **** 				timeout = PD_T_SEND_SOURCE_CAP;
 7175              		.loc 1 2447 5 is_stmt 1 view .LVU1898
 7176              		.loc 1 2447 13 is_stmt 0 view .LVU1899
 7177 0500 9A4B     		ldr	r3, .L583+4
 7178 0502 A04A     		ldr	r2, .L583+28
 7179 0504 1A60     		str	r2, [r3]
2448:Src/usb_pd_protocol.c **** 				caps_count++;
 7180              		.loc 1 2448 5 is_stmt 1 view .LVU1900
ARM GAS  /tmp/ccoQIC4J.s 			page 199


 7181              		.loc 1 2448 15 is_stmt 0 view .LVU1901
 7182 0506 9D4A     		ldr	r2, .L583+20
 7183 0508 1368     		ldr	r3, [r2]
 7184 050a 0133     		adds	r3, r3, #1
 7185 050c 1360     		str	r3, [r2]
 7186 050e 00F0A9FE 		bl	.L354	@ far jump
 7187              	.L531:
2423:Src/usb_pd_protocol.c **** 					get_time().val +
 7188              		.loc 1 2423 5 is_stmt 1 view .LVU1902
2424:Src/usb_pd_protocol.c **** 					PD_T_NO_RESPONSE,
 7189              		.loc 1 2424 6 is_stmt 0 view .LVU1903
 7190 0512 04A8     		add	r0, sp, #16
 7191 0514 FFF7FEFF 		bl	get_time
 7192              	.LVL560:
2423:Src/usb_pd_protocol.c **** 					get_time().val +
 7193              		.loc 1 2423 5 view .LVU1904
 7194 0518 9B48     		ldr	r0, .L583+32
 7195 051a 0021     		movs	r1, #0
 7196 051c 049B     		ldr	r3, [sp, #16]
 7197 051e 059C     		ldr	r4, [sp, #20]
 7198 0520 C018     		adds	r0, r0, r3
 7199 0522 6141     		adcs	r1, r1, r4
2426:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
 7200              		.loc 1 2426 23 view .LVU1905
 7201 0524 994B     		ldr	r3, .L583+36
 7202 0526 1B68     		ldr	r3, [r3]
2423:Src/usb_pd_protocol.c **** 					get_time().val +
 7203              		.loc 1 2423 5 view .LVU1906
 7204 0528 012B     		cmp	r3, #1
 7205 052a 07DD     		ble	.L533
 7206 052c 0E24     		movs	r4, #14
 7207              	.L413:
 7208              	.LVL561:
 7209              	.LBB907:
 7210              	.LBI907:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7211              		.loc 1 261 20 is_stmt 1 discriminator 4 view .LVU1907
 7212              	.LBB908:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7213              		.loc 1 265 2 discriminator 4 view .LVU1908
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7214              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU1909
 7215 052e F201     		lsls	r2, r6, #7
 7216 0530 8D4B     		ldr	r3, .L583
 7217 0532 9B18     		adds	r3, r3, r2
 7218 0534 1861     		str	r0, [r3, #16]
 7219 0536 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7220              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU1910
 266:Src/usb_pd_protocol.c **** }
 7221              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU1911
 7222 0538 DC71     		strb	r4, [r3, #7]
 7223 053a D6E7     		b	.L412
 7224              	.LVL562:
 7225              	.L533:
 266:Src/usb_pd_protocol.c **** }
 7226              		.loc 1 266 25 discriminator 4 view .LVU1912
ARM GAS  /tmp/ccoQIC4J.s 			page 200


 7227              	.LBE908:
 7228              	.LBE907:
2423:Src/usb_pd_protocol.c **** 					get_time().val +
 7229              		.loc 1 2423 5 view .LVU1913
 7230 053c 1F24     		movs	r4, #31
 7231 053e F6E7     		b	.L413
 7232              	.L532:
2438:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_NEGOCIATE);
 7233              		.loc 1 2438 5 is_stmt 1 view .LVU1914
 7234              	.LVL563:
 7235              	.LBB909:
 7236              	.LBI909:
 326:Src/usb_pd_protocol.c **** {
 7237              		.loc 1 326 20 view .LVU1915
 7238              	.LBB910:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7239              		.loc 1 328 2 view .LVU1916
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 7240              		.loc 1 333 2 view .LVU1917
 7241              	.LBB911:
 7242              	.LBI911:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7243              		.loc 1 261 20 view .LVU1918
 7244              	.LBB912:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7245              		.loc 1 265 2 view .LVU1919
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7246              		.loc 1 265 19 is_stmt 0 view .LVU1920
 7247 0540 F201     		lsls	r2, r6, #7
 7248 0542 894B     		ldr	r3, .L583
 7249 0544 9B18     		adds	r3, r3, r2
 7250 0546 0020     		movs	r0, #0
 7251 0548 0021     		movs	r1, #0
 7252 054a 1861     		str	r0, [r3, #16]
 7253 054c 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7254              		.loc 1 266 2 is_stmt 1 view .LVU1921
 266:Src/usb_pd_protocol.c **** }
 7255              		.loc 1 266 25 is_stmt 0 view .LVU1922
 7256 054e 0022     		movs	r2, #0
 7257 0550 DA71     		strb	r2, [r3, #7]
 7258              	.LVL564:
 266:Src/usb_pd_protocol.c **** }
 7259              		.loc 1 266 25 view .LVU1923
 7260              	.LBE912:
 7261              	.LBE911:
 334:Src/usb_pd_protocol.c **** 
 7262              		.loc 1 334 2 is_stmt 1 view .LVU1924
 334:Src/usb_pd_protocol.c **** 
 7263              		.loc 1 334 22 is_stmt 0 view .LVU1925
 7264 0552 1321     		movs	r1, #19
 7265 0554 1971     		strb	r1, [r3, #4]
 7266              	.LVL565:
 336:Src/usb_pd_protocol.c **** 		return;
 7267              		.loc 1 336 2 is_stmt 1 view .LVU1926
 336:Src/usb_pd_protocol.c **** 		return;
 7268              		.loc 1 336 2 is_stmt 0 view .LVU1927
ARM GAS  /tmp/ccoQIC4J.s 			page 201


 7269              	.LBE910:
 7270              	.LBE909:
2440:Src/usb_pd_protocol.c **** 				hard_reset_count = 0;
 7271              		.loc 1 2440 5 is_stmt 1 view .LVU1928
2440:Src/usb_pd_protocol.c **** 				hard_reset_count = 0;
 7272              		.loc 1 2440 13 is_stmt 0 view .LVU1929
 7273 0556 8549     		ldr	r1, .L583+4
 7274 0558 8648     		ldr	r0, .L583+12
 7275 055a 0860     		str	r0, [r1]
2441:Src/usb_pd_protocol.c **** 				caps_count = 0;
 7276              		.loc 1 2441 5 is_stmt 1 view .LVU1930
2441:Src/usb_pd_protocol.c **** 				caps_count = 0;
 7277              		.loc 1 2441 22 is_stmt 0 view .LVU1931
 7278 055c 8B49     		ldr	r1, .L583+36
 7279 055e 0A60     		str	r2, [r1]
2442:Src/usb_pd_protocol.c **** 				/* Port partner is PD capable */
 7280              		.loc 1 2442 5 is_stmt 1 view .LVU1932
2442:Src/usb_pd_protocol.c **** 				/* Port partner is PD capable */
 7281              		.loc 1 2442 16 is_stmt 0 view .LVU1933
 7282 0560 8649     		ldr	r1, .L583+20
 7283 0562 0A60     		str	r2, [r1]
2444:Src/usb_pd_protocol.c **** 					PD_FLAGS_PREVIOUS_PD_CONN;
 7284              		.loc 1 2444 5 is_stmt 1 view .LVU1934
2444:Src/usb_pd_protocol.c **** 					PD_FLAGS_PREVIOUS_PD_CONN;
 7285              		.loc 1 2444 20 is_stmt 0 view .LVU1935
 7286 0564 0132     		adds	r2, r2, #1
 7287 0566 FF32     		adds	r2, r2, #255
 7288 0568 9968     		ldr	r1, [r3, #8]
 7289 056a 0A43     		orrs	r2, r1
 7290 056c 9A60     		str	r2, [r3, #8]
 7291 056e 00F079FE 		bl	.L354	@ far jump
 7292              	.L369:
2449:Src/usb_pd_protocol.c **** 			}
2450:Src/usb_pd_protocol.c **** 		}
2451:Src/usb_pd_protocol.c **** 		break;
2452:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_NEGOCIATE:
2453:Src/usb_pd_protocol.c **** 		/* wait for a "Request" message */
2454:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 7293              		.loc 1 2454 3 is_stmt 1 view .LVU1936
 7294              		.loc 1 2454 15 is_stmt 0 view .LVU1937
 7295 0572 F101     		lsls	r1, r6, #7
 7296 0574 7C4A     		ldr	r2, .L583
 7297 0576 5218     		adds	r2, r2, r1
 7298 0578 5279     		ldrb	r2, [r2, #5]
 7299              		.loc 1 2454 6 view .LVU1938
 7300 057a 9342     		cmp	r3, r2
 7301 057c 01D1     		bne	.LCB6851
 7302 057e 00F071FE 		bl	.L354	@far jump
 7303              	.LCB6851:
2455:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 7304              		.loc 1 2455 4 is_stmt 1 view .LVU1939
2456:Src/usb_pd_protocol.c **** 						get_time().val +
 7305              		.loc 1 2456 7 is_stmt 0 view .LVU1940
 7306 0582 04A8     		add	r0, sp, #16
 7307 0584 FFF7FEFF 		bl	get_time
 7308              	.LVL566:
2455:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
ARM GAS  /tmp/ccoQIC4J.s 			page 202


 7309              		.loc 1 2455 4 view .LVU1941
 7310 0588 7E48     		ldr	r0, .L583+28
 7311 058a 0021     		movs	r1, #0
 7312 058c 049B     		ldr	r3, [sp, #16]
 7313 058e 059C     		ldr	r4, [sp, #20]
 7314 0590 C018     		adds	r0, r0, r3
 7315 0592 6141     		adcs	r1, r1, r4
 7316              	.LVL567:
 7317              	.LBB913:
 7318              	.LBI913:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7319              		.loc 1 261 20 is_stmt 1 view .LVU1942
 7320              	.LBB914:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7321              		.loc 1 265 2 view .LVU1943
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7322              		.loc 1 265 19 is_stmt 0 view .LVU1944
 7323 0594 F201     		lsls	r2, r6, #7
 7324 0596 744B     		ldr	r3, .L583
 7325 0598 9B18     		adds	r3, r3, r2
 7326 059a 1861     		str	r0, [r3, #16]
 7327 059c 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7328              		.loc 1 266 2 is_stmt 1 view .LVU1945
 266:Src/usb_pd_protocol.c **** }
 7329              		.loc 1 266 25 is_stmt 0 view .LVU1946
 7330 059e 1F22     		movs	r2, #31
 7331 05a0 DA71     		strb	r2, [r3, #7]
 7332 05a2 00F05FFE 		bl	.L354	@ far jump
 7333              	.LVL568:
 7334              	.L368:
 266:Src/usb_pd_protocol.c **** }
 7335              		.loc 1 266 25 view .LVU1947
 7336              	.LBE914:
 7337              	.LBE913:
2457:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2458:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
2459:Src/usb_pd_protocol.c **** 		break;
2460:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_ACCEPTED:
2461:Src/usb_pd_protocol.c **** 		/* Accept sent, wait for enabling the new voltage */
2462:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 7338              		.loc 1 2462 3 is_stmt 1 view .LVU1948
 7339              		.loc 1 2462 15 is_stmt 0 view .LVU1949
 7340 05a6 F101     		lsls	r1, r6, #7
 7341 05a8 6F4A     		ldr	r2, .L583
 7342 05aa 5218     		adds	r2, r2, r1
 7343 05ac 5279     		ldrb	r2, [r2, #5]
 7344              		.loc 1 2462 6 view .LVU1950
 7345 05ae 9342     		cmp	r3, r2
 7346 05b0 01D1     		bne	.LCB6890
 7347 05b2 00F057FE 		bl	.L354	@far jump
 7348              	.LCB6890:
2463:Src/usb_pd_protocol.c **** 			set_state_timeout(
 7349              		.loc 1 2463 4 is_stmt 1 view .LVU1951
2464:Src/usb_pd_protocol.c **** 				port,
2465:Src/usb_pd_protocol.c **** 				get_time().val +
 7350              		.loc 1 2465 5 is_stmt 0 view .LVU1952
ARM GAS  /tmp/ccoQIC4J.s 			page 203


 7351 05b6 04A8     		add	r0, sp, #16
 7352 05b8 FFF7FEFF 		bl	get_time
 7353              	.LVL569:
2463:Src/usb_pd_protocol.c **** 			set_state_timeout(
 7354              		.loc 1 2463 4 view .LVU1953
 7355 05bc 7448     		ldr	r0, .L583+40
 7356 05be 0021     		movs	r1, #0
 7357 05c0 049B     		ldr	r3, [sp, #16]
 7358 05c2 059C     		ldr	r4, [sp, #20]
 7359 05c4 C018     		adds	r0, r0, r3
 7360 05c6 6141     		adcs	r1, r1, r4
 7361              	.LVL570:
 7362              	.LBB915:
 7363              	.LBI915:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7364              		.loc 1 261 20 is_stmt 1 view .LVU1954
 7365              	.LBB916:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7366              		.loc 1 265 2 view .LVU1955
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7367              		.loc 1 265 19 is_stmt 0 view .LVU1956
 7368 05c8 F201     		lsls	r2, r6, #7
 7369 05ca 674B     		ldr	r3, .L583
 7370 05cc 9B18     		adds	r3, r3, r2
 7371 05ce 1861     		str	r0, [r3, #16]
 7372 05d0 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7373              		.loc 1 266 2 is_stmt 1 view .LVU1957
 266:Src/usb_pd_protocol.c **** }
 7374              		.loc 1 266 25 is_stmt 0 view .LVU1958
 7375 05d2 1522     		movs	r2, #21
 7376 05d4 DA71     		strb	r2, [r3, #7]
 7377 05d6 00F045FE 		bl	.L354	@ far jump
 7378              	.LVL571:
 7379              	.L367:
 266:Src/usb_pd_protocol.c **** }
 7380              		.loc 1 266 25 view .LVU1959
 7381              	.LBE916:
 7382              	.LBE915:
2466:Src/usb_pd_protocol.c **** 				PD_T_SINK_TRANSITION,
2467:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_POWERED);
2468:Src/usb_pd_protocol.c **** 		break;
2469:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_POWERED:
2470:Src/usb_pd_protocol.c **** 		/* Switch to the new requested voltage */
2471:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 7383              		.loc 1 2471 3 is_stmt 1 view .LVU1960
 7384              		.loc 1 2471 15 is_stmt 0 view .LVU1961
 7385 05da F101     		lsls	r1, r6, #7
 7386 05dc 624A     		ldr	r2, .L583
 7387 05de 5218     		adds	r2, r2, r1
 7388 05e0 5279     		ldrb	r2, [r2, #5]
 7389              		.loc 1 2471 6 view .LVU1962
 7390 05e2 9342     		cmp	r3, r2
 7391 05e4 01D1     		bne	.LCB6929
 7392 05e6 00F03DFE 		bl	.L354	@far jump
 7393              	.LCB6929:
2472:Src/usb_pd_protocol.c **** 			pd_transition_voltage(pd[port].requested_idx);
ARM GAS  /tmp/ccoQIC4J.s 			page 204


 7394              		.loc 1 2472 4 is_stmt 1 view .LVU1963
 7395 05ea 5F4C     		ldr	r4, .L583
 7396 05ec 6418     		adds	r4, r4, r1
 7397 05ee E06A     		ldr	r0, [r4, #44]
 7398 05f0 FFF7FEFF 		bl	pd_transition_voltage
 7399              	.LVL572:
2473:Src/usb_pd_protocol.c **** 			set_state_timeout(
 7400              		.loc 1 2473 4 view .LVU1964
2474:Src/usb_pd_protocol.c **** 				port,
2475:Src/usb_pd_protocol.c **** 				get_time().val +
 7401              		.loc 1 2475 5 is_stmt 0 view .LVU1965
 7402 05f4 04A8     		add	r0, sp, #16
 7403 05f6 FFF7FEFF 		bl	get_time
 7404              	.LVL573:
2473:Src/usb_pd_protocol.c **** 			set_state_timeout(
 7405              		.loc 1 2473 4 view .LVU1966
 7406 05fa 5E4A     		ldr	r2, .L583+12
 7407 05fc 0023     		movs	r3, #0
 7408 05fe 0498     		ldr	r0, [sp, #16]
 7409 0600 0599     		ldr	r1, [sp, #20]
 7410 0602 1218     		adds	r2, r2, r0
 7411 0604 4B41     		adcs	r3, r3, r1
 7412              	.LVL574:
 7413              	.LBB917:
 7414              	.LBI917:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7415              		.loc 1 261 20 is_stmt 1 view .LVU1967
 7416              	.LBB918:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7417              		.loc 1 265 2 view .LVU1968
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7418              		.loc 1 265 19 is_stmt 0 view .LVU1969
 7419 0606 2261     		str	r2, [r4, #16]
 7420 0608 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 7421              		.loc 1 266 2 is_stmt 1 view .LVU1970
 266:Src/usb_pd_protocol.c **** }
 7422              		.loc 1 266 25 is_stmt 0 view .LVU1971
 7423 060a 1623     		movs	r3, #22
 7424 060c E371     		strb	r3, [r4, #7]
 7425 060e 00F029FE 		bl	.L354	@ far jump
 7426              	.LVL575:
 7427              	.L366:
 266:Src/usb_pd_protocol.c **** }
 7428              		.loc 1 266 25 view .LVU1972
 7429              	.LBE918:
 7430              	.LBE917:
2476:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
2477:Src/usb_pd_protocol.c **** 				PD_STATE_SRC_TRANSITION);
2478:Src/usb_pd_protocol.c **** 		}
2479:Src/usb_pd_protocol.c **** 		break;
2480:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_TRANSITION:
2481:Src/usb_pd_protocol.c **** 		/* the voltage output is good, notify the source */
2482:Src/usb_pd_protocol.c **** 		res = send_control(port, PD_CTRL_PS_RDY);
 7431              		.loc 1 2482 3 is_stmt 1 view .LVU1973
 7432              		.loc 1 2482 9 is_stmt 0 view .LVU1974
 7433 0612 0621     		movs	r1, #6
ARM GAS  /tmp/ccoQIC4J.s 			page 205


 7434 0614 3000     		movs	r0, r6
 7435 0616 FFF7FEFF 		bl	send_control
 7436              	.LVL576:
2483:Src/usb_pd_protocol.c **** 		if (res >= 0) {
 7437              		.loc 1 2483 3 is_stmt 1 view .LVU1975
 7438              		.loc 1 2483 6 is_stmt 0 view .LVU1976
 7439 061a 0028     		cmp	r0, #0
 7440 061c 0FDB     		blt	.L415
2484:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC_US;
 7441              		.loc 1 2484 4 is_stmt 1 view .LVU1977
 7442              		.loc 1 2484 12 is_stmt 0 view .LVU1978
 7443 061e 534B     		ldr	r3, .L583+4
 7444 0620 544A     		ldr	r2, .L583+12
 7445 0622 1A60     		str	r2, [r3]
2485:Src/usb_pd_protocol.c **** 			/* it'a time to ping regularly the sink */
2486:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_READY);
 7446              		.loc 1 2486 4 is_stmt 1 view .LVU1979
 7447              	.LVL577:
 7448              	.LBB919:
 7449              	.LBI919:
 326:Src/usb_pd_protocol.c **** {
 7450              		.loc 1 326 20 view .LVU1980
 7451              	.LBB920:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7452              		.loc 1 328 2 view .LVU1981
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 7453              		.loc 1 333 2 view .LVU1982
 7454              	.LBB921:
 7455              	.LBI921:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7456              		.loc 1 261 20 view .LVU1983
 7457              	.LBB922:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7458              		.loc 1 265 2 view .LVU1984
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7459              		.loc 1 265 19 is_stmt 0 view .LVU1985
 7460 0624 F201     		lsls	r2, r6, #7
 7461 0626 504B     		ldr	r3, .L583
 7462 0628 9B18     		adds	r3, r3, r2
 7463 062a 0020     		movs	r0, #0
 7464 062c 0021     		movs	r1, #0
 7465 062e 1861     		str	r0, [r3, #16]
 7466 0630 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7467              		.loc 1 266 2 is_stmt 1 view .LVU1986
 266:Src/usb_pd_protocol.c **** }
 7468              		.loc 1 266 25 is_stmt 0 view .LVU1987
 7469 0632 0022     		movs	r2, #0
 7470 0634 DA71     		strb	r2, [r3, #7]
 7471              	.LVL578:
 266:Src/usb_pd_protocol.c **** }
 7472              		.loc 1 266 25 view .LVU1988
 7473              	.LBE922:
 7474              	.LBE921:
 334:Src/usb_pd_protocol.c **** 
 7475              		.loc 1 334 2 is_stmt 1 view .LVU1989
 334:Src/usb_pd_protocol.c **** 
ARM GAS  /tmp/ccoQIC4J.s 			page 206


 7476              		.loc 1 334 22 is_stmt 0 view .LVU1990
 7477 0636 1732     		adds	r2, r2, #23
 7478 0638 1A71     		strb	r2, [r3, #4]
 7479              	.LVL579:
 336:Src/usb_pd_protocol.c **** 		return;
 7480              		.loc 1 336 2 is_stmt 1 view .LVU1991
 7481 063a 00F013FE 		bl	.L354	@ far jump
 7482              	.LVL580:
 7483              	.L415:
 336:Src/usb_pd_protocol.c **** 		return;
 7484              		.loc 1 336 2 is_stmt 0 view .LVU1992
 7485              	.LBE920:
 7486              	.LBE919:
2487:Src/usb_pd_protocol.c **** 		} else {
2488:Src/usb_pd_protocol.c **** 			/* The sink did not ack, cut the power... */
2489:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
 7487              		.loc 1 2489 4 is_stmt 1 view .LVU1993
 7488              	.LBB923:
 7489              	.LBI923:
 326:Src/usb_pd_protocol.c **** {
 7490              		.loc 1 326 20 view .LVU1994
 7491              	.LBB924:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7492              		.loc 1 328 2 view .LVU1995
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7493              		.loc 1 328 17 is_stmt 0 view .LVU1996
 7494 063e F201     		lsls	r2, r6, #7
 7495 0640 494B     		ldr	r3, .L583
 7496 0642 9B18     		adds	r3, r3, r2
 7497 0644 1A79     		ldrb	r2, [r3, #4]
 7498              	.LVL581:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 7499              		.loc 1 333 2 is_stmt 1 view .LVU1997
 7500              	.LBB925:
 7501              	.LBI925:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7502              		.loc 1 261 20 view .LVU1998
 7503              	.LBB926:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7504              		.loc 1 265 2 view .LVU1999
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7505              		.loc 1 265 19 is_stmt 0 view .LVU2000
 7506 0646 0020     		movs	r0, #0
 7507 0648 0021     		movs	r1, #0
 7508 064a 1861     		str	r0, [r3, #16]
 7509 064c 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7510              		.loc 1 266 2 is_stmt 1 view .LVU2001
 266:Src/usb_pd_protocol.c **** }
 7511              		.loc 1 266 25 is_stmt 0 view .LVU2002
 7512 064e 0021     		movs	r1, #0
 7513 0650 D971     		strb	r1, [r3, #7]
 7514              	.LVL582:
 266:Src/usb_pd_protocol.c **** }
 7515              		.loc 1 266 25 view .LVU2003
 7516              	.LBE926:
 7517              	.LBE925:
ARM GAS  /tmp/ccoQIC4J.s 			page 207


 334:Src/usb_pd_protocol.c **** 
 7518              		.loc 1 334 2 is_stmt 1 view .LVU2004
 334:Src/usb_pd_protocol.c **** 
 7519              		.loc 1 334 22 is_stmt 0 view .LVU2005
 7520 0652 0E31     		adds	r1, r1, #14
 7521 0654 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 7522              		.loc 1 336 2 is_stmt 1 view .LVU2006
 336:Src/usb_pd_protocol.c **** 		return;
 7523              		.loc 1 336 5 is_stmt 0 view .LVU2007
 7524 0656 0E2A     		cmp	r2, #14
 7525 0658 01D1     		bne	.LCB7056
 7526 065a 00F003FE 		bl	.L354	@far jump
 7527              	.LCB7056:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 7528              		.loc 1 347 2 is_stmt 1 view .LVU2008
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 7529              		.loc 1 347 5 is_stmt 0 view .LVU2009
 7530 065e 022A     		cmp	r2, #2
 7531 0660 01D1     		bne	.LCB7059
 7532 0662 00F0FFFD 		bl	.L354	@far jump
 7533              	.LCB7059:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 7534              		.loc 1 353 2 is_stmt 1 view .LVU2010
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 7535              		.loc 1 356 3 view .LVU2011
 7536 0666 0022     		movs	r2, #0
 7537              	.LVL583:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 7538              		.loc 1 356 3 is_stmt 0 view .LVU2012
 7539 0668 0021     		movs	r1, #0
 7540 066a 3000     		movs	r0, r6
 7541 066c FFF7FEFF 		bl	pd_set_input_current_limit
 7542              	.LVL584:
 373:Src/usb_pd_protocol.c **** 			/*
 7543              		.loc 1 373 3 is_stmt 1 view .LVU2013
 373:Src/usb_pd_protocol.c **** 			/*
 7544              		.loc 1 373 15 is_stmt 0 view .LVU2014
 7545 0670 F301     		lsls	r3, r6, #7
 7546 0672 3D4A     		ldr	r2, .L583
 7547 0674 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 7548              		.loc 1 373 6 view .LVU2015
 7549 0676 012B     		cmp	r3, #1
 7550 0678 09D0     		beq	.L534
 7551              	.L416:
 405:Src/usb_pd_protocol.c **** 	}
 7552              		.loc 1 405 3 is_stmt 1 view .LVU2016
 7553              	.LVL585:
 7554              	.LBB927:
 7555              	.LBI927:
  94:Inc/tcpm.h    **** {
 7556              		.loc 2 94 19 view .LVU2017
 7557              	.LBB928:
  96:Inc/tcpm.h    **** }
 7558              		.loc 2 96 2 view .LVU2018
  96:Inc/tcpm.h    **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 208


 7559              		.loc 2 96 26 is_stmt 0 view .LVU2019
 7560 067a 3201     		lsls	r2, r6, #4
 7561 067c 3E4B     		ldr	r3, .L583+16
 7562 067e 9B18     		adds	r3, r3, r2
 7563 0680 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 7564              		.loc 2 96 30 view .LVU2020
 7565 0682 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 7566              		.loc 2 96 9 view .LVU2021
 7567 0684 0021     		movs	r1, #0
 7568 0686 3000     		movs	r0, r6
 7569 0688 9847     		blx	r3
 7570              	.LVL586:
 7571 068a 00F0EBFD 		bl	.L354	@ far jump
 7572              	.LVL587:
 7573              	.L534:
  96:Inc/tcpm.h    **** }
 7574              		.loc 2 96 9 view .LVU2022
 7575              	.LBE928:
 7576              	.LBE927:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 7577              		.loc 1 378 4 is_stmt 1 view .LVU2023
 7578 068e 3000     		movs	r0, r6
 7579 0690 FFF7FEFF 		bl	pd_power_supply_reset
 7580              	.LVL588:
 7581 0694 F1E7     		b	.L416
 7582              	.LVL589:
 7583              	.L365:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 7584              		.loc 1 378 4 is_stmt 0 view .LVU2024
 7585              	.LBE924:
 7586              	.LBE923:
2490:Src/usb_pd_protocol.c **** 		}
2491:Src/usb_pd_protocol.c **** 		break;
2492:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_READY:
2493:Src/usb_pd_protocol.c **** 		timeout = PD_T_SOURCE_ACTIVITY;
 7587              		.loc 1 2493 3 is_stmt 1 view .LVU2025
 7588              		.loc 1 2493 11 is_stmt 0 view .LVU2026
 7589 0696 354B     		ldr	r3, .L583+4
 7590 0698 3E4A     		ldr	r2, .L583+44
 7591 069a 1A60     		str	r2, [r3]
2494:Src/usb_pd_protocol.c **** 
2495:Src/usb_pd_protocol.c **** 		/*
2496:Src/usb_pd_protocol.c **** 			* Don't send any PD traffic if we woke up due to
2497:Src/usb_pd_protocol.c **** 			* incoming packet or if VDO response pending to avoid
2498:Src/usb_pd_protocol.c **** 			* collisions.
2499:Src/usb_pd_protocol.c **** 			*/
2500:Src/usb_pd_protocol.c **** 		if (incoming_packet ||
 7592              		.loc 1 2500 3 is_stmt 1 view .LVU2027
 7593              		.loc 1 2500 7 is_stmt 0 view .LVU2028
 7594 069c 3E4B     		ldr	r3, .L583+48
 7595 069e 1B68     		ldr	r3, [r3]
 7596              		.loc 1 2500 6 view .LVU2029
 7597 06a0 002B     		cmp	r3, #0
 7598 06a2 01D0     		beq	.LCB7121
 7599 06a4 00F0DEFD 		bl	.L354	@far jump
ARM GAS  /tmp/ccoQIC4J.s 			page 209


 7600              	.LCB7121:
2501:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 7601              		.loc 1 2501 13 discriminator 1 view .LVU2030
 7602 06a8 F201     		lsls	r2, r6, #7
 7603 06aa 2F4B     		ldr	r3, .L583
 7604 06ac 9B18     		adds	r3, r3, r2
 7605 06ae 4833     		adds	r3, r3, #72
 7606 06b0 1B78     		ldrb	r3, [r3]
 7607 06b2 5BB2     		sxtb	r3, r3
2500:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 7608              		.loc 1 2500 23 discriminator 1 view .LVU2031
 7609 06b4 022B     		cmp	r3, #2
 7610 06b6 01D1     		bne	.LCB7129
 7611 06b8 00F0D4FD 		bl	.L354	@far jump
 7612              	.LCB7129:
2502:Src/usb_pd_protocol.c **** 			break;
2503:Src/usb_pd_protocol.c **** 
2504:Src/usb_pd_protocol.c **** 		/* Send updated source capabilities to our partner */
2505:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_UPDATE_SRC_CAPS) {
 7613              		.loc 1 2505 3 is_stmt 1 view .LVU2032
 7614              		.loc 1 2505 15 is_stmt 0 view .LVU2033
 7615 06bc 2A4B     		ldr	r3, .L583
 7616 06be 9B18     		adds	r3, r3, r2
 7617 06c0 9A68     		ldr	r2, [r3, #8]
 7618              		.loc 1 2505 6 view .LVU2034
 7619 06c2 1304     		lsls	r3, r2, #16
 7620 06c4 26D4     		bmi	.L535
2506:Src/usb_pd_protocol.c **** 			res = send_source_cap(port);
2507:Src/usb_pd_protocol.c **** 			if (res >= 0) {
2508:Src/usb_pd_protocol.c **** 				set_state(port,
2509:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_NEGOCIATE);
2510:Src/usb_pd_protocol.c **** 				pd[port].flags &=
2511:Src/usb_pd_protocol.c **** 					~PD_FLAGS_UPDATE_SRC_CAPS;
2512:Src/usb_pd_protocol.c **** 			}
2513:Src/usb_pd_protocol.c **** 			break;
2514:Src/usb_pd_protocol.c **** 		}
2515:Src/usb_pd_protocol.c **** 
2516:Src/usb_pd_protocol.c **** 		/* Send get sink cap if haven't received it yet */
2517:Src/usb_pd_protocol.c **** 		if (!(pd[port].flags & PD_FLAGS_SNK_CAP_RECVD)) {
 7621              		.loc 1 2517 3 is_stmt 1 view .LVU2035
 7622              		.loc 1 2517 6 is_stmt 0 view .LVU2036
 7623 06c6 D306     		lsls	r3, r2, #27
 7624 06c8 05D4     		bmi	.L418
2518:Src/usb_pd_protocol.c **** 			if (++snk_cap_count <= PD_SNK_CAP_RETRIES) {
 7625              		.loc 1 2518 4 is_stmt 1 view .LVU2037
 7626              		.loc 1 2518 8 is_stmt 0 view .LVU2038
 7627 06ca 2D49     		ldr	r1, .L583+24
 7628 06cc 0B68     		ldr	r3, [r1]
 7629 06ce 0133     		adds	r3, r3, #1
 7630              		.loc 1 2518 7 view .LVU2039
 7631 06d0 0B60     		str	r3, [r1]
 7632 06d2 032B     		cmp	r3, #3
 7633 06d4 36DD     		ble	.L536
 7634              	.L418:
2519:Src/usb_pd_protocol.c **** 				/* Get sink cap to know if dual-role device */
2520:Src/usb_pd_protocol.c **** 				send_control(port, PD_CTRL_GET_SINK_CAP);
2521:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_GET_SINK_CAP);
ARM GAS  /tmp/ccoQIC4J.s 			page 210


2522:Src/usb_pd_protocol.c **** 				break;
2523:Src/usb_pd_protocol.c **** 			} else if (debug_level >= 2 &&
2524:Src/usb_pd_protocol.c **** 					snk_cap_count == PD_SNK_CAP_RETRIES+1) {
2525:Src/usb_pd_protocol.c **** 				CPRINTF("ERR SNK_CAP\n");
 7635              		.loc 1 2525 29 is_stmt 1 view .LVU2040
2526:Src/usb_pd_protocol.c **** 			}
2527:Src/usb_pd_protocol.c **** 		}
2528:Src/usb_pd_protocol.c **** 
2529:Src/usb_pd_protocol.c **** 		/* Check power role policy, which may trigger a swap */
2530:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_PR_ROLE) {
 7636              		.loc 1 2530 3 view .LVU2041
 7637              		.loc 1 2530 6 is_stmt 0 view .LVU2042
 7638 06d6 9305     		lsls	r3, r2, #22
 7639 06d8 62D4     		bmi	.L537
2531:Src/usb_pd_protocol.c **** 			pd_check_pr_role(port, PD_ROLE_SOURCE,
2532:Src/usb_pd_protocol.c **** 						pd[port].flags);
2533:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_PR_ROLE;
2534:Src/usb_pd_protocol.c **** 			break;
2535:Src/usb_pd_protocol.c **** 		}
2536:Src/usb_pd_protocol.c **** 
2537:Src/usb_pd_protocol.c **** 		/* Check data role policy, which may trigger a swap */
2538:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_DR_ROLE) {
 7640              		.loc 1 2538 3 is_stmt 1 view .LVU2043
 7641              		.loc 1 2538 6 is_stmt 0 view .LVU2044
 7642 06da 5305     		lsls	r3, r2, #21
 7643 06dc 6DD4     		bmi	.L538
2539:Src/usb_pd_protocol.c **** 			pd_check_dr_role(port, pd[port].data_role,
2540:Src/usb_pd_protocol.c **** 						pd[port].flags);
2541:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_DR_ROLE;
2542:Src/usb_pd_protocol.c **** 			break;
2543:Src/usb_pd_protocol.c **** 		}
2544:Src/usb_pd_protocol.c **** 
2545:Src/usb_pd_protocol.c **** 		/* Send discovery SVDMs last */
2546:Src/usb_pd_protocol.c **** 		if (pd[port].data_role == PD_ROLE_DFP &&
 7644              		.loc 1 2546 3 is_stmt 1 view .LVU2045
 7645              		.loc 1 2546 15 is_stmt 0 view .LVU2046
 7646 06de F101     		lsls	r1, r6, #7
 7647 06e0 214B     		ldr	r3, .L583
 7648 06e2 5B18     		adds	r3, r3, r1
 7649 06e4 5B78     		ldrb	r3, [r3, #1]
 7650              		.loc 1 2546 6 view .LVU2047
 7651 06e6 012B     		cmp	r3, #1
 7652 06e8 74D0     		beq	.L539
 7653              	.L421:
2547:Src/usb_pd_protocol.c **** 			(pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
2548:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_SIMPLE_DFP
2549:Src/usb_pd_protocol.c **** 			pd_send_vdm(port, USB_SID_PD,
2550:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
2551:Src/usb_pd_protocol.c **** #endif
2552:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_IDENTITY;
2553:Src/usb_pd_protocol.c **** 			break;
2554:Src/usb_pd_protocol.c **** 		}
2555:Src/usb_pd_protocol.c **** 
2556:Src/usb_pd_protocol.c **** 		if (!(pd[port].flags & PD_FLAGS_PING_ENABLED))
 7654              		.loc 1 2556 3 is_stmt 1 view .LVU2048
 7655              		.loc 1 2556 6 is_stmt 0 view .LVU2049
 7656 06ea D307     		lsls	r3, r2, #31
ARM GAS  /tmp/ccoQIC4J.s 			page 211


 7657 06ec 01D4     		bmi	.LCB7175
 7658 06ee 00F0B9FD 		bl	.L354	@far jump
 7659              	.LCB7175:
2557:Src/usb_pd_protocol.c **** 			break;
2558:Src/usb_pd_protocol.c **** 
2559:Src/usb_pd_protocol.c **** 		/* Verify that the sink is alive */
2560:Src/usb_pd_protocol.c **** 		res = send_control(port, PD_CTRL_PING);
 7660              		.loc 1 2560 3 is_stmt 1 view .LVU2050
 7661              		.loc 1 2560 9 is_stmt 0 view .LVU2051
 7662 06f2 0521     		movs	r1, #5
 7663 06f4 3000     		movs	r0, r6
 7664 06f6 FFF7FEFF 		bl	send_control
 7665              	.LVL590:
2561:Src/usb_pd_protocol.c **** 		if (res >= 0)
 7666              		.loc 1 2561 3 is_stmt 1 view .LVU2052
 7667              		.loc 1 2561 6 is_stmt 0 view .LVU2053
 7668 06fa 0028     		cmp	r0, #0
 7669 06fc 01DB     		blt	.LCB7182
 7670 06fe 00F0B1FD 		bl	.L354	@far jump
 7671              	.LCB7182:
2562:Src/usb_pd_protocol.c **** 			break;
2563:Src/usb_pd_protocol.c **** 
2564:Src/usb_pd_protocol.c **** 		/* Ping dropped. Try soft reset. */
2565:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SOFT_RESET);
 7672              		.loc 1 2565 3 is_stmt 1 view .LVU2054
 7673 0702 1E21     		movs	r1, #30
 7674 0704 3000     		movs	r0, r6
 7675 0706 FFF7FEFF 		bl	set_state
 7676              	.LVL591:
2566:Src/usb_pd_protocol.c **** 		timeout = 10 * MSEC_US;
 7677              		.loc 1 2566 3 view .LVU2055
 7678              		.loc 1 2566 11 is_stmt 0 view .LVU2056
 7679 070a 184B     		ldr	r3, .L583+4
 7680 070c 194A     		ldr	r2, .L583+12
 7681 070e 1A60     		str	r2, [r3]
2567:Src/usb_pd_protocol.c **** 		break;
 7682              		.loc 1 2567 3 is_stmt 1 view .LVU2057
 7683 0710 00F0A8FD 		bl	.L354	@ far jump
 7684              	.L535:
2506:Src/usb_pd_protocol.c **** 			if (res >= 0) {
 7685              		.loc 1 2506 4 view .LVU2058
2506:Src/usb_pd_protocol.c **** 			if (res >= 0) {
 7686              		.loc 1 2506 10 is_stmt 0 view .LVU2059
 7687 0714 3000     		movs	r0, r6
 7688 0716 FFF7FEFF 		bl	send_source_cap
 7689              	.LVL592:
2507:Src/usb_pd_protocol.c **** 				set_state(port,
 7690              		.loc 1 2507 4 is_stmt 1 view .LVU2060
2507:Src/usb_pd_protocol.c **** 				set_state(port,
 7691              		.loc 1 2507 7 is_stmt 0 view .LVU2061
 7692 071a 0028     		cmp	r0, #0
 7693 071c 01DA     		bge	.LCB7202
 7694 071e 00F0A1FD 		bl	.L354	@far jump
 7695              	.LCB7202:
2508:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_NEGOCIATE);
 7696              		.loc 1 2508 5 is_stmt 1 view .LVU2062
 7697              	.LVL593:
ARM GAS  /tmp/ccoQIC4J.s 			page 212


 7698              	.LBB929:
 7699              	.LBI929:
 326:Src/usb_pd_protocol.c **** {
 7700              		.loc 1 326 20 view .LVU2063
 7701              	.LBB930:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7702              		.loc 1 328 2 view .LVU2064
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 7703              		.loc 1 333 2 view .LVU2065
 7704              	.LBB931:
 7705              	.LBI931:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7706              		.loc 1 261 20 view .LVU2066
 7707              	.LBB932:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7708              		.loc 1 265 2 view .LVU2067
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7709              		.loc 1 265 19 is_stmt 0 view .LVU2068
 7710 0722 F201     		lsls	r2, r6, #7
 7711 0724 104B     		ldr	r3, .L583
 7712 0726 9B18     		adds	r3, r3, r2
 7713 0728 0020     		movs	r0, #0
 7714 072a 0021     		movs	r1, #0
 7715 072c 1861     		str	r0, [r3, #16]
 7716 072e 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7717              		.loc 1 266 2 is_stmt 1 view .LVU2069
 266:Src/usb_pd_protocol.c **** }
 7718              		.loc 1 266 25 is_stmt 0 view .LVU2070
 7719 0730 0022     		movs	r2, #0
 7720 0732 DA71     		strb	r2, [r3, #7]
 7721              	.LVL594:
 266:Src/usb_pd_protocol.c **** }
 7722              		.loc 1 266 25 view .LVU2071
 7723              	.LBE932:
 7724              	.LBE931:
 334:Src/usb_pd_protocol.c **** 
 7725              		.loc 1 334 2 is_stmt 1 view .LVU2072
 334:Src/usb_pd_protocol.c **** 
 7726              		.loc 1 334 22 is_stmt 0 view .LVU2073
 7727 0734 1332     		adds	r2, r2, #19
 7728 0736 1A71     		strb	r2, [r3, #4]
 7729              	.LVL595:
 336:Src/usb_pd_protocol.c **** 		return;
 7730              		.loc 1 336 2 is_stmt 1 view .LVU2074
 336:Src/usb_pd_protocol.c **** 		return;
 7731              		.loc 1 336 2 is_stmt 0 view .LVU2075
 7732              	.LBE930:
 7733              	.LBE929:
2510:Src/usb_pd_protocol.c **** 					~PD_FLAGS_UPDATE_SRC_CAPS;
 7734              		.loc 1 2510 5 is_stmt 1 view .LVU2076
2510:Src/usb_pd_protocol.c **** 					~PD_FLAGS_UPDATE_SRC_CAPS;
 7735              		.loc 1 2510 20 is_stmt 0 view .LVU2077
 7736 0738 184A     		ldr	r2, .L583+52
 7737 073a 9968     		ldr	r1, [r3, #8]
 7738 073c 0A40     		ands	r2, r1
 7739 073e 9A60     		str	r2, [r3, #8]
ARM GAS  /tmp/ccoQIC4J.s 			page 213


 7740 0740 00F090FD 		bl	.L354	@ far jump
 7741              	.L536:
2520:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SRC_GET_SINK_CAP);
 7742              		.loc 1 2520 5 is_stmt 1 view .LVU2078
 7743 0744 0821     		movs	r1, #8
 7744 0746 3000     		movs	r0, r6
 7745 0748 FFF7FEFF 		bl	send_control
 7746              	.LVL596:
2521:Src/usb_pd_protocol.c **** 				break;
 7747              		.loc 1 2521 5 view .LVU2079
 7748              	.LBB933:
 7749              	.LBI933:
 326:Src/usb_pd_protocol.c **** {
 7750              		.loc 1 326 20 view .LVU2080
 7751              	.LBB934:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7752              		.loc 1 328 2 view .LVU2081
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 7753              		.loc 1 333 2 view .LVU2082
 7754              	.LBB935:
 7755              	.LBI935:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7756              		.loc 1 261 20 view .LVU2083
 7757              	.LBB936:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7758              		.loc 1 265 2 view .LVU2084
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7759              		.loc 1 265 19 is_stmt 0 view .LVU2085
 7760 074c F201     		lsls	r2, r6, #7
 7761 074e 064B     		ldr	r3, .L583
 7762 0750 9B18     		adds	r3, r3, r2
 7763 0752 0020     		movs	r0, #0
 7764 0754 0021     		movs	r1, #0
 7765 0756 1861     		str	r0, [r3, #16]
 7766 0758 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7767              		.loc 1 266 2 is_stmt 1 view .LVU2086
 266:Src/usb_pd_protocol.c **** }
 7768              		.loc 1 266 25 is_stmt 0 view .LVU2087
 7769 075a 0022     		movs	r2, #0
 7770 075c DA71     		strb	r2, [r3, #7]
 7771              	.LVL597:
 266:Src/usb_pd_protocol.c **** }
 7772              		.loc 1 266 25 view .LVU2088
 7773              	.LBE936:
 7774              	.LBE935:
 334:Src/usb_pd_protocol.c **** 
 7775              		.loc 1 334 2 is_stmt 1 view .LVU2089
 334:Src/usb_pd_protocol.c **** 
 7776              		.loc 1 334 22 is_stmt 0 view .LVU2090
 7777 075e 1832     		adds	r2, r2, #24
 7778 0760 1A71     		strb	r2, [r3, #4]
 7779              	.LVL598:
 336:Src/usb_pd_protocol.c **** 		return;
 7780              		.loc 1 336 2 is_stmt 1 view .LVU2091
 7781 0762 00F07FFD 		bl	.L354	@ far jump
 7782              	.L584:
ARM GAS  /tmp/ccoQIC4J.s 			page 214


 7783 0766 C046     		.align	2
 7784              	.L583:
 7785 0768 00000000 		.word	pd
 7786 076c 00000000 		.word	.LANCHOR5
 7787 0770 50C30000 		.word	50000
 7788 0774 10270000 		.word	10000
 7789 0778 00000000 		.word	tcpc_config
 7790 077c 00000000 		.word	.LANCHOR11
 7791 0780 00000000 		.word	.LANCHOR12
 7792 0784 A0860100 		.word	100000
 7793 0788 60EC5300 		.word	5500000
 7794 078c 00000000 		.word	.LANCHOR10
 7795 0790 B8880000 		.word	35000
 7796 0794 C8AF0000 		.word	45000
 7797 0798 00000000 		.word	.LANCHOR2
 7798 079c FF7FFFFF 		.word	-32769
 7799              	.LVL599:
 7800              	.L537:
 336:Src/usb_pd_protocol.c **** 		return;
 7801              		.loc 1 336 2 is_stmt 0 view .LVU2092
 7802              	.LBE934:
 7803              	.LBE933:
2531:Src/usb_pd_protocol.c **** 						pd[port].flags);
 7804              		.loc 1 2531 4 is_stmt 1 view .LVU2093
 7805 07a0 0121     		movs	r1, #1
 7806 07a2 3000     		movs	r0, r6
 7807 07a4 FFF7FEFF 		bl	pd_check_pr_role
 7808              	.LVL600:
2533:Src/usb_pd_protocol.c **** 			break;
 7809              		.loc 1 2533 4 view .LVU2094
2533:Src/usb_pd_protocol.c **** 			break;
 7810              		.loc 1 2533 19 is_stmt 0 view .LVU2095
 7811 07a8 F201     		lsls	r2, r6, #7
 7812 07aa CD4B     		ldr	r3, .L585
 7813 07ac 9B18     		adds	r3, r3, r2
 7814 07ae CD4A     		ldr	r2, .L585+4
 7815 07b0 9968     		ldr	r1, [r3, #8]
 7816 07b2 0A40     		ands	r2, r1
 7817 07b4 9A60     		str	r2, [r3, #8]
2534:Src/usb_pd_protocol.c **** 		}
 7818              		.loc 1 2534 4 is_stmt 1 view .LVU2096
 7819 07b6 00F055FD 		bl	.L354	@ far jump
 7820              	.L538:
2539:Src/usb_pd_protocol.c **** 						pd[port].flags);
 7821              		.loc 1 2539 4 view .LVU2097
2539:Src/usb_pd_protocol.c **** 						pd[port].flags);
 7822              		.loc 1 2539 35 is_stmt 0 view .LVU2098
 7823 07ba F301     		lsls	r3, r6, #7
 7824 07bc C84C     		ldr	r4, .L585
 7825 07be E418     		adds	r4, r4, r3
 7826 07c0 6178     		ldrb	r1, [r4, #1]
2539:Src/usb_pd_protocol.c **** 						pd[port].flags);
 7827              		.loc 1 2539 4 view .LVU2099
 7828 07c2 3000     		movs	r0, r6
 7829 07c4 FFF7FEFF 		bl	pd_check_dr_role
 7830              	.LVL601:
2541:Src/usb_pd_protocol.c **** 			break;
ARM GAS  /tmp/ccoQIC4J.s 			page 215


 7831              		.loc 1 2541 4 is_stmt 1 view .LVU2100
2541:Src/usb_pd_protocol.c **** 			break;
 7832              		.loc 1 2541 19 is_stmt 0 view .LVU2101
 7833 07c8 C74B     		ldr	r3, .L585+8
 7834 07ca A268     		ldr	r2, [r4, #8]
 7835 07cc 1340     		ands	r3, r2
 7836 07ce A360     		str	r3, [r4, #8]
2542:Src/usb_pd_protocol.c **** 		}
 7837              		.loc 1 2542 4 is_stmt 1 view .LVU2102
 7838 07d0 00F048FD 		bl	.L354	@ far jump
 7839              	.L539:
2546:Src/usb_pd_protocol.c **** 			(pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
 7840              		.loc 1 2546 41 is_stmt 0 discriminator 1 view .LVU2103
 7841 07d4 1307     		lsls	r3, r2, #28
 7842 07d6 88D5     		bpl	.L421
2549:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
 7843              		.loc 1 2549 4 is_stmt 1 view .LVU2104
 7844 07d8 FF21     		movs	r1, #255
 7845 07da 0023     		movs	r3, #0
 7846 07dc 0093     		str	r3, [sp]
 7847 07de 0122     		movs	r2, #1
 7848 07e0 0902     		lsls	r1, r1, #8
 7849 07e2 3000     		movs	r0, r6
 7850 07e4 FFF7FEFF 		bl	pd_send_vdm
 7851              	.LVL602:
2552:Src/usb_pd_protocol.c **** 			break;
 7852              		.loc 1 2552 4 view .LVU2105
2552:Src/usb_pd_protocol.c **** 			break;
 7853              		.loc 1 2552 19 is_stmt 0 view .LVU2106
 7854 07e8 F201     		lsls	r2, r6, #7
 7855 07ea BD4B     		ldr	r3, .L585
 7856 07ec 9B18     		adds	r3, r3, r2
 7857 07ee 0822     		movs	r2, #8
 7858 07f0 9968     		ldr	r1, [r3, #8]
 7859 07f2 9143     		bics	r1, r2
 7860 07f4 9960     		str	r1, [r3, #8]
2553:Src/usb_pd_protocol.c **** 		}
 7861              		.loc 1 2553 4 is_stmt 1 view .LVU2107
 7862 07f6 00F035FD 		bl	.L354	@ far jump
 7863              	.L364:
2568:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_GET_SINK_CAP:
2569:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 7864              		.loc 1 2569 3 view .LVU2108
 7865              		.loc 1 2569 15 is_stmt 0 view .LVU2109
 7866 07fa F101     		lsls	r1, r6, #7
 7867 07fc B84A     		ldr	r2, .L585
 7868 07fe 5218     		adds	r2, r2, r1
 7869 0800 5279     		ldrb	r2, [r2, #5]
 7870              		.loc 1 2569 6 view .LVU2110
 7871 0802 9342     		cmp	r3, r2
 7872 0804 01D1     		bne	.LCB7393
 7873 0806 00F02DFD 		bl	.L354	@far jump
 7874              	.LCB7393:
2570:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 7875              		.loc 1 2570 4 is_stmt 1 view .LVU2111
2571:Src/usb_pd_protocol.c **** 						get_time().val +
 7876              		.loc 1 2571 7 is_stmt 0 view .LVU2112
ARM GAS  /tmp/ccoQIC4J.s 			page 216


 7877 080a 04A8     		add	r0, sp, #16
 7878 080c FFF7FEFF 		bl	get_time
 7879              	.LVL603:
2570:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 7880              		.loc 1 2570 4 view .LVU2113
 7881 0810 B648     		ldr	r0, .L585+12
 7882 0812 0021     		movs	r1, #0
 7883 0814 049B     		ldr	r3, [sp, #16]
 7884 0816 059C     		ldr	r4, [sp, #20]
 7885 0818 C018     		adds	r0, r0, r3
 7886 081a 6141     		adcs	r1, r1, r4
 7887              	.LVL604:
 7888              	.LBB937:
 7889              	.LBI937:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7890              		.loc 1 261 20 is_stmt 1 view .LVU2114
 7891              	.LBB938:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7892              		.loc 1 265 2 view .LVU2115
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7893              		.loc 1 265 19 is_stmt 0 view .LVU2116
 7894 081c F201     		lsls	r2, r6, #7
 7895 081e B04B     		ldr	r3, .L585
 7896 0820 9B18     		adds	r3, r3, r2
 7897 0822 1861     		str	r0, [r3, #16]
 7898 0824 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7899              		.loc 1 266 2 is_stmt 1 view .LVU2117
 266:Src/usb_pd_protocol.c **** }
 7900              		.loc 1 266 25 is_stmt 0 view .LVU2118
 7901 0826 1722     		movs	r2, #23
 7902 0828 DA71     		strb	r2, [r3, #7]
 7903 082a 00F01BFD 		bl	.L354	@ far jump
 7904              	.LVL605:
 7905              	.L363:
 266:Src/usb_pd_protocol.c **** }
 7906              		.loc 1 266 25 view .LVU2119
 7907              	.LBE938:
 7908              	.LBE937:
2572:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2573:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_READY);
2574:Src/usb_pd_protocol.c **** 		break;
2575:Src/usb_pd_protocol.c **** 	case PD_STATE_DR_SWAP:
2576:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 7909              		.loc 1 2576 3 is_stmt 1 view .LVU2120
 7910              		.loc 1 2576 15 is_stmt 0 view .LVU2121
 7911 082e F101     		lsls	r1, r6, #7
 7912 0830 AB4A     		ldr	r2, .L585
 7913 0832 5218     		adds	r2, r2, r1
 7914 0834 5279     		ldrb	r2, [r2, #5]
 7915              		.loc 1 2576 6 view .LVU2122
 7916 0836 9342     		cmp	r3, r2
 7917 0838 01D1     		bne	.LCB7432
 7918 083a 00F013FD 		bl	.L354	@far jump
 7919              	.LCB7432:
2577:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_DR_SWAP);
 7920              		.loc 1 2577 4 is_stmt 1 view .LVU2123
ARM GAS  /tmp/ccoQIC4J.s 			page 217


 7921              		.loc 1 2577 10 is_stmt 0 view .LVU2124
 7922 083e 0921     		movs	r1, #9
 7923 0840 3000     		movs	r0, r6
 7924 0842 FFF7FEFF 		bl	send_control
 7925              	.LVL606:
2578:Src/usb_pd_protocol.c **** 			if (res < 0) {
 7926              		.loc 1 2578 4 is_stmt 1 view .LVU2125
 7927              		.loc 1 2578 7 is_stmt 0 view .LVU2126
 7928 0846 0028     		cmp	r0, #0
 7929 0848 47DA     		bge	.L422
2579:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
 7930              		.loc 1 2579 5 is_stmt 1 view .LVU2127
 7931              		.loc 1 2579 13 is_stmt 0 view .LVU2128
 7932 084a A94B     		ldr	r3, .L585+16
 7933 084c A94A     		ldr	r2, .L585+20
 7934 084e 1A60     		str	r2, [r3]
2580:Src/usb_pd_protocol.c **** 				/*
2581:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
2582:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
2583:Src/usb_pd_protocol.c **** 					* failure.
2584:Src/usb_pd_protocol.c **** 					*/
2585:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
 7935              		.loc 1 2585 5 is_stmt 1 view .LVU2129
 7936 0850 431C     		adds	r3, r0, #1
 7937 0852 06D0     		beq	.L507
2586:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
2587:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
 7938              		.loc 1 2587 7 is_stmt 0 view .LVU2130
 7939 0854 F301     		lsls	r3, r6, #7
 7940 0856 A24A     		ldr	r2, .L585
 7941 0858 9B5C     		ldrb	r3, [r3, r2]
2586:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
 7942              		.loc 1 2586 27 view .LVU2131
 7943 085a 002B     		cmp	r3, #0
 7944 085c 2FD1     		bne	.L508
 7945 085e 0822     		movs	r2, #8
 7946 0860 00E0     		b	.L423
 7947              	.L507:
2585:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
 7948              		.loc 1 2585 5 view .LVU2132
 7949 0862 1E22     		movs	r2, #30
 7950              	.L423:
 7951              	.LVL607:
 7952              	.LBB939:
 7953              	.LBI939:
 326:Src/usb_pd_protocol.c **** {
 7954              		.loc 1 326 20 is_stmt 1 discriminator 3 view .LVU2133
 7955              	.LBB940:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7956              		.loc 1 328 2 discriminator 3 view .LVU2134
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 7957              		.loc 1 328 17 is_stmt 0 discriminator 3 view .LVU2135
 7958 0864 F101     		lsls	r1, r6, #7
 7959 0866 9E4B     		ldr	r3, .L585
 7960 0868 5B18     		adds	r3, r3, r1
 7961 086a 1C79     		ldrb	r4, [r3, #4]
 7962              	.LVL608:
ARM GAS  /tmp/ccoQIC4J.s 			page 218


 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 7963              		.loc 1 333 2 is_stmt 1 discriminator 3 view .LVU2136
 7964              	.LBB941:
 7965              	.LBI941:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 7966              		.loc 1 261 20 discriminator 3 view .LVU2137
 7967              	.LBB942:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7968              		.loc 1 265 2 discriminator 3 view .LVU2138
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 7969              		.loc 1 265 19 is_stmt 0 discriminator 3 view .LVU2139
 7970 086c 0020     		movs	r0, #0
 7971 086e 0021     		movs	r1, #0
 7972 0870 1861     		str	r0, [r3, #16]
 7973 0872 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 7974              		.loc 1 266 2 is_stmt 1 discriminator 3 view .LVU2140
 266:Src/usb_pd_protocol.c **** }
 7975              		.loc 1 266 25 is_stmt 0 discriminator 3 view .LVU2141
 7976 0874 0021     		movs	r1, #0
 7977 0876 D971     		strb	r1, [r3, #7]
 7978              	.LVL609:
 266:Src/usb_pd_protocol.c **** }
 7979              		.loc 1 266 25 discriminator 3 view .LVU2142
 7980              	.LBE942:
 7981              	.LBE941:
 334:Src/usb_pd_protocol.c **** 
 7982              		.loc 1 334 2 is_stmt 1 discriminator 3 view .LVU2143
 334:Src/usb_pd_protocol.c **** 
 7983              		.loc 1 334 22 is_stmt 0 discriminator 3 view .LVU2144
 7984 0878 1A71     		strb	r2, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 7985              		.loc 1 336 2 is_stmt 1 discriminator 3 view .LVU2145
 336:Src/usb_pd_protocol.c **** 		return;
 7986              		.loc 1 336 5 is_stmt 0 discriminator 3 view .LVU2146
 7987 087a A242     		cmp	r2, r4
 7988 087c 01D1     		bne	.LCB7494
 7989 087e 00F0F1FC 		bl	.L354	@far jump
 7990              	.LCB7494:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 7991              		.loc 1 347 2 is_stmt 1 view .LVU2147
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 7992              		.loc 1 347 5 is_stmt 0 view .LVU2148
 7993 0882 022C     		cmp	r4, #2
 7994 0884 1DD0     		beq	.L540
 7995              	.L424:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 7996              		.loc 1 348 48 view .LVU2149
 7997 0886 0E2C     		cmp	r4, #14
 7998 0888 1FD0     		beq	.L541
 7999              	.L425:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8000              		.loc 1 353 2 is_stmt 1 view .LVU2150
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8001              		.loc 1 353 5 is_stmt 0 view .LVU2151
 8002 088a 0E2A     		cmp	r2, #14
 8003 088c 03D0     		beq	.L426
ARM GAS  /tmp/ccoQIC4J.s 			page 219


 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8004              		.loc 1 353 46 view .LVU2152
 8005 088e 022A     		cmp	r2, #2
 8006 0890 01D0     		beq	.LCB7507
 8007 0892 00F0E7FC 		bl	.L354	@far jump
 8008              	.LCB7507:
 8009              	.L426:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8010              		.loc 1 356 3 is_stmt 1 view .LVU2153
 8011 0896 0022     		movs	r2, #0
 8012              	.LVL610:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8013              		.loc 1 356 3 is_stmt 0 view .LVU2154
 8014 0898 0021     		movs	r1, #0
 8015 089a 3000     		movs	r0, r6
 8016 089c FFF7FEFF 		bl	pd_set_input_current_limit
 8017              	.LVL611:
 373:Src/usb_pd_protocol.c **** 			/*
 8018              		.loc 1 373 3 is_stmt 1 view .LVU2155
 373:Src/usb_pd_protocol.c **** 			/*
 8019              		.loc 1 373 15 is_stmt 0 view .LVU2156
 8020 08a0 F301     		lsls	r3, r6, #7
 8021 08a2 8F4A     		ldr	r2, .L585
 8022 08a4 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 8023              		.loc 1 373 6 view .LVU2157
 8024 08a6 012B     		cmp	r3, #1
 8025 08a8 13D0     		beq	.L542
 8026              	.L427:
 405:Src/usb_pd_protocol.c **** 	}
 8027              		.loc 1 405 3 is_stmt 1 view .LVU2158
 8028              	.LVL612:
 8029              	.LBB943:
 8030              	.LBI943:
  94:Inc/tcpm.h    **** {
 8031              		.loc 2 94 19 view .LVU2159
 8032              	.LBB944:
  96:Inc/tcpm.h    **** }
 8033              		.loc 2 96 2 view .LVU2160
  96:Inc/tcpm.h    **** }
 8034              		.loc 2 96 26 is_stmt 0 view .LVU2161
 8035 08aa 3201     		lsls	r2, r6, #4
 8036 08ac 924B     		ldr	r3, .L585+24
 8037 08ae 9B18     		adds	r3, r3, r2
 8038 08b0 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 8039              		.loc 2 96 30 view .LVU2162
 8040 08b2 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 8041              		.loc 2 96 9 view .LVU2163
 8042 08b4 0021     		movs	r1, #0
 8043 08b6 3000     		movs	r0, r6
 8044 08b8 9847     		blx	r3
 8045              	.LVL613:
 8046 08ba 00F0D3FC 		bl	.L354	@ far jump
 8047              	.LVL614:
 8048              	.L508:
ARM GAS  /tmp/ccoQIC4J.s 			page 220


  96:Inc/tcpm.h    **** }
 8049              		.loc 2 96 9 view .LVU2164
 8050              	.LBE944:
 8051              	.LBE943:
 8052              	.LBE940:
 8053              	.LBE939:
2586:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
 8054              		.loc 1 2586 27 view .LVU2165
 8055 08be 1722     		movs	r2, #23
 8056 08c0 D0E7     		b	.L423
 8057              	.LVL615:
 8058              	.L540:
 8059              	.LBB946:
 8060              	.LBB945:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8061              		.loc 1 347 47 view .LVU2166
 8062 08c2 0E2A     		cmp	r2, #14
 8063 08c4 DFD1     		bne	.L424
 8064 08c6 00F0CDFC 		bl	.L354	@ far jump
 8065              	.L541:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 8066              		.loc 1 349 47 view .LVU2167
 8067 08ca 022A     		cmp	r2, #2
 8068 08cc DDD1     		bne	.L425
 8069 08ce 00F0C9FC 		bl	.L354	@ far jump
 8070              	.LVL616:
 8071              	.L542:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8072              		.loc 1 378 4 is_stmt 1 view .LVU2168
 8073 08d2 3000     		movs	r0, r6
 8074 08d4 FFF7FEFF 		bl	pd_power_supply_reset
 8075              	.LVL617:
 8076 08d8 E7E7     		b	.L427
 8077              	.LVL618:
 8078              	.L422:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8079              		.loc 1 378 4 is_stmt 0 view .LVU2169
 8080              	.LBE945:
 8081              	.LBE946:
2588:Src/usb_pd_protocol.c **** 				break;
2589:Src/usb_pd_protocol.c **** 			}
2590:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
2591:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8082              		.loc 1 2591 4 is_stmt 1 view .LVU2170
2592:Src/usb_pd_protocol.c **** 						get_time().val +
 8083              		.loc 1 2592 7 is_stmt 0 view .LVU2171
 8084 08da 04A8     		add	r0, sp, #16
 8085 08dc FFF7FEFF 		bl	get_time
 8086              	.LVL619:
2591:Src/usb_pd_protocol.c **** 						get_time().val +
 8087              		.loc 1 2591 4 view .LVU2172
 8088 08e0 8248     		ldr	r0, .L585+12
 8089 08e2 0021     		movs	r1, #0
 8090 08e4 049B     		ldr	r3, [sp, #16]
 8091 08e6 059C     		ldr	r4, [sp, #20]
 8092 08e8 C018     		adds	r0, r0, r3
 8093 08ea 6141     		adcs	r1, r1, r4
ARM GAS  /tmp/ccoQIC4J.s 			page 221


2593:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2594:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
 8094              		.loc 1 2594 7 view .LVU2173
 8095 08ec F301     		lsls	r3, r6, #7
 8096 08ee 7C4A     		ldr	r2, .L585
 8097 08f0 9B5C     		ldrb	r3, [r3, r2]
2591:Src/usb_pd_protocol.c **** 						get_time().val +
 8098              		.loc 1 2591 4 view .LVU2174
 8099 08f2 002B     		cmp	r3, #0
 8100 08f4 08D1     		bne	.L509
 8101 08f6 0824     		movs	r4, #8
 8102              	.L428:
 8103              	.LVL620:
 8104              	.LBB947:
 8105              	.LBI947:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8106              		.loc 1 261 20 is_stmt 1 discriminator 4 view .LVU2175
 8107              	.LBB948:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8108              		.loc 1 265 2 discriminator 4 view .LVU2176
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8109              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU2177
 8110 08f8 F201     		lsls	r2, r6, #7
 8111 08fa 794B     		ldr	r3, .L585
 8112 08fc 9B18     		adds	r3, r3, r2
 8113 08fe 1861     		str	r0, [r3, #16]
 8114 0900 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 8115              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU2178
 266:Src/usb_pd_protocol.c **** }
 8116              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU2179
 8117 0902 DC71     		strb	r4, [r3, #7]
 8118 0904 00F0AEFC 		bl	.L354	@ far jump
 8119              	.LVL621:
 8120              	.L509:
 266:Src/usb_pd_protocol.c **** }
 8121              		.loc 1 266 25 discriminator 4 view .LVU2180
 8122              	.LBE948:
 8123              	.LBE947:
2591:Src/usb_pd_protocol.c **** 						get_time().val +
 8124              		.loc 1 2591 4 view .LVU2181
 8125 0908 1724     		movs	r4, #23
 8126 090a F5E7     		b	.L428
 8127              	.L362:
2595:Src/usb_pd_protocol.c **** 		}
2596:Src/usb_pd_protocol.c **** 		break;
2597:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
2598:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_INIT:
2599:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 8128              		.loc 1 2599 3 is_stmt 1 view .LVU2182
 8129              		.loc 1 2599 15 is_stmt 0 view .LVU2183
 8130 090c F101     		lsls	r1, r6, #7
 8131 090e 744A     		ldr	r2, .L585
 8132 0910 5218     		adds	r2, r2, r1
 8133 0912 5279     		ldrb	r2, [r2, #5]
 8134              		.loc 1 2599 6 view .LVU2184
 8135 0914 9342     		cmp	r3, r2
ARM GAS  /tmp/ccoQIC4J.s 			page 222


 8136 0916 01D1     		bne	.LCB7643
 8137 0918 00F0A4FC 		bl	.L354	@far jump
 8138              	.LCB7643:
2600:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_PR_SWAP);
 8139              		.loc 1 2600 4 is_stmt 1 view .LVU2185
 8140              		.loc 1 2600 10 is_stmt 0 view .LVU2186
 8141 091c 0A21     		movs	r1, #10
 8142 091e 3000     		movs	r0, r6
 8143 0920 FFF7FEFF 		bl	send_control
 8144              	.LVL622:
2601:Src/usb_pd_protocol.c **** 			if (res < 0) {
 8145              		.loc 1 2601 4 is_stmt 1 view .LVU2187
 8146              		.loc 1 2601 7 is_stmt 0 view .LVU2188
 8147 0924 0028     		cmp	r0, #0
 8148 0926 40DA     		bge	.L429
2602:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
 8149              		.loc 1 2602 5 is_stmt 1 view .LVU2189
 8150              		.loc 1 2602 13 is_stmt 0 view .LVU2190
 8151 0928 714B     		ldr	r3, .L585+16
 8152 092a 724A     		ldr	r2, .L585+20
 8153 092c 1A60     		str	r2, [r3]
2603:Src/usb_pd_protocol.c **** 				/*
2604:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
2605:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
2606:Src/usb_pd_protocol.c **** 					* failure.
2607:Src/usb_pd_protocol.c **** 					*/
2608:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
 8154              		.loc 1 2608 5 is_stmt 1 view .LVU2191
 8155 092e 431C     		adds	r3, r0, #1
 8156 0930 2DD0     		beq	.L543
 8157 0932 1722     		movs	r2, #23
 8158              	.L430:
 8159              	.LVL623:
 8160              	.LBB949:
 8161              	.LBI949:
 326:Src/usb_pd_protocol.c **** {
 8162              		.loc 1 326 20 discriminator 4 view .LVU2192
 8163              	.LBB950:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8164              		.loc 1 328 2 discriminator 4 view .LVU2193
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8165              		.loc 1 328 17 is_stmt 0 discriminator 4 view .LVU2194
 8166 0934 F101     		lsls	r1, r6, #7
 8167 0936 6A4B     		ldr	r3, .L585
 8168 0938 5B18     		adds	r3, r3, r1
 8169 093a 1C79     		ldrb	r4, [r3, #4]
 8170              	.LVL624:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 8171              		.loc 1 333 2 is_stmt 1 discriminator 4 view .LVU2195
 8172              	.LBB951:
 8173              	.LBI951:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8174              		.loc 1 261 20 discriminator 4 view .LVU2196
 8175              	.LBB952:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8176              		.loc 1 265 2 discriminator 4 view .LVU2197
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
ARM GAS  /tmp/ccoQIC4J.s 			page 223


 8177              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU2198
 8178 093c 0020     		movs	r0, #0
 8179 093e 0021     		movs	r1, #0
 8180 0940 1861     		str	r0, [r3, #16]
 8181 0942 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 8182              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU2199
 266:Src/usb_pd_protocol.c **** }
 8183              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU2200
 8184 0944 0021     		movs	r1, #0
 8185 0946 D971     		strb	r1, [r3, #7]
 8186              	.LVL625:
 266:Src/usb_pd_protocol.c **** }
 8187              		.loc 1 266 25 discriminator 4 view .LVU2201
 8188              	.LBE952:
 8189              	.LBE951:
 334:Src/usb_pd_protocol.c **** 
 8190              		.loc 1 334 2 is_stmt 1 discriminator 4 view .LVU2202
 334:Src/usb_pd_protocol.c **** 
 8191              		.loc 1 334 22 is_stmt 0 discriminator 4 view .LVU2203
 8192 0948 1A71     		strb	r2, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 8193              		.loc 1 336 2 is_stmt 1 discriminator 4 view .LVU2204
 336:Src/usb_pd_protocol.c **** 		return;
 8194              		.loc 1 336 5 is_stmt 0 discriminator 4 view .LVU2205
 8195 094a A242     		cmp	r2, r4
 8196 094c 01D1     		bne	.LCB7695
 8197 094e 00F089FC 		bl	.L354	@far jump
 8198              	.LCB7695:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8199              		.loc 1 347 2 is_stmt 1 view .LVU2206
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8200              		.loc 1 347 5 is_stmt 0 view .LVU2207
 8201 0952 022C     		cmp	r4, #2
 8202 0954 1DD0     		beq	.L544
 8203              	.L431:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 8204              		.loc 1 348 48 view .LVU2208
 8205 0956 0E2C     		cmp	r4, #14
 8206 0958 1FD0     		beq	.L545
 8207              	.L432:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8208              		.loc 1 353 2 is_stmt 1 view .LVU2209
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8209              		.loc 1 353 5 is_stmt 0 view .LVU2210
 8210 095a 0E2A     		cmp	r2, #14
 8211 095c 03D0     		beq	.L433
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8212              		.loc 1 353 46 view .LVU2211
 8213 095e 022A     		cmp	r2, #2
 8214 0960 01D0     		beq	.LCB7708
 8215 0962 00F07FFC 		bl	.L354	@far jump
 8216              	.LCB7708:
 8217              	.L433:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8218              		.loc 1 356 3 is_stmt 1 view .LVU2212
 8219 0966 0022     		movs	r2, #0
ARM GAS  /tmp/ccoQIC4J.s 			page 224


 8220              	.LVL626:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8221              		.loc 1 356 3 is_stmt 0 view .LVU2213
 8222 0968 0021     		movs	r1, #0
 8223 096a 3000     		movs	r0, r6
 8224 096c FFF7FEFF 		bl	pd_set_input_current_limit
 8225              	.LVL627:
 373:Src/usb_pd_protocol.c **** 			/*
 8226              		.loc 1 373 3 is_stmt 1 view .LVU2214
 373:Src/usb_pd_protocol.c **** 			/*
 8227              		.loc 1 373 15 is_stmt 0 view .LVU2215
 8228 0970 F301     		lsls	r3, r6, #7
 8229 0972 5B4A     		ldr	r2, .L585
 8230 0974 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 8231              		.loc 1 373 6 view .LVU2216
 8232 0976 012B     		cmp	r3, #1
 8233 0978 13D0     		beq	.L546
 8234              	.L434:
 405:Src/usb_pd_protocol.c **** 	}
 8235              		.loc 1 405 3 is_stmt 1 view .LVU2217
 8236              	.LVL628:
 8237              	.LBB953:
 8238              	.LBI953:
  94:Inc/tcpm.h    **** {
 8239              		.loc 2 94 19 view .LVU2218
 8240              	.LBB954:
  96:Inc/tcpm.h    **** }
 8241              		.loc 2 96 2 view .LVU2219
  96:Inc/tcpm.h    **** }
 8242              		.loc 2 96 26 is_stmt 0 view .LVU2220
 8243 097a 3201     		lsls	r2, r6, #4
 8244 097c 5E4B     		ldr	r3, .L585+24
 8245 097e 9B18     		adds	r3, r3, r2
 8246 0980 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 8247              		.loc 2 96 30 view .LVU2221
 8248 0982 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 8249              		.loc 2 96 9 view .LVU2222
 8250 0984 0021     		movs	r1, #0
 8251 0986 3000     		movs	r0, r6
 8252 0988 9847     		blx	r3
 8253              	.LVL629:
 8254 098a 00F06BFC 		bl	.L354	@ far jump
 8255              	.LVL630:
 8256              	.L543:
  96:Inc/tcpm.h    **** }
 8257              		.loc 2 96 9 view .LVU2223
 8258              	.LBE954:
 8259              	.LBE953:
 8260              	.LBE950:
 8261              	.LBE949:
 8262              		.loc 1 2608 5 view .LVU2224
 8263 098e 1E22     		movs	r2, #30
 8264 0990 D0E7     		b	.L430
 8265              	.LVL631:
ARM GAS  /tmp/ccoQIC4J.s 			page 225


 8266              	.L544:
 8267              	.LBB956:
 8268              	.LBB955:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8269              		.loc 1 347 47 view .LVU2225
 8270 0992 0E2A     		cmp	r2, #14
 8271 0994 DFD1     		bne	.L431
 8272 0996 00F065FC 		bl	.L354	@ far jump
 8273              	.L545:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 8274              		.loc 1 349 47 view .LVU2226
 8275 099a 022A     		cmp	r2, #2
 8276 099c DDD1     		bne	.L432
 8277 099e 00F061FC 		bl	.L354	@ far jump
 8278              	.LVL632:
 8279              	.L546:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8280              		.loc 1 378 4 is_stmt 1 view .LVU2227
 8281 09a2 3000     		movs	r0, r6
 8282 09a4 FFF7FEFF 		bl	pd_power_supply_reset
 8283              	.LVL633:
 8284 09a8 E7E7     		b	.L434
 8285              	.LVL634:
 8286              	.L429:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8287              		.loc 1 378 4 is_stmt 0 view .LVU2228
 8288              	.LBE955:
 8289              	.LBE956:
2609:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
2610:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_READY);
2611:Src/usb_pd_protocol.c **** 				break;
2612:Src/usb_pd_protocol.c **** 			}
2613:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
2614:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8290              		.loc 1 2614 4 is_stmt 1 view .LVU2229
2615:Src/usb_pd_protocol.c **** 						get_time().val +
 8291              		.loc 1 2615 7 is_stmt 0 view .LVU2230
 8292 09aa 04A8     		add	r0, sp, #16
 8293 09ac FFF7FEFF 		bl	get_time
 8294              	.LVL635:
2614:Src/usb_pd_protocol.c **** 						get_time().val +
 8295              		.loc 1 2614 4 view .LVU2231
 8296 09b0 4E48     		ldr	r0, .L585+12
 8297 09b2 0021     		movs	r1, #0
 8298 09b4 049B     		ldr	r3, [sp, #16]
 8299 09b6 059C     		ldr	r4, [sp, #20]
 8300 09b8 C018     		adds	r0, r0, r3
 8301 09ba 6141     		adcs	r1, r1, r4
 8302              	.LVL636:
 8303              	.LBB957:
 8304              	.LBI957:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8305              		.loc 1 261 20 is_stmt 1 view .LVU2232
 8306              	.LBB958:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8307              		.loc 1 265 2 view .LVU2233
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
ARM GAS  /tmp/ccoQIC4J.s 			page 226


 8308              		.loc 1 265 19 is_stmt 0 view .LVU2234
 8309 09bc F201     		lsls	r2, r6, #7
 8310 09be 484B     		ldr	r3, .L585
 8311 09c0 9B18     		adds	r3, r3, r2
 8312 09c2 1861     		str	r0, [r3, #16]
 8313 09c4 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 8314              		.loc 1 266 2 is_stmt 1 view .LVU2235
 266:Src/usb_pd_protocol.c **** }
 8315              		.loc 1 266 25 is_stmt 0 view .LVU2236
 8316 09c6 1722     		movs	r2, #23
 8317 09c8 DA71     		strb	r2, [r3, #7]
 8318 09ca 00F04BFC 		bl	.L354	@ far jump
 8319              	.LVL637:
 8320              	.L361:
 266:Src/usb_pd_protocol.c **** }
 8321              		.loc 1 266 25 view .LVU2237
 8322              	.LBE958:
 8323              	.LBE957:
2616:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2617:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_READY);
2618:Src/usb_pd_protocol.c **** 		}
2619:Src/usb_pd_protocol.c **** 		break;
2620:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_SNK_DISABLE:
2621:Src/usb_pd_protocol.c **** 		/* Give time for sink to stop drawing current */
2622:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 8324              		.loc 1 2622 3 is_stmt 1 view .LVU2238
 8325              		.loc 1 2622 15 is_stmt 0 view .LVU2239
 8326 09ce F101     		lsls	r1, r6, #7
 8327 09d0 434A     		ldr	r2, .L585
 8328 09d2 5218     		adds	r2, r2, r1
 8329 09d4 5279     		ldrb	r2, [r2, #5]
 8330              		.loc 1 2622 6 view .LVU2240
 8331 09d6 9342     		cmp	r3, r2
 8332 09d8 01D1     		bne	.LCB7831
 8333 09da 00F043FC 		bl	.L354	@far jump
 8334              	.LCB7831:
2623:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8335              		.loc 1 2623 4 is_stmt 1 view .LVU2241
2624:Src/usb_pd_protocol.c **** 						get_time().val +
 8336              		.loc 1 2624 7 is_stmt 0 view .LVU2242
 8337 09de 04A8     		add	r0, sp, #16
 8338 09e0 FFF7FEFF 		bl	get_time
 8339              	.LVL638:
2623:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8340              		.loc 1 2623 4 view .LVU2243
 8341 09e4 4548     		ldr	r0, .L585+28
 8342 09e6 0021     		movs	r1, #0
 8343 09e8 049B     		ldr	r3, [sp, #16]
 8344 09ea 059C     		ldr	r4, [sp, #20]
 8345 09ec C018     		adds	r0, r0, r3
 8346 09ee 6141     		adcs	r1, r1, r4
 8347              	.LVL639:
 8348              	.LBB959:
 8349              	.LBI959:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8350              		.loc 1 261 20 is_stmt 1 view .LVU2244
ARM GAS  /tmp/ccoQIC4J.s 			page 227


 8351              	.LBB960:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8352              		.loc 1 265 2 view .LVU2245
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8353              		.loc 1 265 19 is_stmt 0 view .LVU2246
 8354 09f0 F201     		lsls	r2, r6, #7
 8355 09f2 3B4B     		ldr	r3, .L585
 8356 09f4 9B18     		adds	r3, r3, r2
 8357 09f6 1861     		str	r0, [r3, #16]
 8358 09f8 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 8359              		.loc 1 266 2 is_stmt 1 view .LVU2247
 266:Src/usb_pd_protocol.c **** }
 8360              		.loc 1 266 25 is_stmt 0 view .LVU2248
 8361 09fa 1C22     		movs	r2, #28
 8362 09fc DA71     		strb	r2, [r3, #7]
 8363 09fe 00F031FC 		bl	.L354	@ far jump
 8364              	.LVL640:
 8365              	.L360:
 266:Src/usb_pd_protocol.c **** }
 8366              		.loc 1 266 25 view .LVU2249
 8367              	.LBE960:
 8368              	.LBE959:
2625:Src/usb_pd_protocol.c **** 						PD_T_SINK_TRANSITION,
2626:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_SWAP_SRC_DISABLE);
2627:Src/usb_pd_protocol.c **** 		break;
2628:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_SRC_DISABLE:
2629:Src/usb_pd_protocol.c **** 		/* Turn power off */
2630:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 8369              		.loc 1 2630 3 is_stmt 1 view .LVU2250
 8370              		.loc 1 2630 15 is_stmt 0 view .LVU2251
 8371 0a02 F101     		lsls	r1, r6, #7
 8372 0a04 364A     		ldr	r2, .L585
 8373 0a06 5218     		adds	r2, r2, r1
 8374 0a08 5279     		ldrb	r2, [r2, #5]
 8375              		.loc 1 2630 6 view .LVU2252
 8376 0a0a 9342     		cmp	r3, r2
 8377 0a0c 01D1     		bne	.LCB7870
 8378 0a0e 00F029FC 		bl	.L354	@far jump
 8379              	.LCB7870:
2631:Src/usb_pd_protocol.c **** 			pd_power_supply_reset(port);
 8380              		.loc 1 2631 4 is_stmt 1 view .LVU2253
 8381 0a12 3000     		movs	r0, r6
 8382 0a14 FFF7FEFF 		bl	pd_power_supply_reset
 8383              	.LVL641:
2632:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8384              		.loc 1 2632 4 view .LVU2254
2633:Src/usb_pd_protocol.c **** 						get_time().val +
 8385              		.loc 1 2633 7 is_stmt 0 view .LVU2255
 8386 0a18 04A8     		add	r0, sp, #16
 8387 0a1a FFF7FEFF 		bl	get_time
 8388              	.LVL642:
2632:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8389              		.loc 1 2632 4 view .LVU2256
 8390 0a1e 3848     		ldr	r0, .L585+32
 8391 0a20 0021     		movs	r1, #0
 8392 0a22 049B     		ldr	r3, [sp, #16]
ARM GAS  /tmp/ccoQIC4J.s 			page 228


 8393 0a24 059C     		ldr	r4, [sp, #20]
 8394 0a26 C018     		adds	r0, r0, r3
 8395 0a28 6141     		adcs	r1, r1, r4
 8396              	.LVL643:
 8397              	.LBB961:
 8398              	.LBI961:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8399              		.loc 1 261 20 is_stmt 1 view .LVU2257
 8400              	.LBB962:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8401              		.loc 1 265 2 view .LVU2258
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8402              		.loc 1 265 19 is_stmt 0 view .LVU2259
 8403 0a2a F201     		lsls	r2, r6, #7
 8404 0a2c 2C4B     		ldr	r3, .L585
 8405 0a2e 9B18     		adds	r3, r3, r2
 8406 0a30 1861     		str	r0, [r3, #16]
 8407 0a32 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 8408              		.loc 1 266 2 is_stmt 1 view .LVU2260
 266:Src/usb_pd_protocol.c **** }
 8409              		.loc 1 266 25 is_stmt 0 view .LVU2261
 8410 0a34 1D22     		movs	r2, #29
 8411 0a36 DA71     		strb	r2, [r3, #7]
 8412 0a38 00F014FC 		bl	.L354	@ far jump
 8413              	.LVL644:
 8414              	.L359:
 266:Src/usb_pd_protocol.c **** }
 8415              		.loc 1 266 25 view .LVU2262
 8416              	.LBE962:
 8417              	.LBE961:
2634:Src/usb_pd_protocol.c **** 						PD_POWER_SUPPLY_TURN_OFF_DELAY,
2635:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_SWAP_STANDBY);
2636:Src/usb_pd_protocol.c **** 		}
2637:Src/usb_pd_protocol.c **** 		break;
2638:Src/usb_pd_protocol.c **** 	case PD_STATE_SRC_SWAP_STANDBY:
2639:Src/usb_pd_protocol.c **** 		/* Send PS_RDY to let sink know our power is off */
2640:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 8418              		.loc 1 2640 3 is_stmt 1 view .LVU2263
 8419              		.loc 1 2640 15 is_stmt 0 view .LVU2264
 8420 0a3c F101     		lsls	r1, r6, #7
 8421 0a3e 284A     		ldr	r2, .L585
 8422 0a40 5218     		adds	r2, r2, r1
 8423 0a42 5279     		ldrb	r2, [r2, #5]
 8424              		.loc 1 2640 6 view .LVU2265
 8425 0a44 9342     		cmp	r3, r2
 8426 0a46 01D1     		bne	.LCB7912
 8427 0a48 00F00CFC 		bl	.L354	@far jump
 8428              	.LCB7912:
2641:Src/usb_pd_protocol.c **** 			/* Send PS_RDY */
2642:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_PS_RDY);
 8429              		.loc 1 2642 4 is_stmt 1 view .LVU2266
 8430              		.loc 1 2642 10 is_stmt 0 view .LVU2267
 8431 0a4c 0621     		movs	r1, #6
 8432 0a4e 3000     		movs	r0, r6
 8433 0a50 FFF7FEFF 		bl	send_control
 8434              	.LVL645:
ARM GAS  /tmp/ccoQIC4J.s 			page 229


2643:Src/usb_pd_protocol.c **** 			if (res < 0) {
 8435              		.loc 1 2643 4 is_stmt 1 view .LVU2268
 8436              		.loc 1 2643 7 is_stmt 0 view .LVU2269
 8437 0a54 0028     		cmp	r0, #0
 8438 0a56 17DB     		blt	.L547
2644:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
2645:Src/usb_pd_protocol.c **** 				set_state(port,
2646:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED);
2647:Src/usb_pd_protocol.c **** 				break;
2648:Src/usb_pd_protocol.c **** 			}
2649:Src/usb_pd_protocol.c **** 			/* Switch to Rd and swap roles to sink */
2650:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
 8439              		.loc 1 2650 4 is_stmt 1 view .LVU2270
 8440              	.LVL646:
 8441              	.LBB963:
 8442              	.LBI963:
  73:Inc/tcpm.h    **** {
 8443              		.loc 2 73 19 view .LVU2271
 8444              	.LBB964:
  75:Inc/tcpm.h    **** }
 8445              		.loc 2 75 2 view .LVU2272
  75:Inc/tcpm.h    **** }
 8446              		.loc 2 75 9 is_stmt 0 view .LVU2273
 8447 0a58 0221     		movs	r1, #2
 8448 0a5a 3000     		movs	r0, r6
 8449 0a5c 7B69     		ldr	r3, [r7, #20]
 8450 0a5e 9847     		blx	r3
 8451              	.LVL647:
  75:Inc/tcpm.h    **** }
 8452              		.loc 2 75 9 view .LVU2274
 8453              	.LBE964:
 8454              	.LBE963:
2651:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
 8455              		.loc 1 2651 4 is_stmt 1 view .LVU2275
 8456              		.loc 1 2651 24 is_stmt 0 view .LVU2276
 8457 0a60 1F4C     		ldr	r4, .L585
 8458 0a62 F501     		lsls	r5, r6, #7
 8459 0a64 0023     		movs	r3, #0
 8460 0a66 2B55     		strb	r3, [r5, r4]
2652:Src/usb_pd_protocol.c **** 			/* Wait for PS_RDY from new source */
2653:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 8461              		.loc 1 2653 4 is_stmt 1 view .LVU2277
2654:Src/usb_pd_protocol.c **** 						get_time().val +
 8462              		.loc 1 2654 7 is_stmt 0 view .LVU2278
 8463 0a68 04A8     		add	r0, sp, #16
 8464 0a6a FFF7FEFF 		bl	get_time
 8465              	.LVL648:
2653:Src/usb_pd_protocol.c **** 						get_time().val +
 8466              		.loc 1 2653 4 view .LVU2279
 8467 0a6e 254A     		ldr	r2, .L585+36
 8468 0a70 0023     		movs	r3, #0
 8469 0a72 0498     		ldr	r0, [sp, #16]
 8470 0a74 0599     		ldr	r1, [sp, #20]
 8471 0a76 1218     		adds	r2, r2, r0
 8472 0a78 4B41     		adcs	r3, r3, r1
 8473              	.LVL649:
 8474              	.LBB965:
ARM GAS  /tmp/ccoQIC4J.s 			page 230


 8475              	.LBI965:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8476              		.loc 1 261 20 is_stmt 1 view .LVU2280
 8477              	.LBB966:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8478              		.loc 1 265 2 view .LVU2281
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8479              		.loc 1 265 19 is_stmt 0 view .LVU2282
 8480 0a7a 6419     		adds	r4, r4, r5
 8481 0a7c 2261     		str	r2, [r4, #16]
 8482 0a7e 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 8483              		.loc 1 266 2 is_stmt 1 view .LVU2283
 266:Src/usb_pd_protocol.c **** }
 8484              		.loc 1 266 25 is_stmt 0 view .LVU2284
 8485 0a80 0223     		movs	r3, #2
 8486 0a82 E371     		strb	r3, [r4, #7]
 8487 0a84 00F0EEFB 		bl	.L354	@ far jump
 8488              	.LVL650:
 8489              	.L547:
 266:Src/usb_pd_protocol.c **** }
 8490              		.loc 1 266 25 view .LVU2285
 8491              	.LBE966:
 8492              	.LBE965:
2644:Src/usb_pd_protocol.c **** 				set_state(port,
 8493              		.loc 1 2644 5 is_stmt 1 view .LVU2286
2644:Src/usb_pd_protocol.c **** 				set_state(port,
 8494              		.loc 1 2644 13 is_stmt 0 view .LVU2287
 8495 0a88 194B     		ldr	r3, .L585+16
 8496 0a8a 1A4A     		ldr	r2, .L585+20
 8497 0a8c 1A60     		str	r2, [r3]
2645:Src/usb_pd_protocol.c **** 						PD_STATE_SRC_DISCONNECTED);
 8498              		.loc 1 2645 5 is_stmt 1 view .LVU2288
 8499              	.LVL651:
 8500              	.LBB967:
 8501              	.LBI967:
 326:Src/usb_pd_protocol.c **** {
 8502              		.loc 1 326 20 view .LVU2289
 8503              	.LBB968:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8504              		.loc 1 328 2 view .LVU2290
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8505              		.loc 1 328 17 is_stmt 0 view .LVU2291
 8506 0a8e F201     		lsls	r2, r6, #7
 8507 0a90 134B     		ldr	r3, .L585
 8508 0a92 9B18     		adds	r3, r3, r2
 8509 0a94 1A79     		ldrb	r2, [r3, #4]
 8510              	.LVL652:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 8511              		.loc 1 333 2 is_stmt 1 view .LVU2292
 8512              	.LBB969:
 8513              	.LBI969:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8514              		.loc 1 261 20 view .LVU2293
 8515              	.LBB970:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8516              		.loc 1 265 2 view .LVU2294
ARM GAS  /tmp/ccoQIC4J.s 			page 231


 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8517              		.loc 1 265 19 is_stmt 0 view .LVU2295
 8518 0a96 0020     		movs	r0, #0
 8519 0a98 0021     		movs	r1, #0
 8520 0a9a 1861     		str	r0, [r3, #16]
 8521 0a9c 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 8522              		.loc 1 266 2 is_stmt 1 view .LVU2296
 266:Src/usb_pd_protocol.c **** }
 8523              		.loc 1 266 25 is_stmt 0 view .LVU2297
 8524 0a9e 0021     		movs	r1, #0
 8525 0aa0 D971     		strb	r1, [r3, #7]
 8526              	.LVL653:
 266:Src/usb_pd_protocol.c **** }
 8527              		.loc 1 266 25 view .LVU2298
 8528              	.LBE970:
 8529              	.LBE969:
 334:Src/usb_pd_protocol.c **** 
 8530              		.loc 1 334 2 is_stmt 1 view .LVU2299
 334:Src/usb_pd_protocol.c **** 
 8531              		.loc 1 334 22 is_stmt 0 view .LVU2300
 8532 0aa2 0E31     		adds	r1, r1, #14
 8533 0aa4 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 8534              		.loc 1 336 2 is_stmt 1 view .LVU2301
 336:Src/usb_pd_protocol.c **** 		return;
 8535              		.loc 1 336 5 is_stmt 0 view .LVU2302
 8536 0aa6 0E2A     		cmp	r2, #14
 8537 0aa8 00D1     		bne	.LCB8010
 8538 0aaa DBE3     		b	.L354	@long jump
 8539              	.LCB8010:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8540              		.loc 1 347 2 is_stmt 1 view .LVU2303
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8541              		.loc 1 347 5 is_stmt 0 view .LVU2304
 8542 0aac 022A     		cmp	r2, #2
 8543 0aae 00D1     		bne	.LCB8013
 8544 0ab0 D8E3     		b	.L354	@long jump
 8545              	.LCB8013:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8546              		.loc 1 353 2 is_stmt 1 view .LVU2305
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8547              		.loc 1 356 3 view .LVU2306
 8548 0ab2 0022     		movs	r2, #0
 8549              	.LVL654:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8550              		.loc 1 356 3 is_stmt 0 view .LVU2307
 8551 0ab4 0021     		movs	r1, #0
 8552 0ab6 3000     		movs	r0, r6
 8553 0ab8 FFF7FEFF 		bl	pd_set_input_current_limit
 8554              	.LVL655:
 373:Src/usb_pd_protocol.c **** 			/*
 8555              		.loc 1 373 3 is_stmt 1 view .LVU2308
 373:Src/usb_pd_protocol.c **** 			/*
 8556              		.loc 1 373 15 is_stmt 0 view .LVU2309
 8557 0abc F301     		lsls	r3, r6, #7
 8558 0abe 084A     		ldr	r2, .L585
ARM GAS  /tmp/ccoQIC4J.s 			page 232


 8559 0ac0 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 8560              		.loc 1 373 6 view .LVU2310
 8561 0ac2 012B     		cmp	r3, #1
 8562 0ac4 08D0     		beq	.L548
 8563              	.L436:
 405:Src/usb_pd_protocol.c **** 	}
 8564              		.loc 1 405 3 is_stmt 1 view .LVU2311
 8565              	.LVL656:
 8566              	.LBB971:
 8567              	.LBI971:
  94:Inc/tcpm.h    **** {
 8568              		.loc 2 94 19 view .LVU2312
 8569              	.LBB972:
  96:Inc/tcpm.h    **** }
 8570              		.loc 2 96 2 view .LVU2313
  96:Inc/tcpm.h    **** }
 8571              		.loc 2 96 26 is_stmt 0 view .LVU2314
 8572 0ac6 3201     		lsls	r2, r6, #4
 8573 0ac8 0B4B     		ldr	r3, .L585+24
 8574 0aca 9B18     		adds	r3, r3, r2
 8575 0acc 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 8576              		.loc 2 96 30 view .LVU2315
 8577 0ace 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 8578              		.loc 2 96 9 view .LVU2316
 8579 0ad0 0021     		movs	r1, #0
 8580 0ad2 3000     		movs	r0, r6
 8581 0ad4 9847     		blx	r3
 8582              	.LVL657:
 8583 0ad6 C5E3     		b	.L354
 8584              	.LVL658:
 8585              	.L548:
  96:Inc/tcpm.h    **** }
 8586              		.loc 2 96 9 view .LVU2317
 8587              	.LBE972:
 8588              	.LBE971:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8589              		.loc 1 378 4 is_stmt 1 view .LVU2318
 8590 0ad8 3000     		movs	r0, r6
 8591 0ada FFF7FEFF 		bl	pd_power_supply_reset
 8592              	.LVL659:
 8593 0ade F2E7     		b	.L436
 8594              	.L586:
 8595              		.align	2
 8596              	.L585:
 8597 0ae0 00000000 		.word	pd
 8598 0ae4 FFFDFFFF 		.word	-513
 8599 0ae8 FFFBFFFF 		.word	-1025
 8600 0aec A0860100 		.word	100000
 8601 0af0 00000000 		.word	.LANCHOR5
 8602 0af4 10270000 		.word	10000
 8603 0af8 00000000 		.word	tcpc_config
 8604 0afc B8880000 		.word	35000
 8605 0b00 204E0000 		.word	20000
 8606 0b04 00530700 		.word	480000
ARM GAS  /tmp/ccoQIC4J.s 			page 233


 8607              	.LVL660:
 8608              	.L387:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8609              		.loc 1 378 4 is_stmt 0 view .LVU2319
 8610              	.LBE968:
 8611              	.LBE967:
 8612              	.LBB973:
2655:Src/usb_pd_protocol.c **** 						PD_T_PS_SOURCE_ON,
2656:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2657:Src/usb_pd_protocol.c **** 		}
2658:Src/usb_pd_protocol.c **** 		break;
2659:Src/usb_pd_protocol.c **** 	case PD_STATE_SUSPENDED: {
2660:Src/usb_pd_protocol.c **** #ifndef CONFIG_USB_PD_TCPC
2661:Src/usb_pd_protocol.c **** 		int rstatus;
 8613              		.loc 1 2661 3 is_stmt 1 view .LVU2320
2662:Src/usb_pd_protocol.c **** #endif
2663:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d suspended!", port);
 8614              		.loc 1 2663 39 view .LVU2321
2664:Src/usb_pd_protocol.c **** 		pd[port].req_suspend_state = 0;
 8615              		.loc 1 2664 3 view .LVU2322
 8616              		.loc 1 2664 30 is_stmt 0 view .LVU2323
 8617 0b08 F201     		lsls	r2, r6, #7
 8618 0b0a C14B     		ldr	r3, .L587
 8619 0b0c 9B18     		adds	r3, r3, r2
 8620 0b0e 0022     		movs	r2, #0
 8621 0b10 9A71     		strb	r2, [r3, #6]
2665:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC
2666:Src/usb_pd_protocol.c **** 		pd_rx_disable_monitoring(port);
2667:Src/usb_pd_protocol.c **** 		pd_hw_release(port);
2668:Src/usb_pd_protocol.c **** 		pd_power_supply_reset(port);
2669:Src/usb_pd_protocol.c **** #else
2670:Src/usb_pd_protocol.c **** 		rstatus = tcpm_release(port);
 8622              		.loc 1 2670 3 is_stmt 1 view .LVU2324
 8623              	.LVL661:
 8624              	.LBB974:
 8625              	.LBI974:
  53:Inc/tcpm.h    **** {
 8626              		.loc 2 53 19 view .LVU2325
 8627              	.LBB975:
  55:Inc/tcpm.h    **** }
 8628              		.loc 2 55 2 view .LVU2326
  55:Inc/tcpm.h    **** }
 8629              		.loc 2 55 9 is_stmt 0 view .LVU2327
 8630 0b12 3000     		movs	r0, r6
 8631 0b14 7B68     		ldr	r3, [r7, #4]
 8632 0b16 9847     		blx	r3
 8633              	.LVL662:
  55:Inc/tcpm.h    **** }
 8634              		.loc 2 55 9 view .LVU2328
 8635              	.LBE975:
 8636              	.LBE974:
2671:Src/usb_pd_protocol.c **** 		if (rstatus != 0 && rstatus != EC_ERROR_UNIMPLEMENTED)
 8637              		.loc 1 2671 3 is_stmt 1 view .LVU2329
2672:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d release failed!", port);
2673:Src/usb_pd_protocol.c **** #endif
2674:Src/usb_pd_protocol.c **** 		/* Wait for resume */
2675:Src/usb_pd_protocol.c **** 		// getting rid of task stuff
ARM GAS  /tmp/ccoQIC4J.s 			page 234


2676:Src/usb_pd_protocol.c **** 		//while (pd[port].task_state == PD_STATE_SUSPENDED)
2677:Src/usb_pd_protocol.c **** 		//	task_wait_event(-1);
2678:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC
2679:Src/usb_pd_protocol.c **** 		pd_hw_init(port, PD_ROLE_DEFAULT(port));
2680:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d resumed!", port);
2681:Src/usb_pd_protocol.c **** #else
2682:Src/usb_pd_protocol.c **** 		if (rstatus != EC_ERROR_UNIMPLEMENTED &&
 8638              		.loc 1 2682 3 view .LVU2330
 8639              		.loc 1 2682 6 is_stmt 0 view .LVU2331
 8640 0b18 0228     		cmp	r0, #2
 8641 0b1a 05D0     		beq	.L437
2683:Src/usb_pd_protocol.c **** 			pd_restart_tcpc(port) != 0) {
 8642              		.loc 1 2683 4 discriminator 1 view .LVU2332
 8643 0b1c 3000     		movs	r0, r6
 8644              	.LVL663:
 8645              		.loc 1 2683 4 discriminator 1 view .LVU2333
 8646 0b1e FFF7FEFF 		bl	pd_restart_tcpc
 8647              	.LVL664:
2682:Src/usb_pd_protocol.c **** 			pd_restart_tcpc(port) != 0) {
 8648              		.loc 1 2682 41 discriminator 1 view .LVU2334
 8649 0b22 0028     		cmp	r0, #0
 8650 0b24 00D0     		beq	.LCB8113
 8651 0b26 9DE3     		b	.L354	@long jump
 8652              	.LCB8113:
 8653              	.L437:
2684:Src/usb_pd_protocol.c **** 			/* stay in PD_STATE_SUSPENDED */
2685:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d restart failed!", port);
2686:Src/usb_pd_protocol.c **** 			break;
2687:Src/usb_pd_protocol.c **** 		}
2688:Src/usb_pd_protocol.c **** 		set_state(port, PD_DEFAULT_STATE(port));
 8654              		.loc 1 2688 3 is_stmt 1 view .LVU2335
 8655              	.LVL665:
 8656              	.LBB976:
 8657              	.LBI976:
 326:Src/usb_pd_protocol.c **** {
 8658              		.loc 1 326 20 view .LVU2336
 8659              	.LBB977:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8660              		.loc 1 328 2 view .LVU2337
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8661              		.loc 1 328 17 is_stmt 0 view .LVU2338
 8662 0b28 F201     		lsls	r2, r6, #7
 8663 0b2a B94B     		ldr	r3, .L587
 8664 0b2c 9B18     		adds	r3, r3, r2
 8665 0b2e 1A79     		ldrb	r2, [r3, #4]
 8666              	.LVL666:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 8667              		.loc 1 333 2 is_stmt 1 view .LVU2339
 8668              	.LBB978:
 8669              	.LBI978:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8670              		.loc 1 261 20 view .LVU2340
 8671              	.LBB979:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8672              		.loc 1 265 2 view .LVU2341
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8673              		.loc 1 265 19 is_stmt 0 view .LVU2342
ARM GAS  /tmp/ccoQIC4J.s 			page 235


 8674 0b30 0020     		movs	r0, #0
 8675 0b32 0021     		movs	r1, #0
 8676 0b34 1861     		str	r0, [r3, #16]
 8677 0b36 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 8678              		.loc 1 266 2 is_stmt 1 view .LVU2343
 266:Src/usb_pd_protocol.c **** }
 8679              		.loc 1 266 25 is_stmt 0 view .LVU2344
 8680 0b38 0021     		movs	r1, #0
 8681 0b3a D971     		strb	r1, [r3, #7]
 8682              	.LVL667:
 266:Src/usb_pd_protocol.c **** }
 8683              		.loc 1 266 25 view .LVU2345
 8684              	.LBE979:
 8685              	.LBE978:
 334:Src/usb_pd_protocol.c **** 
 8686              		.loc 1 334 2 is_stmt 1 view .LVU2346
 334:Src/usb_pd_protocol.c **** 
 8687              		.loc 1 334 22 is_stmt 0 view .LVU2347
 8688 0b3c 0231     		adds	r1, r1, #2
 8689 0b3e 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 8690              		.loc 1 336 2 is_stmt 1 view .LVU2348
 336:Src/usb_pd_protocol.c **** 		return;
 8691              		.loc 1 336 5 is_stmt 0 view .LVU2349
 8692 0b40 022A     		cmp	r2, #2
 8693 0b42 00D1     		bne	.LCB8151
 8694 0b44 8EE3     		b	.L354	@long jump
 8695              	.LCB8151:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 8696              		.loc 1 347 2 is_stmt 1 view .LVU2350
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 8697              		.loc 1 348 48 is_stmt 0 view .LVU2351
 8698 0b46 0E2A     		cmp	r2, #14
 8699 0b48 00D1     		bne	.LCB8154
 8700 0b4a 8BE3     		b	.L354	@long jump
 8701              	.LCB8154:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 8702              		.loc 1 353 2 is_stmt 1 view .LVU2352
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8703              		.loc 1 356 3 view .LVU2353
 8704 0b4c 0022     		movs	r2, #0
 8705              	.LVL668:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 8706              		.loc 1 356 3 is_stmt 0 view .LVU2354
 8707 0b4e 0021     		movs	r1, #0
 8708 0b50 3000     		movs	r0, r6
 8709 0b52 FFF7FEFF 		bl	pd_set_input_current_limit
 8710              	.LVL669:
 373:Src/usb_pd_protocol.c **** 			/*
 8711              		.loc 1 373 3 is_stmt 1 view .LVU2355
 373:Src/usb_pd_protocol.c **** 			/*
 8712              		.loc 1 373 15 is_stmt 0 view .LVU2356
 8713 0b56 F301     		lsls	r3, r6, #7
 8714 0b58 AD4A     		ldr	r2, .L587
 8715 0b5a 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
ARM GAS  /tmp/ccoQIC4J.s 			page 236


 8716              		.loc 1 373 6 view .LVU2357
 8717 0b5c 012B     		cmp	r3, #1
 8718 0b5e 08D0     		beq	.L549
 8719              	.L438:
 405:Src/usb_pd_protocol.c **** 	}
 8720              		.loc 1 405 3 is_stmt 1 view .LVU2358
 8721              	.LVL670:
 8722              	.LBB980:
 8723              	.LBI980:
  94:Inc/tcpm.h    **** {
 8724              		.loc 2 94 19 view .LVU2359
 8725              	.LBB981:
  96:Inc/tcpm.h    **** }
 8726              		.loc 2 96 2 view .LVU2360
  96:Inc/tcpm.h    **** }
 8727              		.loc 2 96 26 is_stmt 0 view .LVU2361
 8728 0b60 3201     		lsls	r2, r6, #4
 8729 0b62 AC4B     		ldr	r3, .L587+4
 8730 0b64 9B18     		adds	r3, r3, r2
 8731 0b66 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 8732              		.loc 2 96 30 view .LVU2362
 8733 0b68 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 8734              		.loc 2 96 9 view .LVU2363
 8735 0b6a 0021     		movs	r1, #0
 8736 0b6c 3000     		movs	r0, r6
 8737 0b6e 9847     		blx	r3
 8738              	.LVL671:
 8739 0b70 78E3     		b	.L354
 8740              	.LVL672:
 8741              	.L549:
  96:Inc/tcpm.h    **** }
 8742              		.loc 2 96 9 view .LVU2364
 8743              	.LBE981:
 8744              	.LBE980:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8745              		.loc 1 378 4 is_stmt 1 view .LVU2365
 8746 0b72 3000     		movs	r0, r6
 8747 0b74 FFF7FEFF 		bl	pd_power_supply_reset
 8748              	.LVL673:
 8749 0b78 F2E7     		b	.L438
 8750              	.LVL674:
 8751              	.L386:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 8752              		.loc 1 378 4 is_stmt 0 view .LVU2366
 8753              	.LBE977:
 8754              	.LBE976:
 8755              	.LBE973:
2689:Src/usb_pd_protocol.c **** 		CPRINTS("TCPC p%d resumed!", port);
2690:Src/usb_pd_protocol.c **** #endif
2691:Src/usb_pd_protocol.c **** 		break;
2692:Src/usb_pd_protocol.c **** 	}
2693:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_DISCONNECTED:
2694:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_LOW_POWER
2695:Src/usb_pd_protocol.c **** 		timeout = drp_state != PD_DRP_TOGGLE_ON ? SECOND_US
2696:Src/usb_pd_protocol.c **** 							: 10*MSEC_US;
ARM GAS  /tmp/ccoQIC4J.s 			page 237


2697:Src/usb_pd_protocol.c **** #else
2698:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
 8756              		.loc 1 2698 3 is_stmt 1 view .LVU2367
 8757              		.loc 1 2698 11 is_stmt 0 view .LVU2368
 8758 0b7a A74B     		ldr	r3, .L587+8
 8759 0b7c A74A     		ldr	r2, .L587+12
 8760 0b7e 1A60     		str	r2, [r3]
2699:Src/usb_pd_protocol.c **** #endif
2700:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
 8761              		.loc 1 2700 3 is_stmt 1 view .LVU2369
 8762              	.LVL675:
 8763              	.LBB982:
 8764              	.LBI982:
  58:Inc/tcpm.h    **** {
 8765              		.loc 2 58 19 view .LVU2370
 8766              	.LBB983:
  60:Inc/tcpm.h    **** }
 8767              		.loc 2 60 2 view .LVU2371
  60:Inc/tcpm.h    **** }
 8768              		.loc 2 60 9 is_stmt 0 view .LVU2372
 8769 0b80 A74C     		ldr	r4, .L587+16
 8770 0b82 A84A     		ldr	r2, .L587+20
 8771 0b84 2100     		movs	r1, r4
 8772 0b86 3000     		movs	r0, r6
 8773 0b88 BB68     		ldr	r3, [r7, #8]
 8774 0b8a 9847     		blx	r3
 8775              	.LVL676:
  60:Inc/tcpm.h    **** }
 8776              		.loc 2 60 9 view .LVU2373
 8777              	.LBE983:
 8778              	.LBE982:
2701:Src/usb_pd_protocol.c **** 
2702:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
2703:Src/usb_pd_protocol.c **** 		/*
2704:Src/usb_pd_protocol.c **** 			* Attempt TCPC auto DRP toggle if it is
2705:Src/usb_pd_protocol.c **** 			* not already auto toggling and not try.src
2706:Src/usb_pd_protocol.c **** 			*/
2707:Src/usb_pd_protocol.c **** 		if (auto_toggle_supported &&
2708:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TCPC_DRP_TOGGLE) &&
2709:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TRY_SRC) &&
2710:Src/usb_pd_protocol.c **** 			(cc1 == TYPEC_CC_VOLT_OPEN &&
2711:Src/usb_pd_protocol.c **** 			    cc2 == TYPEC_CC_VOLT_OPEN)) {
2712:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_DRP_AUTO_TOGGLE);
2713:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC_US;
2714:Src/usb_pd_protocol.c **** 			break;
2715:Src/usb_pd_protocol.c **** 		}
2716:Src/usb_pd_protocol.c **** #endif
2717:Src/usb_pd_protocol.c **** 
2718:Src/usb_pd_protocol.c **** 		/* Source connection monitoring */
2719:Src/usb_pd_protocol.c **** 		if (cc1 != TYPEC_CC_VOLT_OPEN ||
 8779              		.loc 1 2719 3 is_stmt 1 view .LVU2374
 8780              		.loc 1 2719 11 is_stmt 0 view .LVU2375
 8781 0b8c 2368     		ldr	r3, [r4]
 8782              		.loc 1 2719 6 view .LVU2376
 8783 0b8e 002B     		cmp	r3, #0
 8784 0b90 03D1     		bne	.L439
2720:Src/usb_pd_protocol.c **** 			cc2 != TYPEC_CC_VOLT_OPEN) {
ARM GAS  /tmp/ccoQIC4J.s 			page 238


 8785              		.loc 1 2720 8 discriminator 1 view .LVU2377
 8786 0b92 A44B     		ldr	r3, .L587+20
 8787 0b94 1B68     		ldr	r3, [r3]
2719:Src/usb_pd_protocol.c **** 			cc2 != TYPEC_CC_VOLT_OPEN) {
 8788              		.loc 1 2719 33 discriminator 1 view .LVU2378
 8789 0b96 002B     		cmp	r3, #0
 8790 0b98 20D0     		beq	.L440
 8791              	.L439:
2721:Src/usb_pd_protocol.c **** 			pd[port].cc_state = PD_CC_NONE;
 8792              		.loc 1 2721 4 is_stmt 1 view .LVU2379
 8793              		.loc 1 2721 22 is_stmt 0 view .LVU2380
 8794 0b9a F301     		lsls	r3, r6, #7
 8795 0b9c 9C4C     		ldr	r4, .L587
 8796 0b9e E418     		adds	r4, r4, r3
 8797 0ba0 2300     		movs	r3, r4
 8798 0ba2 2833     		adds	r3, r3, #40
 8799 0ba4 0025     		movs	r5, #0
 8800 0ba6 1D70     		strb	r5, [r3]
2722:Src/usb_pd_protocol.c **** 			hard_reset_count = 0;
 8801              		.loc 1 2722 4 is_stmt 1 view .LVU2381
 8802              		.loc 1 2722 21 is_stmt 0 view .LVU2382
 8803 0ba8 9F4B     		ldr	r3, .L587+24
 8804 0baa 1D60     		str	r5, [r3]
2723:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_NONE;
 8805              		.loc 1 2723 4 is_stmt 1 view .LVU2383
 8806              		.loc 1 2723 17 is_stmt 0 view .LVU2384
 8807 0bac 9F4B     		ldr	r3, .L587+28
 8808 0bae 1D70     		strb	r5, [r3]
2724:Src/usb_pd_protocol.c **** 			pd[port].cc_debounce = get_time().val +
 8809              		.loc 1 2724 4 is_stmt 1 view .LVU2385
 8810              		.loc 1 2724 27 is_stmt 0 view .LVU2386
 8811 0bb0 04A8     		add	r0, sp, #16
 8812 0bb2 FFF7FEFF 		bl	get_time
 8813              	.LVL677:
 8814              		.loc 1 2724 42 view .LVU2387
 8815 0bb6 9E4A     		ldr	r2, .L587+32
 8816 0bb8 0023     		movs	r3, #0
 8817 0bba 0498     		ldr	r0, [sp, #16]
 8818 0bbc 0599     		ldr	r1, [sp, #20]
 8819 0bbe 1218     		adds	r2, r2, r0
 8820 0bc0 4B41     		adcs	r3, r3, r1
 8821              		.loc 1 2724 25 view .LVU2388
 8822 0bc2 2262     		str	r2, [r4, #32]
 8823 0bc4 6362     		str	r3, [r4, #36]
2725:Src/usb_pd_protocol.c **** 						PD_T_CC_DEBOUNCE;
2726:Src/usb_pd_protocol.c **** 			set_state(port,
 8824              		.loc 1 2726 4 is_stmt 1 view .LVU2389
 8825              	.LVL678:
 8826              	.LBB984:
 8827              	.LBI984:
 326:Src/usb_pd_protocol.c **** {
 8828              		.loc 1 326 20 view .LVU2390
 8829              	.LBB985:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 8830              		.loc 1 328 2 view .LVU2391
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 8831              		.loc 1 333 2 view .LVU2392
ARM GAS  /tmp/ccoQIC4J.s 			page 239


 8832              	.LBB986:
 8833              	.LBI986:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 8834              		.loc 1 261 20 view .LVU2393
 8835              	.LBB987:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8836              		.loc 1 265 2 view .LVU2394
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 8837              		.loc 1 265 19 is_stmt 0 view .LVU2395
 8838 0bc6 0022     		movs	r2, #0
 8839 0bc8 0023     		movs	r3, #0
 8840 0bca 2261     		str	r2, [r4, #16]
 8841 0bcc 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 8842              		.loc 1 266 2 is_stmt 1 view .LVU2396
 266:Src/usb_pd_protocol.c **** }
 8843              		.loc 1 266 25 is_stmt 0 view .LVU2397
 8844 0bce E571     		strb	r5, [r4, #7]
 8845              	.LVL679:
 266:Src/usb_pd_protocol.c **** }
 8846              		.loc 1 266 25 view .LVU2398
 8847              	.LBE987:
 8848              	.LBE986:
 334:Src/usb_pd_protocol.c **** 
 8849              		.loc 1 334 2 is_stmt 1 view .LVU2399
 334:Src/usb_pd_protocol.c **** 
 8850              		.loc 1 334 22 is_stmt 0 view .LVU2400
 8851 0bd0 0323     		movs	r3, #3
 8852 0bd2 2371     		strb	r3, [r4, #4]
 8853              	.LVL680:
 336:Src/usb_pd_protocol.c **** 		return;
 8854              		.loc 1 336 2 is_stmt 1 view .LVU2401
 336:Src/usb_pd_protocol.c **** 		return;
 8855              		.loc 1 336 2 is_stmt 0 view .LVU2402
 8856              	.LBE985:
 8857              	.LBE984:
2727:Src/usb_pd_protocol.c **** 				PD_STATE_SNK_DISCONNECTED_DEBOUNCE);
2728:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC_US;
 8858              		.loc 1 2728 4 is_stmt 1 view .LVU2403
 8859              		.loc 1 2728 12 is_stmt 0 view .LVU2404
 8860 0bd4 904B     		ldr	r3, .L587+8
 8861 0bd6 914A     		ldr	r2, .L587+12
 8862 0bd8 1A60     		str	r2, [r3]
2729:Src/usb_pd_protocol.c **** 			break;
 8863              		.loc 1 2729 4 is_stmt 1 view .LVU2405
 8864 0bda 43E3     		b	.L354
 8865              	.L440:
2730:Src/usb_pd_protocol.c **** 		}
2731:Src/usb_pd_protocol.c **** 
2732:Src/usb_pd_protocol.c **** 		/*
2733:Src/usb_pd_protocol.c **** 			* If Try.SRC is active and failed to detect a SNK,
2734:Src/usb_pd_protocol.c **** 			* then it transitions to TryWait.SNK. Need to prevent
2735:Src/usb_pd_protocol.c **** 			* normal dual role toggle until tDRPTryWait timer
2736:Src/usb_pd_protocol.c **** 			* expires.
2737:Src/usb_pd_protocol.c **** 			*/
2738:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_TRY_SRC) {
 8866              		.loc 1 2738 3 view .LVU2406
ARM GAS  /tmp/ccoQIC4J.s 			page 240


 8867              		.loc 1 2738 15 is_stmt 0 view .LVU2407
 8868 0bdc F201     		lsls	r2, r6, #7
 8869 0bde 8C4B     		ldr	r3, .L587
 8870 0be0 9B18     		adds	r3, r3, r2
 8871 0be2 9B68     		ldr	r3, [r3, #8]
 8872              		.loc 1 2738 6 view .LVU2408
 8873 0be4 9B04     		lsls	r3, r3, #18
 8874 0be6 30D4     		bmi	.L550
2739:Src/usb_pd_protocol.c **** 			if (get_time().val > pd[port].try_src_marker)
2740:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
2741:Src/usb_pd_protocol.c **** 			break;
2742:Src/usb_pd_protocol.c **** 		}
2743:Src/usb_pd_protocol.c **** 
2744:Src/usb_pd_protocol.c **** 		/* If no source detected, check for role toggle. */
2745:Src/usb_pd_protocol.c **** 		if (drp_state == PD_DRP_TOGGLE_ON &&
 8875              		.loc 1 2745 3 is_stmt 1 view .LVU2409
 8876              		.loc 1 2745 17 is_stmt 0 view .LVU2410
 8877 0be8 924B     		ldr	r3, .L587+36
 8878 0bea 1B78     		ldrb	r3, [r3]
 8879              		.loc 1 2745 6 view .LVU2411
 8880 0bec 002B     		cmp	r3, #0
 8881 0bee 00D0     		beq	.LCB8325
 8882 0bf0 38E3     		b	.L354	@long jump
 8883              	.LCB8325:
2746:Src/usb_pd_protocol.c **** 			get_time().val >= next_role_swap) {
 8884              		.loc 1 2746 4 discriminator 1 view .LVU2412
 8885 0bf2 04A8     		add	r0, sp, #16
 8886 0bf4 FFF7FEFF 		bl	get_time
 8887              	.LVL681:
 8888              		.loc 1 2746 14 discriminator 1 view .LVU2413
 8889 0bf8 0499     		ldr	r1, [sp, #16]
 8890 0bfa 059A     		ldr	r2, [sp, #20]
 8891              		.loc 1 2746 19 discriminator 1 view .LVU2414
 8892 0bfc 8E4B     		ldr	r3, .L587+40
 8893 0bfe 1868     		ldr	r0, [r3]
 8894 0c00 5B68     		ldr	r3, [r3, #4]
2745:Src/usb_pd_protocol.c **** 			get_time().val >= next_role_swap) {
 8895              		.loc 1 2745 37 discriminator 1 view .LVU2415
 8896 0c02 9342     		cmp	r3, r2
 8897 0c04 00D9     		bls	.LCB8334
 8898 0c06 2DE3     		b	.L354	@long jump
 8899              	.LCB8334:
 8900 0c08 02D1     		bne	.L515
 8901 0c0a 8842     		cmp	r0, r1
 8902 0c0c 00D9     		bls	.LCB8338
 8903 0c0e 29E3     		b	.L354	@long jump
 8904              	.LCB8338:
 8905              	.L515:
2747:Src/usb_pd_protocol.c **** 			/* Swap roles to source */
2748:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SOURCE;
 8906              		.loc 1 2748 4 is_stmt 1 view .LVU2416
 8907              		.loc 1 2748 24 is_stmt 0 view .LVU2417
 8908 0c10 F301     		lsls	r3, r6, #7
 8909 0c12 0124     		movs	r4, #1
 8910 0c14 7E4A     		ldr	r2, .L587
 8911 0c16 9C54     		strb	r4, [r3, r2]
2749:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
ARM GAS  /tmp/ccoQIC4J.s 			page 241


 8912              		.loc 1 2749 4 is_stmt 1 view .LVU2418
 8913 0c18 0E21     		movs	r1, #14
 8914 0c1a 3000     		movs	r0, r6
 8915 0c1c FFF7FEFF 		bl	set_state
 8916              	.LVL682:
2750:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
 8917              		.loc 1 2750 4 view .LVU2419
 8918              	.LBB988:
 8919              	.LBI988:
  73:Inc/tcpm.h    **** {
 8920              		.loc 2 73 19 view .LVU2420
 8921              	.LBB989:
  75:Inc/tcpm.h    **** }
 8922              		.loc 2 75 2 view .LVU2421
  75:Inc/tcpm.h    **** }
 8923              		.loc 2 75 9 is_stmt 0 view .LVU2422
 8924 0c20 2100     		movs	r1, r4
 8925 0c22 3000     		movs	r0, r6
 8926 0c24 7B69     		ldr	r3, [r7, #20]
 8927 0c26 9847     		blx	r3
 8928              	.LVL683:
  75:Inc/tcpm.h    **** }
 8929              		.loc 2 75 9 view .LVU2423
 8930              	.LBE989:
 8931              	.LBE988:
2751:Src/usb_pd_protocol.c **** 			next_role_swap = get_time().val + PD_T_DRP_SRC;
 8932              		.loc 1 2751 4 is_stmt 1 view .LVU2424
 8933              		.loc 1 2751 21 is_stmt 0 view .LVU2425
 8934 0c28 04A8     		add	r0, sp, #16
 8935 0c2a FFF7FEFF 		bl	get_time
 8936              	.LVL684:
 8937              		.loc 1 2751 36 view .LVU2426
 8938 0c2e 834A     		ldr	r2, .L587+44
 8939 0c30 0023     		movs	r3, #0
 8940 0c32 0498     		ldr	r0, [sp, #16]
 8941 0c34 0599     		ldr	r1, [sp, #20]
 8942 0c36 1218     		adds	r2, r2, r0
 8943 0c38 4B41     		adcs	r3, r3, r1
 8944              		.loc 1 2751 19 view .LVU2427
 8945 0c3a 7F49     		ldr	r1, .L587+40
 8946 0c3c 0A60     		str	r2, [r1]
 8947 0c3e 4B60     		str	r3, [r1, #4]
2752:Src/usb_pd_protocol.c **** 
2753:Src/usb_pd_protocol.c **** 			/* Swap states quickly */
2754:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC_US;
 8948              		.loc 1 2754 4 is_stmt 1 view .LVU2428
 8949              		.loc 1 2754 12 is_stmt 0 view .LVU2429
 8950 0c40 754B     		ldr	r3, .L587+8
 8951 0c42 FA22     		movs	r2, #250
 8952 0c44 D200     		lsls	r2, r2, #3
 8953 0c46 1A60     		str	r2, [r3]
 8954 0c48 0CE3     		b	.L354
 8955              	.L550:
2739:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
 8956              		.loc 1 2739 4 is_stmt 1 view .LVU2430
2739:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
 8957              		.loc 1 2739 8 is_stmt 0 view .LVU2431
ARM GAS  /tmp/ccoQIC4J.s 			page 242


 8958 0c4a 04A8     		add	r0, sp, #16
 8959 0c4c FFF7FEFF 		bl	get_time
 8960              	.LVL685:
2739:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
 8961              		.loc 1 2739 18 view .LVU2432
 8962 0c50 0498     		ldr	r0, [sp, #16]
 8963 0c52 0599     		ldr	r1, [sp, #20]
2739:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
 8964              		.loc 1 2739 33 view .LVU2433
 8965 0c54 F201     		lsls	r2, r6, #7
 8966 0c56 6E4B     		ldr	r3, .L587
 8967 0c58 9B18     		adds	r3, r3, r2
 8968 0c5a 1A6C     		ldr	r2, [r3, #64]
 8969 0c5c 5B6C     		ldr	r3, [r3, #68]
2739:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_TRY_SRC;
 8970              		.loc 1 2739 7 view .LVU2434
 8971 0c5e 9942     		cmp	r1, r3
 8972 0c60 04D8     		bhi	.L514
 8973 0c62 00D0     		beq	.LCB8399
 8974 0c64 FEE2     		b	.L354	@long jump
 8975              	.LCB8399:
 8976 0c66 9042     		cmp	r0, r2
 8977 0c68 00D8     		bhi	.LCB8401
 8978 0c6a FBE2     		b	.L354	@long jump
 8979              	.LCB8401:
 8980              	.L514:
2740:Src/usb_pd_protocol.c **** 			break;
 8981              		.loc 1 2740 5 is_stmt 1 view .LVU2435
2740:Src/usb_pd_protocol.c **** 			break;
 8982              		.loc 1 2740 20 is_stmt 0 view .LVU2436
 8983 0c6c F201     		lsls	r2, r6, #7
 8984 0c6e 684B     		ldr	r3, .L587
 8985 0c70 9B18     		adds	r3, r3, r2
 8986 0c72 734A     		ldr	r2, .L587+48
 8987 0c74 9968     		ldr	r1, [r3, #8]
 8988 0c76 0A40     		ands	r2, r1
 8989 0c78 9A60     		str	r2, [r3, #8]
 8990 0c7a F3E2     		b	.L354
 8991              	.L385:
2755:Src/usb_pd_protocol.c **** 		}
2756:Src/usb_pd_protocol.c **** 		break;
2757:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_DISCONNECTED_DEBOUNCE:
2758:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
 8992              		.loc 1 2758 3 is_stmt 1 view .LVU2437
 8993              	.LVL686:
 8994              	.LBB990:
 8995              	.LBI990:
  58:Inc/tcpm.h    **** {
 8996              		.loc 2 58 19 view .LVU2438
 8997              	.LBB991:
  60:Inc/tcpm.h    **** }
 8998              		.loc 2 60 2 view .LVU2439
  60:Inc/tcpm.h    **** }
 8999              		.loc 2 60 9 is_stmt 0 view .LVU2440
 9000 0c7c 684C     		ldr	r4, .L587+16
 9001 0c7e 694A     		ldr	r2, .L587+20
 9002 0c80 2100     		movs	r1, r4
ARM GAS  /tmp/ccoQIC4J.s 			page 243


 9003 0c82 3000     		movs	r0, r6
 9004 0c84 BB68     		ldr	r3, [r7, #8]
 9005 0c86 9847     		blx	r3
 9006              	.LVL687:
  60:Inc/tcpm.h    **** }
 9007              		.loc 2 60 9 view .LVU2441
 9008              	.LBE991:
 9009              	.LBE990:
2759:Src/usb_pd_protocol.c **** 
2760:Src/usb_pd_protocol.c **** 		if (cc_is_rp(cc1) && cc_is_rp(cc2)) {
 9010              		.loc 1 2760 3 is_stmt 1 view .LVU2442
 9011              		.loc 1 2760 7 is_stmt 0 view .LVU2443
 9012 0c88 2368     		ldr	r3, [r4]
 9013              	.LVL688:
 9014              	.LBB992:
 9015              	.LBI992:
1921:Src/usb_pd_protocol.c **** {
 9016              		.loc 1 1921 19 is_stmt 1 view .LVU2444
 9017              	.LBB993:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9018              		.loc 1 1923 2 view .LVU2445
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9019              		.loc 1 1923 72 is_stmt 0 view .LVU2446
 9020 0c8a 053B     		subs	r3, r3, #5
 9021              	.LVL689:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9022              		.loc 1 1923 72 view .LVU2447
 9023              	.LBE993:
 9024              	.LBE992:
 9025              		.loc 1 2760 6 view .LVU2448
 9026 0c8c 022B     		cmp	r3, #2
 9027 0c8e 08D8     		bhi	.L444
 9028              		.loc 1 2760 24 discriminator 1 view .LVU2449
 9029 0c90 644A     		ldr	r2, .L587+20
 9030 0c92 1268     		ldr	r2, [r2]
 9031              	.LVL690:
 9032              	.LBB994:
 9033              	.LBI994:
1921:Src/usb_pd_protocol.c **** {
 9034              		.loc 1 1921 19 is_stmt 1 discriminator 1 view .LVU2450
 9035              	.LBB995:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9036              		.loc 1 1923 2 discriminator 1 view .LVU2451
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9037              		.loc 1 1923 72 is_stmt 0 discriminator 1 view .LVU2452
 9038 0c94 053A     		subs	r2, r2, #5
 9039              	.LVL691:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9040              		.loc 1 1923 72 discriminator 1 view .LVU2453
 9041              	.LBE995:
 9042              	.LBE994:
 9043              		.loc 1 2760 21 discriminator 1 view .LVU2454
 9044 0c96 022A     		cmp	r2, #2
 9045 0c98 03D8     		bhi	.L444
2761:Src/usb_pd_protocol.c **** 			/* Debug accessory */
2762:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_DEBUG_ACC;
 9046              		.loc 1 2762 4 is_stmt 1 view .LVU2455
ARM GAS  /tmp/ccoQIC4J.s 			page 244


 9047              		.loc 1 2762 17 is_stmt 0 view .LVU2456
 9048 0c9a 644B     		ldr	r3, .L587+28
 9049 0c9c 0322     		movs	r2, #3
 9050 0c9e 1A70     		strb	r2, [r3]
 9051 0ca0 09E0     		b	.L445
 9052              	.L444:
2763:Src/usb_pd_protocol.c **** 		} else if (cc_is_rp(cc1) || cc_is_rp(cc2)) {
 9053              		.loc 1 2763 10 is_stmt 1 view .LVU2457
 9054              	.LVL692:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9055              		.loc 1 1923 2 view .LVU2458
 9056              		.loc 1 2763 13 is_stmt 0 view .LVU2459
 9057 0ca2 022B     		cmp	r3, #2
 9058 0ca4 04D9     		bls	.L446
 9059              		.loc 1 2763 31 discriminator 1 view .LVU2460
 9060 0ca6 5F4B     		ldr	r3, .L587+20
 9061 0ca8 1B68     		ldr	r3, [r3]
 9062              	.LVL693:
 9063              	.LBB996:
 9064              	.LBI996:
1921:Src/usb_pd_protocol.c **** {
 9065              		.loc 1 1921 19 is_stmt 1 discriminator 1 view .LVU2461
 9066              	.LBB997:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9067              		.loc 1 1923 2 discriminator 1 view .LVU2462
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9068              		.loc 1 1923 72 is_stmt 0 discriminator 1 view .LVU2463
 9069 0caa 053B     		subs	r3, r3, #5
 9070              	.LVL694:
1923:Src/usb_pd_protocol.c **** 	       (cc == TYPEC_CC_VOLT_SNK_3_0);
 9071              		.loc 1 1923 72 discriminator 1 view .LVU2464
 9072              	.LBE997:
 9073              	.LBE996:
 9074              		.loc 1 2763 28 discriminator 1 view .LVU2465
 9075 0cac 022B     		cmp	r3, #2
 9076 0cae 21D8     		bhi	.L447
 9077              	.L446:
2764:Src/usb_pd_protocol.c **** 			new_cc_state = PD_CC_DFP_ATTACHED;
 9078              		.loc 1 2764 4 is_stmt 1 view .LVU2466
 9079              		.loc 1 2764 17 is_stmt 0 view .LVU2467
 9080 0cb0 5E4B     		ldr	r3, .L587+28
 9081 0cb2 0522     		movs	r2, #5
 9082 0cb4 1A70     		strb	r2, [r3]
 9083              	.L445:
2765:Src/usb_pd_protocol.c **** 		} else {
2766:Src/usb_pd_protocol.c **** 			/* No connection any more */
2767:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
2768:Src/usb_pd_protocol.c **** 			timeout = 5*MSEC_US;
2769:Src/usb_pd_protocol.c **** 			break;
2770:Src/usb_pd_protocol.c **** 		}
2771:Src/usb_pd_protocol.c **** 
2772:Src/usb_pd_protocol.c **** 		timeout = 20*MSEC_US;
 9084              		.loc 1 2772 3 is_stmt 1 view .LVU2468
 9085              		.loc 1 2772 11 is_stmt 0 view .LVU2469
 9086 0cb6 584B     		ldr	r3, .L587+8
 9087 0cb8 624A     		ldr	r2, .L587+52
 9088 0cba 1A60     		str	r2, [r3]
ARM GAS  /tmp/ccoQIC4J.s 			page 245


2773:Src/usb_pd_protocol.c **** 
2774:Src/usb_pd_protocol.c **** 		/* Debounce the cc state */
2775:Src/usb_pd_protocol.c **** 		if (new_cc_state != pd[port].cc_state) {
 9089              		.loc 1 2775 3 is_stmt 1 view .LVU2470
 9090              		.loc 1 2775 31 is_stmt 0 view .LVU2471
 9091 0cbc F201     		lsls	r2, r6, #7
 9092 0cbe 544B     		ldr	r3, .L587
 9093 0cc0 9B18     		adds	r3, r3, r2
 9094 0cc2 2833     		adds	r3, r3, #40
 9095 0cc4 1A78     		ldrb	r2, [r3]
 9096              		.loc 1 2775 20 view .LVU2472
 9097 0cc6 594B     		ldr	r3, .L587+28
 9098 0cc8 1B78     		ldrb	r3, [r3]
 9099              		.loc 1 2775 6 view .LVU2473
 9100 0cca 9A42     		cmp	r2, r3
 9101 0ccc 3CD0     		beq	.L450
2776:Src/usb_pd_protocol.c **** 			pd[port].cc_debounce = get_time().val +
 9102              		.loc 1 2776 4 is_stmt 1 view .LVU2474
 9103              		.loc 1 2776 27 is_stmt 0 view .LVU2475
 9104 0cce 04A8     		add	r0, sp, #16
 9105 0cd0 FFF7FEFF 		bl	get_time
 9106              	.LVL695:
 9107              		.loc 1 2776 42 view .LVU2476
 9108 0cd4 5648     		ldr	r0, .L587+32
 9109 0cd6 0021     		movs	r1, #0
 9110 0cd8 049B     		ldr	r3, [sp, #16]
 9111 0cda 059C     		ldr	r4, [sp, #20]
 9112 0cdc C018     		adds	r0, r0, r3
 9113 0cde 6141     		adcs	r1, r1, r4
 9114              		.loc 1 2776 25 view .LVU2477
 9115 0ce0 F201     		lsls	r2, r6, #7
 9116 0ce2 4B4B     		ldr	r3, .L587
 9117 0ce4 9B18     		adds	r3, r3, r2
 9118 0ce6 1862     		str	r0, [r3, #32]
 9119 0ce8 5962     		str	r1, [r3, #36]
2777:Src/usb_pd_protocol.c **** 				PD_T_CC_DEBOUNCE;
2778:Src/usb_pd_protocol.c **** 			pd[port].cc_state = new_cc_state;
 9120              		.loc 1 2778 4 is_stmt 1 view .LVU2478
 9121              		.loc 1 2778 22 is_stmt 0 view .LVU2479
 9122 0cea 2833     		adds	r3, r3, #40
 9123 0cec 4F4A     		ldr	r2, .L587+28
 9124 0cee 1278     		ldrb	r2, [r2]
 9125 0cf0 1A70     		strb	r2, [r3]
2779:Src/usb_pd_protocol.c **** 			break;
 9126              		.loc 1 2779 4 is_stmt 1 view .LVU2480
 9127 0cf2 B7E2     		b	.L354
 9128              	.L447:
2767:Src/usb_pd_protocol.c **** 			timeout = 5*MSEC_US;
 9129              		.loc 1 2767 4 view .LVU2481
 9130              	.LVL696:
 9131              	.LBB998:
 9132              	.LBI998:
 326:Src/usb_pd_protocol.c **** {
 9133              		.loc 1 326 20 view .LVU2482
 9134              	.LBB999:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 9135              		.loc 1 328 2 view .LVU2483
ARM GAS  /tmp/ccoQIC4J.s 			page 246


 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 9136              		.loc 1 328 17 is_stmt 0 view .LVU2484
 9137 0cf4 F201     		lsls	r2, r6, #7
 9138 0cf6 464B     		ldr	r3, .L587
 9139 0cf8 9B18     		adds	r3, r3, r2
 9140 0cfa 1A79     		ldrb	r2, [r3, #4]
 9141              	.LVL697:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 9142              		.loc 1 333 2 is_stmt 1 view .LVU2485
 9143              	.LBB1000:
 9144              	.LBI1000:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9145              		.loc 1 261 20 view .LVU2486
 9146              	.LBB1001:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9147              		.loc 1 265 2 view .LVU2487
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9148              		.loc 1 265 19 is_stmt 0 view .LVU2488
 9149 0cfc 0020     		movs	r0, #0
 9150 0cfe 0021     		movs	r1, #0
 9151 0d00 1861     		str	r0, [r3, #16]
 9152 0d02 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9153              		.loc 1 266 2 is_stmt 1 view .LVU2489
 266:Src/usb_pd_protocol.c **** }
 9154              		.loc 1 266 25 is_stmt 0 view .LVU2490
 9155 0d04 0021     		movs	r1, #0
 9156 0d06 D971     		strb	r1, [r3, #7]
 9157              	.LVL698:
 266:Src/usb_pd_protocol.c **** }
 9158              		.loc 1 266 25 view .LVU2491
 9159              	.LBE1001:
 9160              	.LBE1000:
 334:Src/usb_pd_protocol.c **** 
 9161              		.loc 1 334 2 is_stmt 1 view .LVU2492
 334:Src/usb_pd_protocol.c **** 
 9162              		.loc 1 334 22 is_stmt 0 view .LVU2493
 9163 0d08 0231     		adds	r1, r1, #2
 9164 0d0a 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 9165              		.loc 1 336 2 is_stmt 1 view .LVU2494
 336:Src/usb_pd_protocol.c **** 		return;
 9166              		.loc 1 336 5 is_stmt 0 view .LVU2495
 9167 0d0c 022A     		cmp	r2, #2
 9168 0d0e 13D0     		beq	.L448
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 9169              		.loc 1 347 2 is_stmt 1 view .LVU2496
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 9170              		.loc 1 348 48 is_stmt 0 view .LVU2497
 9171 0d10 0E2A     		cmp	r2, #14
 9172 0d12 11D0     		beq	.L448
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 9173              		.loc 1 353 2 is_stmt 1 view .LVU2498
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 9174              		.loc 1 356 3 view .LVU2499
 9175 0d14 0022     		movs	r2, #0
 9176              	.LVL699:
ARM GAS  /tmp/ccoQIC4J.s 			page 247


 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 9177              		.loc 1 356 3 is_stmt 0 view .LVU2500
 9178 0d16 0021     		movs	r1, #0
 9179 0d18 3000     		movs	r0, r6
 9180 0d1a FFF7FEFF 		bl	pd_set_input_current_limit
 9181              	.LVL700:
 373:Src/usb_pd_protocol.c **** 			/*
 9182              		.loc 1 373 3 is_stmt 1 view .LVU2501
 373:Src/usb_pd_protocol.c **** 			/*
 9183              		.loc 1 373 15 is_stmt 0 view .LVU2502
 9184 0d1e F301     		lsls	r3, r6, #7
 9185 0d20 3B4A     		ldr	r2, .L587
 9186 0d22 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 9187              		.loc 1 373 6 view .LVU2503
 9188 0d24 012B     		cmp	r3, #1
 9189 0d26 0BD0     		beq	.L551
 9190              	.L449:
 405:Src/usb_pd_protocol.c **** 	}
 9191              		.loc 1 405 3 is_stmt 1 view .LVU2504
 9192              	.LVL701:
 9193              	.LBB1002:
 9194              	.LBI1002:
  94:Inc/tcpm.h    **** {
 9195              		.loc 2 94 19 view .LVU2505
 9196              	.LBB1003:
  96:Inc/tcpm.h    **** }
 9197              		.loc 2 96 2 view .LVU2506
  96:Inc/tcpm.h    **** }
 9198              		.loc 2 96 26 is_stmt 0 view .LVU2507
 9199 0d28 3201     		lsls	r2, r6, #4
 9200 0d2a 3A4B     		ldr	r3, .L587+4
 9201 0d2c 9B18     		adds	r3, r3, r2
 9202 0d2e 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 9203              		.loc 2 96 30 view .LVU2508
 9204 0d30 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 9205              		.loc 2 96 9 view .LVU2509
 9206 0d32 0021     		movs	r1, #0
 9207 0d34 3000     		movs	r0, r6
 9208 0d36 9847     		blx	r3
 9209              	.LVL702:
 9210              	.L448:
  96:Inc/tcpm.h    **** }
 9211              		.loc 2 96 9 view .LVU2510
 9212              	.LBE1003:
 9213              	.LBE1002:
 9214              	.LBE999:
 9215              	.LBE998:
2768:Src/usb_pd_protocol.c **** 			break;
 9216              		.loc 1 2768 4 is_stmt 1 view .LVU2511
2768:Src/usb_pd_protocol.c **** 			break;
 9217              		.loc 1 2768 12 is_stmt 0 view .LVU2512
 9218 0d38 374B     		ldr	r3, .L587+8
 9219 0d3a 434A     		ldr	r2, .L587+56
 9220 0d3c 1A60     		str	r2, [r3]
ARM GAS  /tmp/ccoQIC4J.s 			page 248


2769:Src/usb_pd_protocol.c **** 		}
 9221              		.loc 1 2769 4 is_stmt 1 view .LVU2513
 9222 0d3e 91E2     		b	.L354
 9223              	.LVL703:
 9224              	.L551:
 9225              	.LBB1005:
 9226              	.LBB1004:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 9227              		.loc 1 378 4 view .LVU2514
 9228 0d40 3000     		movs	r0, r6
 9229 0d42 FFF7FEFF 		bl	pd_power_supply_reset
 9230              	.LVL704:
 9231 0d46 EFE7     		b	.L449
 9232              	.LVL705:
 9233              	.L450:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 9234              		.loc 1 378 4 is_stmt 0 view .LVU2515
 9235              	.LBE1004:
 9236              	.LBE1005:
2780:Src/usb_pd_protocol.c **** 		}
2781:Src/usb_pd_protocol.c **** 		/* Wait for CC debounce and VBUS present */
2782:Src/usb_pd_protocol.c **** 		if (get_time().val < pd[port].cc_debounce ||
 9237              		.loc 1 2782 3 is_stmt 1 view .LVU2516
 9238              		.loc 1 2782 7 is_stmt 0 view .LVU2517
 9239 0d48 04A8     		add	r0, sp, #16
 9240 0d4a FFF7FEFF 		bl	get_time
 9241              	.LVL706:
 9242              		.loc 1 2782 17 view .LVU2518
 9243 0d4e 0498     		ldr	r0, [sp, #16]
 9244 0d50 0599     		ldr	r1, [sp, #20]
 9245              		.loc 1 2782 32 view .LVU2519
 9246 0d52 F201     		lsls	r2, r6, #7
 9247 0d54 2E4B     		ldr	r3, .L587
 9248 0d56 9B18     		adds	r3, r3, r2
 9249 0d58 1A6A     		ldr	r2, [r3, #32]
 9250 0d5a 5B6A     		ldr	r3, [r3, #36]
 9251              		.loc 1 2782 6 view .LVU2520
 9252 0d5c 8B42     		cmp	r3, r1
 9253 0d5e 00D9     		bls	.LCB8659
 9254 0d60 80E2     		b	.L354	@long jump
 9255              	.LCB8659:
 9256 0d62 02D1     		bne	.L516
 9257 0d64 8242     		cmp	r2, r0
 9258 0d66 00D9     		bls	.LCB8663
 9259 0d68 7CE2     		b	.L354	@long jump
 9260              	.LCB8663:
 9261              	.L516:
 9262              	.LVL707:
 9263              	.LBB1006:
 9264              	.LBI1006:
 316:Src/usb_pd_protocol.c **** {
 9265              		.loc 1 316 19 is_stmt 1 view .LVU2521
 9266              	.LBB1007:
 321:Src/usb_pd_protocol.c **** #endif
 9267              		.loc 1 321 2 view .LVU2522
 321:Src/usb_pd_protocol.c **** #endif
 9268              		.loc 1 321 9 is_stmt 0 view .LVU2523
ARM GAS  /tmp/ccoQIC4J.s 			page 249


 9269 0d6a 3000     		movs	r0, r6
 9270 0d6c FFF7FEFF 		bl	pd_snk_is_vbus_provided
 9271              	.LVL708:
 321:Src/usb_pd_protocol.c **** #endif
 9272              		.loc 1 321 9 view .LVU2524
 9273              	.LBE1007:
 9274              	.LBE1006:
 9275              		.loc 1 2782 45 view .LVU2525
 9276 0d70 0028     		cmp	r0, #0
 9277 0d72 00D1     		bne	.LCB8676
 9278 0d74 76E2     		b	.L354	@long jump
 9279              	.LCB8676:
2783:Src/usb_pd_protocol.c **** 			!pd_is_vbus_present(port))
2784:Src/usb_pd_protocol.c **** 			break;
2785:Src/usb_pd_protocol.c **** 
2786:Src/usb_pd_protocol.c **** 		if (pd_try_src_enable &&
 9280              		.loc 1 2786 3 is_stmt 1 view .LVU2526
2787:Src/usb_pd_protocol.c **** 			!(pd[port].flags & PD_FLAGS_TRY_SRC)) {
2788:Src/usb_pd_protocol.c **** 			/*
2789:Src/usb_pd_protocol.c **** 				* If TRY_SRC is enabled, but not active,
2790:Src/usb_pd_protocol.c **** 				* then force attempt to connect as source.
2791:Src/usb_pd_protocol.c **** 				*/
2792:Src/usb_pd_protocol.c **** 			pd[port].try_src_marker = get_time().val
2793:Src/usb_pd_protocol.c **** 				+ PD_T_TRY_SRC;
2794:Src/usb_pd_protocol.c **** 			/* Swap roles to source */
2795:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SOURCE;
2796:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
2797:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC_US;
2798:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
2799:Src/usb_pd_protocol.c **** 			/* Set flag after the state change */
2800:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_TRY_SRC;
2801:Src/usb_pd_protocol.c **** 			break;
2802:Src/usb_pd_protocol.c **** 		}
2803:Src/usb_pd_protocol.c **** 
2804:Src/usb_pd_protocol.c **** 		/* We are attached */
2805:Src/usb_pd_protocol.c **** 		pd[port].polarity = get_snk_polarity(cc1, cc2);
 9281              		.loc 1 2805 3 view .LVU2527
 9282              		.loc 1 2805 23 is_stmt 0 view .LVU2528
 9283 0d76 2A4B     		ldr	r3, .L587+16
 9284 0d78 1968     		ldr	r1, [r3]
 9285 0d7a 2A4B     		ldr	r3, .L587+20
 9286 0d7c 1A68     		ldr	r2, [r3]
 9287              	.LVL709:
 9288              	.LBB1008:
 9289              	.LBI1008:
1943:Src/usb_pd_protocol.c **** {
 9290              		.loc 1 1943 19 is_stmt 1 view .LVU2529
 9291              	.LBB1009:
1950:Src/usb_pd_protocol.c **** }
 9292              		.loc 1 1950 2 view .LVU2530
1950:Src/usb_pd_protocol.c **** }
 9293              		.loc 1 1950 14 is_stmt 0 view .LVU2531
 9294 0d7e 0123     		movs	r3, #1
 9295 0d80 9142     		cmp	r1, r2
 9296 0d82 00DB     		blt	.L452
 9297 0d84 0023     		movs	r3, #0
 9298              	.L452:
ARM GAS  /tmp/ccoQIC4J.s 			page 250


 9299 0d86 D9B2     		uxtb	r1, r3
 9300              	.LVL710:
1950:Src/usb_pd_protocol.c **** }
 9301              		.loc 1 1950 14 view .LVU2532
 9302              	.LBE1009:
 9303              	.LBE1008:
 9304              		.loc 1 2805 21 view .LVU2533
 9305 0d88 F201     		lsls	r2, r6, #7
 9306 0d8a 214C     		ldr	r4, .L587
 9307 0d8c A418     		adds	r4, r4, r2
 9308 0d8e E370     		strb	r3, [r4, #3]
2806:Src/usb_pd_protocol.c **** 		tcpm_set_polarity(port, pd[port].polarity);
 9309              		.loc 1 2806 3 is_stmt 1 view .LVU2534
 9310              	.LVL711:
 9311              	.LBB1010:
 9312              	.LBI1010:
  78:Inc/tcpm.h    **** {
 9313              		.loc 2 78 19 view .LVU2535
 9314              	.LBB1011:
  80:Inc/tcpm.h    **** }
 9315              		.loc 2 80 2 view .LVU2536
  80:Inc/tcpm.h    **** }
 9316              		.loc 2 80 9 is_stmt 0 view .LVU2537
 9317 0d90 3000     		movs	r0, r6
 9318 0d92 BB69     		ldr	r3, [r7, #24]
 9319 0d94 9847     		blx	r3
 9320              	.LVL712:
  80:Inc/tcpm.h    **** }
 9321              		.loc 2 80 9 view .LVU2538
 9322              	.LBE1011:
 9323              	.LBE1010:
2807:Src/usb_pd_protocol.c **** 		/* reset message ID  on connection */
2808:Src/usb_pd_protocol.c **** 		pd[port].msg_id = 0;
 9324              		.loc 1 2808 3 is_stmt 1 view .LVU2539
 9325              		.loc 1 2808 19 is_stmt 0 view .LVU2540
 9326 0d96 0023     		movs	r3, #0
 9327 0d98 A370     		strb	r3, [r4, #2]
2809:Src/usb_pd_protocol.c **** 		/* initial data role for sink is UFP */
2810:Src/usb_pd_protocol.c **** 		pd_set_data_role(port, PD_ROLE_UFP);
 9328              		.loc 1 2810 3 is_stmt 1 view .LVU2541
 9329 0d9a 0021     		movs	r1, #0
 9330 0d9c 3000     		movs	r0, r6
 9331 0d9e FFF7FEFF 		bl	pd_set_data_role
 9332              	.LVL713:
2811:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
2812:Src/usb_pd_protocol.c **** 		typec_curr = get_typec_current_limit(pd[port].polarity,
 9333              		.loc 1 2812 3 view .LVU2542
 9334              		.loc 1 2812 48 is_stmt 0 view .LVU2543
 9335 0da2 E078     		ldrb	r0, [r4, #3]
 9336              		.loc 1 2812 16 view .LVU2544
 9337 0da4 1F4B     		ldr	r3, .L587+20
 9338 0da6 1A68     		ldr	r2, [r3]
 9339 0da8 1D4B     		ldr	r3, .L587+16
 9340 0daa 1968     		ldr	r1, [r3]
 9341 0dac FFF7FEFF 		bl	get_typec_current_limit
 9342              	.LVL714:
 9343              		.loc 1 2812 14 view .LVU2545
ARM GAS  /tmp/ccoQIC4J.s 			page 251


 9344 0db0 264B     		ldr	r3, .L587+60
 9345 0db2 1860     		str	r0, [r3]
2813:Src/usb_pd_protocol.c **** 							    cc1, cc2);
2814:Src/usb_pd_protocol.c **** 		//typec_set_input_current_limit(
2815:Src/usb_pd_protocol.c **** 		//	port, typec_curr, TYPE_C_VOLTAGE);
2816:Src/usb_pd_protocol.c **** #endif
2817:Src/usb_pd_protocol.c **** 		/* If PD comm is enabled, enable TCPC RX */
2818:Src/usb_pd_protocol.c **** 		if (pd_comm_is_enabled(port))
 9346              		.loc 1 2818 3 is_stmt 1 view .LVU2546
 9347              		.loc 1 2818 7 is_stmt 0 view .LVU2547
 9348 0db4 3000     		movs	r0, r6
 9349 0db6 FFF7FEFF 		bl	pd_comm_is_enabled
 9350              	.LVL715:
 9351              		.loc 1 2818 6 view .LVU2548
 9352 0dba 0028     		cmp	r0, #0
 9353 0dbc 03D0     		beq	.L453
2819:Src/usb_pd_protocol.c **** 			tcpm_set_rx_enable(port, 1);
 9354              		.loc 1 2819 4 is_stmt 1 view .LVU2549
 9355              	.LVL716:
 9356              	.LBB1012:
 9357              	.LBI1012:
  94:Inc/tcpm.h    **** {
 9358              		.loc 2 94 19 view .LVU2550
 9359              	.LBB1013:
  96:Inc/tcpm.h    **** }
 9360              		.loc 2 96 2 view .LVU2551
  96:Inc/tcpm.h    **** }
 9361              		.loc 2 96 9 is_stmt 0 view .LVU2552
 9362 0dbe 0121     		movs	r1, #1
 9363 0dc0 3000     		movs	r0, r6
 9364 0dc2 7B6A     		ldr	r3, [r7, #36]
 9365 0dc4 9847     		blx	r3
 9366              	.LVL717:
 9367              	.L453:
  96:Inc/tcpm.h    **** }
 9368              		.loc 2 96 9 view .LVU2553
 9369              	.LBE1013:
 9370              	.LBE1012:
2820:Src/usb_pd_protocol.c **** 
2821:Src/usb_pd_protocol.c **** 		/* DFP is attached */
2822:Src/usb_pd_protocol.c **** 		if (new_cc_state == PD_CC_DFP_ATTACHED ||
 9371              		.loc 1 2822 3 is_stmt 1 view .LVU2554
 9372              		.loc 1 2822 20 is_stmt 0 view .LVU2555
 9373 0dc6 194B     		ldr	r3, .L587+28
 9374 0dc8 1978     		ldrb	r1, [r3]
 9375              		.loc 1 2822 6 view .LVU2556
 9376 0dca 0529     		cmp	r1, #5
 9377 0dcc 02D0     		beq	.L454
 9378              		.loc 1 2822 42 discriminator 1 view .LVU2557
 9379 0dce 0329     		cmp	r1, #3
 9380 0dd0 00D0     		beq	.LCB8767
 9381 0dd2 47E2     		b	.L354	@long jump
 9382              	.LCB8767:
 9383              	.L454:
2823:Src/usb_pd_protocol.c **** 			new_cc_state == PD_CC_DEBUG_ACC) {
2824:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_PR_ROLE |
 9384              		.loc 1 2824 4 is_stmt 1 view .LVU2558
ARM GAS  /tmp/ccoQIC4J.s 			page 252


 9385              		.loc 1 2824 19 is_stmt 0 view .LVU2559
 9386 0dd4 F301     		lsls	r3, r6, #7
 9387 0dd6 0E4A     		ldr	r2, .L587
 9388 0dd8 D218     		adds	r2, r2, r3
 9389 0dda C123     		movs	r3, #193
 9390 0ddc DB00     		lsls	r3, r3, #3
 9391 0dde 9068     		ldr	r0, [r2, #8]
 9392 0de0 0343     		orrs	r3, r0
 9393 0de2 9360     		str	r3, [r2, #8]
2825:Src/usb_pd_protocol.c **** 						PD_FLAGS_CHECK_DR_ROLE |
2826:Src/usb_pd_protocol.c **** 						PD_FLAGS_CHECK_IDENTITY;
2827:Src/usb_pd_protocol.c **** 			if (new_cc_state == PD_CC_DEBUG_ACC)
 9394              		.loc 1 2827 4 is_stmt 1 view .LVU2560
 9395              		.loc 1 2827 7 is_stmt 0 view .LVU2561
 9396 0de4 0329     		cmp	r1, #3
 9397 0de6 0BD0     		beq	.L552
 9398              	.L455:
2828:Src/usb_pd_protocol.c **** 				pd[port].flags |=
2829:Src/usb_pd_protocol.c **** 					PD_FLAGS_TS_DTS_PARTNER;
2830:Src/usb_pd_protocol.c **** 			send_control(port, PD_CTRL_GET_SOURCE_CAP);
 9399              		.loc 1 2830 4 is_stmt 1 view .LVU2562
 9400 0de8 0721     		movs	r1, #7
 9401 0dea 3000     		movs	r0, r6
 9402 0dec FFF7FEFF 		bl	send_control
 9403              	.LVL718:
2831:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
 9404              		.loc 1 2831 4 view .LVU2563
 9405 0df0 0521     		movs	r1, #5
 9406 0df2 3000     		movs	r0, r6
 9407 0df4 FFF7FEFF 		bl	set_state
 9408              	.LVL719:
2832:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC_US;
 9409              		.loc 1 2832 4 view .LVU2564
 9410              		.loc 1 2832 12 is_stmt 0 view .LVU2565
 9411 0df8 074B     		ldr	r3, .L587+8
 9412 0dfa 084A     		ldr	r2, .L587+12
 9413 0dfc 1A60     		str	r2, [r3]
 9414 0dfe 31E2     		b	.L354
 9415              	.L552:
2828:Src/usb_pd_protocol.c **** 				pd[port].flags |=
 9416              		.loc 1 2828 5 is_stmt 1 view .LVU2566
2828:Src/usb_pd_protocol.c **** 				pd[port].flags |=
 9417              		.loc 1 2828 20 is_stmt 0 view .LVU2567
 9418 0e00 F101     		lsls	r1, r6, #7
 9419 0e02 034A     		ldr	r2, .L587
 9420 0e04 5218     		adds	r2, r2, r1
 9421 0e06 8021     		movs	r1, #128
 9422 0e08 4902     		lsls	r1, r1, #9
 9423 0e0a 0B43     		orrs	r3, r1
 9424 0e0c 9360     		str	r3, [r2, #8]
 9425 0e0e EBE7     		b	.L455
 9426              	.L588:
 9427              		.align	2
 9428              	.L587:
 9429 0e10 00000000 		.word	pd
 9430 0e14 00000000 		.word	tcpc_config
 9431 0e18 00000000 		.word	.LANCHOR5
ARM GAS  /tmp/ccoQIC4J.s 			page 253


 9432 0e1c 10270000 		.word	10000
 9433 0e20 00000000 		.word	.LANCHOR7
 9434 0e24 00000000 		.word	.LANCHOR6
 9435 0e28 00000000 		.word	.LANCHOR10
 9436 0e2c 00000000 		.word	.LANCHOR9
 9437 0e30 A0860100 		.word	100000
 9438 0e34 00000000 		.word	.LANCHOR0
 9439 0e38 00000000 		.word	.LANCHOR8
 9440 0e3c 30750000 		.word	30000
 9441 0e40 FFDFFFFF 		.word	-8193
 9442 0e44 204E0000 		.word	20000
 9443 0e48 88130000 		.word	5000
 9444 0e4c 00000000 		.word	.LANCHOR13
 9445              	.L384:
2833:Src/usb_pd_protocol.c **** 			//hook_call_deferred(
2834:Src/usb_pd_protocol.c **** 			//	&pd_usb_billboard_deferred_data,
2835:Src/usb_pd_protocol.c **** 			//	PD_T_AME);
2836:Src/usb_pd_protocol.c **** 		}
2837:Src/usb_pd_protocol.c **** 		break;
2838:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_HARD_RESET_RECOVER:
2839:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 9446              		.loc 1 2839 3 is_stmt 1 view .LVU2568
 9447              		.loc 1 2839 15 is_stmt 0 view .LVU2569
 9448 0e50 F101     		lsls	r1, r6, #7
 9449 0e52 B94A     		ldr	r2, .L589
 9450 0e54 5218     		adds	r2, r2, r1
 9451 0e56 5179     		ldrb	r1, [r2, #5]
 9452              		.loc 1 2839 6 view .LVU2570
 9453 0e58 8B42     		cmp	r3, r1
 9454 0e5a 06D0     		beq	.L456
2840:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_CHECK_IDENTITY;
 9455              		.loc 1 2840 4 is_stmt 1 view .LVU2571
 9456              		.loc 1 2840 19 is_stmt 0 view .LVU2572
 9457 0e5c F001     		lsls	r0, r6, #7
 9458 0e5e B64A     		ldr	r2, .L589
 9459 0e60 1218     		adds	r2, r2, r0
 9460 0e62 0820     		movs	r0, #8
 9461 0e64 9468     		ldr	r4, [r2, #8]
 9462 0e66 2043     		orrs	r0, r4
 9463 0e68 9060     		str	r0, [r2, #8]
 9464              	.L456:
2841:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_VBUS_DETECT_NONE
2842:Src/usb_pd_protocol.c **** 		/*
2843:Src/usb_pd_protocol.c **** 			* Can't measure vbus state so this is the maximum
2844:Src/usb_pd_protocol.c **** 			* recovery time for the source.
2845:Src/usb_pd_protocol.c **** 			*/
2846:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
2847:Src/usb_pd_protocol.c **** 			set_state_timeout(port, get_time().val +
2848:Src/usb_pd_protocol.c **** 						PD_T_SAFE_0V +
2849:Src/usb_pd_protocol.c **** 						PD_T_SRC_RECOVER_MAX +
2850:Src/usb_pd_protocol.c **** 						PD_T_SRC_TURN_ON,
2851:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2852:Src/usb_pd_protocol.c **** #else
2853:Src/usb_pd_protocol.c **** 		/* Wait for VBUS to go low and then high*/
2854:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 9465              		.loc 1 2854 3 is_stmt 1 view .LVU2573
 9466              		.loc 1 2854 6 is_stmt 0 view .LVU2574
ARM GAS  /tmp/ccoQIC4J.s 			page 254


 9467 0e6a 8B42     		cmp	r3, r1
 9468 0e6c 22D1     		bne	.L553
 9469              	.L457:
2855:Src/usb_pd_protocol.c **** 			snk_hard_reset_vbus_off = 0;
2856:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2857:Src/usb_pd_protocol.c **** 						get_time().val +
2858:Src/usb_pd_protocol.c **** 						PD_T_SAFE_0V,
2859:Src/usb_pd_protocol.c **** 						hard_reset_count <
2860:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
2861:Src/usb_pd_protocol.c **** 						    PD_STATE_HARD_RESET_SEND :
2862:Src/usb_pd_protocol.c **** 						    PD_STATE_SNK_DISCOVERY);
2863:Src/usb_pd_protocol.c **** 		}
2864:Src/usb_pd_protocol.c **** 
2865:Src/usb_pd_protocol.c **** 		if (!pd_is_vbus_present(port) &&
 9470              		.loc 1 2865 3 is_stmt 1 view .LVU2575
 9471              	.LVL720:
 9472              	.LBB1014:
 9473              	.LBI1014:
 316:Src/usb_pd_protocol.c **** {
 9474              		.loc 1 316 19 view .LVU2576
 9475              	.LBB1015:
 321:Src/usb_pd_protocol.c **** #endif
 9476              		.loc 1 321 2 view .LVU2577
 321:Src/usb_pd_protocol.c **** #endif
 9477              		.loc 1 321 9 is_stmt 0 view .LVU2578
 9478 0e6e 3000     		movs	r0, r6
 9479 0e70 FFF7FEFF 		bl	pd_snk_is_vbus_provided
 9480              	.LVL721:
 321:Src/usb_pd_protocol.c **** #endif
 9481              		.loc 1 321 9 view .LVU2579
 9482              	.LBE1015:
 9483              	.LBE1014:
 9484              		.loc 1 2865 6 view .LVU2580
 9485 0e74 0028     		cmp	r0, #0
 9486 0e76 03D1     		bne	.L459
2866:Src/usb_pd_protocol.c **** 			!snk_hard_reset_vbus_off) {
 9487              		.loc 1 2866 4 discriminator 1 view .LVU2581
 9488 0e78 B04B     		ldr	r3, .L589+4
 9489 0e7a 1B68     		ldr	r3, [r3]
2865:Src/usb_pd_protocol.c **** 			!snk_hard_reset_vbus_off) {
 9490              		.loc 1 2865 33 discriminator 1 view .LVU2582
 9491 0e7c 002B     		cmp	r3, #0
 9492 0e7e 33D0     		beq	.L554
 9493              	.L459:
2867:Src/usb_pd_protocol.c **** 			/* VBUS has gone low, reset timeout */
2868:Src/usb_pd_protocol.c **** 			snk_hard_reset_vbus_off = 1;
2869:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
2870:Src/usb_pd_protocol.c **** 						get_time().val +
2871:Src/usb_pd_protocol.c **** 						PD_T_SRC_RECOVER_MAX +
2872:Src/usb_pd_protocol.c **** 						PD_T_SRC_TURN_ON,
2873:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2874:Src/usb_pd_protocol.c **** 		}
2875:Src/usb_pd_protocol.c **** 		if (pd_is_vbus_present(port) &&
 9494              		.loc 1 2875 3 is_stmt 1 view .LVU2583
 9495              	.LVL722:
 9496              	.LBB1016:
 9497              	.LBI1016:
ARM GAS  /tmp/ccoQIC4J.s 			page 255


 316:Src/usb_pd_protocol.c **** {
 9498              		.loc 1 316 19 view .LVU2584
 9499              	.LBB1017:
 321:Src/usb_pd_protocol.c **** #endif
 9500              		.loc 1 321 2 view .LVU2585
 321:Src/usb_pd_protocol.c **** #endif
 9501              		.loc 1 321 9 is_stmt 0 view .LVU2586
 9502 0e80 3000     		movs	r0, r6
 9503 0e82 FFF7FEFF 		bl	pd_snk_is_vbus_provided
 9504              	.LVL723:
 321:Src/usb_pd_protocol.c **** #endif
 9505              		.loc 1 321 9 view .LVU2587
 9506              	.LBE1017:
 9507              	.LBE1016:
 9508              		.loc 1 2875 6 view .LVU2588
 9509 0e86 0028     		cmp	r0, #0
 9510 0e88 00D1     		bne	.LCB8886
 9511 0e8a EBE1     		b	.L354	@long jump
 9512              	.LCB8886:
 9513              		.loc 1 2875 32 discriminator 1 view .LVU2589
 9514 0e8c AB4B     		ldr	r3, .L589+4
 9515 0e8e 1B68     		ldr	r3, [r3]
 9516 0e90 002B     		cmp	r3, #0
 9517 0e92 00D1     		bne	.LCB8890
 9518 0e94 E6E1     		b	.L354	@long jump
 9519              	.LCB8890:
2876:Src/usb_pd_protocol.c **** 			snk_hard_reset_vbus_off) {
2877:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPM_TCPCI
2878:Src/usb_pd_protocol.c **** 			/*
2879:Src/usb_pd_protocol.c **** 				* After transmitting hard reset, TCPM writes
2880:Src/usb_pd_protocol.c **** 				* to RECEIVE_MESSAGE register to enable
2881:Src/usb_pd_protocol.c **** 				* PD message passing.
2882:Src/usb_pd_protocol.c **** 				*/
2883:Src/usb_pd_protocol.c **** 			if (pd_comm_is_enabled(port))
2884:Src/usb_pd_protocol.c **** 				tcpm_set_rx_enable(port, 1);
2885:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_TCPM_TCPCI */
2886:Src/usb_pd_protocol.c **** 
2887:Src/usb_pd_protocol.c **** 			/* VBUS went high again */
2888:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCOVERY);
 9520              		.loc 1 2888 4 is_stmt 1 view .LVU2590
 9521              	.LVL724:
 9522              	.LBB1018:
 9523              	.LBI1018:
 326:Src/usb_pd_protocol.c **** {
 9524              		.loc 1 326 20 view .LVU2591
 9525              	.LBB1019:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 9526              		.loc 1 328 2 view .LVU2592
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 9527              		.loc 1 333 2 view .LVU2593
 9528              	.LBB1020:
 9529              	.LBI1020:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9530              		.loc 1 261 20 view .LVU2594
 9531              	.LBB1021:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9532              		.loc 1 265 2 view .LVU2595
ARM GAS  /tmp/ccoQIC4J.s 			page 256


 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9533              		.loc 1 265 19 is_stmt 0 view .LVU2596
 9534 0e96 F201     		lsls	r2, r6, #7
 9535 0e98 A74B     		ldr	r3, .L589
 9536 0e9a 9B18     		adds	r3, r3, r2
 9537 0e9c 0020     		movs	r0, #0
 9538 0e9e 0021     		movs	r1, #0
 9539 0ea0 1861     		str	r0, [r3, #16]
 9540 0ea2 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9541              		.loc 1 266 2 is_stmt 1 view .LVU2597
 266:Src/usb_pd_protocol.c **** }
 9542              		.loc 1 266 25 is_stmt 0 view .LVU2598
 9543 0ea4 0022     		movs	r2, #0
 9544 0ea6 DA71     		strb	r2, [r3, #7]
 9545              	.LVL725:
 266:Src/usb_pd_protocol.c **** }
 9546              		.loc 1 266 25 view .LVU2599
 9547              	.LBE1021:
 9548              	.LBE1020:
 334:Src/usb_pd_protocol.c **** 
 9549              		.loc 1 334 2 is_stmt 1 view .LVU2600
 334:Src/usb_pd_protocol.c **** 
 9550              		.loc 1 334 22 is_stmt 0 view .LVU2601
 9551 0ea8 0532     		adds	r2, r2, #5
 9552 0eaa 1A71     		strb	r2, [r3, #4]
 9553              	.LVL726:
 336:Src/usb_pd_protocol.c **** 		return;
 9554              		.loc 1 336 2 is_stmt 1 view .LVU2602
 336:Src/usb_pd_protocol.c **** 		return;
 9555              		.loc 1 336 2 is_stmt 0 view .LVU2603
 9556              	.LBE1019:
 9557              	.LBE1018:
2889:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC_US;
 9558              		.loc 1 2889 4 is_stmt 1 view .LVU2604
 9559              		.loc 1 2889 12 is_stmt 0 view .LVU2605
 9560 0eac A44B     		ldr	r3, .L589+8
 9561 0eae A54A     		ldr	r2, .L589+12
 9562 0eb0 1A60     		str	r2, [r3]
 9563 0eb2 D7E1     		b	.L354
 9564              	.L553:
2855:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9565              		.loc 1 2855 4 is_stmt 1 view .LVU2606
2855:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9566              		.loc 1 2855 28 is_stmt 0 view .LVU2607
 9567 0eb4 A14B     		ldr	r3, .L589+4
 9568 0eb6 0022     		movs	r2, #0
 9569 0eb8 1A60     		str	r2, [r3]
2856:Src/usb_pd_protocol.c **** 						get_time().val +
 9570              		.loc 1 2856 4 is_stmt 1 view .LVU2608
2857:Src/usb_pd_protocol.c **** 						PD_T_SAFE_0V,
 9571              		.loc 1 2857 7 is_stmt 0 view .LVU2609
 9572 0eba 04A8     		add	r0, sp, #16
 9573 0ebc FFF7FEFF 		bl	get_time
 9574              	.LVL727:
2856:Src/usb_pd_protocol.c **** 						get_time().val +
 9575              		.loc 1 2856 4 view .LVU2610
ARM GAS  /tmp/ccoQIC4J.s 			page 257


 9576 0ec0 A148     		ldr	r0, .L589+16
 9577 0ec2 0021     		movs	r1, #0
 9578 0ec4 049B     		ldr	r3, [sp, #16]
 9579 0ec6 059C     		ldr	r4, [sp, #20]
 9580 0ec8 C018     		adds	r0, r0, r3
 9581 0eca 6141     		adcs	r1, r1, r4
2859:Src/usb_pd_protocol.c **** 						PD_HARD_RESET_COUNT ?
 9582              		.loc 1 2859 24 view .LVU2611
 9583 0ecc 9F4B     		ldr	r3, .L589+20
 9584 0ece 1B68     		ldr	r3, [r3]
2856:Src/usb_pd_protocol.c **** 						get_time().val +
 9585              		.loc 1 2856 4 view .LVU2612
 9586 0ed0 012B     		cmp	r3, #1
 9587 0ed2 07DD     		ble	.L555
 9588 0ed4 0524     		movs	r4, #5
 9589              	.L458:
 9590              	.LVL728:
 9591              	.LBB1022:
 9592              	.LBI1022:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9593              		.loc 1 261 20 is_stmt 1 discriminator 4 view .LVU2613
 9594              	.LBB1023:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9595              		.loc 1 265 2 discriminator 4 view .LVU2614
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9596              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU2615
 9597 0ed6 F201     		lsls	r2, r6, #7
 9598 0ed8 974B     		ldr	r3, .L589
 9599 0eda 9B18     		adds	r3, r3, r2
 9600 0edc 1861     		str	r0, [r3, #16]
 9601 0ede 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9602              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU2616
 266:Src/usb_pd_protocol.c **** }
 9603              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU2617
 9604 0ee0 DC71     		strb	r4, [r3, #7]
 9605 0ee2 C4E7     		b	.L457
 9606              	.LVL729:
 9607              	.L555:
 266:Src/usb_pd_protocol.c **** }
 9608              		.loc 1 266 25 discriminator 4 view .LVU2618
 9609              	.LBE1023:
 9610              	.LBE1022:
2856:Src/usb_pd_protocol.c **** 						get_time().val +
 9611              		.loc 1 2856 4 view .LVU2619
 9612 0ee4 1F24     		movs	r4, #31
 9613 0ee6 F6E7     		b	.L458
 9614              	.L554:
2868:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9615              		.loc 1 2868 4 is_stmt 1 view .LVU2620
2868:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9616              		.loc 1 2868 28 is_stmt 0 view .LVU2621
 9617 0ee8 944B     		ldr	r3, .L589+4
 9618 0eea 0122     		movs	r2, #1
 9619 0eec 1A60     		str	r2, [r3]
2869:Src/usb_pd_protocol.c **** 						get_time().val +
 9620              		.loc 1 2869 4 is_stmt 1 view .LVU2622
ARM GAS  /tmp/ccoQIC4J.s 			page 258


2870:Src/usb_pd_protocol.c **** 						PD_T_SRC_RECOVER_MAX +
 9621              		.loc 1 2870 7 is_stmt 0 view .LVU2623
 9622 0eee 04A8     		add	r0, sp, #16
 9623 0ef0 FFF7FEFF 		bl	get_time
 9624              	.LVL730:
2869:Src/usb_pd_protocol.c **** 						get_time().val +
 9625              		.loc 1 2869 4 view .LVU2624
 9626 0ef4 9648     		ldr	r0, .L589+24
 9627 0ef6 0021     		movs	r1, #0
 9628 0ef8 049B     		ldr	r3, [sp, #16]
 9629 0efa 059C     		ldr	r4, [sp, #20]
 9630 0efc C018     		adds	r0, r0, r3
 9631 0efe 6141     		adcs	r1, r1, r4
 9632              	.LVL731:
 9633              	.LBB1024:
 9634              	.LBI1024:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9635              		.loc 1 261 20 is_stmt 1 view .LVU2625
 9636              	.LBB1025:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9637              		.loc 1 265 2 view .LVU2626
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9638              		.loc 1 265 19 is_stmt 0 view .LVU2627
 9639 0f00 F201     		lsls	r2, r6, #7
 9640 0f02 8D4B     		ldr	r3, .L589
 9641 0f04 9B18     		adds	r3, r3, r2
 9642 0f06 1861     		str	r0, [r3, #16]
 9643 0f08 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9644              		.loc 1 266 2 is_stmt 1 view .LVU2628
 266:Src/usb_pd_protocol.c **** }
 9645              		.loc 1 266 25 is_stmt 0 view .LVU2629
 9646 0f0a 0222     		movs	r2, #2
 9647 0f0c DA71     		strb	r2, [r3, #7]
 9648 0f0e B7E7     		b	.L459
 9649              	.LVL732:
 9650              	.L383:
 266:Src/usb_pd_protocol.c **** }
 9651              		.loc 1 266 25 view .LVU2630
 9652              	.LBE1025:
 9653              	.LBE1024:
2890:Src/usb_pd_protocol.c **** 		}
2891:Src/usb_pd_protocol.c **** 
2892:Src/usb_pd_protocol.c **** 		/*
2893:Src/usb_pd_protocol.c **** 			* Don't need to set timeout because VBUS changing
2894:Src/usb_pd_protocol.c **** 			* will trigger an interrupt and wake us up.
2895:Src/usb_pd_protocol.c **** 			*/
2896:Src/usb_pd_protocol.c **** #endif
2897:Src/usb_pd_protocol.c **** 		break;
2898:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_DISCOVERY:
2899:Src/usb_pd_protocol.c **** 		/* Wait for source cap expired only if we are enabled */
2900:Src/usb_pd_protocol.c **** 		if ((pd[port].last_state != pd[port].task_state)
 9654              		.loc 1 2900 3 is_stmt 1 view .LVU2631
 9655              		.loc 1 2900 16 is_stmt 0 view .LVU2632
 9656 0f10 F101     		lsls	r1, r6, #7
 9657 0f12 894A     		ldr	r2, .L589
 9658 0f14 5218     		adds	r2, r2, r1
ARM GAS  /tmp/ccoQIC4J.s 			page 259


 9659 0f16 5279     		ldrb	r2, [r2, #5]
 9660              		.loc 1 2900 6 view .LVU2633
 9661 0f18 9342     		cmp	r3, r2
 9662 0f1a 19D0     		beq	.L460
2901:Src/usb_pd_protocol.c **** 			&& pd_comm_is_enabled(port)) {
 9663              		.loc 1 2901 7 view .LVU2634
 9664 0f1c 3000     		movs	r0, r6
 9665 0f1e FFF7FEFF 		bl	pd_comm_is_enabled
 9666              	.LVL733:
 9667              		.loc 1 2901 4 view .LVU2635
 9668 0f22 0028     		cmp	r0, #0
 9669 0f24 14D0     		beq	.L460
2902:Src/usb_pd_protocol.c **** 			/*
2903:Src/usb_pd_protocol.c **** 				* If VBUS has never been low, and we timeout
2904:Src/usb_pd_protocol.c **** 				* waiting for source cap, try a soft reset
2905:Src/usb_pd_protocol.c **** 				* first, in case we were already in a stable
2906:Src/usb_pd_protocol.c **** 				* contract before this boot.
2907:Src/usb_pd_protocol.c **** 				*/
2908:Src/usb_pd_protocol.c **** 			if (pd[port].flags & PD_FLAGS_VBUS_NEVER_LOW)
 9670              		.loc 1 2908 4 is_stmt 1 view .LVU2636
 9671              		.loc 1 2908 16 is_stmt 0 view .LVU2637
 9672 0f26 F201     		lsls	r2, r6, #7
 9673 0f28 834B     		ldr	r3, .L589
 9674 0f2a 9B18     		adds	r3, r3, r2
 9675 0f2c 9B68     		ldr	r3, [r3, #8]
 9676              		.loc 1 2908 7 view .LVU2638
 9677 0f2e 1A06     		lsls	r2, r3, #24
 9678 0f30 2FD4     		bmi	.L556
2909:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2910:Src/usb_pd_protocol.c **** 						get_time().val +
2911:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
2912:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET);
2913:Src/usb_pd_protocol.c **** 			/*
2914:Src/usb_pd_protocol.c **** 				* If we haven't passed hard reset counter,
2915:Src/usb_pd_protocol.c **** 				* start SinkWaitCapTimer, otherwise start
2916:Src/usb_pd_protocol.c **** 				* NoResponseTimer.
2917:Src/usb_pd_protocol.c **** 				*/
2918:Src/usb_pd_protocol.c **** 			else if (hard_reset_count < PD_HARD_RESET_COUNT)
 9679              		.loc 1 2918 9 is_stmt 1 view .LVU2639
 9680              		.loc 1 2918 30 is_stmt 0 view .LVU2640
 9681 0f32 864A     		ldr	r2, .L589+20
 9682 0f34 1268     		ldr	r2, [r2]
 9683              		.loc 1 2918 12 view .LVU2641
 9684 0f36 012A     		cmp	r2, #1
 9685 0f38 3CDD     		ble	.L557
2919:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2920:Src/usb_pd_protocol.c **** 						get_time().val +
2921:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
2922:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
2923:Src/usb_pd_protocol.c **** 			else if (pd[port].flags &
 9686              		.loc 1 2923 9 is_stmt 1 view .LVU2642
 9687              		.loc 1 2923 12 is_stmt 0 view .LVU2643
 9688 0f3a DB05     		lsls	r3, r3, #23
 9689 0f3c 4BD4     		bmi	.L558
 9690              	.L462:
2924:Src/usb_pd_protocol.c **** 					PD_FLAGS_PREVIOUS_PD_CONN)
2925:Src/usb_pd_protocol.c **** 				/* ErrorRecovery */
ARM GAS  /tmp/ccoQIC4J.s 			page 260


2926:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
2927:Src/usb_pd_protocol.c **** 						get_time().val +
2928:Src/usb_pd_protocol.c **** 						PD_T_NO_RESPONSE,
2929:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
2930:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
2931:Src/usb_pd_protocol.c **** 			/*
2932:Src/usb_pd_protocol.c **** 				* If we didn't come from disconnected, must
2933:Src/usb_pd_protocol.c **** 				* have come from some path that did not set
2934:Src/usb_pd_protocol.c **** 				* typec current limit. So, set to 0 so that
2935:Src/usb_pd_protocol.c **** 				* we guarantee this is revised below.
2936:Src/usb_pd_protocol.c **** 				*/
2937:Src/usb_pd_protocol.c **** 			if (pd[port].last_state !=
 9691              		.loc 1 2937 4 is_stmt 1 view .LVU2644
 9692              		.loc 1 2937 16 is_stmt 0 view .LVU2645
 9693 0f3e F201     		lsls	r2, r6, #7
 9694 0f40 7D4B     		ldr	r3, .L589
 9695 0f42 9B18     		adds	r3, r3, r2
 9696 0f44 5B79     		ldrb	r3, [r3, #5]
 9697              		.loc 1 2937 7 view .LVU2646
 9698 0f46 032B     		cmp	r3, #3
 9699 0f48 02D0     		beq	.L460
2938:Src/usb_pd_protocol.c **** 				PD_STATE_SNK_DISCONNECTED_DEBOUNCE)
2939:Src/usb_pd_protocol.c **** 				typec_curr = 0;
 9700              		.loc 1 2939 5 is_stmt 1 view .LVU2647
 9701              		.loc 1 2939 16 is_stmt 0 view .LVU2648
 9702 0f4a 824B     		ldr	r3, .L589+28
 9703 0f4c 0022     		movs	r2, #0
 9704 0f4e 1A60     		str	r2, [r3]
 9705              	.L460:
2940:Src/usb_pd_protocol.c **** #endif
2941:Src/usb_pd_protocol.c **** 		}
2942:Src/usb_pd_protocol.c **** 
2943:Src/usb_pd_protocol.c **** #if defined(CONFIG_CHARGE_MANAGER)
2944:Src/usb_pd_protocol.c **** 		timeout = PD_T_SINK_ADJ - PD_T_DEBOUNCE;
 9706              		.loc 1 2944 3 is_stmt 1 view .LVU2649
 9707              		.loc 1 2944 11 is_stmt 0 view .LVU2650
 9708 0f50 7B4B     		ldr	r3, .L589+8
 9709 0f52 814A     		ldr	r2, .L589+32
 9710 0f54 1A60     		str	r2, [r3]
2945:Src/usb_pd_protocol.c **** 
2946:Src/usb_pd_protocol.c **** 		/* Check if CC pull-up has changed */
2947:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
 9711              		.loc 1 2947 3 is_stmt 1 view .LVU2651
 9712              	.LVL734:
 9713              	.LBB1026:
 9714              	.LBI1026:
  58:Inc/tcpm.h    **** {
 9715              		.loc 2 58 19 view .LVU2652
 9716              	.LBB1027:
  60:Inc/tcpm.h    **** }
 9717              		.loc 2 60 2 view .LVU2653
  60:Inc/tcpm.h    **** }
 9718              		.loc 2 60 9 is_stmt 0 view .LVU2654
 9719 0f56 814D     		ldr	r5, .L589+36
 9720 0f58 814C     		ldr	r4, .L589+40
 9721 0f5a 2A00     		movs	r2, r5
 9722 0f5c 2100     		movs	r1, r4
ARM GAS  /tmp/ccoQIC4J.s 			page 261


 9723 0f5e 3000     		movs	r0, r6
 9724 0f60 BB68     		ldr	r3, [r7, #8]
 9725 0f62 9847     		blx	r3
 9726              	.LVL735:
  60:Inc/tcpm.h    **** }
 9727              		.loc 2 60 9 view .LVU2655
 9728              	.LBE1027:
 9729              	.LBE1026:
2948:Src/usb_pd_protocol.c **** 		if (typec_curr != get_typec_current_limit(
 9730              		.loc 1 2948 3 is_stmt 1 view .LVU2656
2949:Src/usb_pd_protocol.c **** 					pd[port].polarity, cc1, cc2)) {
 9731              		.loc 1 2949 14 is_stmt 0 view .LVU2657
 9732 0f64 F201     		lsls	r2, r6, #7
 9733 0f66 744B     		ldr	r3, .L589
 9734 0f68 9B18     		adds	r3, r3, r2
 9735 0f6a D878     		ldrb	r0, [r3, #3]
2948:Src/usb_pd_protocol.c **** 		if (typec_curr != get_typec_current_limit(
 9736              		.loc 1 2948 21 view .LVU2658
 9737 0f6c 2A68     		ldr	r2, [r5]
 9738 0f6e 2168     		ldr	r1, [r4]
 9739 0f70 FFF7FEFF 		bl	get_typec_current_limit
 9740              	.LVL736:
2948:Src/usb_pd_protocol.c **** 		if (typec_curr != get_typec_current_limit(
 9741              		.loc 1 2948 18 view .LVU2659
 9742 0f74 774B     		ldr	r3, .L589+28
 9743 0f76 1B68     		ldr	r3, [r3]
2948:Src/usb_pd_protocol.c **** 		if (typec_curr != get_typec_current_limit(
 9744              		.loc 1 2948 6 view .LVU2660
 9745 0f78 9842     		cmp	r0, r3
 9746 0f7a 41D0     		beq	.L464
2950:Src/usb_pd_protocol.c **** 			/* debounce signal by requiring two reads */
2951:Src/usb_pd_protocol.c **** 			if (typec_curr_change) {
 9747              		.loc 1 2951 4 is_stmt 1 view .LVU2661
 9748              		.loc 1 2951 8 is_stmt 0 view .LVU2662
 9749 0f7c 794B     		ldr	r3, .L589+44
 9750 0f7e 1B68     		ldr	r3, [r3]
 9751              		.loc 1 2951 7 view .LVU2663
 9752 0f80 002B     		cmp	r3, #0
 9753 0f82 39D0     		beq	.L465
2952:Src/usb_pd_protocol.c **** 				/* set new input current limit */
2953:Src/usb_pd_protocol.c **** 				typec_curr = get_typec_current_limit(
 9754              		.loc 1 2953 5 is_stmt 1 view .LVU2664
 9755              		.loc 1 2953 16 is_stmt 0 view .LVU2665
 9756 0f84 734A     		ldr	r2, .L589+28
 9757 0f86 1060     		str	r0, [r2]
 9758              	.L466:
2954:Src/usb_pd_protocol.c **** 					pd[port].polarity, cc1, cc2);
2955:Src/usb_pd_protocol.c **** 				//typec_set_input_current_limit(
2956:Src/usb_pd_protocol.c **** 				//	port, typec_curr, TYPE_C_VOLTAGE);
2957:Src/usb_pd_protocol.c **** 			} else {
2958:Src/usb_pd_protocol.c **** 				/* delay for debounce */
2959:Src/usb_pd_protocol.c **** 				timeout = PD_T_DEBOUNCE;
2960:Src/usb_pd_protocol.c **** 			}
2961:Src/usb_pd_protocol.c **** 			typec_curr_change = !typec_curr_change;
 9759              		.loc 1 2961 4 is_stmt 1 view .LVU2666
 9760              		.loc 1 2961 24 is_stmt 0 view .LVU2667
 9761 0f88 5A42     		rsbs	r2, r3, #0
ARM GAS  /tmp/ccoQIC4J.s 			page 262


 9762 0f8a 5341     		adcs	r3, r3, r2
 9763              		.loc 1 2961 22 view .LVU2668
 9764 0f8c 754A     		ldr	r2, .L589+44
 9765 0f8e 1360     		str	r3, [r2]
 9766 0f90 68E1     		b	.L354
 9767              	.L556:
2909:Src/usb_pd_protocol.c **** 						get_time().val +
 9768              		.loc 1 2909 5 is_stmt 1 view .LVU2669
2910:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
 9769              		.loc 1 2910 7 is_stmt 0 view .LVU2670
 9770 0f92 04A8     		add	r0, sp, #16
 9771 0f94 FFF7FEFF 		bl	get_time
 9772              	.LVL737:
2909:Src/usb_pd_protocol.c **** 						get_time().val +
 9773              		.loc 1 2909 5 view .LVU2671
 9774 0f98 7348     		ldr	r0, .L589+48
 9775 0f9a 0021     		movs	r1, #0
 9776 0f9c 049B     		ldr	r3, [sp, #16]
 9777 0f9e 059C     		ldr	r4, [sp, #20]
 9778 0fa0 C018     		adds	r0, r0, r3
 9779 0fa2 6141     		adcs	r1, r1, r4
 9780              	.LVL738:
 9781              	.LBB1028:
 9782              	.LBI1028:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9783              		.loc 1 261 20 is_stmt 1 view .LVU2672
 9784              	.LBB1029:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9785              		.loc 1 265 2 view .LVU2673
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9786              		.loc 1 265 19 is_stmt 0 view .LVU2674
 9787 0fa4 F201     		lsls	r2, r6, #7
 9788 0fa6 644B     		ldr	r3, .L589
 9789 0fa8 9B18     		adds	r3, r3, r2
 9790 0faa 1861     		str	r0, [r3, #16]
 9791 0fac 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9792              		.loc 1 266 2 is_stmt 1 view .LVU2675
 266:Src/usb_pd_protocol.c **** }
 9793              		.loc 1 266 25 is_stmt 0 view .LVU2676
 9794 0fae 1E22     		movs	r2, #30
 9795 0fb0 DA71     		strb	r2, [r3, #7]
 9796 0fb2 C4E7     		b	.L462
 9797              	.LVL739:
 9798              	.L557:
 266:Src/usb_pd_protocol.c **** }
 9799              		.loc 1 266 25 view .LVU2677
 9800              	.LBE1029:
 9801              	.LBE1028:
2919:Src/usb_pd_protocol.c **** 						get_time().val +
 9802              		.loc 1 2919 5 is_stmt 1 view .LVU2678
2920:Src/usb_pd_protocol.c **** 						PD_T_SINK_WAIT_CAP,
 9803              		.loc 1 2920 7 is_stmt 0 view .LVU2679
 9804 0fb4 04A8     		add	r0, sp, #16
 9805 0fb6 FFF7FEFF 		bl	get_time
 9806              	.LVL740:
2919:Src/usb_pd_protocol.c **** 						get_time().val +
ARM GAS  /tmp/ccoQIC4J.s 			page 263


 9807              		.loc 1 2919 5 view .LVU2680
 9808 0fba 6B48     		ldr	r0, .L589+48
 9809 0fbc 0021     		movs	r1, #0
 9810 0fbe 049B     		ldr	r3, [sp, #16]
 9811 0fc0 059C     		ldr	r4, [sp, #20]
 9812 0fc2 C018     		adds	r0, r0, r3
 9813 0fc4 6141     		adcs	r1, r1, r4
 9814              	.LVL741:
 9815              	.LBB1030:
 9816              	.LBI1030:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9817              		.loc 1 261 20 is_stmt 1 view .LVU2681
 9818              	.LBB1031:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9819              		.loc 1 265 2 view .LVU2682
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9820              		.loc 1 265 19 is_stmt 0 view .LVU2683
 9821 0fc6 F201     		lsls	r2, r6, #7
 9822 0fc8 5B4B     		ldr	r3, .L589
 9823 0fca 9B18     		adds	r3, r3, r2
 9824 0fcc 1861     		str	r0, [r3, #16]
 9825 0fce 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9826              		.loc 1 266 2 is_stmt 1 view .LVU2684
 266:Src/usb_pd_protocol.c **** }
 9827              		.loc 1 266 25 is_stmt 0 view .LVU2685
 9828 0fd0 1F22     		movs	r2, #31
 9829 0fd2 DA71     		strb	r2, [r3, #7]
 9830 0fd4 B3E7     		b	.L462
 9831              	.LVL742:
 9832              	.L558:
 266:Src/usb_pd_protocol.c **** }
 9833              		.loc 1 266 25 view .LVU2686
 9834              	.LBE1031:
 9835              	.LBE1030:
2926:Src/usb_pd_protocol.c **** 						get_time().val +
 9836              		.loc 1 2926 5 is_stmt 1 view .LVU2687
2927:Src/usb_pd_protocol.c **** 						PD_T_NO_RESPONSE,
 9837              		.loc 1 2927 7 is_stmt 0 view .LVU2688
 9838 0fd6 04A8     		add	r0, sp, #16
 9839 0fd8 FFF7FEFF 		bl	get_time
 9840              	.LVL743:
2926:Src/usb_pd_protocol.c **** 						get_time().val +
 9841              		.loc 1 2926 5 view .LVU2689
 9842 0fdc 6348     		ldr	r0, .L589+52
 9843 0fde 0021     		movs	r1, #0
 9844 0fe0 049B     		ldr	r3, [sp, #16]
 9845 0fe2 059C     		ldr	r4, [sp, #20]
 9846 0fe4 C018     		adds	r0, r0, r3
 9847 0fe6 6141     		adcs	r1, r1, r4
 9848              	.LVL744:
 9849              	.LBB1032:
 9850              	.LBI1032:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9851              		.loc 1 261 20 is_stmt 1 view .LVU2690
 9852              	.LBB1033:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
ARM GAS  /tmp/ccoQIC4J.s 			page 264


 9853              		.loc 1 265 2 view .LVU2691
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9854              		.loc 1 265 19 is_stmt 0 view .LVU2692
 9855 0fe8 F201     		lsls	r2, r6, #7
 9856 0fea 534B     		ldr	r3, .L589
 9857 0fec 9B18     		adds	r3, r3, r2
 9858 0fee 1861     		str	r0, [r3, #16]
 9859 0ff0 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9860              		.loc 1 266 2 is_stmt 1 view .LVU2693
 266:Src/usb_pd_protocol.c **** }
 9861              		.loc 1 266 25 is_stmt 0 view .LVU2694
 9862 0ff2 0222     		movs	r2, #2
 9863 0ff4 DA71     		strb	r2, [r3, #7]
 9864 0ff6 A2E7     		b	.L462
 9865              	.LVL745:
 9866              	.L465:
 266:Src/usb_pd_protocol.c **** }
 9867              		.loc 1 266 25 view .LVU2695
 9868              	.LBE1033:
 9869              	.LBE1032:
2959:Src/usb_pd_protocol.c **** 			}
 9870              		.loc 1 2959 5 is_stmt 1 view .LVU2696
2959:Src/usb_pd_protocol.c **** 			}
 9871              		.loc 1 2959 13 is_stmt 0 view .LVU2697
 9872 0ff8 514A     		ldr	r2, .L589+8
 9873 0ffa 5D49     		ldr	r1, .L589+56
 9874 0ffc 1160     		str	r1, [r2]
 9875 0ffe C3E7     		b	.L466
 9876              	.L464:
2962:Src/usb_pd_protocol.c **** 		} else {
2963:Src/usb_pd_protocol.c **** 			typec_curr_change = 0;
 9877              		.loc 1 2963 4 is_stmt 1 view .LVU2698
 9878              		.loc 1 2963 22 is_stmt 0 view .LVU2699
 9879 1000 584B     		ldr	r3, .L589+44
 9880 1002 0022     		movs	r2, #0
 9881 1004 1A60     		str	r2, [r3]
 9882 1006 2DE1     		b	.L354
 9883              	.L382:
2964:Src/usb_pd_protocol.c **** 		}
2965:Src/usb_pd_protocol.c **** #endif
2966:Src/usb_pd_protocol.c **** 		break;
2967:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_REQUESTED:
2968:Src/usb_pd_protocol.c **** 		/* Wait for ACCEPT or REJECT */
2969:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 9884              		.loc 1 2969 3 is_stmt 1 view .LVU2700
 9885              		.loc 1 2969 15 is_stmt 0 view .LVU2701
 9886 1008 F101     		lsls	r1, r6, #7
 9887 100a 4B4A     		ldr	r2, .L589
 9888 100c 5218     		adds	r2, r2, r1
 9889 100e 5279     		ldrb	r2, [r2, #5]
 9890              		.loc 1 2969 6 view .LVU2702
 9891 1010 9342     		cmp	r3, r2
 9892 1012 00D1     		bne	.LCB9244
 9893 1014 26E1     		b	.L354	@long jump
 9894              	.LCB9244:
2970:Src/usb_pd_protocol.c **** 			hard_reset_count = 0;
ARM GAS  /tmp/ccoQIC4J.s 			page 265


 9895              		.loc 1 2970 4 is_stmt 1 view .LVU2703
 9896              		.loc 1 2970 21 is_stmt 0 view .LVU2704
 9897 1016 4D4B     		ldr	r3, .L589+20
 9898 1018 0022     		movs	r2, #0
 9899 101a 1A60     		str	r2, [r3]
2971:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9900              		.loc 1 2971 4 is_stmt 1 view .LVU2705
2972:Src/usb_pd_protocol.c **** 						get_time().val +
 9901              		.loc 1 2972 7 is_stmt 0 view .LVU2706
 9902 101c 04A8     		add	r0, sp, #16
 9903 101e FFF7FEFF 		bl	get_time
 9904              	.LVL746:
2971:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9905              		.loc 1 2971 4 view .LVU2707
 9906 1022 5448     		ldr	r0, .L589+60
 9907 1024 0021     		movs	r1, #0
 9908 1026 049B     		ldr	r3, [sp, #16]
 9909 1028 059C     		ldr	r4, [sp, #20]
 9910 102a C018     		adds	r0, r0, r3
 9911 102c 6141     		adcs	r1, r1, r4
 9912              	.LVL747:
 9913              	.LBB1034:
 9914              	.LBI1034:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9915              		.loc 1 261 20 is_stmt 1 view .LVU2708
 9916              	.LBB1035:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9917              		.loc 1 265 2 view .LVU2709
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9918              		.loc 1 265 19 is_stmt 0 view .LVU2710
 9919 102e F201     		lsls	r2, r6, #7
 9920 1030 414B     		ldr	r3, .L589
 9921 1032 9B18     		adds	r3, r3, r2
 9922 1034 1861     		str	r0, [r3, #16]
 9923 1036 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9924              		.loc 1 266 2 is_stmt 1 view .LVU2711
 266:Src/usb_pd_protocol.c **** }
 9925              		.loc 1 266 25 is_stmt 0 view .LVU2712
 9926 1038 1F22     		movs	r2, #31
 9927 103a DA71     		strb	r2, [r3, #7]
 9928 103c 12E1     		b	.L354
 9929              	.LVL748:
 9930              	.L381:
 266:Src/usb_pd_protocol.c **** }
 9931              		.loc 1 266 25 view .LVU2713
 9932              	.LBE1035:
 9933              	.LBE1034:
2973:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
2974:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
2975:Src/usb_pd_protocol.c **** 		}
2976:Src/usb_pd_protocol.c **** 		break;
2977:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_TRANSITION:
2978:Src/usb_pd_protocol.c **** 		/* Wait for PS_RDY */
2979:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 9934              		.loc 1 2979 3 is_stmt 1 view .LVU2714
 9935              		.loc 1 2979 15 is_stmt 0 view .LVU2715
ARM GAS  /tmp/ccoQIC4J.s 			page 266


 9936 103e F101     		lsls	r1, r6, #7
 9937 1040 3D4A     		ldr	r2, .L589
 9938 1042 5218     		adds	r2, r2, r1
 9939 1044 5279     		ldrb	r2, [r2, #5]
 9940              		.loc 1 2979 6 view .LVU2716
 9941 1046 9342     		cmp	r3, r2
 9942 1048 00D1     		bne	.LCB9287
 9943 104a 0BE1     		b	.L354	@long jump
 9944              	.LCB9287:
2980:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9945              		.loc 1 2980 4 is_stmt 1 view .LVU2717
2981:Src/usb_pd_protocol.c **** 						get_time().val +
 9946              		.loc 1 2981 7 is_stmt 0 view .LVU2718
 9947 104c 04A8     		add	r0, sp, #16
 9948 104e FFF7FEFF 		bl	get_time
 9949              	.LVL749:
2980:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 9950              		.loc 1 2980 4 view .LVU2719
 9951 1052 4948     		ldr	r0, .L589+64
 9952 1054 0021     		movs	r1, #0
 9953 1056 049B     		ldr	r3, [sp, #16]
 9954 1058 059C     		ldr	r4, [sp, #20]
 9955 105a C018     		adds	r0, r0, r3
 9956 105c 6141     		adcs	r1, r1, r4
 9957              	.LVL750:
 9958              	.LBB1036:
 9959              	.LBI1036:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 9960              		.loc 1 261 20 is_stmt 1 view .LVU2720
 9961              	.LBB1037:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9962              		.loc 1 265 2 view .LVU2721
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 9963              		.loc 1 265 19 is_stmt 0 view .LVU2722
 9964 105e F201     		lsls	r2, r6, #7
 9965 1060 354B     		ldr	r3, .L589
 9966 1062 9B18     		adds	r3, r3, r2
 9967 1064 1861     		str	r0, [r3, #16]
 9968 1066 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 9969              		.loc 1 266 2 is_stmt 1 view .LVU2723
 266:Src/usb_pd_protocol.c **** }
 9970              		.loc 1 266 25 is_stmt 0 view .LVU2724
 9971 1068 1F22     		movs	r2, #31
 9972 106a DA71     		strb	r2, [r3, #7]
 9973 106c FAE0     		b	.L354
 9974              	.LVL751:
 9975              	.L380:
 266:Src/usb_pd_protocol.c **** }
 9976              		.loc 1 266 25 view .LVU2725
 9977              	.LBE1037:
 9978              	.LBE1036:
2982:Src/usb_pd_protocol.c **** 						PD_T_PS_TRANSITION,
2983:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
2984:Src/usb_pd_protocol.c **** 		break;
2985:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_READY:
2986:Src/usb_pd_protocol.c **** 		timeout = 20*MSEC_US;
ARM GAS  /tmp/ccoQIC4J.s 			page 267


 9979              		.loc 1 2986 3 is_stmt 1 view .LVU2726
 9980              		.loc 1 2986 11 is_stmt 0 view .LVU2727
 9981 106e 344B     		ldr	r3, .L589+8
 9982 1070 424A     		ldr	r2, .L589+68
 9983 1072 1A60     		str	r2, [r3]
2987:Src/usb_pd_protocol.c **** 
2988:Src/usb_pd_protocol.c **** 		/*
2989:Src/usb_pd_protocol.c **** 			* Don't send any PD traffic if we woke up due to
2990:Src/usb_pd_protocol.c **** 			* incoming packet or if VDO response pending to avoid
2991:Src/usb_pd_protocol.c **** 			* collisions.
2992:Src/usb_pd_protocol.c **** 			*/
2993:Src/usb_pd_protocol.c **** 		if (incoming_packet ||
 9984              		.loc 1 2993 3 is_stmt 1 view .LVU2728
 9985              		.loc 1 2993 7 is_stmt 0 view .LVU2729
 9986 1074 424B     		ldr	r3, .L589+72
 9987 1076 1B68     		ldr	r3, [r3]
 9988              		.loc 1 2993 6 view .LVU2730
 9989 1078 002B     		cmp	r3, #0
 9990 107a 00D0     		beq	.LCB9328
 9991 107c F2E0     		b	.L354	@long jump
 9992              	.LCB9328:
2994:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 9993              		.loc 1 2994 13 discriminator 1 view .LVU2731
 9994 107e F201     		lsls	r2, r6, #7
 9995 1080 2D4B     		ldr	r3, .L589
 9996 1082 9B18     		adds	r3, r3, r2
 9997 1084 4833     		adds	r3, r3, #72
 9998 1086 1B78     		ldrb	r3, [r3]
 9999 1088 5BB2     		sxtb	r3, r3
2993:Src/usb_pd_protocol.c **** 			(pd[port].vdm_state == VDM_STATE_BUSY))
 10000              		.loc 1 2993 23 discriminator 1 view .LVU2732
 10001 108a 022B     		cmp	r3, #2
 10002 108c 00D1     		bne	.LCB9336
 10003 108e E9E0     		b	.L354	@long jump
 10004              	.LCB9336:
2995:Src/usb_pd_protocol.c **** 			break;
2996:Src/usb_pd_protocol.c **** 
2997:Src/usb_pd_protocol.c **** 		/* Check for new power to request */
2998:Src/usb_pd_protocol.c **** 		if (pd[port].new_power_request) {
 10005              		.loc 1 2998 3 is_stmt 1 view .LVU2733
 10006              		.loc 1 2998 15 is_stmt 0 view .LVU2734
 10007 1090 294B     		ldr	r3, .L589
 10008 1092 9B18     		adds	r3, r3, r2
 10009 1094 9B6B     		ldr	r3, [r3, #56]
 10010              		.loc 1 2998 6 view .LVU2735
 10011 1096 002B     		cmp	r3, #0
 10012 1098 11D1     		bne	.L559
2999:Src/usb_pd_protocol.c **** 			if (pd_send_request_msg(port, 0) != EC_SUCCESS)
3000:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SOFT_RESET);
3001:Src/usb_pd_protocol.c **** 			break;
3002:Src/usb_pd_protocol.c **** 		}
3003:Src/usb_pd_protocol.c **** 
3004:Src/usb_pd_protocol.c **** 		/* Check power role policy, which may trigger a swap */
3005:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_PR_ROLE) {
 10013              		.loc 1 3005 3 is_stmt 1 view .LVU2736
 10014              		.loc 1 3005 15 is_stmt 0 view .LVU2737
 10015 109a F201     		lsls	r2, r6, #7
ARM GAS  /tmp/ccoQIC4J.s 			page 268


 10016 109c 264B     		ldr	r3, .L589
 10017 109e 9B18     		adds	r3, r3, r2
 10018 10a0 9A68     		ldr	r2, [r3, #8]
 10019              		.loc 1 3005 6 view .LVU2738
 10020 10a2 9305     		lsls	r3, r2, #22
 10021 10a4 1ED4     		bmi	.L560
3006:Src/usb_pd_protocol.c **** 			pd_check_pr_role(port, PD_ROLE_SINK,
3007:Src/usb_pd_protocol.c **** 						pd[port].flags);
3008:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_PR_ROLE;
3009:Src/usb_pd_protocol.c **** 			break;
3010:Src/usb_pd_protocol.c **** 		}
3011:Src/usb_pd_protocol.c **** 
3012:Src/usb_pd_protocol.c **** 		/* Check data role policy, which may trigger a swap */
3013:Src/usb_pd_protocol.c **** 		if (pd[port].flags & PD_FLAGS_CHECK_DR_ROLE) {
 10022              		.loc 1 3013 3 is_stmt 1 view .LVU2739
 10023              		.loc 1 3013 6 is_stmt 0 view .LVU2740
 10024 10a6 5305     		lsls	r3, r2, #21
 10025 10a8 28D4     		bmi	.L561
3014:Src/usb_pd_protocol.c **** 			pd_check_dr_role(port, pd[port].data_role,
3015:Src/usb_pd_protocol.c **** 						pd[port].flags);
3016:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_DR_ROLE;
3017:Src/usb_pd_protocol.c **** 			break;
3018:Src/usb_pd_protocol.c **** 		}
3019:Src/usb_pd_protocol.c **** 
3020:Src/usb_pd_protocol.c **** 		/* If DFP, send discovery SVDMs */
3021:Src/usb_pd_protocol.c **** 		if (pd[port].data_role == PD_ROLE_DFP &&
 10026              		.loc 1 3021 3 is_stmt 1 view .LVU2741
 10027              		.loc 1 3021 15 is_stmt 0 view .LVU2742
 10028 10aa F101     		lsls	r1, r6, #7
 10029 10ac 224B     		ldr	r3, .L589
 10030 10ae 5B18     		adds	r3, r3, r1
 10031 10b0 5B78     		ldrb	r3, [r3, #1]
 10032              		.loc 1 3021 6 view .LVU2743
 10033 10b2 012B     		cmp	r3, #1
 10034 10b4 2ED0     		beq	.L562
 10035              	.L470:
3022:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
3023:Src/usb_pd_protocol.c **** 			pd_send_vdm(port, USB_SID_PD,
3024:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
3025:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_CHECK_IDENTITY;
3026:Src/usb_pd_protocol.c **** 			break;
3027:Src/usb_pd_protocol.c **** 		}
3028:Src/usb_pd_protocol.c **** 
3029:Src/usb_pd_protocol.c **** 		/* Sent all messages, don't need to wake very often */
3030:Src/usb_pd_protocol.c **** 		timeout = 200*MSEC_US;
 10036              		.loc 1 3030 3 is_stmt 1 view .LVU2744
 10037              		.loc 1 3030 11 is_stmt 0 view .LVU2745
 10038 10b6 224B     		ldr	r3, .L589+8
 10039 10b8 324A     		ldr	r2, .L589+76
 10040 10ba 1A60     		str	r2, [r3]
3031:Src/usb_pd_protocol.c **** 		break;
 10041              		.loc 1 3031 3 is_stmt 1 view .LVU2746
 10042 10bc D2E0     		b	.L354
 10043              	.L559:
2999:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SOFT_RESET);
 10044              		.loc 1 2999 4 view .LVU2747
2999:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SOFT_RESET);
ARM GAS  /tmp/ccoQIC4J.s 			page 269


 10045              		.loc 1 2999 8 is_stmt 0 view .LVU2748
 10046 10be 0021     		movs	r1, #0
 10047 10c0 3000     		movs	r0, r6
 10048 10c2 FFF7FEFF 		bl	pd_send_request_msg
 10049              	.LVL752:
2999:Src/usb_pd_protocol.c **** 				set_state(port, PD_STATE_SOFT_RESET);
 10050              		.loc 1 2999 7 view .LVU2749
 10051 10c6 0028     		cmp	r0, #0
 10052 10c8 00D1     		bne	.LCB9379
 10053 10ca CBE0     		b	.L354	@long jump
 10054              	.LCB9379:
3000:Src/usb_pd_protocol.c **** 			break;
 10055              		.loc 1 3000 5 is_stmt 1 view .LVU2750
 10056              	.LVL753:
 10057              	.LBB1038:
 10058              	.LBI1038:
 326:Src/usb_pd_protocol.c **** {
 10059              		.loc 1 326 20 view .LVU2751
 10060              	.LBB1039:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10061              		.loc 1 328 2 view .LVU2752
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 10062              		.loc 1 333 2 view .LVU2753
 10063              	.LBB1040:
 10064              	.LBI1040:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10065              		.loc 1 261 20 view .LVU2754
 10066              	.LBB1041:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10067              		.loc 1 265 2 view .LVU2755
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10068              		.loc 1 265 19 is_stmt 0 view .LVU2756
 10069 10cc F201     		lsls	r2, r6, #7
 10070 10ce 1A4B     		ldr	r3, .L589
 10071 10d0 9B18     		adds	r3, r3, r2
 10072 10d2 0020     		movs	r0, #0
 10073 10d4 0021     		movs	r1, #0
 10074 10d6 1861     		str	r0, [r3, #16]
 10075 10d8 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10076              		.loc 1 266 2 is_stmt 1 view .LVU2757
 266:Src/usb_pd_protocol.c **** }
 10077              		.loc 1 266 25 is_stmt 0 view .LVU2758
 10078 10da 0022     		movs	r2, #0
 10079 10dc DA71     		strb	r2, [r3, #7]
 10080              	.LVL754:
 266:Src/usb_pd_protocol.c **** }
 10081              		.loc 1 266 25 view .LVU2759
 10082              	.LBE1041:
 10083              	.LBE1040:
 334:Src/usb_pd_protocol.c **** 
 10084              		.loc 1 334 2 is_stmt 1 view .LVU2760
 334:Src/usb_pd_protocol.c **** 
 10085              		.loc 1 334 22 is_stmt 0 view .LVU2761
 10086 10de 1E32     		adds	r2, r2, #30
 10087 10e0 1A71     		strb	r2, [r3, #4]
 10088              	.LVL755:
ARM GAS  /tmp/ccoQIC4J.s 			page 270


 336:Src/usb_pd_protocol.c **** 		return;
 10089              		.loc 1 336 2 is_stmt 1 view .LVU2762
 10090 10e2 BFE0     		b	.L354
 10091              	.LVL756:
 10092              	.L560:
 336:Src/usb_pd_protocol.c **** 		return;
 10093              		.loc 1 336 2 is_stmt 0 view .LVU2763
 10094              	.LBE1039:
 10095              	.LBE1038:
3006:Src/usb_pd_protocol.c **** 						pd[port].flags);
 10096              		.loc 1 3006 4 is_stmt 1 view .LVU2764
 10097 10e4 0021     		movs	r1, #0
 10098 10e6 3000     		movs	r0, r6
 10099 10e8 FFF7FEFF 		bl	pd_check_pr_role
 10100              	.LVL757:
3008:Src/usb_pd_protocol.c **** 			break;
 10101              		.loc 1 3008 4 view .LVU2765
3008:Src/usb_pd_protocol.c **** 			break;
 10102              		.loc 1 3008 19 is_stmt 0 view .LVU2766
 10103 10ec F201     		lsls	r2, r6, #7
 10104 10ee 124B     		ldr	r3, .L589
 10105 10f0 9B18     		adds	r3, r3, r2
 10106 10f2 254A     		ldr	r2, .L589+80
 10107 10f4 9968     		ldr	r1, [r3, #8]
 10108 10f6 0A40     		ands	r2, r1
 10109 10f8 9A60     		str	r2, [r3, #8]
3009:Src/usb_pd_protocol.c **** 		}
 10110              		.loc 1 3009 4 is_stmt 1 view .LVU2767
 10111 10fa B3E0     		b	.L354
 10112              	.L561:
3014:Src/usb_pd_protocol.c **** 						pd[port].flags);
 10113              		.loc 1 3014 4 view .LVU2768
3014:Src/usb_pd_protocol.c **** 						pd[port].flags);
 10114              		.loc 1 3014 35 is_stmt 0 view .LVU2769
 10115 10fc F301     		lsls	r3, r6, #7
 10116 10fe 0E4C     		ldr	r4, .L589
 10117 1100 E418     		adds	r4, r4, r3
 10118 1102 6178     		ldrb	r1, [r4, #1]
3014:Src/usb_pd_protocol.c **** 						pd[port].flags);
 10119              		.loc 1 3014 4 view .LVU2770
 10120 1104 3000     		movs	r0, r6
 10121 1106 FFF7FEFF 		bl	pd_check_dr_role
 10122              	.LVL758:
3016:Src/usb_pd_protocol.c **** 			break;
 10123              		.loc 1 3016 4 is_stmt 1 view .LVU2771
3016:Src/usb_pd_protocol.c **** 			break;
 10124              		.loc 1 3016 19 is_stmt 0 view .LVU2772
 10125 110a 204B     		ldr	r3, .L589+84
 10126 110c A268     		ldr	r2, [r4, #8]
 10127 110e 1340     		ands	r3, r2
 10128 1110 A360     		str	r3, [r4, #8]
3017:Src/usb_pd_protocol.c **** 		}
 10129              		.loc 1 3017 4 is_stmt 1 view .LVU2773
 10130 1112 A7E0     		b	.L354
 10131              	.L562:
3021:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_CHECK_IDENTITY)) {
 10132              		.loc 1 3021 41 is_stmt 0 discriminator 1 view .LVU2774
ARM GAS  /tmp/ccoQIC4J.s 			page 271


 10133 1114 1307     		lsls	r3, r2, #28
 10134 1116 CED5     		bpl	.L470
3023:Src/usb_pd_protocol.c **** 					CMD_DISCOVER_IDENT, NULL, 0);
 10135              		.loc 1 3023 4 is_stmt 1 view .LVU2775
 10136 1118 FF21     		movs	r1, #255
 10137 111a 0023     		movs	r3, #0
 10138 111c 0093     		str	r3, [sp]
 10139 111e 0122     		movs	r2, #1
 10140 1120 0902     		lsls	r1, r1, #8
 10141 1122 3000     		movs	r0, r6
 10142 1124 FFF7FEFF 		bl	pd_send_vdm
 10143              	.LVL759:
3025:Src/usb_pd_protocol.c **** 			break;
 10144              		.loc 1 3025 4 view .LVU2776
3025:Src/usb_pd_protocol.c **** 			break;
 10145              		.loc 1 3025 19 is_stmt 0 view .LVU2777
 10146 1128 F201     		lsls	r2, r6, #7
 10147 112a 034B     		ldr	r3, .L589
 10148 112c 9B18     		adds	r3, r3, r2
 10149 112e 0822     		movs	r2, #8
 10150 1130 9968     		ldr	r1, [r3, #8]
 10151 1132 9143     		bics	r1, r2
 10152 1134 9960     		str	r1, [r3, #8]
3026:Src/usb_pd_protocol.c **** 		}
 10153              		.loc 1 3026 4 is_stmt 1 view .LVU2778
 10154 1136 95E0     		b	.L354
 10155              	.L590:
 10156              		.align	2
 10157              	.L589:
 10158 1138 00000000 		.word	pd
 10159 113c 00000000 		.word	.LANCHOR14
 10160 1140 00000000 		.word	.LANCHOR5
 10161 1144 10270000 		.word	10000
 10162 1148 10EB0900 		.word	650000
 10163 114c 00000000 		.word	.LANCHOR10
 10164 1150 78741300 		.word	1275000
 10165 1154 00000000 		.word	.LANCHOR13
 10166 1158 409C0000 		.word	40000
 10167 115c 00000000 		.word	.LANCHOR6
 10168 1160 00000000 		.word	.LANCHOR7
 10169 1164 00000000 		.word	.LANCHOR15
 10170 1168 C0270900 		.word	600000
 10171 116c 60EC5300 		.word	5500000
 10172 1170 983A0000 		.word	15000
 10173 1174 A0860100 		.word	100000
 10174 1178 20A10700 		.word	500000
 10175 117c 204E0000 		.word	20000
 10176 1180 00000000 		.word	.LANCHOR2
 10177 1184 400D0300 		.word	200000
 10178 1188 FFFDFFFF 		.word	-513
 10179 118c FFFBFFFF 		.word	-1025
 10180              	.L379:
3032:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_INIT:
3033:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
 10181              		.loc 1 3033 3 view .LVU2779
 10182              		.loc 1 3033 15 is_stmt 0 view .LVU2780
 10183 1190 F101     		lsls	r1, r6, #7
ARM GAS  /tmp/ccoQIC4J.s 			page 272


 10184 1192 C84A     		ldr	r2, .L591
 10185 1194 5218     		adds	r2, r2, r1
 10186 1196 5279     		ldrb	r2, [r2, #5]
 10187              		.loc 1 3033 6 view .LVU2781
 10188 1198 9342     		cmp	r3, r2
 10189 119a 63D0     		beq	.L354
3034:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_PR_SWAP);
 10190              		.loc 1 3034 4 is_stmt 1 view .LVU2782
 10191              		.loc 1 3034 10 is_stmt 0 view .LVU2783
 10192 119c 0A21     		movs	r1, #10
 10193 119e 3000     		movs	r0, r6
 10194 11a0 FFF7FEFF 		bl	send_control
 10195              	.LVL760:
3035:Src/usb_pd_protocol.c **** 			if (res < 0) {
 10196              		.loc 1 3035 4 is_stmt 1 view .LVU2784
 10197              		.loc 1 3035 7 is_stmt 0 view .LVU2785
 10198 11a4 0028     		cmp	r0, #0
 10199 11a6 39DA     		bge	.L471
3036:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
 10200              		.loc 1 3036 5 is_stmt 1 view .LVU2786
 10201              		.loc 1 3036 13 is_stmt 0 view .LVU2787
 10202 11a8 C34B     		ldr	r3, .L591+4
 10203 11aa C44A     		ldr	r2, .L591+8
 10204 11ac 1A60     		str	r2, [r3]
3037:Src/usb_pd_protocol.c **** 				/*
3038:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
3039:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
3040:Src/usb_pd_protocol.c **** 					* failure.
3041:Src/usb_pd_protocol.c **** 					*/
3042:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
 10205              		.loc 1 3042 5 is_stmt 1 view .LVU2788
 10206 11ae 431C     		adds	r3, r0, #1
 10207 11b0 28D0     		beq	.L563
 10208 11b2 0822     		movs	r2, #8
 10209              	.L472:
 10210              	.LVL761:
 10211              	.LBB1042:
 10212              	.LBI1042:
 326:Src/usb_pd_protocol.c **** {
 10213              		.loc 1 326 20 discriminator 4 view .LVU2789
 10214              	.LBB1043:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10215              		.loc 1 328 2 discriminator 4 view .LVU2790
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10216              		.loc 1 328 17 is_stmt 0 discriminator 4 view .LVU2791
 10217 11b4 F101     		lsls	r1, r6, #7
 10218 11b6 BF4B     		ldr	r3, .L591
 10219 11b8 5B18     		adds	r3, r3, r1
 10220 11ba 1C79     		ldrb	r4, [r3, #4]
 10221              	.LVL762:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 10222              		.loc 1 333 2 is_stmt 1 discriminator 4 view .LVU2792
 10223              	.LBB1044:
 10224              	.LBI1044:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10225              		.loc 1 261 20 discriminator 4 view .LVU2793
 10226              	.LBB1045:
ARM GAS  /tmp/ccoQIC4J.s 			page 273


 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10227              		.loc 1 265 2 discriminator 4 view .LVU2794
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10228              		.loc 1 265 19 is_stmt 0 discriminator 4 view .LVU2795
 10229 11bc 0020     		movs	r0, #0
 10230 11be 0021     		movs	r1, #0
 10231 11c0 1861     		str	r0, [r3, #16]
 10232 11c2 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10233              		.loc 1 266 2 is_stmt 1 discriminator 4 view .LVU2796
 266:Src/usb_pd_protocol.c **** }
 10234              		.loc 1 266 25 is_stmt 0 discriminator 4 view .LVU2797
 10235 11c4 0021     		movs	r1, #0
 10236 11c6 D971     		strb	r1, [r3, #7]
 10237              	.LVL763:
 266:Src/usb_pd_protocol.c **** }
 10238              		.loc 1 266 25 discriminator 4 view .LVU2798
 10239              	.LBE1045:
 10240              	.LBE1044:
 334:Src/usb_pd_protocol.c **** 
 10241              		.loc 1 334 2 is_stmt 1 discriminator 4 view .LVU2799
 334:Src/usb_pd_protocol.c **** 
 10242              		.loc 1 334 22 is_stmt 0 discriminator 4 view .LVU2800
 10243 11c8 1A71     		strb	r2, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 10244              		.loc 1 336 2 is_stmt 1 discriminator 4 view .LVU2801
 336:Src/usb_pd_protocol.c **** 		return;
 10245              		.loc 1 336 5 is_stmt 0 discriminator 4 view .LVU2802
 10246 11ca A242     		cmp	r2, r4
 10247 11cc 4AD0     		beq	.L354
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 10248              		.loc 1 347 2 is_stmt 1 view .LVU2803
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 10249              		.loc 1 347 5 is_stmt 0 view .LVU2804
 10250 11ce 022C     		cmp	r4, #2
 10251 11d0 1AD0     		beq	.L564
 10252              	.L473:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 10253              		.loc 1 348 48 view .LVU2805
 10254 11d2 0E2C     		cmp	r4, #14
 10255 11d4 1BD0     		beq	.L565
 10256              	.L474:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 10257              		.loc 1 353 2 is_stmt 1 view .LVU2806
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 10258              		.loc 1 353 5 is_stmt 0 view .LVU2807
 10259 11d6 0E2A     		cmp	r2, #14
 10260 11d8 01D0     		beq	.L475
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 10261              		.loc 1 353 46 view .LVU2808
 10262 11da 022A     		cmp	r2, #2
 10263 11dc 42D1     		bne	.L354
 10264              	.L475:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 10265              		.loc 1 356 3 is_stmt 1 view .LVU2809
 10266 11de 0022     		movs	r2, #0
 10267              	.LVL764:
ARM GAS  /tmp/ccoQIC4J.s 			page 274


 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 10268              		.loc 1 356 3 is_stmt 0 view .LVU2810
 10269 11e0 0021     		movs	r1, #0
 10270 11e2 3000     		movs	r0, r6
 10271 11e4 FFF7FEFF 		bl	pd_set_input_current_limit
 10272              	.LVL765:
 373:Src/usb_pd_protocol.c **** 			/*
 10273              		.loc 1 373 3 is_stmt 1 view .LVU2811
 373:Src/usb_pd_protocol.c **** 			/*
 10274              		.loc 1 373 15 is_stmt 0 view .LVU2812
 10275 11e8 F301     		lsls	r3, r6, #7
 10276 11ea B24A     		ldr	r2, .L591
 10277 11ec 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 10278              		.loc 1 373 6 view .LVU2813
 10279 11ee 012B     		cmp	r3, #1
 10280 11f0 10D0     		beq	.L566
 10281              	.L476:
 405:Src/usb_pd_protocol.c **** 	}
 10282              		.loc 1 405 3 is_stmt 1 view .LVU2814
 10283              	.LVL766:
 10284              	.LBB1046:
 10285              	.LBI1046:
  94:Inc/tcpm.h    **** {
 10286              		.loc 2 94 19 view .LVU2815
 10287              	.LBB1047:
  96:Inc/tcpm.h    **** }
 10288              		.loc 2 96 2 view .LVU2816
  96:Inc/tcpm.h    **** }
 10289              		.loc 2 96 26 is_stmt 0 view .LVU2817
 10290 11f2 3201     		lsls	r2, r6, #4
 10291 11f4 B24B     		ldr	r3, .L591+12
 10292 11f6 9B18     		adds	r3, r3, r2
 10293 11f8 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 10294              		.loc 2 96 30 view .LVU2818
 10295 11fa 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 10296              		.loc 2 96 9 view .LVU2819
 10297 11fc 0021     		movs	r1, #0
 10298 11fe 3000     		movs	r0, r6
 10299 1200 9847     		blx	r3
 10300              	.LVL767:
 10301 1202 2FE0     		b	.L354
 10302              	.LVL768:
 10303              	.L563:
  96:Inc/tcpm.h    **** }
 10304              		.loc 2 96 9 view .LVU2820
 10305              	.LBE1047:
 10306              	.LBE1046:
 10307              	.LBE1043:
 10308              	.LBE1042:
 10309              		.loc 1 3042 5 view .LVU2821
 10310 1204 1E22     		movs	r2, #30
 10311 1206 D5E7     		b	.L472
 10312              	.LVL769:
 10313              	.L564:
ARM GAS  /tmp/ccoQIC4J.s 			page 275


 10314              	.LBB1049:
 10315              	.LBB1048:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 10316              		.loc 1 347 47 view .LVU2822
 10317 1208 0E2A     		cmp	r2, #14
 10318 120a E2D1     		bne	.L473
 10319 120c 2AE0     		b	.L354
 10320              	.L565:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 10321              		.loc 1 349 47 view .LVU2823
 10322 120e 022A     		cmp	r2, #2
 10323 1210 E1D1     		bne	.L474
 10324 1212 27E0     		b	.L354
 10325              	.LVL770:
 10326              	.L566:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 10327              		.loc 1 378 4 is_stmt 1 view .LVU2824
 10328 1214 3000     		movs	r0, r6
 10329 1216 FFF7FEFF 		bl	pd_power_supply_reset
 10330              	.LVL771:
 10331 121a EAE7     		b	.L476
 10332              	.LVL772:
 10333              	.L471:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 10334              		.loc 1 378 4 is_stmt 0 view .LVU2825
 10335              	.LBE1048:
 10336              	.LBE1049:
3043:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
3044:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_READY);
3045:Src/usb_pd_protocol.c **** 				break;
3046:Src/usb_pd_protocol.c **** 			}
3047:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
3048:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 10337              		.loc 1 3048 4 is_stmt 1 view .LVU2826
3049:Src/usb_pd_protocol.c **** 						get_time().val +
 10338              		.loc 1 3049 7 is_stmt 0 view .LVU2827
 10339 121c 04A8     		add	r0, sp, #16
 10340 121e FFF7FEFF 		bl	get_time
 10341              	.LVL773:
3048:Src/usb_pd_protocol.c **** 						get_time().val +
 10342              		.loc 1 3048 4 view .LVU2828
 10343 1222 A848     		ldr	r0, .L591+16
 10344 1224 0021     		movs	r1, #0
 10345 1226 049B     		ldr	r3, [sp, #16]
 10346 1228 059C     		ldr	r4, [sp, #20]
 10347 122a C018     		adds	r0, r0, r3
 10348 122c 6141     		adcs	r1, r1, r4
 10349              	.LVL774:
 10350              	.LBB1050:
 10351              	.LBI1050:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10352              		.loc 1 261 20 is_stmt 1 view .LVU2829
 10353              	.LBB1051:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10354              		.loc 1 265 2 view .LVU2830
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10355              		.loc 1 265 19 is_stmt 0 view .LVU2831
ARM GAS  /tmp/ccoQIC4J.s 			page 276


 10356 122e F201     		lsls	r2, r6, #7
 10357 1230 A04B     		ldr	r3, .L591
 10358 1232 9B18     		adds	r3, r3, r2
 10359 1234 1861     		str	r0, [r3, #16]
 10360 1236 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10361              		.loc 1 266 2 is_stmt 1 view .LVU2832
 266:Src/usb_pd_protocol.c **** }
 10362              		.loc 1 266 25 is_stmt 0 view .LVU2833
 10363 1238 0822     		movs	r2, #8
 10364 123a DA71     		strb	r2, [r3, #7]
 10365 123c 12E0     		b	.L354
 10366              	.LVL775:
 10367              	.L378:
 266:Src/usb_pd_protocol.c **** }
 10368              		.loc 1 266 25 view .LVU2834
 10369              	.LBE1051:
 10370              	.LBE1050:
3050:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
3051:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_READY);
3052:Src/usb_pd_protocol.c **** 		}
3053:Src/usb_pd_protocol.c **** 		break;
3054:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_SNK_DISABLE:
3055:Src/usb_pd_protocol.c **** 		/* Stop drawing power */
3056:Src/usb_pd_protocol.c **** 		pd_set_input_current_limit(port, 0, 0);
 10371              		.loc 1 3056 3 is_stmt 1 view .LVU2835
 10372 123e 0022     		movs	r2, #0
 10373 1240 0021     		movs	r1, #0
 10374 1242 3000     		movs	r0, r6
 10375 1244 FFF7FEFF 		bl	pd_set_input_current_limit
 10376              	.LVL776:
3057:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
3058:Src/usb_pd_protocol.c **** 		//typec_set_input_current_limit(port, 0, 0);
3059:Src/usb_pd_protocol.c **** 		//charge_manager_set_ceil(port,
3060:Src/usb_pd_protocol.c **** 		//			CEIL_REQUESTOR_PD,
3061:Src/usb_pd_protocol.c **** 		//			CHARGE_CEIL_NONE);
3062:Src/usb_pd_protocol.c **** #endif
3063:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_SWAP_SRC_DISABLE);
 10377              		.loc 1 3063 3 view .LVU2836
 10378              	.LBB1052:
 10379              	.LBI1052:
 326:Src/usb_pd_protocol.c **** {
 10380              		.loc 1 326 20 view .LVU2837
 10381              	.LBB1053:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10382              		.loc 1 328 2 view .LVU2838
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 10383              		.loc 1 333 2 view .LVU2839
 10384              	.LBB1054:
 10385              	.LBI1054:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10386              		.loc 1 261 20 view .LVU2840
 10387              	.LBB1055:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10388              		.loc 1 265 2 view .LVU2841
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10389              		.loc 1 265 19 is_stmt 0 view .LVU2842
ARM GAS  /tmp/ccoQIC4J.s 			page 277


 10390 1248 F201     		lsls	r2, r6, #7
 10391 124a 9A4B     		ldr	r3, .L591
 10392 124c 9B18     		adds	r3, r3, r2
 10393 124e 0020     		movs	r0, #0
 10394 1250 0021     		movs	r1, #0
 10395 1252 1861     		str	r0, [r3, #16]
 10396 1254 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10397              		.loc 1 266 2 is_stmt 1 view .LVU2843
 266:Src/usb_pd_protocol.c **** }
 10398              		.loc 1 266 25 is_stmt 0 view .LVU2844
 10399 1256 0022     		movs	r2, #0
 10400 1258 DA71     		strb	r2, [r3, #7]
 10401              	.LVL777:
 266:Src/usb_pd_protocol.c **** }
 10402              		.loc 1 266 25 view .LVU2845
 10403              	.LBE1055:
 10404              	.LBE1054:
 334:Src/usb_pd_protocol.c **** 
 10405              		.loc 1 334 2 is_stmt 1 view .LVU2846
 334:Src/usb_pd_protocol.c **** 
 10406              		.loc 1 334 22 is_stmt 0 view .LVU2847
 10407 125a 0B32     		adds	r2, r2, #11
 10408 125c 1A71     		strb	r2, [r3, #4]
 10409              	.LVL778:
 336:Src/usb_pd_protocol.c **** 		return;
 10410              		.loc 1 336 2 is_stmt 1 view .LVU2848
 336:Src/usb_pd_protocol.c **** 		return;
 10411              		.loc 1 336 2 is_stmt 0 view .LVU2849
 10412              	.LBE1053:
 10413              	.LBE1052:
3064:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
 10414              		.loc 1 3064 3 is_stmt 1 view .LVU2850
 10415              		.loc 1 3064 11 is_stmt 0 view .LVU2851
 10416 125e 964B     		ldr	r3, .L591+4
 10417 1260 964A     		ldr	r2, .L591+8
 10418 1262 1A60     		str	r2, [r3]
3065:Src/usb_pd_protocol.c **** 		break;
 10419              		.loc 1 3065 3 is_stmt 1 view .LVU2852
 10420              	.L354:
3066:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_SRC_DISABLE:
3067:Src/usb_pd_protocol.c **** 		/* Wait for PS_RDY */
3068:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
3069:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
3070:Src/usb_pd_protocol.c **** 						get_time().val +
3071:Src/usb_pd_protocol.c **** 						PD_T_PS_SOURCE_OFF,
3072:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
3073:Src/usb_pd_protocol.c **** 		break;
3074:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_STANDBY:
3075:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3076:Src/usb_pd_protocol.c **** 			/* Switch to Rp and enable power supply */
3077:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
3078:Src/usb_pd_protocol.c **** 			if (pd_set_power_supply_ready(port)) {
3079:Src/usb_pd_protocol.c **** 				/* Restore Rd */
3080:Src/usb_pd_protocol.c **** 				tcpm_set_cc(port, TYPEC_CC_RD);
3081:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
3082:Src/usb_pd_protocol.c **** 				set_state(port,
ARM GAS  /tmp/ccoQIC4J.s 			page 278


3083:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
3084:Src/usb_pd_protocol.c **** 				break;
3085:Src/usb_pd_protocol.c **** 			}
3086:Src/usb_pd_protocol.c **** 			/* Wait for power supply to turn on */
3087:Src/usb_pd_protocol.c **** 			set_state_timeout(
3088:Src/usb_pd_protocol.c **** 				port,
3089:Src/usb_pd_protocol.c **** 				get_time().val +
3090:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
3091:Src/usb_pd_protocol.c **** 				PD_STATE_SNK_SWAP_COMPLETE);
3092:Src/usb_pd_protocol.c **** 		}
3093:Src/usb_pd_protocol.c **** 		break;
3094:Src/usb_pd_protocol.c **** 	case PD_STATE_SNK_SWAP_COMPLETE:
3095:Src/usb_pd_protocol.c **** 		/* Send PS_RDY and change to source role */
3096:Src/usb_pd_protocol.c **** 		res = send_control(port, PD_CTRL_PS_RDY);
3097:Src/usb_pd_protocol.c **** 		if (res < 0) {
3098:Src/usb_pd_protocol.c **** 			/* Restore Rd */
3099:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
3100:Src/usb_pd_protocol.c **** 			pd_power_supply_reset(port);
3101:Src/usb_pd_protocol.c **** 			timeout = 10 * MSEC_US;
3102:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
3103:Src/usb_pd_protocol.c **** 			break;
3104:Src/usb_pd_protocol.c **** 		}
3105:Src/usb_pd_protocol.c **** 
3106:Src/usb_pd_protocol.c **** 		/* Don't send GET_SINK_CAP on swap */
3107:Src/usb_pd_protocol.c **** 		snk_cap_count = PD_SNK_CAP_RETRIES+1;
3108:Src/usb_pd_protocol.c **** 		caps_count = 0;
3109:Src/usb_pd_protocol.c **** 		pd[port].msg_id = 0;
3110:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
3111:Src/usb_pd_protocol.c **** 		pd_update_roles(port);
3112:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCOVERY);
3113:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
3114:Src/usb_pd_protocol.c **** 		break;
3115:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
3116:Src/usb_pd_protocol.c **** 	case PD_STATE_VCONN_SWAP_SEND:
3117:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3118:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_VCONN_SWAP);
3119:Src/usb_pd_protocol.c **** 			if (res < 0) {
3120:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
3121:Src/usb_pd_protocol.c **** 				/*
3122:Src/usb_pd_protocol.c **** 					* If failed to get goodCRC, send
3123:Src/usb_pd_protocol.c **** 					* soft reset, otherwise ignore
3124:Src/usb_pd_protocol.c **** 					* failure.
3125:Src/usb_pd_protocol.c **** 					*/
3126:Src/usb_pd_protocol.c **** 				set_state(port, res == -1 ?
3127:Src/usb_pd_protocol.c **** 						PD_STATE_SOFT_RESET :
3128:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
3129:Src/usb_pd_protocol.c **** 				break;
3130:Src/usb_pd_protocol.c **** 			}
3131:Src/usb_pd_protocol.c **** 			/* Wait for accept or reject */
3132:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
3133:Src/usb_pd_protocol.c **** 						get_time().val +
3134:Src/usb_pd_protocol.c **** 						PD_T_SENDER_RESPONSE,
3135:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
3136:Src/usb_pd_protocol.c **** 		}
3137:Src/usb_pd_protocol.c **** 		break;
3138:Src/usb_pd_protocol.c **** 	case PD_STATE_VCONN_SWAP_INIT:
3139:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
ARM GAS  /tmp/ccoQIC4J.s 			page 279


3140:Src/usb_pd_protocol.c **** 			if (!(pd[port].flags & PD_FLAGS_VCONN_ON)) {
3141:Src/usb_pd_protocol.c **** 				/* Turn VCONN on and wait for it */
3142:Src/usb_pd_protocol.c **** 				tcpm_set_vconn(port, 1);
3143:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3144:Src/usb_pd_protocol.c **** 					get_time().val + PD_VCONN_SWAP_DELAY,
3145:Src/usb_pd_protocol.c **** 					PD_STATE_VCONN_SWAP_READY);
3146:Src/usb_pd_protocol.c **** 			} else {
3147:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3148:Src/usb_pd_protocol.c **** 					get_time().val + PD_T_VCONN_SOURCE_ON,
3149:Src/usb_pd_protocol.c **** 					READY_RETURN_STATE(port));
3150:Src/usb_pd_protocol.c **** 			}
3151:Src/usb_pd_protocol.c **** 		}
3152:Src/usb_pd_protocol.c **** 		break;
3153:Src/usb_pd_protocol.c **** 	case PD_STATE_VCONN_SWAP_READY:
3154:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3155:Src/usb_pd_protocol.c **** 			if (!(pd[port].flags & PD_FLAGS_VCONN_ON)) {
3156:Src/usb_pd_protocol.c **** 				/* VCONN is now on, send PS_RDY */
3157:Src/usb_pd_protocol.c **** 				pd[port].flags |= PD_FLAGS_VCONN_ON;
3158:Src/usb_pd_protocol.c **** 				res = send_control(port,
3159:Src/usb_pd_protocol.c **** 							PD_CTRL_PS_RDY);
3160:Src/usb_pd_protocol.c **** 				if (res == -1) {
3161:Src/usb_pd_protocol.c **** 					timeout = 10*MSEC_US;
3162:Src/usb_pd_protocol.c **** 					/*
3163:Src/usb_pd_protocol.c **** 						* If failed to get goodCRC,
3164:Src/usb_pd_protocol.c **** 						* send soft reset
3165:Src/usb_pd_protocol.c **** 						*/
3166:Src/usb_pd_protocol.c **** 					set_state(port,
3167:Src/usb_pd_protocol.c **** 							PD_STATE_SOFT_RESET);
3168:Src/usb_pd_protocol.c **** 					break;
3169:Src/usb_pd_protocol.c **** 				}
3170:Src/usb_pd_protocol.c **** 				set_state(port,
3171:Src/usb_pd_protocol.c **** 						READY_RETURN_STATE(port));
3172:Src/usb_pd_protocol.c **** 			} else {
3173:Src/usb_pd_protocol.c **** 				/* Turn VCONN off and wait for it */
3174:Src/usb_pd_protocol.c **** 				tcpm_set_vconn(port, 0);
3175:Src/usb_pd_protocol.c **** 				pd[port].flags &= ~PD_FLAGS_VCONN_ON;
3176:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3177:Src/usb_pd_protocol.c **** 					get_time().val + PD_VCONN_SWAP_DELAY,
3178:Src/usb_pd_protocol.c **** 					READY_RETURN_STATE(port));
3179:Src/usb_pd_protocol.c **** 			}
3180:Src/usb_pd_protocol.c **** 		}
3181:Src/usb_pd_protocol.c **** 		break;
3182:Src/usb_pd_protocol.c **** #endif /* CONFIG_USBC_VCONN_SWAP */
3183:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
3184:Src/usb_pd_protocol.c **** 	case PD_STATE_SOFT_RESET:
3185:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state) {
3186:Src/usb_pd_protocol.c **** 			/* Message ID of soft reset is always 0 */
3187:Src/usb_pd_protocol.c **** 			pd[port].msg_id = 0;
3188:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_SOFT_RESET);
3189:Src/usb_pd_protocol.c **** 
3190:Src/usb_pd_protocol.c **** 			/* if soft reset failed, try hard reset. */
3191:Src/usb_pd_protocol.c **** 			if (res < 0) {
3192:Src/usb_pd_protocol.c **** 				set_state(port,
3193:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
3194:Src/usb_pd_protocol.c **** 				timeout = 5*MSEC_US;
3195:Src/usb_pd_protocol.c **** 				break;
3196:Src/usb_pd_protocol.c **** 			}
ARM GAS  /tmp/ccoQIC4J.s 			page 280


3197:Src/usb_pd_protocol.c **** 
3198:Src/usb_pd_protocol.c **** 			set_state_timeout(
3199:Src/usb_pd_protocol.c **** 				port,
3200:Src/usb_pd_protocol.c **** 				get_time().val + PD_T_SENDER_RESPONSE,
3201:Src/usb_pd_protocol.c **** 				PD_STATE_HARD_RESET_SEND);
3202:Src/usb_pd_protocol.c **** 		}
3203:Src/usb_pd_protocol.c **** 		break;
3204:Src/usb_pd_protocol.c **** 	case PD_STATE_HARD_RESET_SEND:
3205:Src/usb_pd_protocol.c **** 		hard_reset_count++;
3206:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
3207:Src/usb_pd_protocol.c **** 			hard_reset_sent = 0;
3208:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
3209:Src/usb_pd_protocol.c **** 		if (pd[port].last_state == PD_STATE_SNK_DISCOVERY ||
3210:Src/usb_pd_protocol.c **** 			(pd[port].last_state == PD_STATE_SOFT_RESET &&
3211:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_VBUS_NEVER_LOW))) {
3212:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
3213:Src/usb_pd_protocol.c **** 			/*
3214:Src/usb_pd_protocol.c **** 				* If discovery timed out, assume that we
3215:Src/usb_pd_protocol.c **** 				* have a dedicated charger attached. This
3216:Src/usb_pd_protocol.c **** 				* may not be a correct assumption according
3217:Src/usb_pd_protocol.c **** 				* to the specification, but it generally
3218:Src/usb_pd_protocol.c **** 				* works in practice and the harmful
3219:Src/usb_pd_protocol.c **** 				* effects of a wrong assumption here
3220:Src/usb_pd_protocol.c **** 				* are minimal.
3221:Src/usb_pd_protocol.c **** 				*/
3222:Src/usb_pd_protocol.c **** 			//charge_manager_update_dualrole(port,
3223:Src/usb_pd_protocol.c **** 			//				    CAP_DEDICATED);
3224:Src/usb_pd_protocol.c **** 		}
3225:Src/usb_pd_protocol.c **** #endif
3226:Src/usb_pd_protocol.c **** 
3227:Src/usb_pd_protocol.c **** 		/* try sending hard reset until it succeeds */
3228:Src/usb_pd_protocol.c **** 		if (!hard_reset_sent) {
3229:Src/usb_pd_protocol.c **** 			if (pd_transmit(port, TCPC_TX_HARD_RESET,
3230:Src/usb_pd_protocol.c **** 					0, NULL) < 0) {
3231:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
3232:Src/usb_pd_protocol.c **** 				break;
3233:Src/usb_pd_protocol.c **** 			}
3234:Src/usb_pd_protocol.c **** 
3235:Src/usb_pd_protocol.c **** 			/* successfully sent hard reset */
3236:Src/usb_pd_protocol.c **** 			hard_reset_sent = 1;
3237:Src/usb_pd_protocol.c **** 			/*
3238:Src/usb_pd_protocol.c **** 				* If we are source, delay before cutting power
3239:Src/usb_pd_protocol.c **** 				* to allow sink time to get hard reset.
3240:Src/usb_pd_protocol.c **** 				*/
3241:Src/usb_pd_protocol.c **** 			if (pd[port].power_role == PD_ROLE_SOURCE) {
3242:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
3243:Src/usb_pd_protocol.c **** 					get_time().val + PD_T_PS_HARD_RESET,
3244:Src/usb_pd_protocol.c **** 					PD_STATE_HARD_RESET_EXECUTE);
3245:Src/usb_pd_protocol.c **** 			} else {
3246:Src/usb_pd_protocol.c **** 				set_state(port,
3247:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_EXECUTE);
3248:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
3249:Src/usb_pd_protocol.c **** 			}
3250:Src/usb_pd_protocol.c **** 		}
3251:Src/usb_pd_protocol.c **** 		break;
3252:Src/usb_pd_protocol.c **** 	case PD_STATE_HARD_RESET_EXECUTE:
3253:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
ARM GAS  /tmp/ccoQIC4J.s 			page 281


3254:Src/usb_pd_protocol.c **** 		/*
3255:Src/usb_pd_protocol.c **** 			* If hard reset while in the last stages of power
3256:Src/usb_pd_protocol.c **** 			* swap, then we need to restore our CC resistor.
3257:Src/usb_pd_protocol.c **** 			*/
3258:Src/usb_pd_protocol.c **** 		if (pd[port].last_state == PD_STATE_SNK_SWAP_STANDBY)
3259:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
3260:Src/usb_pd_protocol.c **** #endif
3261:Src/usb_pd_protocol.c **** 
3262:Src/usb_pd_protocol.c **** 		/* reset our own state machine */
3263:Src/usb_pd_protocol.c **** 		pd_execute_hard_reset(port);
3264:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
3265:Src/usb_pd_protocol.c **** 		break;
3266:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
3267:Src/usb_pd_protocol.c **** 	case PD_STATE_BIST_RX:
3268:Src/usb_pd_protocol.c **** 		send_bist_cmd(port);
3269:Src/usb_pd_protocol.c **** 		/* Delay at least enough for partner to finish BIST */
3270:Src/usb_pd_protocol.c **** 		timeout = PD_T_BIST_RECEIVE + 20*MSEC_US;
3271:Src/usb_pd_protocol.c **** 		/* Set to appropriate port disconnected state */
3272:Src/usb_pd_protocol.c **** 		set_state(port, DUAL_ROLE_IF_ELSE(port,
3273:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_DISCONNECTED,
3274:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_DISCONNECTED));
3275:Src/usb_pd_protocol.c **** 		break;
3276:Src/usb_pd_protocol.c **** 	case PD_STATE_BIST_TX:
3277:Src/usb_pd_protocol.c **** 		pd_transmit(port, TCPC_TX_BIST_MODE_2, 0, NULL);
3278:Src/usb_pd_protocol.c **** 		/* Delay at least enough to finish sending BIST */
3279:Src/usb_pd_protocol.c **** 		timeout = PD_T_BIST_TRANSMIT + 20*MSEC_US;
3280:Src/usb_pd_protocol.c **** 		/* Set to appropriate port disconnected state */
3281:Src/usb_pd_protocol.c **** 		set_state(port, DUAL_ROLE_IF_ELSE(port,
3282:Src/usb_pd_protocol.c **** 					PD_STATE_SNK_DISCONNECTED,
3283:Src/usb_pd_protocol.c **** 					PD_STATE_SRC_DISCONNECTED));
3284:Src/usb_pd_protocol.c **** 		break;
3285:Src/usb_pd_protocol.c **** #endif
3286:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE_AUTO_TOGGLE
3287:Src/usb_pd_protocol.c **** 	case PD_STATE_DRP_AUTO_TOGGLE:
3288:Src/usb_pd_protocol.c **** 	{
3289:Src/usb_pd_protocol.c **** 		enum pd_states next_state;
3290:Src/usb_pd_protocol.c **** 
3291:Src/usb_pd_protocol.c **** 		assert(auto_toggle_supported);
3292:Src/usb_pd_protocol.c **** 
3293:Src/usb_pd_protocol.c **** 		/* Check for connection */
3294:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
3295:Src/usb_pd_protocol.c **** 
3296:Src/usb_pd_protocol.c **** 		/* Set to appropriate port state */
3297:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_OPEN &&
3298:Src/usb_pd_protocol.c **** 			cc2 == TYPEC_CC_VOLT_OPEN)
3299:Src/usb_pd_protocol.c **** 			/* nothing connected, keep toggling*/
3300:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_DRP_AUTO_TOGGLE;
3301:Src/usb_pd_protocol.c **** 		else if ((cc_is_rp(cc1) || cc_is_rp(cc2)) &&
3302:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SOURCE)
3303:Src/usb_pd_protocol.c **** 			/* SNK allowed unless ForceSRC */
3304:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_SNK_DISCONNECTED;
3305:Src/usb_pd_protocol.c **** 		else if (((cc1 == TYPEC_CC_VOLT_RD ||
3306:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RD) ||
3307:Src/usb_pd_protocol.c **** 				(cc1 == TYPEC_CC_VOLT_RA &&
3308:Src/usb_pd_protocol.c **** 				cc2 == TYPEC_CC_VOLT_RA)) &&
3309:Src/usb_pd_protocol.c **** 				(drp_state != PD_DRP_TOGGLE_OFF &&
3310:Src/usb_pd_protocol.c **** 				drp_state != PD_DRP_FORCE_SINK))
ARM GAS  /tmp/ccoQIC4J.s 			page 282


3311:Src/usb_pd_protocol.c **** 			/* SRC allowed unless ForceSNK or Toggle Off */
3312:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_SRC_DISCONNECTED;
3313:Src/usb_pd_protocol.c **** 		else
3314:Src/usb_pd_protocol.c **** 			/* Anything else, keep toggling */
3315:Src/usb_pd_protocol.c **** 			next_state = PD_STATE_DRP_AUTO_TOGGLE;
3316:Src/usb_pd_protocol.c **** 
3317:Src/usb_pd_protocol.c **** 		if (next_state != PD_STATE_DRP_AUTO_TOGGLE) {
3318:Src/usb_pd_protocol.c **** 			tcpm_set_drp_toggle(port, 0);
3319:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC_LOW_POWER
3320:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d Exit Low Power Mode", port);
3321:Src/usb_pd_protocol.c **** #endif
3322:Src/usb_pd_protocol.c **** 		}
3323:Src/usb_pd_protocol.c **** 
3324:Src/usb_pd_protocol.c **** 		if (next_state == PD_STATE_SNK_DISCONNECTED) {
3325:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
3326:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SINK;
3327:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC_US;
3328:Src/usb_pd_protocol.c **** 		} else if (next_state == PD_STATE_SRC_DISCONNECTED) {
3329:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RP);
3330:Src/usb_pd_protocol.c **** 			pd[port].power_role = PD_ROLE_SOURCE;
3331:Src/usb_pd_protocol.c **** 			timeout = 2*MSEC_US;
3332:Src/usb_pd_protocol.c **** 		} else {
3333:Src/usb_pd_protocol.c **** 			tcpm_set_drp_toggle(port, 1);
3334:Src/usb_pd_protocol.c **** 			pd[port].flags |= PD_FLAGS_TCPC_DRP_TOGGLE;
3335:Src/usb_pd_protocol.c **** 			timeout = -1;
3336:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_TCPC_LOW_POWER
3337:Src/usb_pd_protocol.c **** 			CPRINTS("TCPC p%d Low Power Mode", port);
3338:Src/usb_pd_protocol.c **** #endif
3339:Src/usb_pd_protocol.c **** 		}
3340:Src/usb_pd_protocol.c **** 		set_state(port, next_state);
3341:Src/usb_pd_protocol.c **** 
3342:Src/usb_pd_protocol.c **** 		break;
3343:Src/usb_pd_protocol.c **** 	}
3344:Src/usb_pd_protocol.c **** #endif
3345:Src/usb_pd_protocol.c **** 	default:
3346:Src/usb_pd_protocol.c **** 		break;
3347:Src/usb_pd_protocol.c **** 	}
3348:Src/usb_pd_protocol.c **** 
3349:Src/usb_pd_protocol.c **** 	pd[port].last_state = this_state;
 10421              		.loc 1 3349 2 view .LVU2853
 10422              		.loc 1 3349 22 is_stmt 0 view .LVU2854
 10423 1264 F301     		lsls	r3, r6, #7
 10424 1266 934C     		ldr	r4, .L591
 10425 1268 E418     		adds	r4, r4, r3
 10426 126a 974B     		ldr	r3, .L591+20
 10427 126c 1B78     		ldrb	r3, [r3]
 10428 126e 6371     		strb	r3, [r4, #5]
3350:Src/usb_pd_protocol.c **** 
3351:Src/usb_pd_protocol.c **** 	/*
3352:Src/usb_pd_protocol.c **** 		* Check for state timeout, and if not check if need to adjust
3353:Src/usb_pd_protocol.c **** 		* timeout value to wake up on the next state timeout.
3354:Src/usb_pd_protocol.c **** 		*/
3355:Src/usb_pd_protocol.c **** 	now = get_time();
 10429              		.loc 1 3355 2 is_stmt 1 view .LVU2855
 10430              		.loc 1 3355 8 is_stmt 0 view .LVU2856
 10431 1270 04A8     		add	r0, sp, #16
 10432 1272 FFF7FEFF 		bl	get_time
ARM GAS  /tmp/ccoQIC4J.s 			page 283


 10433              	.LVL779:
 10434 1276 954B     		ldr	r3, .L591+24
 10435 1278 0499     		ldr	r1, [sp, #16]
 10436 127a 059A     		ldr	r2, [sp, #20]
 10437 127c 1960     		str	r1, [r3]
 10438 127e 5A60     		str	r2, [r3, #4]
3356:Src/usb_pd_protocol.c **** 	if (pd[port].timeout) {
 10439              		.loc 1 3356 2 is_stmt 1 view .LVU2857
 10440              		.loc 1 3356 14 is_stmt 0 view .LVU2858
 10441 1280 2269     		ldr	r2, [r4, #16]
 10442 1282 6369     		ldr	r3, [r4, #20]
 10443              		.loc 1 3356 5 view .LVU2859
 10444 1284 1100     		movs	r1, r2
 10445 1286 1943     		orrs	r1, r3
 10446 1288 1DD0     		beq	.L488
3357:Src/usb_pd_protocol.c **** 		if (now.val >= pd[port].timeout) {
 10447              		.loc 1 3357 3 is_stmt 1 view .LVU2860
 10448              		.loc 1 3357 10 is_stmt 0 view .LVU2861
 10449 128a 9049     		ldr	r1, .L591+24
 10450 128c 0868     		ldr	r0, [r1]
 10451 128e 4968     		ldr	r1, [r1, #4]
 10452 1290 0290     		str	r0, [sp, #8]
 10453 1292 0391     		str	r1, [sp, #12]
 10454              		.loc 1 3357 6 view .LVU2862
 10455 1294 0399     		ldr	r1, [sp, #12]
 10456 1296 8B42     		cmp	r3, r1
 10457 1298 00D8     		bhi	.LCB9784
 10458 129a 96E1     		b	.L567	@long jump
 10459              	.LCB9784:
 10460              	.L490:
3358:Src/usb_pd_protocol.c **** 			set_state(port, pd[port].timeout_state);
3359:Src/usb_pd_protocol.c **** 			/* On a state timeout, run next state soon */
3360:Src/usb_pd_protocol.c **** 			timeout = timeout < 10*MSEC_US ? timeout : 10*MSEC_US;
3361:Src/usb_pd_protocol.c **** 		} else if (pd[port].timeout - now.val < timeout) {
 10461              		.loc 1 3361 10 is_stmt 1 view .LVU2863
 10462              		.loc 1 3361 31 is_stmt 0 view .LVU2864
 10463 129c 1400     		movs	r4, r2
 10464 129e 1D00     		movs	r5, r3
 10465 12a0 0298     		ldr	r0, [sp, #8]
 10466 12a2 0399     		ldr	r1, [sp, #12]
 10467 12a4 241A     		subs	r4, r4, r0
 10468 12a6 8D41     		sbcs	r5, r5, r1
 10469 12a8 2000     		movs	r0, r4
 10470              		.loc 1 3361 41 view .LVU2865
 10471 12aa 834C     		ldr	r4, .L591+4
 10472 12ac 2468     		ldr	r4, [r4]
 10473 12ae A046     		mov	r8, r4
 10474 12b0 E417     		asrs	r4, r4, #31
 10475 12b2 A446     		mov	ip, r4
 10476              		.loc 1 3361 13 view .LVU2866
 10477 12b4 AC45     		cmp	ip, r5
 10478 12b6 02D8     		bhi	.L518
 10479 12b8 05D1     		bne	.L488
 10480 12ba 8045     		cmp	r8, r0
 10481 12bc 03D9     		bls	.L488
 10482              	.L518:
3362:Src/usb_pd_protocol.c **** 			timeout = pd[port].timeout - now.val;
ARM GAS  /tmp/ccoQIC4J.s 			page 284


 10483              		.loc 1 3362 4 is_stmt 1 view .LVU2867
 10484              		.loc 1 3362 31 is_stmt 0 view .LVU2868
 10485 12be 0299     		ldr	r1, [sp, #8]
 10486 12c0 521A     		subs	r2, r2, r1
 10487              		.loc 1 3362 12 view .LVU2869
 10488 12c2 7D4B     		ldr	r3, .L591+4
 10489 12c4 1A60     		str	r2, [r3]
 10490              	.L488:
3363:Src/usb_pd_protocol.c **** 		}
3364:Src/usb_pd_protocol.c **** 	}
3365:Src/usb_pd_protocol.c **** 
3366:Src/usb_pd_protocol.c **** 	/* Check for disconnection if we're connected */
3367:Src/usb_pd_protocol.c **** 	if (!pd_is_connected(port))
 10491              		.loc 1 3367 2 is_stmt 1 view .LVU2870
 10492              		.loc 1 3367 7 is_stmt 0 view .LVU2871
 10493 12c6 3000     		movs	r0, r6
 10494 12c8 FFF7FEFF 		bl	pd_is_connected
 10495              	.LVL780:
 10496              		.loc 1 3367 5 view .LVU2872
 10497 12cc 0028     		cmp	r0, #0
 10498 12ce 10D0     		beq	.L350
3368:Src/usb_pd_protocol.c **** 		return;
3369:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
3370:Src/usb_pd_protocol.c **** 	if (pd_is_power_swapping(port))
 10499              		.loc 1 3370 2 is_stmt 1 view .LVU2873
 10500              		.loc 1 3370 6 is_stmt 0 view .LVU2874
 10501 12d0 3000     		movs	r0, r6
 10502 12d2 FFF7FEFF 		bl	pd_is_power_swapping
 10503              	.LVL781:
 10504              		.loc 1 3370 5 view .LVU2875
 10505 12d6 0028     		cmp	r0, #0
 10506 12d8 0BD1     		bne	.L350
3371:Src/usb_pd_protocol.c **** 		return;
3372:Src/usb_pd_protocol.c **** #endif
3373:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SOURCE) {
 10507              		.loc 1 3373 2 is_stmt 1 view .LVU2876
 10508              		.loc 1 3373 14 is_stmt 0 view .LVU2877
 10509 12da F301     		lsls	r3, r6, #7
 10510 12dc 754A     		ldr	r2, .L591
 10511 12de 9B5C     		ldrb	r3, [r3, r2]
 10512              		.loc 1 3373 5 view .LVU2878
 10513 12e0 012B     		cmp	r3, #1
 10514 12e2 00D1     		bne	.LCB9827
 10515 12e4 B3E1     		b	.L568	@long jump
 10516              	.LCB9827:
 10517              	.L500:
3374:Src/usb_pd_protocol.c **** 		/* Source: detect disconnect by monitoring CC */
3375:Src/usb_pd_protocol.c **** 		tcpm_get_cc(port, &cc1, &cc2);
3376:Src/usb_pd_protocol.c **** 		if (pd[port].polarity)
3377:Src/usb_pd_protocol.c **** 			cc1 = cc2;
3378:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_OPEN) {
3379:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
3380:Src/usb_pd_protocol.c **** 			/* Debouncing */
3381:Src/usb_pd_protocol.c **** 			timeout = 10*MSEC_US;
3382:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
3383:Src/usb_pd_protocol.c **** 			/*
3384:Src/usb_pd_protocol.c **** 				* If Try.SRC is configured, then ATTACHED_SRC
ARM GAS  /tmp/ccoQIC4J.s 			page 285


3385:Src/usb_pd_protocol.c **** 				* needs to transition to TryWait.SNK. Change
3386:Src/usb_pd_protocol.c **** 				* power role to SNK and start state timer.
3387:Src/usb_pd_protocol.c **** 				*/
3388:Src/usb_pd_protocol.c **** 			if (pd_try_src_enable) {
3389:Src/usb_pd_protocol.c **** 				/* Swap roles to sink */
3390:Src/usb_pd_protocol.c **** 				pd[port].power_role = PD_ROLE_SINK;
3391:Src/usb_pd_protocol.c **** 				tcpm_set_cc(port, TYPEC_CC_RD);
3392:Src/usb_pd_protocol.c **** 				/* Set timer for TryWait.SNK state */
3393:Src/usb_pd_protocol.c **** 				pd[port].try_src_marker = get_time().val
3394:Src/usb_pd_protocol.c **** 					+ PD_T_TRY_WAIT;
3395:Src/usb_pd_protocol.c **** 				/* Advance to TryWait.SNK state */
3396:Src/usb_pd_protocol.c **** 				set_state(port,
3397:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
3398:Src/usb_pd_protocol.c **** 				/* Mark state as TryWait.SNK */
3399:Src/usb_pd_protocol.c **** 				pd[port].flags |= PD_FLAGS_TRY_SRC;
3400:Src/usb_pd_protocol.c **** 			}
3401:Src/usb_pd_protocol.c **** #endif
3402:Src/usb_pd_protocol.c **** 		}
3403:Src/usb_pd_protocol.c **** 	}
3404:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
3405:Src/usb_pd_protocol.c **** 	/*
3406:Src/usb_pd_protocol.c **** 		* Sink disconnect if VBUS is low and we are not recovering
3407:Src/usb_pd_protocol.c **** 		* a hard reset.
3408:Src/usb_pd_protocol.c **** 		*/
3409:Src/usb_pd_protocol.c **** 	if (pd[port].power_role == PD_ROLE_SINK &&
 10518              		.loc 1 3409 2 is_stmt 1 view .LVU2879
 10519              		.loc 1 3409 14 is_stmt 0 view .LVU2880
 10520 12e6 F301     		lsls	r3, r6, #7
 10521 12e8 724A     		ldr	r2, .L591
 10522 12ea 9B5C     		ldrb	r3, [r3, r2]
 10523              		.loc 1 3409 5 view .LVU2881
 10524 12ec 002B     		cmp	r3, #0
 10525 12ee 00D1     		bne	.LCB9834
 10526 12f0 EBE1     		b	.L569	@long jump
 10527              	.LCB9834:
 10528              	.L350:
3410:Src/usb_pd_protocol.c **** 		!pd_is_vbus_present(port) &&
3411:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_HARD_RESET_RECOVER &&
3412:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_HARD_RESET_EXECUTE) {
3413:Src/usb_pd_protocol.c **** 		/* Sink: detect disconnect by monitoring VBUS */
3414:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SNK_DISCONNECTED);
3415:Src/usb_pd_protocol.c **** 		/* set timeout small to reconnect fast */
3416:Src/usb_pd_protocol.c **** 		timeout = 5*MSEC_US;
3417:Src/usb_pd_protocol.c **** 	}
3418:Src/usb_pd_protocol.c **** #endif /* CONFIG_USB_PD_DUAL_ROLE */
3419:Src/usb_pd_protocol.c **** }
 10529              		.loc 1 3419 1 view .LVU2882
 10530 12f2 06B0     		add	sp, sp, #24
 10531              		@ sp needed
 10532              	.LVL782:
 10533              		.loc 1 3419 1 view .LVU2883
 10534 12f4 04BC     		pop	{r2}
 10535 12f6 9046     		mov	r8, r2
 10536 12f8 F0BD     		pop	{r4, r5, r6, r7, pc}
 10537              	.LVL783:
 10538              	.L377:
3068:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
ARM GAS  /tmp/ccoQIC4J.s 			page 286


 10539              		.loc 1 3068 3 is_stmt 1 view .LVU2884
3068:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 10540              		.loc 1 3068 15 is_stmt 0 view .LVU2885
 10541 12fa F101     		lsls	r1, r6, #7
 10542 12fc 6D4A     		ldr	r2, .L591
 10543 12fe 5218     		adds	r2, r2, r1
 10544 1300 5279     		ldrb	r2, [r2, #5]
3068:Src/usb_pd_protocol.c **** 			set_state_timeout(port,
 10545              		.loc 1 3068 6 view .LVU2886
 10546 1302 9342     		cmp	r3, r2
 10547 1304 AED0     		beq	.L354
3069:Src/usb_pd_protocol.c **** 						get_time().val +
 10548              		.loc 1 3069 4 is_stmt 1 view .LVU2887
3070:Src/usb_pd_protocol.c **** 						PD_T_PS_SOURCE_OFF,
 10549              		.loc 1 3070 7 is_stmt 0 view .LVU2888
 10550 1306 04A8     		add	r0, sp, #16
 10551 1308 FFF7FEFF 		bl	get_time
 10552              	.LVL784:
3069:Src/usb_pd_protocol.c **** 						get_time().val +
 10553              		.loc 1 3069 4 view .LVU2889
 10554 130c 7048     		ldr	r0, .L591+28
 10555 130e 0021     		movs	r1, #0
 10556 1310 049B     		ldr	r3, [sp, #16]
 10557 1312 059C     		ldr	r4, [sp, #20]
 10558 1314 C018     		adds	r0, r0, r3
 10559 1316 6141     		adcs	r1, r1, r4
 10560              	.LVL785:
 10561              	.LBB1056:
 10562              	.LBI1056:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10563              		.loc 1 261 20 is_stmt 1 view .LVU2890
 10564              	.LBB1057:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10565              		.loc 1 265 2 view .LVU2891
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10566              		.loc 1 265 19 is_stmt 0 view .LVU2892
 10567 1318 F201     		lsls	r2, r6, #7
 10568 131a 664B     		ldr	r3, .L591
 10569 131c 9B18     		adds	r3, r3, r2
 10570 131e 1861     		str	r0, [r3, #16]
 10571 1320 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10572              		.loc 1 266 2 is_stmt 1 view .LVU2893
 266:Src/usb_pd_protocol.c **** }
 10573              		.loc 1 266 25 is_stmt 0 view .LVU2894
 10574 1322 1F22     		movs	r2, #31
 10575 1324 DA71     		strb	r2, [r3, #7]
 10576 1326 9DE7     		b	.L354
 10577              	.LVL786:
 10578              	.L376:
 266:Src/usb_pd_protocol.c **** }
 10579              		.loc 1 266 25 view .LVU2895
 10580              	.LBE1057:
 10581              	.LBE1056:
3075:Src/usb_pd_protocol.c **** 			/* Switch to Rp and enable power supply */
 10582              		.loc 1 3075 3 is_stmt 1 view .LVU2896
3075:Src/usb_pd_protocol.c **** 			/* Switch to Rp and enable power supply */
ARM GAS  /tmp/ccoQIC4J.s 			page 287


 10583              		.loc 1 3075 15 is_stmt 0 view .LVU2897
 10584 1328 F101     		lsls	r1, r6, #7
 10585 132a 624A     		ldr	r2, .L591
 10586 132c 5218     		adds	r2, r2, r1
 10587 132e 5279     		ldrb	r2, [r2, #5]
3075:Src/usb_pd_protocol.c **** 			/* Switch to Rp and enable power supply */
 10588              		.loc 1 3075 6 view .LVU2898
 10589 1330 9342     		cmp	r3, r2
 10590 1332 00D1     		bne	.LCB9897
 10591 1334 96E7     		b	.L354	@long jump
 10592              	.LCB9897:
3077:Src/usb_pd_protocol.c **** 			if (pd_set_power_supply_ready(port)) {
 10593              		.loc 1 3077 4 is_stmt 1 view .LVU2899
 10594              	.LVL787:
 10595              	.LBB1058:
 10596              	.LBI1058:
  73:Inc/tcpm.h    **** {
 10597              		.loc 2 73 19 view .LVU2900
 10598              	.LBB1059:
  75:Inc/tcpm.h    **** }
 10599              		.loc 2 75 2 view .LVU2901
  75:Inc/tcpm.h    **** }
 10600              		.loc 2 75 9 is_stmt 0 view .LVU2902
 10601 1336 0121     		movs	r1, #1
 10602 1338 3000     		movs	r0, r6
 10603 133a 7B69     		ldr	r3, [r7, #20]
 10604 133c 9847     		blx	r3
 10605              	.LVL788:
  75:Inc/tcpm.h    **** }
 10606              		.loc 2 75 9 view .LVU2903
 10607              	.LBE1059:
 10608              	.LBE1058:
3078:Src/usb_pd_protocol.c **** 				/* Restore Rd */
 10609              		.loc 1 3078 4 is_stmt 1 view .LVU2904
3078:Src/usb_pd_protocol.c **** 				/* Restore Rd */
 10610              		.loc 1 3078 8 is_stmt 0 view .LVU2905
 10611 133e 3000     		movs	r0, r6
 10612 1340 FFF7FEFF 		bl	pd_set_power_supply_ready
 10613              	.LVL789:
3078:Src/usb_pd_protocol.c **** 				/* Restore Rd */
 10614              		.loc 1 3078 7 view .LVU2906
 10615 1344 0028     		cmp	r0, #0
 10616 1346 2FD0     		beq	.L477
3080:Src/usb_pd_protocol.c **** 				timeout = 10*MSEC_US;
 10617              		.loc 1 3080 5 is_stmt 1 view .LVU2907
 10618              	.LVL790:
 10619              	.LBB1060:
 10620              	.LBI1060:
  73:Inc/tcpm.h    **** {
 10621              		.loc 2 73 19 view .LVU2908
 10622              	.LBB1061:
  75:Inc/tcpm.h    **** }
 10623              		.loc 2 75 2 view .LVU2909
  75:Inc/tcpm.h    **** }
 10624              		.loc 2 75 9 is_stmt 0 view .LVU2910
 10625 1348 0221     		movs	r1, #2
 10626 134a 3000     		movs	r0, r6
ARM GAS  /tmp/ccoQIC4J.s 			page 288


 10627 134c 7B69     		ldr	r3, [r7, #20]
 10628 134e 9847     		blx	r3
 10629              	.LVL791:
  75:Inc/tcpm.h    **** }
 10630              		.loc 2 75 9 view .LVU2911
 10631              	.LBE1061:
 10632              	.LBE1060:
3081:Src/usb_pd_protocol.c **** 				set_state(port,
 10633              		.loc 1 3081 5 is_stmt 1 view .LVU2912
3081:Src/usb_pd_protocol.c **** 				set_state(port,
 10634              		.loc 1 3081 13 is_stmt 0 view .LVU2913
 10635 1350 594B     		ldr	r3, .L591+4
 10636 1352 5A4A     		ldr	r2, .L591+8
 10637 1354 1A60     		str	r2, [r3]
3082:Src/usb_pd_protocol.c **** 						PD_STATE_SNK_DISCONNECTED);
 10638              		.loc 1 3082 5 is_stmt 1 view .LVU2914
 10639              	.LVL792:
 10640              	.LBB1062:
 10641              	.LBI1062:
 326:Src/usb_pd_protocol.c **** {
 10642              		.loc 1 326 20 view .LVU2915
 10643              	.LBB1063:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10644              		.loc 1 328 2 view .LVU2916
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10645              		.loc 1 328 17 is_stmt 0 view .LVU2917
 10646 1356 F201     		lsls	r2, r6, #7
 10647 1358 564B     		ldr	r3, .L591
 10648 135a 9B18     		adds	r3, r3, r2
 10649 135c 1A79     		ldrb	r2, [r3, #4]
 10650              	.LVL793:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 10651              		.loc 1 333 2 is_stmt 1 view .LVU2918
 10652              	.LBB1064:
 10653              	.LBI1064:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10654              		.loc 1 261 20 view .LVU2919
 10655              	.LBB1065:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10656              		.loc 1 265 2 view .LVU2920
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10657              		.loc 1 265 19 is_stmt 0 view .LVU2921
 10658 135e 0020     		movs	r0, #0
 10659 1360 0021     		movs	r1, #0
 10660 1362 1861     		str	r0, [r3, #16]
 10661 1364 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10662              		.loc 1 266 2 is_stmt 1 view .LVU2922
 266:Src/usb_pd_protocol.c **** }
 10663              		.loc 1 266 25 is_stmt 0 view .LVU2923
 10664 1366 0021     		movs	r1, #0
 10665 1368 D971     		strb	r1, [r3, #7]
 10666              	.LVL794:
 266:Src/usb_pd_protocol.c **** }
 10667              		.loc 1 266 25 view .LVU2924
 10668              	.LBE1065:
 10669              	.LBE1064:
ARM GAS  /tmp/ccoQIC4J.s 			page 289


 334:Src/usb_pd_protocol.c **** 
 10670              		.loc 1 334 2 is_stmt 1 view .LVU2925
 334:Src/usb_pd_protocol.c **** 
 10671              		.loc 1 334 22 is_stmt 0 view .LVU2926
 10672 136a 0231     		adds	r1, r1, #2
 10673 136c 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 10674              		.loc 1 336 2 is_stmt 1 view .LVU2927
 336:Src/usb_pd_protocol.c **** 		return;
 10675              		.loc 1 336 5 is_stmt 0 view .LVU2928
 10676 136e 022A     		cmp	r2, #2
 10677 1370 00D1     		bne	.LCB9975
 10678 1372 77E7     		b	.L354	@long jump
 10679              	.LCB9975:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 10680              		.loc 1 347 2 is_stmt 1 view .LVU2929
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 10681              		.loc 1 348 48 is_stmt 0 view .LVU2930
 10682 1374 0E2A     		cmp	r2, #14
 10683 1376 00D1     		bne	.LCB9978
 10684 1378 74E7     		b	.L354	@long jump
 10685              	.LCB9978:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 10686              		.loc 1 353 2 is_stmt 1 view .LVU2931
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 10687              		.loc 1 356 3 view .LVU2932
 10688 137a 0022     		movs	r2, #0
 10689              	.LVL795:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 10690              		.loc 1 356 3 is_stmt 0 view .LVU2933
 10691 137c 0021     		movs	r1, #0
 10692 137e 3000     		movs	r0, r6
 10693 1380 FFF7FEFF 		bl	pd_set_input_current_limit
 10694              	.LVL796:
 373:Src/usb_pd_protocol.c **** 			/*
 10695              		.loc 1 373 3 is_stmt 1 view .LVU2934
 373:Src/usb_pd_protocol.c **** 			/*
 10696              		.loc 1 373 15 is_stmt 0 view .LVU2935
 10697 1384 F301     		lsls	r3, r6, #7
 10698 1386 4B4A     		ldr	r2, .L591
 10699 1388 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 10700              		.loc 1 373 6 view .LVU2936
 10701 138a 012B     		cmp	r3, #1
 10702 138c 08D0     		beq	.L570
 10703              	.L478:
 405:Src/usb_pd_protocol.c **** 	}
 10704              		.loc 1 405 3 is_stmt 1 view .LVU2937
 10705              	.LVL797:
 10706              	.LBB1066:
 10707              	.LBI1066:
  94:Inc/tcpm.h    **** {
 10708              		.loc 2 94 19 view .LVU2938
 10709              	.LBB1067:
  96:Inc/tcpm.h    **** }
 10710              		.loc 2 96 2 view .LVU2939
  96:Inc/tcpm.h    **** }
ARM GAS  /tmp/ccoQIC4J.s 			page 290


 10711              		.loc 2 96 26 is_stmt 0 view .LVU2940
 10712 138e 3201     		lsls	r2, r6, #4
 10713 1390 4B4B     		ldr	r3, .L591+12
 10714 1392 9B18     		adds	r3, r3, r2
 10715 1394 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 10716              		.loc 2 96 30 view .LVU2941
 10717 1396 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 10718              		.loc 2 96 9 view .LVU2942
 10719 1398 0021     		movs	r1, #0
 10720 139a 3000     		movs	r0, r6
 10721 139c 9847     		blx	r3
 10722              	.LVL798:
 10723 139e 61E7     		b	.L354
 10724              	.LVL799:
 10725              	.L570:
  96:Inc/tcpm.h    **** }
 10726              		.loc 2 96 9 view .LVU2943
 10727              	.LBE1067:
 10728              	.LBE1066:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 10729              		.loc 1 378 4 is_stmt 1 view .LVU2944
 10730 13a0 3000     		movs	r0, r6
 10731 13a2 FFF7FEFF 		bl	pd_power_supply_reset
 10732              	.LVL800:
 10733 13a6 F2E7     		b	.L478
 10734              	.LVL801:
 10735              	.L477:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 10736              		.loc 1 378 4 is_stmt 0 view .LVU2945
 10737              	.LBE1063:
 10738              	.LBE1062:
3087:Src/usb_pd_protocol.c **** 				port,
 10739              		.loc 1 3087 4 is_stmt 1 view .LVU2946
3089:Src/usb_pd_protocol.c **** 				PD_POWER_SUPPLY_TURN_ON_DELAY,
 10740              		.loc 1 3089 5 is_stmt 0 view .LVU2947
 10741 13a8 04A8     		add	r0, sp, #16
 10742 13aa FFF7FEFF 		bl	get_time
 10743              	.LVL802:
3087:Src/usb_pd_protocol.c **** 				port,
 10744              		.loc 1 3087 4 view .LVU2948
 10745 13ae 4348     		ldr	r0, .L591+8
 10746 13b0 0021     		movs	r1, #0
 10747 13b2 049B     		ldr	r3, [sp, #16]
 10748 13b4 059C     		ldr	r4, [sp, #20]
 10749 13b6 C018     		adds	r0, r0, r3
 10750 13b8 6141     		adcs	r1, r1, r4
 10751              	.LVL803:
 10752              	.LBB1068:
 10753              	.LBI1068:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10754              		.loc 1 261 20 is_stmt 1 view .LVU2949
 10755              	.LBB1069:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10756              		.loc 1 265 2 view .LVU2950
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
ARM GAS  /tmp/ccoQIC4J.s 			page 291


 10757              		.loc 1 265 19 is_stmt 0 view .LVU2951
 10758 13ba F201     		lsls	r2, r6, #7
 10759 13bc 3D4B     		ldr	r3, .L591
 10760 13be 9B18     		adds	r3, r3, r2
 10761 13c0 1861     		str	r0, [r3, #16]
 10762 13c2 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10763              		.loc 1 266 2 is_stmt 1 view .LVU2952
 266:Src/usb_pd_protocol.c **** }
 10764              		.loc 1 266 25 is_stmt 0 view .LVU2953
 10765 13c4 0D22     		movs	r2, #13
 10766 13c6 DA71     		strb	r2, [r3, #7]
 10767 13c8 4CE7     		b	.L354
 10768              	.LVL804:
 10769              	.L375:
 266:Src/usb_pd_protocol.c **** }
 10770              		.loc 1 266 25 view .LVU2954
 10771              	.LBE1069:
 10772              	.LBE1068:
3096:Src/usb_pd_protocol.c **** 		if (res < 0) {
 10773              		.loc 1 3096 3 is_stmt 1 view .LVU2955
3096:Src/usb_pd_protocol.c **** 		if (res < 0) {
 10774              		.loc 1 3096 9 is_stmt 0 view .LVU2956
 10775 13ca 0621     		movs	r1, #6
 10776 13cc 3000     		movs	r0, r6
 10777 13ce FFF7FEFF 		bl	send_control
 10778              	.LVL805:
3097:Src/usb_pd_protocol.c **** 			/* Restore Rd */
 10779              		.loc 1 3097 3 is_stmt 1 view .LVU2957
3097:Src/usb_pd_protocol.c **** 			/* Restore Rd */
 10780              		.loc 1 3097 6 is_stmt 0 view .LVU2958
 10781 13d2 0028     		cmp	r0, #0
 10782 13d4 32DA     		bge	.L479
3099:Src/usb_pd_protocol.c **** 			pd_power_supply_reset(port);
 10783              		.loc 1 3099 4 is_stmt 1 view .LVU2959
 10784              	.LVL806:
 10785              	.LBB1070:
 10786              	.LBI1070:
  73:Inc/tcpm.h    **** {
 10787              		.loc 2 73 19 view .LVU2960
 10788              	.LBB1071:
  75:Inc/tcpm.h    **** }
 10789              		.loc 2 75 2 view .LVU2961
  75:Inc/tcpm.h    **** }
 10790              		.loc 2 75 9 is_stmt 0 view .LVU2962
 10791 13d6 0221     		movs	r1, #2
 10792 13d8 3000     		movs	r0, r6
 10793 13da 7B69     		ldr	r3, [r7, #20]
 10794 13dc 9847     		blx	r3
 10795              	.LVL807:
  75:Inc/tcpm.h    **** }
 10796              		.loc 2 75 9 view .LVU2963
 10797              	.LBE1071:
 10798              	.LBE1070:
3100:Src/usb_pd_protocol.c **** 			timeout = 10 * MSEC_US;
 10799              		.loc 1 3100 4 is_stmt 1 view .LVU2964
 10800 13de 3000     		movs	r0, r6
ARM GAS  /tmp/ccoQIC4J.s 			page 292


 10801 13e0 FFF7FEFF 		bl	pd_power_supply_reset
 10802              	.LVL808:
3101:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
 10803              		.loc 1 3101 4 view .LVU2965
3101:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SNK_DISCONNECTED);
 10804              		.loc 1 3101 12 is_stmt 0 view .LVU2966
 10805 13e4 344B     		ldr	r3, .L591+4
 10806 13e6 354A     		ldr	r2, .L591+8
 10807 13e8 1A60     		str	r2, [r3]
3102:Src/usb_pd_protocol.c **** 			break;
 10808              		.loc 1 3102 4 is_stmt 1 view .LVU2967
 10809              	.LVL809:
 10810              	.LBB1072:
 10811              	.LBI1072:
 326:Src/usb_pd_protocol.c **** {
 10812              		.loc 1 326 20 view .LVU2968
 10813              	.LBB1073:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10814              		.loc 1 328 2 view .LVU2969
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10815              		.loc 1 328 17 is_stmt 0 view .LVU2970
 10816 13ea F201     		lsls	r2, r6, #7
 10817 13ec 314B     		ldr	r3, .L591
 10818 13ee 9B18     		adds	r3, r3, r2
 10819 13f0 1A79     		ldrb	r2, [r3, #4]
 10820              	.LVL810:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 10821              		.loc 1 333 2 is_stmt 1 view .LVU2971
 10822              	.LBB1074:
 10823              	.LBI1074:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10824              		.loc 1 261 20 view .LVU2972
 10825              	.LBB1075:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10826              		.loc 1 265 2 view .LVU2973
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10827              		.loc 1 265 19 is_stmt 0 view .LVU2974
 10828 13f2 0020     		movs	r0, #0
 10829 13f4 0021     		movs	r1, #0
 10830 13f6 1861     		str	r0, [r3, #16]
 10831 13f8 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 10832              		.loc 1 266 2 is_stmt 1 view .LVU2975
 266:Src/usb_pd_protocol.c **** }
 10833              		.loc 1 266 25 is_stmt 0 view .LVU2976
 10834 13fa 0021     		movs	r1, #0
 10835 13fc D971     		strb	r1, [r3, #7]
 10836              	.LVL811:
 266:Src/usb_pd_protocol.c **** }
 10837              		.loc 1 266 25 view .LVU2977
 10838              	.LBE1075:
 10839              	.LBE1074:
 334:Src/usb_pd_protocol.c **** 
 10840              		.loc 1 334 2 is_stmt 1 view .LVU2978
 334:Src/usb_pd_protocol.c **** 
 10841              		.loc 1 334 22 is_stmt 0 view .LVU2979
 10842 13fe 0231     		adds	r1, r1, #2
ARM GAS  /tmp/ccoQIC4J.s 			page 293


 10843 1400 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 10844              		.loc 1 336 2 is_stmt 1 view .LVU2980
 336:Src/usb_pd_protocol.c **** 		return;
 10845              		.loc 1 336 5 is_stmt 0 view .LVU2981
 10846 1402 022A     		cmp	r2, #2
 10847 1404 00D1     		bne	.LCB10130
 10848 1406 2DE7     		b	.L354	@long jump
 10849              	.LCB10130:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 10850              		.loc 1 347 2 is_stmt 1 view .LVU2982
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 10851              		.loc 1 348 48 is_stmt 0 view .LVU2983
 10852 1408 0E2A     		cmp	r2, #14
 10853 140a 00D1     		bne	.LCB10133
 10854 140c 2AE7     		b	.L354	@long jump
 10855              	.LCB10133:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 10856              		.loc 1 353 2 is_stmt 1 view .LVU2984
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 10857              		.loc 1 356 3 view .LVU2985
 10858 140e 0022     		movs	r2, #0
 10859              	.LVL812:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 10860              		.loc 1 356 3 is_stmt 0 view .LVU2986
 10861 1410 0021     		movs	r1, #0
 10862 1412 3000     		movs	r0, r6
 10863 1414 FFF7FEFF 		bl	pd_set_input_current_limit
 10864              	.LVL813:
 373:Src/usb_pd_protocol.c **** 			/*
 10865              		.loc 1 373 3 is_stmt 1 view .LVU2987
 373:Src/usb_pd_protocol.c **** 			/*
 10866              		.loc 1 373 15 is_stmt 0 view .LVU2988
 10867 1418 F301     		lsls	r3, r6, #7
 10868 141a 264A     		ldr	r2, .L591
 10869 141c 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 10870              		.loc 1 373 6 view .LVU2989
 10871 141e 012B     		cmp	r3, #1
 10872 1420 08D0     		beq	.L571
 10873              	.L480:
 405:Src/usb_pd_protocol.c **** 	}
 10874              		.loc 1 405 3 is_stmt 1 view .LVU2990
 10875              	.LVL814:
 10876              	.LBB1076:
 10877              	.LBI1076:
  94:Inc/tcpm.h    **** {
 10878              		.loc 2 94 19 view .LVU2991
 10879              	.LBB1077:
  96:Inc/tcpm.h    **** }
 10880              		.loc 2 96 2 view .LVU2992
  96:Inc/tcpm.h    **** }
 10881              		.loc 2 96 26 is_stmt 0 view .LVU2993
 10882 1422 3201     		lsls	r2, r6, #4
 10883 1424 264B     		ldr	r3, .L591+12
 10884 1426 9B18     		adds	r3, r3, r2
 10885 1428 9B68     		ldr	r3, [r3, #8]
ARM GAS  /tmp/ccoQIC4J.s 			page 294


  96:Inc/tcpm.h    **** }
 10886              		.loc 2 96 30 view .LVU2994
 10887 142a 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 10888              		.loc 2 96 9 view .LVU2995
 10889 142c 0021     		movs	r1, #0
 10890 142e 3000     		movs	r0, r6
 10891 1430 9847     		blx	r3
 10892              	.LVL815:
 10893 1432 17E7     		b	.L354
 10894              	.LVL816:
 10895              	.L571:
  96:Inc/tcpm.h    **** }
 10896              		.loc 2 96 9 view .LVU2996
 10897              	.LBE1077:
 10898              	.LBE1076:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 10899              		.loc 1 378 4 is_stmt 1 view .LVU2997
 10900 1434 3000     		movs	r0, r6
 10901 1436 FFF7FEFF 		bl	pd_power_supply_reset
 10902              	.LVL817:
 10903 143a F2E7     		b	.L480
 10904              	.LVL818:
 10905              	.L479:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 10906              		.loc 1 378 4 is_stmt 0 view .LVU2998
 10907              	.LBE1073:
 10908              	.LBE1072:
3107:Src/usb_pd_protocol.c **** 		caps_count = 0;
 10909              		.loc 1 3107 3 is_stmt 1 view .LVU2999
3107:Src/usb_pd_protocol.c **** 		caps_count = 0;
 10910              		.loc 1 3107 17 is_stmt 0 view .LVU3000
 10911 143c 254B     		ldr	r3, .L591+32
 10912 143e 0422     		movs	r2, #4
 10913 1440 1A60     		str	r2, [r3]
3108:Src/usb_pd_protocol.c **** 		pd[port].msg_id = 0;
 10914              		.loc 1 3108 3 is_stmt 1 view .LVU3001
3108:Src/usb_pd_protocol.c **** 		pd[port].msg_id = 0;
 10915              		.loc 1 3108 14 is_stmt 0 view .LVU3002
 10916 1442 0025     		movs	r5, #0
 10917 1444 244B     		ldr	r3, .L591+36
 10918 1446 1D60     		str	r5, [r3]
3109:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
 10919              		.loc 1 3109 3 is_stmt 1 view .LVU3003
3109:Src/usb_pd_protocol.c **** 		pd[port].power_role = PD_ROLE_SOURCE;
 10920              		.loc 1 3109 19 is_stmt 0 view .LVU3004
 10921 1448 1A4B     		ldr	r3, .L591
 10922 144a F201     		lsls	r2, r6, #7
 10923 144c 9C18     		adds	r4, r3, r2
 10924 144e A570     		strb	r5, [r4, #2]
3110:Src/usb_pd_protocol.c **** 		pd_update_roles(port);
 10925              		.loc 1 3110 3 is_stmt 1 view .LVU3005
3110:Src/usb_pd_protocol.c **** 		pd_update_roles(port);
 10926              		.loc 1 3110 23 is_stmt 0 view .LVU3006
 10927 1450 0121     		movs	r1, #1
 10928 1452 D154     		strb	r1, [r2, r3]
3111:Src/usb_pd_protocol.c **** 		set_state(port, PD_STATE_SRC_DISCOVERY);
ARM GAS  /tmp/ccoQIC4J.s 			page 295


 10929              		.loc 1 3111 3 is_stmt 1 view .LVU3007
 10930 1454 3000     		movs	r0, r6
 10931 1456 FFF7FEFF 		bl	pd_update_roles
 10932              	.LVL819:
3112:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
 10933              		.loc 1 3112 3 view .LVU3008
 10934              	.LBB1078:
 10935              	.LBI1078:
 326:Src/usb_pd_protocol.c **** {
 10936              		.loc 1 326 20 view .LVU3009
 10937              	.LBB1079:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 10938              		.loc 1 328 2 view .LVU3010
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 10939              		.loc 1 333 2 view .LVU3011
 10940              	.LBB1080:
 10941              	.LBI1080:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 10942              		.loc 1 261 20 view .LVU3012
 10943              	.LBB1081:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10944              		.loc 1 265 2 view .LVU3013
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 10945              		.loc 1 265 19 is_stmt 0 view .LVU3014
 10946 145a 0022     		movs	r2, #0
 10947 145c 0023     		movs	r3, #0
 10948 145e 2261     		str	r2, [r4, #16]
 10949 1460 6361     		str	r3, [r4, #20]
 266:Src/usb_pd_protocol.c **** }
 10950              		.loc 1 266 2 is_stmt 1 view .LVU3015
 266:Src/usb_pd_protocol.c **** }
 10951              		.loc 1 266 25 is_stmt 0 view .LVU3016
 10952 1462 E571     		strb	r5, [r4, #7]
 10953              	.LVL820:
 266:Src/usb_pd_protocol.c **** }
 10954              		.loc 1 266 25 view .LVU3017
 10955              	.LBE1081:
 10956              	.LBE1080:
 334:Src/usb_pd_protocol.c **** 
 10957              		.loc 1 334 2 is_stmt 1 view .LVU3018
 334:Src/usb_pd_protocol.c **** 
 10958              		.loc 1 334 22 is_stmt 0 view .LVU3019
 10959 1464 1223     		movs	r3, #18
 10960 1466 2371     		strb	r3, [r4, #4]
 10961              	.LVL821:
 336:Src/usb_pd_protocol.c **** 		return;
 10962              		.loc 1 336 2 is_stmt 1 view .LVU3020
 336:Src/usb_pd_protocol.c **** 		return;
 10963              		.loc 1 336 2 is_stmt 0 view .LVU3021
 10964              	.LBE1079:
 10965              	.LBE1078:
3113:Src/usb_pd_protocol.c **** 		break;
 10966              		.loc 1 3113 3 is_stmt 1 view .LVU3022
3113:Src/usb_pd_protocol.c **** 		break;
 10967              		.loc 1 3113 11 is_stmt 0 view .LVU3023
 10968 1468 134B     		ldr	r3, .L591+4
 10969 146a 144A     		ldr	r2, .L591+8
ARM GAS  /tmp/ccoQIC4J.s 			page 296


 10970 146c 1A60     		str	r2, [r3]
3114:Src/usb_pd_protocol.c **** #ifdef CONFIG_USBC_VCONN_SWAP
 10971              		.loc 1 3114 3 is_stmt 1 view .LVU3024
 10972 146e F9E6     		b	.L354
 10973              	.L358:
3185:Src/usb_pd_protocol.c **** 			/* Message ID of soft reset is always 0 */
 10974              		.loc 1 3185 3 view .LVU3025
3185:Src/usb_pd_protocol.c **** 			/* Message ID of soft reset is always 0 */
 10975              		.loc 1 3185 15 is_stmt 0 view .LVU3026
 10976 1470 F101     		lsls	r1, r6, #7
 10977 1472 104A     		ldr	r2, .L591
 10978 1474 5218     		adds	r2, r2, r1
 10979 1476 5279     		ldrb	r2, [r2, #5]
3185:Src/usb_pd_protocol.c **** 			/* Message ID of soft reset is always 0 */
 10980              		.loc 1 3185 6 view .LVU3027
 10981 1478 9342     		cmp	r3, r2
 10982 147a 00D1     		bne	.LCB10258
 10983 147c F2E6     		b	.L354	@long jump
 10984              	.LCB10258:
3187:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_SOFT_RESET);
 10985              		.loc 1 3187 4 is_stmt 1 view .LVU3028
3187:Src/usb_pd_protocol.c **** 			res = send_control(port, PD_CTRL_SOFT_RESET);
 10986              		.loc 1 3187 20 is_stmt 0 view .LVU3029
 10987 147e 0D4B     		ldr	r3, .L591
 10988 1480 5B18     		adds	r3, r3, r1
 10989 1482 0022     		movs	r2, #0
 10990 1484 9A70     		strb	r2, [r3, #2]
3188:Src/usb_pd_protocol.c **** 
 10991              		.loc 1 3188 4 is_stmt 1 view .LVU3030
3188:Src/usb_pd_protocol.c **** 
 10992              		.loc 1 3188 10 is_stmt 0 view .LVU3031
 10993 1486 0D21     		movs	r1, #13
 10994 1488 3000     		movs	r0, r6
 10995 148a FFF7FEFF 		bl	send_control
 10996              	.LVL822:
3191:Src/usb_pd_protocol.c **** 				set_state(port,
 10997              		.loc 1 3191 4 is_stmt 1 view .LVU3032
3191:Src/usb_pd_protocol.c **** 				set_state(port,
 10998              		.loc 1 3191 7 is_stmt 0 view .LVU3033
 10999 148e 0028     		cmp	r0, #0
 11000 1490 24DB     		blt	.L572
3198:Src/usb_pd_protocol.c **** 				port,
 11001              		.loc 1 3198 4 is_stmt 1 view .LVU3034
3200:Src/usb_pd_protocol.c **** 				PD_STATE_HARD_RESET_SEND);
 11002              		.loc 1 3200 5 is_stmt 0 view .LVU3035
 11003 1492 04A8     		add	r0, sp, #16
 11004 1494 FFF7FEFF 		bl	get_time
 11005              	.LVL823:
3198:Src/usb_pd_protocol.c **** 				port,
 11006              		.loc 1 3198 4 view .LVU3036
 11007 1498 0A48     		ldr	r0, .L591+16
 11008 149a 0021     		movs	r1, #0
 11009 149c 049B     		ldr	r3, [sp, #16]
 11010 149e 059C     		ldr	r4, [sp, #20]
 11011 14a0 C018     		adds	r0, r0, r3
 11012 14a2 6141     		adcs	r1, r1, r4
 11013              	.LVL824:
ARM GAS  /tmp/ccoQIC4J.s 			page 297


 11014              	.LBB1082:
 11015              	.LBI1082:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 11016              		.loc 1 261 20 is_stmt 1 view .LVU3037
 11017              	.LBB1083:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11018              		.loc 1 265 2 view .LVU3038
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11019              		.loc 1 265 19 is_stmt 0 view .LVU3039
 11020 14a4 F201     		lsls	r2, r6, #7
 11021 14a6 034B     		ldr	r3, .L591
 11022 14a8 9B18     		adds	r3, r3, r2
 11023 14aa 1861     		str	r0, [r3, #16]
 11024 14ac 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 11025              		.loc 1 266 2 is_stmt 1 view .LVU3040
 266:Src/usb_pd_protocol.c **** }
 11026              		.loc 1 266 25 is_stmt 0 view .LVU3041
 11027 14ae 1F22     		movs	r2, #31
 11028 14b0 DA71     		strb	r2, [r3, #7]
 11029 14b2 D7E6     		b	.L354
 11030              	.L592:
 11031              		.align	2
 11032              	.L591:
 11033 14b4 00000000 		.word	pd
 11034 14b8 00000000 		.word	.LANCHOR5
 11035 14bc 10270000 		.word	10000
 11036 14c0 00000000 		.word	tcpc_config
 11037 14c4 A0860100 		.word	100000
 11038 14c8 00000000 		.word	.LANCHOR1
 11039 14cc 00000000 		.word	.LANCHOR17
 11040 14d0 C0090E00 		.word	920000
 11041 14d4 00000000 		.word	.LANCHOR12
 11042 14d8 00000000 		.word	.LANCHOR11
 11043              	.LVL825:
 11044              	.L572:
 266:Src/usb_pd_protocol.c **** }
 11045              		.loc 1 266 25 view .LVU3042
 11046              	.LBE1083:
 11047              	.LBE1082:
3192:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_SEND);
 11048              		.loc 1 3192 5 is_stmt 1 view .LVU3043
 11049              	.LBB1084:
 11050              	.LBI1084:
 326:Src/usb_pd_protocol.c **** {
 11051              		.loc 1 326 20 view .LVU3044
 11052              	.LBB1085:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 11053              		.loc 1 328 2 view .LVU3045
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 11054              		.loc 1 333 2 view .LVU3046
 11055              	.LBB1086:
 11056              	.LBI1086:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 11057              		.loc 1 261 20 view .LVU3047
 11058              	.LBB1087:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
ARM GAS  /tmp/ccoQIC4J.s 			page 298


 11059              		.loc 1 265 2 view .LVU3048
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11060              		.loc 1 265 19 is_stmt 0 view .LVU3049
 11061 14dc F201     		lsls	r2, r6, #7
 11062 14de 974B     		ldr	r3, .L593
 11063 14e0 9B18     		adds	r3, r3, r2
 11064 14e2 0020     		movs	r0, #0
 11065 14e4 0021     		movs	r1, #0
 11066 14e6 1861     		str	r0, [r3, #16]
 11067 14e8 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 11068              		.loc 1 266 2 is_stmt 1 view .LVU3050
 266:Src/usb_pd_protocol.c **** }
 11069              		.loc 1 266 25 is_stmt 0 view .LVU3051
 11070 14ea 0022     		movs	r2, #0
 11071 14ec DA71     		strb	r2, [r3, #7]
 11072              	.LVL826:
 266:Src/usb_pd_protocol.c **** }
 11073              		.loc 1 266 25 view .LVU3052
 11074              	.LBE1087:
 11075              	.LBE1086:
 334:Src/usb_pd_protocol.c **** 
 11076              		.loc 1 334 2 is_stmt 1 view .LVU3053
 334:Src/usb_pd_protocol.c **** 
 11077              		.loc 1 334 22 is_stmt 0 view .LVU3054
 11078 14ee 1F32     		adds	r2, r2, #31
 11079 14f0 1A71     		strb	r2, [r3, #4]
 11080              	.LVL827:
 336:Src/usb_pd_protocol.c **** 		return;
 11081              		.loc 1 336 2 is_stmt 1 view .LVU3055
 336:Src/usb_pd_protocol.c **** 		return;
 11082              		.loc 1 336 2 is_stmt 0 view .LVU3056
 11083              	.LBE1085:
 11084              	.LBE1084:
3194:Src/usb_pd_protocol.c **** 				break;
 11085              		.loc 1 3194 5 is_stmt 1 view .LVU3057
3194:Src/usb_pd_protocol.c **** 				break;
 11086              		.loc 1 3194 13 is_stmt 0 view .LVU3058
 11087 14f2 934B     		ldr	r3, .L593+4
 11088 14f4 934A     		ldr	r2, .L593+8
 11089 14f6 1A60     		str	r2, [r3]
3195:Src/usb_pd_protocol.c **** 			}
 11090              		.loc 1 3195 5 is_stmt 1 view .LVU3059
 11091 14f8 B4E6     		b	.L354
 11092              	.L357:
3205:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 11093              		.loc 1 3205 3 view .LVU3060
3205:Src/usb_pd_protocol.c **** 		if (pd[port].last_state != pd[port].task_state)
 11094              		.loc 1 3205 19 is_stmt 0 view .LVU3061
 11095 14fa 9349     		ldr	r1, .L593+12
 11096 14fc 0A68     		ldr	r2, [r1]
 11097 14fe 0132     		adds	r2, r2, #1
 11098 1500 0A60     		str	r2, [r1]
3206:Src/usb_pd_protocol.c **** 			hard_reset_sent = 0;
 11099              		.loc 1 3206 3 is_stmt 1 view .LVU3062
3206:Src/usb_pd_protocol.c **** 			hard_reset_sent = 0;
 11100              		.loc 1 3206 15 is_stmt 0 view .LVU3063
ARM GAS  /tmp/ccoQIC4J.s 			page 299


 11101 1502 F101     		lsls	r1, r6, #7
 11102 1504 8D4A     		ldr	r2, .L593
 11103 1506 5218     		adds	r2, r2, r1
 11104 1508 5279     		ldrb	r2, [r2, #5]
3206:Src/usb_pd_protocol.c **** 			hard_reset_sent = 0;
 11105              		.loc 1 3206 6 view .LVU3064
 11106 150a 9342     		cmp	r3, r2
 11107 150c 02D0     		beq	.L482
3207:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11108              		.loc 1 3207 4 is_stmt 1 view .LVU3065
3207:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11109              		.loc 1 3207 20 is_stmt 0 view .LVU3066
 11110 150e 8F4B     		ldr	r3, .L593+16
 11111 1510 0021     		movs	r1, #0
 11112 1512 1960     		str	r1, [r3]
 11113              	.L482:
3209:Src/usb_pd_protocol.c **** 			(pd[port].last_state == PD_STATE_SOFT_RESET &&
 11114              		.loc 1 3209 3 is_stmt 1 view .LVU3067
3209:Src/usb_pd_protocol.c **** 			(pd[port].last_state == PD_STATE_SOFT_RESET &&
 11115              		.loc 1 3209 6 is_stmt 0 view .LVU3068
 11116 1514 052A     		cmp	r2, #5
 11117 1516 07D0     		beq	.L483
3209:Src/usb_pd_protocol.c **** 			(pd[port].last_state == PD_STATE_SOFT_RESET &&
 11118              		.loc 1 3209 53 discriminator 1 view .LVU3069
 11119 1518 1E2A     		cmp	r2, #30
 11120 151a 0CD1     		bne	.L484
3211:Src/usb_pd_protocol.c **** 			pd[port].flags &= ~PD_FLAGS_VBUS_NEVER_LOW;
 11121              		.loc 1 3211 17 view .LVU3070
 11122 151c F201     		lsls	r2, r6, #7
 11123 151e 874B     		ldr	r3, .L593
 11124 1520 9B18     		adds	r3, r3, r2
 11125 1522 9B68     		ldr	r3, [r3, #8]
3210:Src/usb_pd_protocol.c **** 			    (pd[port].flags & PD_FLAGS_VBUS_NEVER_LOW))) {
 11126              		.loc 1 3210 48 view .LVU3071
 11127 1524 1B06     		lsls	r3, r3, #24
 11128 1526 06D5     		bpl	.L484
 11129              	.L483:
3212:Src/usb_pd_protocol.c **** 			/*
 11130              		.loc 1 3212 4 is_stmt 1 view .LVU3072
3212:Src/usb_pd_protocol.c **** 			/*
 11131              		.loc 1 3212 19 is_stmt 0 view .LVU3073
 11132 1528 F201     		lsls	r2, r6, #7
 11133 152a 844B     		ldr	r3, .L593
 11134 152c 9B18     		adds	r3, r3, r2
 11135 152e 8022     		movs	r2, #128
 11136 1530 9968     		ldr	r1, [r3, #8]
 11137 1532 9143     		bics	r1, r2
 11138 1534 9960     		str	r1, [r3, #8]
 11139              	.L484:
3228:Src/usb_pd_protocol.c **** 			if (pd_transmit(port, TCPC_TX_HARD_RESET,
 11140              		.loc 1 3228 3 is_stmt 1 view .LVU3074
3228:Src/usb_pd_protocol.c **** 			if (pd_transmit(port, TCPC_TX_HARD_RESET,
 11141              		.loc 1 3228 7 is_stmt 0 view .LVU3075
 11142 1536 854B     		ldr	r3, .L593+16
 11143 1538 1B68     		ldr	r3, [r3]
3228:Src/usb_pd_protocol.c **** 			if (pd_transmit(port, TCPC_TX_HARD_RESET,
 11144              		.loc 1 3228 6 view .LVU3076
ARM GAS  /tmp/ccoQIC4J.s 			page 300


 11145 153a 002B     		cmp	r3, #0
 11146 153c 00D0     		beq	.LCB10417
 11147 153e 91E6     		b	.L354	@long jump
 11148              	.LCB10417:
3229:Src/usb_pd_protocol.c **** 					0, NULL) < 0) {
 11149              		.loc 1 3229 4 is_stmt 1 view .LVU3077
3229:Src/usb_pd_protocol.c **** 					0, NULL) < 0) {
 11150              		.loc 1 3229 8 is_stmt 0 view .LVU3078
 11151 1540 0022     		movs	r2, #0
 11152 1542 0521     		movs	r1, #5
 11153 1544 3000     		movs	r0, r6
 11154 1546 FFF7FEFF 		bl	pd_transmit
 11155              	.LVL828:
3229:Src/usb_pd_protocol.c **** 					0, NULL) < 0) {
 11156              		.loc 1 3229 7 view .LVU3079
 11157 154a 0028     		cmp	r0, #0
 11158 154c 16DB     		blt	.L573
3236:Src/usb_pd_protocol.c **** 			/*
 11159              		.loc 1 3236 4 is_stmt 1 view .LVU3080
3236:Src/usb_pd_protocol.c **** 			/*
 11160              		.loc 1 3236 20 is_stmt 0 view .LVU3081
 11161 154e 7F4B     		ldr	r3, .L593+16
 11162 1550 0122     		movs	r2, #1
 11163 1552 1A60     		str	r2, [r3]
3241:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
 11164              		.loc 1 3241 4 is_stmt 1 view .LVU3082
3241:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
 11165              		.loc 1 3241 16 is_stmt 0 view .LVU3083
 11166 1554 F301     		lsls	r3, r6, #7
 11167 1556 794A     		ldr	r2, .L593
 11168 1558 9B5C     		ldrb	r3, [r3, r2]
3241:Src/usb_pd_protocol.c **** 				set_state_timeout(port,
 11169              		.loc 1 3241 7 view .LVU3084
 11170 155a 012B     		cmp	r3, #1
 11171 155c 12D0     		beq	.L574
3246:Src/usb_pd_protocol.c **** 						PD_STATE_HARD_RESET_EXECUTE);
 11172              		.loc 1 3246 5 is_stmt 1 view .LVU3085
 11173              	.LVL829:
 11174              	.LBB1088:
 11175              	.LBI1088:
 326:Src/usb_pd_protocol.c **** {
 11176              		.loc 1 326 20 view .LVU3086
 11177              	.LBB1089:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 11178              		.loc 1 328 2 view .LVU3087
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 11179              		.loc 1 333 2 view .LVU3088
 11180              	.LBB1090:
 11181              	.LBI1090:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 11182              		.loc 1 261 20 view .LVU3089
 11183              	.LBB1091:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11184              		.loc 1 265 2 view .LVU3090
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11185              		.loc 1 265 19 is_stmt 0 view .LVU3091
 11186 155e F201     		lsls	r2, r6, #7
ARM GAS  /tmp/ccoQIC4J.s 			page 301


 11187 1560 764B     		ldr	r3, .L593
 11188 1562 9B18     		adds	r3, r3, r2
 11189 1564 0020     		movs	r0, #0
 11190 1566 0021     		movs	r1, #0
 11191 1568 1861     		str	r0, [r3, #16]
 11192 156a 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 11193              		.loc 1 266 2 is_stmt 1 view .LVU3092
 266:Src/usb_pd_protocol.c **** }
 11194              		.loc 1 266 25 is_stmt 0 view .LVU3093
 11195 156c 0022     		movs	r2, #0
 11196 156e DA71     		strb	r2, [r3, #7]
 11197              	.LVL830:
 266:Src/usb_pd_protocol.c **** }
 11198              		.loc 1 266 25 view .LVU3094
 11199              	.LBE1091:
 11200              	.LBE1090:
 334:Src/usb_pd_protocol.c **** 
 11201              		.loc 1 334 2 is_stmt 1 view .LVU3095
 334:Src/usb_pd_protocol.c **** 
 11202              		.loc 1 334 22 is_stmt 0 view .LVU3096
 11203 1570 2032     		adds	r2, r2, #32
 11204 1572 1A71     		strb	r2, [r3, #4]
 11205              	.LVL831:
 336:Src/usb_pd_protocol.c **** 		return;
 11206              		.loc 1 336 2 is_stmt 1 view .LVU3097
 336:Src/usb_pd_protocol.c **** 		return;
 11207              		.loc 1 336 2 is_stmt 0 view .LVU3098
 11208              	.LBE1089:
 11209              	.LBE1088:
3248:Src/usb_pd_protocol.c **** 			}
 11210              		.loc 1 3248 5 is_stmt 1 view .LVU3099
3248:Src/usb_pd_protocol.c **** 			}
 11211              		.loc 1 3248 13 is_stmt 0 view .LVU3100
 11212 1574 724B     		ldr	r3, .L593+4
 11213 1576 764A     		ldr	r2, .L593+20
 11214 1578 1A60     		str	r2, [r3]
 11215 157a 73E6     		b	.L354
 11216              	.L573:
3231:Src/usb_pd_protocol.c **** 				break;
 11217              		.loc 1 3231 5 is_stmt 1 view .LVU3101
3231:Src/usb_pd_protocol.c **** 				break;
 11218              		.loc 1 3231 13 is_stmt 0 view .LVU3102
 11219 157c 704B     		ldr	r3, .L593+4
 11220 157e 744A     		ldr	r2, .L593+20
 11221 1580 1A60     		str	r2, [r3]
3232:Src/usb_pd_protocol.c **** 			}
 11222              		.loc 1 3232 5 is_stmt 1 view .LVU3103
 11223 1582 6FE6     		b	.L354
 11224              	.L574:
3242:Src/usb_pd_protocol.c **** 					get_time().val + PD_T_PS_HARD_RESET,
 11225              		.loc 1 3242 5 view .LVU3104
3243:Src/usb_pd_protocol.c **** 					PD_STATE_HARD_RESET_EXECUTE);
 11226              		.loc 1 3243 6 is_stmt 0 view .LVU3105
 11227 1584 04A8     		add	r0, sp, #16
 11228 1586 FFF7FEFF 		bl	get_time
 11229              	.LVL832:
ARM GAS  /tmp/ccoQIC4J.s 			page 302


3242:Src/usb_pd_protocol.c **** 					get_time().val + PD_T_PS_HARD_RESET,
 11230              		.loc 1 3242 5 view .LVU3106
 11231 158a 7248     		ldr	r0, .L593+24
 11232 158c 0021     		movs	r1, #0
 11233 158e 049B     		ldr	r3, [sp, #16]
 11234 1590 059C     		ldr	r4, [sp, #20]
 11235 1592 C018     		adds	r0, r0, r3
 11236 1594 6141     		adcs	r1, r1, r4
 11237              	.LVL833:
 11238              	.LBB1092:
 11239              	.LBI1092:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 11240              		.loc 1 261 20 is_stmt 1 view .LVU3107
 11241              	.LBB1093:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11242              		.loc 1 265 2 view .LVU3108
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11243              		.loc 1 265 19 is_stmt 0 view .LVU3109
 11244 1596 F201     		lsls	r2, r6, #7
 11245 1598 684B     		ldr	r3, .L593
 11246 159a 9B18     		adds	r3, r3, r2
 11247 159c 1861     		str	r0, [r3, #16]
 11248 159e 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 11249              		.loc 1 266 2 is_stmt 1 view .LVU3110
 266:Src/usb_pd_protocol.c **** }
 11250              		.loc 1 266 25 is_stmt 0 view .LVU3111
 11251 15a0 2022     		movs	r2, #32
 11252 15a2 DA71     		strb	r2, [r3, #7]
 11253 15a4 5EE6     		b	.L354
 11254              	.LVL834:
 11255              	.L355:
 266:Src/usb_pd_protocol.c **** }
 11256              		.loc 1 266 25 view .LVU3112
 11257              	.LBE1093:
 11258              	.LBE1092:
3258:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
 11259              		.loc 1 3258 3 is_stmt 1 view .LVU3113
3258:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
 11260              		.loc 1 3258 15 is_stmt 0 view .LVU3114
 11261 15a6 F201     		lsls	r2, r6, #7
 11262 15a8 644B     		ldr	r3, .L593
 11263 15aa 9B18     		adds	r3, r3, r2
 11264 15ac 5B79     		ldrb	r3, [r3, #5]
3258:Src/usb_pd_protocol.c **** 			tcpm_set_cc(port, TYPEC_CC_RD);
 11265              		.loc 1 3258 6 view .LVU3115
 11266 15ae 0C2B     		cmp	r3, #12
 11267 15b0 06D0     		beq	.L575
 11268              	.L487:
3263:Src/usb_pd_protocol.c **** 		timeout = 10*MSEC_US;
 11269              		.loc 1 3263 3 is_stmt 1 view .LVU3116
 11270 15b2 3000     		movs	r0, r6
 11271 15b4 FFF7FEFF 		bl	pd_execute_hard_reset
 11272              	.LVL835:
3264:Src/usb_pd_protocol.c **** 		break;
 11273              		.loc 1 3264 3 view .LVU3117
3264:Src/usb_pd_protocol.c **** 		break;
ARM GAS  /tmp/ccoQIC4J.s 			page 303


 11274              		.loc 1 3264 11 is_stmt 0 view .LVU3118
 11275 15b8 614B     		ldr	r3, .L593+4
 11276 15ba 654A     		ldr	r2, .L593+20
 11277 15bc 1A60     		str	r2, [r3]
3265:Src/usb_pd_protocol.c **** #ifdef CONFIG_COMMON_RUNTIME
 11278              		.loc 1 3265 3 is_stmt 1 view .LVU3119
 11279 15be 51E6     		b	.L354
 11280              	.L575:
3259:Src/usb_pd_protocol.c **** #endif
 11281              		.loc 1 3259 4 view .LVU3120
 11282              	.LVL836:
 11283              	.LBB1094:
 11284              	.LBI1094:
  73:Inc/tcpm.h    **** {
 11285              		.loc 2 73 19 view .LVU3121
 11286              	.LBB1095:
  75:Inc/tcpm.h    **** }
 11287              		.loc 2 75 2 view .LVU3122
  75:Inc/tcpm.h    **** }
 11288              		.loc 2 75 9 is_stmt 0 view .LVU3123
 11289 15c0 0221     		movs	r1, #2
 11290 15c2 3000     		movs	r0, r6
 11291 15c4 7B69     		ldr	r3, [r7, #20]
 11292 15c6 9847     		blx	r3
 11293              	.LVL837:
 11294 15c8 F3E7     		b	.L487
 11295              	.LVL838:
 11296              	.L567:
  75:Inc/tcpm.h    **** }
 11297              		.loc 2 75 9 view .LVU3124
 11298              	.LBE1095:
 11299              	.LBE1094:
3357:Src/usb_pd_protocol.c **** 			set_state(port, pd[port].timeout_state);
 11300              		.loc 1 3357 6 view .LVU3125
 11301 15ca 8B42     		cmp	r3, r1
 11302 15cc 03D1     		bne	.L517
 11303 15ce 0299     		ldr	r1, [sp, #8]
 11304 15d0 8A42     		cmp	r2, r1
 11305 15d2 00D9     		bls	.LCB10570
 11306 15d4 62E6     		b	.L490	@long jump
 11307              	.LCB10570:
 11308              	.L517:
3358:Src/usb_pd_protocol.c **** 			/* On a state timeout, run next state soon */
 11309              		.loc 1 3358 4 is_stmt 1 view .LVU3126
 11310 15d6 F201     		lsls	r2, r6, #7
 11311 15d8 584B     		ldr	r3, .L593
 11312 15da 9B18     		adds	r3, r3, r2
 11313 15dc DA79     		ldrb	r2, [r3, #7]
 11314              	.LVL839:
 11315              	.LBB1096:
 11316              	.LBI1096:
 326:Src/usb_pd_protocol.c **** {
 11317              		.loc 1 326 20 view .LVU3127
 11318              	.LBB1097:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 11319              		.loc 1 328 2 view .LVU3128
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
ARM GAS  /tmp/ccoQIC4J.s 			page 304


 11320              		.loc 1 328 17 is_stmt 0 view .LVU3129
 11321 15de 1C79     		ldrb	r4, [r3, #4]
 11322              	.LVL840:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 11323              		.loc 1 333 2 is_stmt 1 view .LVU3130
 11324              	.LBB1098:
 11325              	.LBI1098:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 11326              		.loc 1 261 20 view .LVU3131
 11327              	.LBB1099:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11328              		.loc 1 265 2 view .LVU3132
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11329              		.loc 1 265 19 is_stmt 0 view .LVU3133
 11330 15e0 0020     		movs	r0, #0
 11331 15e2 0021     		movs	r1, #0
 11332 15e4 1861     		str	r0, [r3, #16]
 11333 15e6 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 11334              		.loc 1 266 2 is_stmt 1 view .LVU3134
 266:Src/usb_pd_protocol.c **** }
 11335              		.loc 1 266 25 is_stmt 0 view .LVU3135
 11336 15e8 0021     		movs	r1, #0
 11337 15ea D971     		strb	r1, [r3, #7]
 11338              	.LVL841:
 266:Src/usb_pd_protocol.c **** }
 11339              		.loc 1 266 25 view .LVU3136
 11340              	.LBE1099:
 11341              	.LBE1098:
 334:Src/usb_pd_protocol.c **** 
 11342              		.loc 1 334 2 is_stmt 1 view .LVU3137
 334:Src/usb_pd_protocol.c **** 
 11343              		.loc 1 334 22 is_stmt 0 view .LVU3138
 11344 15ec 1A71     		strb	r2, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 11345              		.loc 1 336 2 is_stmt 1 view .LVU3139
 336:Src/usb_pd_protocol.c **** 		return;
 11346              		.loc 1 336 5 is_stmt 0 view .LVU3140
 11347 15ee A242     		cmp	r2, r4
 11348 15f0 07D0     		beq	.L492
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 11349              		.loc 1 347 2 is_stmt 1 view .LVU3141
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 11350              		.loc 1 347 5 is_stmt 0 view .LVU3142
 11351 15f2 022C     		cmp	r4, #2
 11352 15f4 0ED0     		beq	.L576
 11353              	.L493:
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 11354              		.loc 1 348 48 view .LVU3143
 11355 15f6 0E2C     		cmp	r4, #14
 11356 15f8 0FD0     		beq	.L577
 11357              	.L494:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 11358              		.loc 1 353 2 is_stmt 1 view .LVU3144
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 11359              		.loc 1 353 5 is_stmt 0 view .LVU3145
 11360 15fa 0E2A     		cmp	r2, #14
ARM GAS  /tmp/ccoQIC4J.s 			page 305


 11361 15fc 10D0     		beq	.L495
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 11362              		.loc 1 353 46 view .LVU3146
 11363 15fe 022A     		cmp	r2, #2
 11364 1600 0ED0     		beq	.L495
 11365              	.LVL842:
 11366              	.L492:
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 11367              		.loc 1 353 46 view .LVU3147
 11368              	.LBE1097:
 11369              	.LBE1096:
3360:Src/usb_pd_protocol.c **** 		} else if (pd[port].timeout - now.val < timeout) {
 11370              		.loc 1 3360 4 is_stmt 1 view .LVU3148
3360:Src/usb_pd_protocol.c **** 		} else if (pd[port].timeout - now.val < timeout) {
 11371              		.loc 1 3360 45 is_stmt 0 view .LVU3149
 11372 1602 4F4B     		ldr	r3, .L593+4
 11373 1604 1B68     		ldr	r3, [r3]
 11374 1606 524A     		ldr	r2, .L593+20
 11375 1608 9342     		cmp	r3, r2
 11376 160a 00D9     		bls	.L497
 11377 160c 1300     		movs	r3, r2
 11378              	.L497:
3360:Src/usb_pd_protocol.c **** 		} else if (pd[port].timeout - now.val < timeout) {
 11379              		.loc 1 3360 12 view .LVU3150
 11380 160e 4C4A     		ldr	r2, .L593+4
 11381 1610 1360     		str	r3, [r2]
 11382 1612 58E6     		b	.L488
 11383              	.LVL843:
 11384              	.L576:
 11385              	.LBB1103:
 11386              	.LBB1102:
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 11387              		.loc 1 347 47 view .LVU3151
 11388 1614 0E2A     		cmp	r2, #14
 11389 1616 EED1     		bne	.L493
 11390 1618 F3E7     		b	.L492
 11391              	.L577:
 349:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SNK_DISCONNECTED))
 11392              		.loc 1 349 47 view .LVU3152
 11393 161a 022A     		cmp	r2, #2
 11394 161c EDD1     		bne	.L494
 11395 161e F0E7     		b	.L492
 11396              	.L495:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11397              		.loc 1 356 3 is_stmt 1 view .LVU3153
 11398 1620 0022     		movs	r2, #0
 11399              	.LVL844:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11400              		.loc 1 356 3 is_stmt 0 view .LVU3154
 11401 1622 0021     		movs	r1, #0
 11402 1624 3000     		movs	r0, r6
 11403 1626 FFF7FEFF 		bl	pd_set_input_current_limit
 11404              	.LVL845:
 373:Src/usb_pd_protocol.c **** 			/*
 11405              		.loc 1 373 3 is_stmt 1 view .LVU3155
 373:Src/usb_pd_protocol.c **** 			/*
 11406              		.loc 1 373 15 is_stmt 0 view .LVU3156
ARM GAS  /tmp/ccoQIC4J.s 			page 306


 11407 162a F301     		lsls	r3, r6, #7
 11408 162c 434A     		ldr	r2, .L593
 11409 162e 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 11410              		.loc 1 373 6 view .LVU3157
 11411 1630 012B     		cmp	r3, #1
 11412 1632 08D0     		beq	.L578
 11413              	.L496:
 405:Src/usb_pd_protocol.c **** 	}
 11414              		.loc 1 405 3 is_stmt 1 view .LVU3158
 11415              	.LVL846:
 11416              	.LBB1100:
 11417              	.LBI1100:
  94:Inc/tcpm.h    **** {
 11418              		.loc 2 94 19 view .LVU3159
 11419              	.LBB1101:
  96:Inc/tcpm.h    **** }
 11420              		.loc 2 96 2 view .LVU3160
  96:Inc/tcpm.h    **** }
 11421              		.loc 2 96 26 is_stmt 0 view .LVU3161
 11422 1634 3201     		lsls	r2, r6, #4
 11423 1636 484B     		ldr	r3, .L593+28
 11424 1638 9B18     		adds	r3, r3, r2
 11425 163a 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 11426              		.loc 2 96 30 view .LVU3162
 11427 163c 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 11428              		.loc 2 96 9 view .LVU3163
 11429 163e 0021     		movs	r1, #0
 11430 1640 3000     		movs	r0, r6
 11431 1642 9847     		blx	r3
 11432              	.LVL847:
 11433 1644 DDE7     		b	.L492
 11434              	.LVL848:
 11435              	.L578:
  96:Inc/tcpm.h    **** }
 11436              		.loc 2 96 9 view .LVU3164
 11437              	.LBE1101:
 11438              	.LBE1100:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 11439              		.loc 1 378 4 is_stmt 1 view .LVU3165
 11440 1646 3000     		movs	r0, r6
 11441 1648 FFF7FEFF 		bl	pd_power_supply_reset
 11442              	.LVL849:
 11443 164c F2E7     		b	.L496
 11444              	.LVL850:
 11445              	.L568:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 11446              		.loc 1 378 4 is_stmt 0 view .LVU3166
 11447              	.LBE1102:
 11448              	.LBE1103:
3375:Src/usb_pd_protocol.c **** 		if (pd[port].polarity)
 11449              		.loc 1 3375 3 is_stmt 1 view .LVU3167
 11450              	.LBB1104:
 11451              	.LBI1104:
  58:Inc/tcpm.h    **** {
ARM GAS  /tmp/ccoQIC4J.s 			page 307


 11452              		.loc 2 58 19 view .LVU3168
 11453              	.LBB1105:
  60:Inc/tcpm.h    **** }
 11454              		.loc 2 60 2 view .LVU3169
  60:Inc/tcpm.h    **** }
 11455              		.loc 2 60 30 is_stmt 0 view .LVU3170
 11456 164e BB68     		ldr	r3, [r7, #8]
  60:Inc/tcpm.h    **** }
 11457              		.loc 2 60 9 view .LVU3171
 11458 1650 424A     		ldr	r2, .L593+32
 11459 1652 4349     		ldr	r1, .L593+36
 11460 1654 3000     		movs	r0, r6
 11461 1656 9847     		blx	r3
 11462              	.LVL851:
  60:Inc/tcpm.h    **** }
 11463              		.loc 2 60 9 view .LVU3172
 11464              	.LBE1105:
 11465              	.LBE1104:
3376:Src/usb_pd_protocol.c **** 			cc1 = cc2;
 11466              		.loc 1 3376 3 is_stmt 1 view .LVU3173
3376:Src/usb_pd_protocol.c **** 			cc1 = cc2;
 11467              		.loc 1 3376 15 is_stmt 0 view .LVU3174
 11468 1658 F201     		lsls	r2, r6, #7
 11469 165a 384B     		ldr	r3, .L593
 11470 165c 9B18     		adds	r3, r3, r2
 11471 165e DB78     		ldrb	r3, [r3, #3]
3376:Src/usb_pd_protocol.c **** 			cc1 = cc2;
 11472              		.loc 1 3376 6 view .LVU3175
 11473 1660 002B     		cmp	r3, #0
 11474 1662 03D0     		beq	.L501
3377:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_OPEN) {
 11475              		.loc 1 3377 4 is_stmt 1 view .LVU3176
3377:Src/usb_pd_protocol.c **** 		if (cc1 == TYPEC_CC_VOLT_OPEN) {
 11476              		.loc 1 3377 8 is_stmt 0 view .LVU3177
 11477 1664 3D4B     		ldr	r3, .L593+32
 11478 1666 1A68     		ldr	r2, [r3]
 11479 1668 3D4B     		ldr	r3, .L593+36
 11480 166a 1A60     		str	r2, [r3]
 11481              	.L501:
3378:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
 11482              		.loc 1 3378 3 is_stmt 1 view .LVU3178
3378:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
 11483              		.loc 1 3378 11 is_stmt 0 view .LVU3179
 11484 166c 3C4B     		ldr	r3, .L593+36
 11485 166e 1B68     		ldr	r3, [r3]
3378:Src/usb_pd_protocol.c **** 			set_state(port, PD_STATE_SRC_DISCONNECTED);
 11486              		.loc 1 3378 6 view .LVU3180
 11487 1670 002B     		cmp	r3, #0
 11488 1672 00D0     		beq	.LCB10750
 11489 1674 37E6     		b	.L500	@long jump
 11490              	.LCB10750:
3379:Src/usb_pd_protocol.c **** 			/* Debouncing */
 11491              		.loc 1 3379 4 is_stmt 1 view .LVU3181
 11492              	.LVL852:
 11493              	.LBB1106:
 11494              	.LBI1106:
 326:Src/usb_pd_protocol.c **** {
ARM GAS  /tmp/ccoQIC4J.s 			page 308


 11495              		.loc 1 326 20 view .LVU3182
 11496              	.LBB1107:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 11497              		.loc 1 328 2 view .LVU3183
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 11498              		.loc 1 328 17 is_stmt 0 view .LVU3184
 11499 1676 F201     		lsls	r2, r6, #7
 11500 1678 304B     		ldr	r3, .L593
 11501 167a 9B18     		adds	r3, r3, r2
 11502 167c 1A79     		ldrb	r2, [r3, #4]
 11503              	.LVL853:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 11504              		.loc 1 333 2 is_stmt 1 view .LVU3185
 11505              	.LBB1108:
 11506              	.LBI1108:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 11507              		.loc 1 261 20 view .LVU3186
 11508              	.LBB1109:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11509              		.loc 1 265 2 view .LVU3187
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11510              		.loc 1 265 19 is_stmt 0 view .LVU3188
 11511 167e 0020     		movs	r0, #0
 11512 1680 0021     		movs	r1, #0
 11513 1682 1861     		str	r0, [r3, #16]
 11514 1684 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 11515              		.loc 1 266 2 is_stmt 1 view .LVU3189
 266:Src/usb_pd_protocol.c **** }
 11516              		.loc 1 266 25 is_stmt 0 view .LVU3190
 11517 1686 0021     		movs	r1, #0
 11518 1688 D971     		strb	r1, [r3, #7]
 11519              	.LVL854:
 266:Src/usb_pd_protocol.c **** }
 11520              		.loc 1 266 25 view .LVU3191
 11521              	.LBE1109:
 11522              	.LBE1108:
 334:Src/usb_pd_protocol.c **** 
 11523              		.loc 1 334 2 is_stmt 1 view .LVU3192
 334:Src/usb_pd_protocol.c **** 
 11524              		.loc 1 334 22 is_stmt 0 view .LVU3193
 11525 168a 0E31     		adds	r1, r1, #14
 11526 168c 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 11527              		.loc 1 336 2 is_stmt 1 view .LVU3194
 336:Src/usb_pd_protocol.c **** 		return;
 11528              		.loc 1 336 5 is_stmt 0 view .LVU3195
 11529 168e 0E2A     		cmp	r2, #14
 11530 1690 13D0     		beq	.L502
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 11531              		.loc 1 347 2 is_stmt 1 view .LVU3196
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 11532              		.loc 1 347 5 is_stmt 0 view .LVU3197
 11533 1692 022A     		cmp	r2, #2
 11534 1694 11D0     		beq	.L502
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 11535              		.loc 1 353 2 is_stmt 1 view .LVU3198
ARM GAS  /tmp/ccoQIC4J.s 			page 309


 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11536              		.loc 1 356 3 view .LVU3199
 11537 1696 0022     		movs	r2, #0
 11538              	.LVL855:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11539              		.loc 1 356 3 is_stmt 0 view .LVU3200
 11540 1698 0021     		movs	r1, #0
 11541 169a 3000     		movs	r0, r6
 11542 169c FFF7FEFF 		bl	pd_set_input_current_limit
 11543              	.LVL856:
 373:Src/usb_pd_protocol.c **** 			/*
 11544              		.loc 1 373 3 is_stmt 1 view .LVU3201
 373:Src/usb_pd_protocol.c **** 			/*
 11545              		.loc 1 373 15 is_stmt 0 view .LVU3202
 11546 16a0 F301     		lsls	r3, r6, #7
 11547 16a2 264A     		ldr	r2, .L593
 11548 16a4 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 11549              		.loc 1 373 6 view .LVU3203
 11550 16a6 012B     		cmp	r3, #1
 11551 16a8 0BD0     		beq	.L579
 11552              	.L503:
 405:Src/usb_pd_protocol.c **** 	}
 11553              		.loc 1 405 3 is_stmt 1 view .LVU3204
 11554              	.LVL857:
 11555              	.LBB1110:
 11556              	.LBI1110:
  94:Inc/tcpm.h    **** {
 11557              		.loc 2 94 19 view .LVU3205
 11558              	.LBB1111:
  96:Inc/tcpm.h    **** }
 11559              		.loc 2 96 2 view .LVU3206
  96:Inc/tcpm.h    **** }
 11560              		.loc 2 96 26 is_stmt 0 view .LVU3207
 11561 16aa 3201     		lsls	r2, r6, #4
 11562 16ac 2A4B     		ldr	r3, .L593+28
 11563 16ae 9B18     		adds	r3, r3, r2
 11564 16b0 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 11565              		.loc 2 96 30 view .LVU3208
 11566 16b2 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 11567              		.loc 2 96 9 view .LVU3209
 11568 16b4 0021     		movs	r1, #0
 11569 16b6 3000     		movs	r0, r6
 11570 16b8 9847     		blx	r3
 11571              	.LVL858:
 11572              	.L502:
  96:Inc/tcpm.h    **** }
 11573              		.loc 2 96 9 view .LVU3210
 11574              	.LBE1111:
 11575              	.LBE1110:
 11576              	.LBE1107:
 11577              	.LBE1106:
3381:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
 11578              		.loc 1 3381 4 is_stmt 1 view .LVU3211
3381:Src/usb_pd_protocol.c **** #ifdef CONFIG_USB_PD_DUAL_ROLE
ARM GAS  /tmp/ccoQIC4J.s 			page 310


 11579              		.loc 1 3381 12 is_stmt 0 view .LVU3212
 11580 16ba 214B     		ldr	r3, .L593+4
 11581 16bc 244A     		ldr	r2, .L593+20
 11582 16be 1A60     		str	r2, [r3]
3388:Src/usb_pd_protocol.c **** 				/* Swap roles to sink */
 11583              		.loc 1 3388 4 is_stmt 1 view .LVU3213
 11584 16c0 11E6     		b	.L500
 11585              	.LVL859:
 11586              	.L579:
 11587              	.LBB1113:
 11588              	.LBB1112:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 11589              		.loc 1 378 4 view .LVU3214
 11590 16c2 3000     		movs	r0, r6
 11591 16c4 FFF7FEFF 		bl	pd_power_supply_reset
 11592              	.LVL860:
 11593 16c8 EFE7     		b	.L503
 11594              	.LVL861:
 11595              	.L569:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 11596              		.loc 1 378 4 is_stmt 0 view .LVU3215
 11597              	.LBE1112:
 11598              	.LBE1113:
 11599              	.LBB1114:
 11600              	.LBI1114:
 316:Src/usb_pd_protocol.c **** {
 11601              		.loc 1 316 19 is_stmt 1 view .LVU3216
 11602              	.LBB1115:
 321:Src/usb_pd_protocol.c **** #endif
 11603              		.loc 1 321 2 view .LVU3217
 321:Src/usb_pd_protocol.c **** #endif
 11604              		.loc 1 321 9 is_stmt 0 view .LVU3218
 11605 16ca 3000     		movs	r0, r6
 11606 16cc FFF7FEFF 		bl	pd_snk_is_vbus_provided
 11607              	.LVL862:
 321:Src/usb_pd_protocol.c **** #endif
 11608              		.loc 1 321 9 view .LVU3219
 11609              	.LBE1115:
 11610              	.LBE1114:
3409:Src/usb_pd_protocol.c **** 		!pd_is_vbus_present(port) &&
 11611              		.loc 1 3409 42 view .LVU3220
 11612 16d0 0028     		cmp	r0, #0
 11613 16d2 00D0     		beq	.LCB10872
 11614 16d4 0DE6     		b	.L350	@long jump
 11615              	.LCB10872:
3411:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_HARD_RESET_EXECUTE) {
 11616              		.loc 1 3411 11 view .LVU3221
 11617 16d6 F201     		lsls	r2, r6, #7
 11618 16d8 184B     		ldr	r3, .L593
 11619 16da 9B18     		adds	r3, r3, r2
 11620 16dc 1B79     		ldrb	r3, [r3, #4]
3410:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_SNK_HARD_RESET_RECOVER &&
 11621              		.loc 1 3410 29 view .LVU3222
 11622 16de 042B     		cmp	r3, #4
 11623 16e0 00D1     		bne	.LCB10878
 11624 16e2 06E6     		b	.L350	@long jump
 11625              	.LCB10878:
ARM GAS  /tmp/ccoQIC4J.s 			page 311


3411:Src/usb_pd_protocol.c **** 		pd[port].task_state != PD_STATE_HARD_RESET_EXECUTE) {
 11626              		.loc 1 3411 58 view .LVU3223
 11627 16e4 202B     		cmp	r3, #32
 11628 16e6 00D1     		bne	.LCB10880
 11629 16e8 03E6     		b	.L350	@long jump
 11630              	.LCB10880:
3414:Src/usb_pd_protocol.c **** 		/* set timeout small to reconnect fast */
 11631              		.loc 1 3414 3 is_stmt 1 view .LVU3224
 11632              	.LVL863:
 11633              	.LBB1116:
 11634              	.LBI1116:
 326:Src/usb_pd_protocol.c **** {
 11635              		.loc 1 326 20 view .LVU3225
 11636              	.LBB1117:
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 11637              		.loc 1 328 2 view .LVU3226
 328:Src/usb_pd_protocol.c **** #ifdef CONFIG_LOW_POWER_IDLE
 11638              		.loc 1 328 17 is_stmt 0 view .LVU3227
 11639 16ea 144B     		ldr	r3, .L593
 11640 16ec 9B18     		adds	r3, r3, r2
 11641 16ee 1A79     		ldrb	r2, [r3, #4]
 11642              	.LVL864:
 333:Src/usb_pd_protocol.c **** 	pd[port].task_state = next_state;
 11643              		.loc 1 333 2 is_stmt 1 view .LVU3228
 11644              	.LBB1118:
 11645              	.LBI1118:
 261:Src/usb_pd_protocol.c **** 				     uint64_t timeout,
 11646              		.loc 1 261 20 view .LVU3229
 11647              	.LBB1119:
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11648              		.loc 1 265 2 view .LVU3230
 265:Src/usb_pd_protocol.c **** 	pd[port].timeout_state = timeout_state;
 11649              		.loc 1 265 19 is_stmt 0 view .LVU3231
 11650 16f0 0020     		movs	r0, #0
 11651 16f2 0021     		movs	r1, #0
 11652 16f4 1861     		str	r0, [r3, #16]
 11653 16f6 5961     		str	r1, [r3, #20]
 266:Src/usb_pd_protocol.c **** }
 11654              		.loc 1 266 2 is_stmt 1 view .LVU3232
 266:Src/usb_pd_protocol.c **** }
 11655              		.loc 1 266 25 is_stmt 0 view .LVU3233
 11656 16f8 0021     		movs	r1, #0
 11657 16fa D971     		strb	r1, [r3, #7]
 11658              	.LVL865:
 266:Src/usb_pd_protocol.c **** }
 11659              		.loc 1 266 25 view .LVU3234
 11660              	.LBE1119:
 11661              	.LBE1118:
 334:Src/usb_pd_protocol.c **** 
 11662              		.loc 1 334 2 is_stmt 1 view .LVU3235
 334:Src/usb_pd_protocol.c **** 
 11663              		.loc 1 334 22 is_stmt 0 view .LVU3236
 11664 16fc 0231     		adds	r1, r1, #2
 11665 16fe 1971     		strb	r1, [r3, #4]
 336:Src/usb_pd_protocol.c **** 		return;
 11666              		.loc 1 336 2 is_stmt 1 view .LVU3237
 336:Src/usb_pd_protocol.c **** 		return;
ARM GAS  /tmp/ccoQIC4J.s 			page 312


 11667              		.loc 1 336 5 is_stmt 0 view .LVU3238
 11668 1700 022A     		cmp	r2, #2
 11669 1702 13D0     		beq	.L504
 347:Src/usb_pd_protocol.c **** 	     next_state == PD_STATE_SRC_DISCONNECTED) ||
 11670              		.loc 1 347 2 is_stmt 1 view .LVU3239
 348:Src/usb_pd_protocol.c **** 	    (last_state == PD_STATE_SRC_DISCONNECTED &&
 11671              		.loc 1 348 48 is_stmt 0 view .LVU3240
 11672 1704 0E2A     		cmp	r2, #14
 11673 1706 11D0     		beq	.L504
 353:Src/usb_pd_protocol.c **** 	    next_state == PD_STATE_SNK_DISCONNECTED) {
 11674              		.loc 1 353 2 is_stmt 1 view .LVU3241
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11675              		.loc 1 356 3 view .LVU3242
 11676 1708 0022     		movs	r2, #0
 11677              	.LVL866:
 356:Src/usb_pd_protocol.c **** #ifdef CONFIG_CHARGE_MANAGER
 11678              		.loc 1 356 3 is_stmt 0 view .LVU3243
 11679 170a 0021     		movs	r1, #0
 11680 170c 3000     		movs	r0, r6
 11681 170e FFF7FEFF 		bl	pd_set_input_current_limit
 11682              	.LVL867:
 373:Src/usb_pd_protocol.c **** 			/*
 11683              		.loc 1 373 3 is_stmt 1 view .LVU3244
 373:Src/usb_pd_protocol.c **** 			/*
 11684              		.loc 1 373 15 is_stmt 0 view .LVU3245
 11685 1712 F301     		lsls	r3, r6, #7
 11686 1714 094A     		ldr	r2, .L593
 11687 1716 9B5C     		ldrb	r3, [r3, r2]
 373:Src/usb_pd_protocol.c **** 			/*
 11688              		.loc 1 373 6 view .LVU3246
 11689 1718 012B     		cmp	r3, #1
 11690 171a 0BD0     		beq	.L580
 11691              	.L505:
 405:Src/usb_pd_protocol.c **** 	}
 11692              		.loc 1 405 3 is_stmt 1 view .LVU3247
 11693              	.LVL868:
 11694              	.LBB1120:
 11695              	.LBI1120:
  94:Inc/tcpm.h    **** {
 11696              		.loc 2 94 19 view .LVU3248
 11697              	.LBB1121:
  96:Inc/tcpm.h    **** }
 11698              		.loc 2 96 2 view .LVU3249
  96:Inc/tcpm.h    **** }
 11699              		.loc 2 96 26 is_stmt 0 view .LVU3250
 11700 171c 3201     		lsls	r2, r6, #4
 11701 171e 0E4B     		ldr	r3, .L593+28
 11702 1720 9B18     		adds	r3, r3, r2
 11703 1722 9B68     		ldr	r3, [r3, #8]
  96:Inc/tcpm.h    **** }
 11704              		.loc 2 96 30 view .LVU3251
 11705 1724 5B6A     		ldr	r3, [r3, #36]
  96:Inc/tcpm.h    **** }
 11706              		.loc 2 96 9 view .LVU3252
 11707 1726 0021     		movs	r1, #0
 11708 1728 3000     		movs	r0, r6
 11709 172a 9847     		blx	r3
ARM GAS  /tmp/ccoQIC4J.s 			page 313


 11710              	.LVL869:
 11711              	.L504:
  96:Inc/tcpm.h    **** }
 11712              		.loc 2 96 9 view .LVU3253
 11713              	.LBE1121:
 11714              	.LBE1120:
 11715              	.LBE1117:
 11716              	.LBE1116:
3416:Src/usb_pd_protocol.c **** 	}
 11717              		.loc 1 3416 3 is_stmt 1 view .LVU3254
3416:Src/usb_pd_protocol.c **** 	}
 11718              		.loc 1 3416 11 is_stmt 0 view .LVU3255
 11719 172c 044B     		ldr	r3, .L593+4
 11720 172e 054A     		ldr	r2, .L593+8
 11721 1730 1A60     		str	r2, [r3]
 11722 1732 DEE5     		b	.L350
 11723              	.LVL870:
 11724              	.L580:
 11725              	.LBB1123:
 11726              	.LBB1122:
 378:Src/usb_pd_protocol.c **** #if !defined(CONFIG_USB_PD_MAX_SINGLE_SOURCE_CURRENT) && \
 11727              		.loc 1 378 4 is_stmt 1 view .LVU3256
 11728 1734 3000     		movs	r0, r6
 11729 1736 FFF7FEFF 		bl	pd_power_supply_reset
 11730              	.LVL871:
 11731 173a EFE7     		b	.L505
 11732              	.L594:
 11733              		.align	2
 11734              	.L593:
 11735 173c 00000000 		.word	pd
 11736 1740 00000000 		.word	.LANCHOR5
 11737 1744 88130000 		.word	5000
 11738 1748 00000000 		.word	.LANCHOR10
 11739 174c 00000000 		.word	.LANCHOR16
 11740 1750 10270000 		.word	10000
 11741 1754 A8610000 		.word	25000
 11742 1758 00000000 		.word	tcpc_config
 11743 175c 00000000 		.word	.LANCHOR6
 11744 1760 00000000 		.word	.LANCHOR7
 11745              	.LBE1122:
 11746              	.LBE1123:
 11747              		.cfi_endproc
 11748              	.LFE67:
 11750              		.global	drp_state
 11751              		.section	.bss.caps_count,"aw",%nobits
 11752              		.align	2
 11753              		.set	.LANCHOR11,. + 0
 11756              	caps_count:
 11757 0000 00000000 		.space	4
 11758              		.section	.bss.cc1,"aw",%nobits
 11759              		.align	2
 11760              		.set	.LANCHOR7,. + 0
 11763              	cc1:
 11764 0000 00000000 		.space	4
 11765              		.section	.bss.cc2,"aw",%nobits
 11766              		.align	2
 11767              		.set	.LANCHOR6,. + 0
ARM GAS  /tmp/ccoQIC4J.s 			page 314


 11770              	cc2:
 11771 0000 00000000 		.space	4
 11772              		.section	.bss.hard_reset_count,"aw",%nobits
 11773              		.align	2
 11774              		.set	.LANCHOR10,. + 0
 11777              	hard_reset_count:
 11778 0000 00000000 		.space	4
 11779              		.section	.bss.hard_reset_sent,"aw",%nobits
 11780              		.align	2
 11781              		.set	.LANCHOR16,. + 0
 11784              	hard_reset_sent:
 11785 0000 00000000 		.space	4
 11786              		.section	.bss.head,"aw",%nobits
 11787              		.align	2
 11788              		.set	.LANCHOR3,. + 0
 11791              	head:
 11792 0000 00000000 		.space	4
 11793              		.section	.bss.incoming_packet,"aw",%nobits
 11794              		.align	2
 11795              		.set	.LANCHOR2,. + 0
 11798              	incoming_packet:
 11799 0000 00000000 		.space	4
 11800              		.section	.bss.new_cc_state,"aw",%nobits
 11801              		.set	.LANCHOR9,. + 0
 11804              	new_cc_state:
 11805 0000 00       		.space	1
 11806              		.section	.bss.now,"aw",%nobits
 11807              		.align	3
 11808              		.set	.LANCHOR17,. + 0
 11811              	now:
 11812 0000 00000000 		.space	8
 11812      00000000 
 11813              		.section	.bss.payload,"aw",%nobits
 11814              		.align	2
 11815              		.set	.LANCHOR4,. + 0
 11818              	payload:
 11819 0000 00000000 		.space	28
 11819      00000000 
 11819      00000000 
 11819      00000000 
 11819      00000000 
 11820              		.section	.bss.pd,"aw",%nobits
 11821              		.align	3
 11824              	pd:
 11825 0000 00000000 		.space	128
 11825      00000000 
 11825      00000000 
 11825      00000000 
 11825      00000000 
 11826              		.section	.bss.snk_cap_count,"aw",%nobits
 11827              		.align	2
 11828              		.set	.LANCHOR12,. + 0
 11831              	snk_cap_count:
 11832 0000 00000000 		.space	4
 11833              		.section	.bss.snk_hard_reset_vbus_off,"aw",%nobits
 11834              		.align	2
 11835              		.set	.LANCHOR14,. + 0
ARM GAS  /tmp/ccoQIC4J.s 			page 315


 11838              	snk_hard_reset_vbus_off:
 11839 0000 00000000 		.space	4
 11840              		.section	.bss.this_state,"aw",%nobits
 11841              		.set	.LANCHOR1,. + 0
 11844              	this_state:
 11845 0000 00       		.space	1
 11846              		.section	.bss.typec_curr,"aw",%nobits
 11847              		.align	2
 11848              		.set	.LANCHOR13,. + 0
 11851              	typec_curr:
 11852 0000 00000000 		.space	4
 11853              		.section	.bss.typec_curr_change,"aw",%nobits
 11854              		.align	2
 11855              		.set	.LANCHOR15,. + 0
 11858              	typec_curr_change:
 11859 0000 00000000 		.space	4
 11860              		.section	.data.drp_state,"aw"
 11861              		.set	.LANCHOR0,. + 0
 11864              	drp_state:
 11865 0000 02       		.byte	2
 11866              		.section	.data.next_role_swap,"aw"
 11867              		.align	3
 11868              		.set	.LANCHOR8,. + 0
 11871              	next_role_swap:
 11872 0000 409C0000 		.word	40000
 11873 0004 00000000 		.word	0
 11874              		.section	.data.timeout,"aw"
 11875              		.align	2
 11876              		.set	.LANCHOR5,. + 0
 11879              	timeout:
 11880 0000 10270000 		.word	10000
 11881              		.weak	board_tcpc_post_init
 11882              		.weak	board_set_tcpc_power_mode
 11883              		.text
 11884              	.Letext0:
 11885              		.file 3 "/usr/arm-none-eabi/include/machine/_default_types.h"
 11886              		.file 4 "/usr/arm-none-eabi/include/sys/lock.h"
 11887              		.file 5 "/usr/arm-none-eabi/include/sys/_types.h"
 11888              		.file 6 "/usr/lib/gcc/arm-none-eabi/8.2.0/include/stddef.h"
 11889              		.file 7 "/usr/arm-none-eabi/include/sys/reent.h"
 11890              		.file 8 "/usr/arm-none-eabi/include/sys/_stdint.h"
 11891              		.file 9 "Inc/usb_pd_tcpm.h"
 11892              		.file 10 "Inc/FUSB302.h"
 11893              		.file 11 "Inc/tcpm_driver.h"
 11894              		.file 12 "Inc/usb_pd_driver.h"
 11895              		.file 13 "Inc/usb_pd.h"
 11896              		.file 14 "<built-in>"
ARM GAS  /tmp/ccoQIC4J.s 			page 316


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_pd_protocol.c
     /tmp/ccoQIC4J.s:16     .text.inc_id:0000000000000000 $t
     /tmp/ccoQIC4J.s:23     .text.inc_id:0000000000000000 inc_id
     /tmp/ccoQIC4J.s:53     .text.inc_id:0000000000000014 $d
     /tmp/ccoQIC4J.s:11824  .bss.pd:0000000000000000 pd
     /tmp/ccoQIC4J.s:58     .text.pd_update_roles:0000000000000000 $t
     /tmp/ccoQIC4J.s:64     .text.pd_update_roles:0000000000000000 pd_update_roles
     /tmp/ccoQIC4J.s:111    .text.pd_update_roles:000000000000001c $d
     /tmp/ccoQIC4J.s:117    .text.pd_update_pdo_flags:0000000000000000 $t
     /tmp/ccoQIC4J.s:123    .text.pd_update_pdo_flags:0000000000000000 pd_update_pdo_flags
     /tmp/ccoQIC4J.s:256    .text.pd_update_pdo_flags:0000000000000094 $d
     /tmp/ccoQIC4J.s:263    .text.vdm_get_ready_timeout:0000000000000000 $t
     /tmp/ccoQIC4J.s:269    .text.vdm_get_ready_timeout:0000000000000000 vdm_get_ready_timeout
     /tmp/ccoQIC4J.s:343    .text.vdm_get_ready_timeout:0000000000000038 $d
     /tmp/ccoQIC4J.s:352    .text.pd_is_power_swapping:0000000000000000 $t
     /tmp/ccoQIC4J.s:358    .text.pd_is_power_swapping:0000000000000000 pd_is_power_swapping
     /tmp/ccoQIC4J.s:412    .text.pd_is_power_swapping:0000000000000034 $d
     /tmp/ccoQIC4J.s:417    .text.get_typec_current_limit:0000000000000000 $t
     /tmp/ccoQIC4J.s:423    .text.get_typec_current_limit:0000000000000000 get_typec_current_limit
     /tmp/ccoQIC4J.s:513    .text.get_typec_current_limit:0000000000000034 $d
     /tmp/ccoQIC4J.s:519    .text.set_state:0000000000000000 $t
     /tmp/ccoQIC4J.s:525    .text.set_state:0000000000000000 set_state
     /tmp/ccoQIC4J.s:663    .text.set_state:000000000000006c $d
     /tmp/ccoQIC4J.s:669    .text.queue_vdm:0000000000000000 $t
     /tmp/ccoQIC4J.s:675    .text.queue_vdm:0000000000000000 queue_vdm
     /tmp/ccoQIC4J.s:736    .text.queue_vdm:000000000000002c $d
     /tmp/ccoQIC4J.s:741    .text.handle_vdm_request:0000000000000000 $t
     /tmp/ccoQIC4J.s:747    .text.handle_vdm_request:0000000000000000 handle_vdm_request
     /tmp/ccoQIC4J.s:900    .text.handle_vdm_request:0000000000000094 $d
     /tmp/ccoQIC4J.s:906    .text.pd_set_data_role:0000000000000000 $t
     /tmp/ccoQIC4J.s:912    .text.pd_set_data_role:0000000000000000 pd_set_data_role
     /tmp/ccoQIC4J.s:947    .text.pd_set_data_role:0000000000000018 $d
     /tmp/ccoQIC4J.s:952    .text.pd_dr_swap:0000000000000000 $t
     /tmp/ccoQIC4J.s:958    .text.pd_dr_swap:0000000000000000 pd_dr_swap
     /tmp/ccoQIC4J.s:994    .text.pd_dr_swap:000000000000001c $d
     /tmp/ccoQIC4J.s:999    .text.pd_restart_tcpc:0000000000000000 $t
     /tmp/ccoQIC4J.s:1005   .text.pd_restart_tcpc:0000000000000000 pd_restart_tcpc
     /tmp/ccoQIC4J.s:1075   .text.pd_restart_tcpc:0000000000000030 $d
     /tmp/ccoQIC4J.s:1082   .text.execute_soft_reset:0000000000000000 $t
     /tmp/ccoQIC4J.s:1088   .text.execute_soft_reset:0000000000000000 execute_soft_reset
     /tmp/ccoQIC4J.s:1250   .text.execute_soft_reset:0000000000000074 $d
     /tmp/ccoQIC4J.s:1258   .text.pd_comm_is_enabled:0000000000000000 $t
     /tmp/ccoQIC4J.s:1265   .text.pd_comm_is_enabled:0000000000000000 pd_comm_is_enabled
     /tmp/ccoQIC4J.s:1284   .text.pd_transmit:0000000000000000 $t
     /tmp/ccoQIC4J.s:1290   .text.pd_transmit:0000000000000000 pd_transmit
     /tmp/ccoQIC4J.s:1381   .text.pd_transmit:0000000000000048 $d
     /tmp/ccoQIC4J.s:1387   .text.send_sink_cap:0000000000000000 $t
     /tmp/ccoQIC4J.s:1393   .text.send_sink_cap:0000000000000000 send_sink_cap
     /tmp/ccoQIC4J.s:1447   .text.send_sink_cap:0000000000000038 $d
     /tmp/ccoQIC4J.s:1454   .text.send_source_cap:0000000000000000 $t
     /tmp/ccoQIC4J.s:1460   .text.send_source_cap:0000000000000000 send_source_cap
     /tmp/ccoQIC4J.s:1554   .text.send_source_cap:000000000000005c $d
     /tmp/ccoQIC4J.s:1561   .text.send_request:0000000000000000 $t
     /tmp/ccoQIC4J.s:1567   .text.send_request:0000000000000000 send_request
     /tmp/ccoQIC4J.s:1628   .text.send_request:0000000000000038 $d
     /tmp/ccoQIC4J.s:1633   .text.pd_send_request_msg:0000000000000000 $t
ARM GAS  /tmp/ccoQIC4J.s 			page 317


     /tmp/ccoQIC4J.s:1639   .text.pd_send_request_msg:0000000000000000 pd_send_request_msg
     /tmp/ccoQIC4J.s:1799   .text.pd_send_request_msg:0000000000000078 $d
     /tmp/ccoQIC4J.s:1804   .text.send_control:0000000000000000 $t
     /tmp/ccoQIC4J.s:1810   .text.send_control:0000000000000000 send_control
     /tmp/ccoQIC4J.s:1863   .text.send_control:0000000000000030 $d
     /tmp/ccoQIC4J.s:1868   .text.handle_ctrl_request:0000000000000000 $t
     /tmp/ccoQIC4J.s:1874   .text.handle_ctrl_request:0000000000000000 handle_ctrl_request
     /tmp/ccoQIC4J.s:1911   .rodata.handle_ctrl_request:0000000000000000 $d
     /tmp/ccoQIC4J.s:2925   .text.handle_ctrl_request:0000000000000320 $d
     /tmp/ccoQIC4J.s:2933   .text.handle_ctrl_request:0000000000000330 $t
     /tmp/ccoQIC4J.s:3148   .text.handle_ctrl_request:0000000000000404 $d
     /tmp/ccoQIC4J.s:3156   .text.handle_data_request:0000000000000000 $t
     /tmp/ccoQIC4J.s:3162   .text.handle_data_request:0000000000000000 handle_data_request
     /tmp/ccoQIC4J.s:3198   .rodata.handle_data_request:0000000000000000 $d
     /tmp/ccoQIC4J.s:3688   .text.handle_data_request:00000000000001cc $d
     /tmp/ccoQIC4J.s:3695   .text.pd_is_connected:0000000000000000 $t
     /tmp/ccoQIC4J.s:3702   .text.pd_is_connected:0000000000000000 pd_is_connected
     /tmp/ccoQIC4J.s:3757   .text.pd_is_connected:0000000000000038 $d
     /tmp/ccoQIC4J.s:3762   .text.pd_vdm_send_state_machine:0000000000000000 $t
     /tmp/ccoQIC4J.s:3768   .text.pd_vdm_send_state_machine:0000000000000000 pd_vdm_send_state_machine
     /tmp/ccoQIC4J.s:4047   .text.pd_vdm_send_state_machine:000000000000013c $d
     /tmp/ccoQIC4J.s:4052   .text.handle_request:0000000000000000 $t
     /tmp/ccoQIC4J.s:4058   .text.handle_request:0000000000000000 handle_request
     /tmp/ccoQIC4J.s:4167   .text.handle_request:000000000000004c $d
     /tmp/ccoQIC4J.s:4172   .text.pd_ts_dts_plugged:0000000000000000 $t
     /tmp/ccoQIC4J.s:4179   .text.pd_ts_dts_plugged:0000000000000000 pd_ts_dts_plugged
     /tmp/ccoQIC4J.s:4205   .text.pd_ts_dts_plugged:0000000000000010 $d
     /tmp/ccoQIC4J.s:4210   .text.pd_vbus_low:0000000000000000 $t
     /tmp/ccoQIC4J.s:4217   .text.pd_vbus_low:0000000000000000 pd_vbus_low
     /tmp/ccoQIC4J.s:4242   .text.pd_vbus_low:0000000000000010 $d
     /tmp/ccoQIC4J.s:4247   .text.pd_transmit_complete:0000000000000000 $t
     /tmp/ccoQIC4J.s:4254   .text.pd_transmit_complete:0000000000000000 pd_transmit_complete
     /tmp/ccoQIC4J.s:4305   .text.pd_transmit_complete:0000000000000024 $d
     /tmp/ccoQIC4J.s:4310   .text.pd_execute_hard_reset:0000000000000000 $t
     /tmp/ccoQIC4J.s:4317   .text.pd_execute_hard_reset:0000000000000000 pd_execute_hard_reset
     /tmp/ccoQIC4J.s:4503   .text.pd_execute_hard_reset:0000000000000098 $d
     /tmp/ccoQIC4J.s:4512   .text.pd_soft_reset:0000000000000000 $t
     /tmp/ccoQIC4J.s:4519   .text.pd_soft_reset:0000000000000000 pd_soft_reset
     /tmp/ccoQIC4J.s:4601   .text.pd_soft_reset:0000000000000030 $d
     /tmp/ccoQIC4J.s:4608   .text.pd_request_power_swap:0000000000000000 $t
     /tmp/ccoQIC4J.s:4615   .text.pd_request_power_swap:0000000000000000 pd_request_power_swap
     /tmp/ccoQIC4J.s:4726   .text.pd_request_power_swap:0000000000000040 $d
     /tmp/ccoQIC4J.s:4731   .text.pd_request_data_swap:0000000000000000 $t
     /tmp/ccoQIC4J.s:4738   .text.pd_request_data_swap:0000000000000000 pd_request_data_swap
     /tmp/ccoQIC4J.s:4827   .text.pd_request_data_swap:0000000000000048 $d
     /tmp/ccoQIC4J.s:4832   .text.pd_send_vdm:0000000000000000 $t
     /tmp/ccoQIC4J.s:4839   .text.pd_send_vdm:0000000000000000 pd_send_vdm
     /tmp/ccoQIC4J.s:4920   .text.pd_send_vdm:000000000000004c $d
     /tmp/ccoQIC4J.s:4925   .text.pd_dev_store_rw_hash:0000000000000000 $t
     /tmp/ccoQIC4J.s:4932   .text.pd_dev_store_rw_hash:0000000000000000 pd_dev_store_rw_hash
     /tmp/ccoQIC4J.s:4951   .text.pd_get_dual_role:0000000000000000 $t
     /tmp/ccoQIC4J.s:4958   .text.pd_get_dual_role:0000000000000000 pd_get_dual_role
     /tmp/ccoQIC4J.s:4975   .text.pd_get_dual_role:0000000000000008 $d
     /tmp/ccoQIC4J.s:4980   .text.pd_set_dual_role:0000000000000000 $t
     /tmp/ccoQIC4J.s:4987   .text.pd_set_dual_role:0000000000000000 pd_set_dual_role
     /tmp/ccoQIC4J.s:5022   .text.pd_set_dual_role:0000000000000010 $d
     /tmp/ccoQIC4J.s:5027   .text.pd_update_dual_role_config:0000000000000000 $t
ARM GAS  /tmp/ccoQIC4J.s 			page 318


     /tmp/ccoQIC4J.s:5034   .text.pd_update_dual_role_config:0000000000000000 pd_update_dual_role_config
     /tmp/ccoQIC4J.s:5368   .text.pd_update_dual_role_config:000000000000010c $d
     /tmp/ccoQIC4J.s:5377   .text.pd_get_role:0000000000000000 $t
     /tmp/ccoQIC4J.s:5384   .text.pd_get_role:0000000000000000 pd_get_role
     /tmp/ccoQIC4J.s:5405   .text.pd_get_role:0000000000000008 $d
     /tmp/ccoQIC4J.s:5410   .text.pd_get_polarity:0000000000000000 $t
     /tmp/ccoQIC4J.s:5417   .text.pd_get_polarity:0000000000000000 pd_get_polarity
     /tmp/ccoQIC4J.s:5439   .text.pd_get_polarity:000000000000000c $d
     /tmp/ccoQIC4J.s:5444   .text.pd_get_partner_data_swap_capable:0000000000000000 $t
     /tmp/ccoQIC4J.s:5451   .text.pd_get_partner_data_swap_capable:0000000000000000 pd_get_partner_data_swap_capable
     /tmp/ccoQIC4J.s:5476   .text.pd_get_partner_data_swap_capable:0000000000000010 $d
     /tmp/ccoQIC4J.s:5481   .text.pd_ping_enable:0000000000000000 $t
     /tmp/ccoQIC4J.s:5488   .text.pd_ping_enable:0000000000000000 pd_ping_enable
     /tmp/ccoQIC4J.s:5533   .text.pd_ping_enable:0000000000000024 $d
     /tmp/ccoQIC4J.s:5538   .text.pd_set_new_power_request:0000000000000000 $t
     /tmp/ccoQIC4J.s:5545   .text.pd_set_new_power_request:0000000000000000 pd_set_new_power_request
     /tmp/ccoQIC4J.s:5568   .text.pd_set_new_power_request:000000000000000c $d
     /tmp/ccoQIC4J.s:5573   .text.pd_init:0000000000000000 $t
     /tmp/ccoQIC4J.s:5580   .text.pd_init:0000000000000000 pd_init
     /tmp/ccoQIC4J.s:5911   .text.pd_init:0000000000000108 $d
     /tmp/ccoQIC4J.s:5921   .text.pd_run_state_machine:0000000000000000 $t
     /tmp/ccoQIC4J.s:5928   .text.pd_run_state_machine:0000000000000000 pd_run_state_machine
     /tmp/ccoQIC4J.s:6032   .rodata.pd_run_state_machine:0000000000000000 $d
     /tmp/ccoQIC4J.s:6853   .text.pd_run_state_machine:000000000000037c $d
     /tmp/ccoQIC4J.s:6881   .text.pd_run_state_machine:00000000000003d0 $t
     /tmp/ccoQIC4J.s:7785   .text.pd_run_state_machine:0000000000000768 $d
     /tmp/ccoQIC4J.s:7805   .text.pd_run_state_machine:00000000000007a0 $t
     /tmp/ccoQIC4J.s:8597   .text.pd_run_state_machine:0000000000000ae0 $d
     /tmp/ccoQIC4J.s:8617   .text.pd_run_state_machine:0000000000000b08 $t
     /tmp/ccoQIC4J.s:9429   .text.pd_run_state_machine:0000000000000e10 $d
     /tmp/ccoQIC4J.s:9448   .text.pd_run_state_machine:0000000000000e50 $t
     /tmp/ccoQIC4J.s:10158  .text.pd_run_state_machine:0000000000001138 $d
     /tmp/ccoQIC4J.s:10183  .text.pd_run_state_machine:0000000000001190 $t
     /tmp/ccoQIC4J.s:11033  .text.pd_run_state_machine:00000000000014b4 $d
     /tmp/ccoQIC4J.s:11061  .text.pd_run_state_machine:00000000000014dc $t
     /tmp/ccoQIC4J.s:11735  .text.pd_run_state_machine:000000000000173c $d
     /tmp/ccoQIC4J.s:11864  .data.drp_state:0000000000000000 drp_state
     /tmp/ccoQIC4J.s:11752  .bss.caps_count:0000000000000000 $d
     /tmp/ccoQIC4J.s:11756  .bss.caps_count:0000000000000000 caps_count
     /tmp/ccoQIC4J.s:11759  .bss.cc1:0000000000000000 $d
     /tmp/ccoQIC4J.s:11763  .bss.cc1:0000000000000000 cc1
     /tmp/ccoQIC4J.s:11766  .bss.cc2:0000000000000000 $d
     /tmp/ccoQIC4J.s:11770  .bss.cc2:0000000000000000 cc2
     /tmp/ccoQIC4J.s:11773  .bss.hard_reset_count:0000000000000000 $d
     /tmp/ccoQIC4J.s:11777  .bss.hard_reset_count:0000000000000000 hard_reset_count
     /tmp/ccoQIC4J.s:11780  .bss.hard_reset_sent:0000000000000000 $d
     /tmp/ccoQIC4J.s:11784  .bss.hard_reset_sent:0000000000000000 hard_reset_sent
     /tmp/ccoQIC4J.s:11787  .bss.head:0000000000000000 $d
     /tmp/ccoQIC4J.s:11791  .bss.head:0000000000000000 head
     /tmp/ccoQIC4J.s:11794  .bss.incoming_packet:0000000000000000 $d
     /tmp/ccoQIC4J.s:11798  .bss.incoming_packet:0000000000000000 incoming_packet
     /tmp/ccoQIC4J.s:11804  .bss.new_cc_state:0000000000000000 new_cc_state
     /tmp/ccoQIC4J.s:11805  .bss.new_cc_state:0000000000000000 $d
     /tmp/ccoQIC4J.s:11807  .bss.now:0000000000000000 $d
     /tmp/ccoQIC4J.s:11811  .bss.now:0000000000000000 now
     /tmp/ccoQIC4J.s:11814  .bss.payload:0000000000000000 $d
     /tmp/ccoQIC4J.s:11818  .bss.payload:0000000000000000 payload
ARM GAS  /tmp/ccoQIC4J.s 			page 319


     /tmp/ccoQIC4J.s:11821  .bss.pd:0000000000000000 $d
     /tmp/ccoQIC4J.s:11827  .bss.snk_cap_count:0000000000000000 $d
     /tmp/ccoQIC4J.s:11831  .bss.snk_cap_count:0000000000000000 snk_cap_count
     /tmp/ccoQIC4J.s:11834  .bss.snk_hard_reset_vbus_off:0000000000000000 $d
     /tmp/ccoQIC4J.s:11838  .bss.snk_hard_reset_vbus_off:0000000000000000 snk_hard_reset_vbus_off
     /tmp/ccoQIC4J.s:11844  .bss.this_state:0000000000000000 this_state
     /tmp/ccoQIC4J.s:11845  .bss.this_state:0000000000000000 $d
     /tmp/ccoQIC4J.s:11847  .bss.typec_curr:0000000000000000 $d
     /tmp/ccoQIC4J.s:11851  .bss.typec_curr:0000000000000000 typec_curr
     /tmp/ccoQIC4J.s:11854  .bss.typec_curr_change:0000000000000000 $d
     /tmp/ccoQIC4J.s:11858  .bss.typec_curr_change:0000000000000000 typec_curr_change
     /tmp/ccoQIC4J.s:11867  .data.next_role_swap:0000000000000000 $d
     /tmp/ccoQIC4J.s:11871  .data.next_role_swap:0000000000000000 next_role_swap
     /tmp/ccoQIC4J.s:11875  .data.timeout:0000000000000000 $d
     /tmp/ccoQIC4J.s:11879  .data.timeout:0000000000000000 timeout

UNDEFINED SYMBOLS
tcpc_config
pd_set_input_current_limit
pd_power_supply_reset
memcpy
pd_svdm
get_time
pd_custom_vdm
pd_execute_data_swap
board_set_tcpc_power_mode
board_tcpc_post_init
pd_snk_pdo_cnt
pd_snk_pdo
pd_src_pdo_cnt
pd_src_pdo
pd_build_request
pd_check_power_swap
pd_check_data_swap
pd_process_source_cap
pd_process_source_cap_callback
pd_check_requested_voltage
pd_task_set_event
pd_board_checks
pd_set_power_supply_ready
pd_transition_voltage
pd_check_pr_role
pd_check_dr_role
pd_snk_is_vbus_provided
